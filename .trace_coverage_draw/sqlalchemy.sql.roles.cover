       # sql/roles.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
    1: from __future__ import annotations
       
    1: from typing import Any
    1: from typing import Generic
    1: from typing import Optional
    1: from typing import TYPE_CHECKING
    1: from typing import TypeVar
       
    1: from .. import util
    1: from ..util.typing import Literal
       
    1: if TYPE_CHECKING:
>>>>>>     from ._typing import _PropagateAttrsType
>>>>>>     from .elements import Label
>>>>>>     from .selectable import _SelectIterable
>>>>>>     from .selectable import FromClause
>>>>>>     from .selectable import Subquery
       
    1: _T = TypeVar("_T", bound=Any)
    1: _T_co = TypeVar("_T_co", bound=Any, covariant=True)
       
       
    2: class SQLRole:
    1:     """Define a "role" within a SQL statement structure.
       
           Classes within SQL Core participate within SQLRole hierarchies in order
           to more accurately indicate where they may be used within SQL statements
           of all types.
       
           .. versionadded:: 1.4
       
           """
       
    1:     __slots__ = ()
    1:     allows_lambda = False
    1:     uses_inspection = False
       
       
    2: class UsesInspection:
    1:     __slots__ = ()
    1:     _post_inspect: Literal[None] = None
    1:     uses_inspection = True
       
       
    2: class AllowsLambdaRole:
    1:     __slots__ = ()
    1:     allows_lambda = True
       
       
    2: class HasCacheKeyRole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = "Cacheable Core or ORM object"
       
       
    2: class ExecutableOptionRole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = "ExecutionOption Core or ORM object"
       
       
    2: class LiteralValueRole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = "Literal Python value"
       
       
    2: class ColumnArgumentRole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = "Column expression"
       
       
    2: class ColumnArgumentOrKeyRole(ColumnArgumentRole):
    1:     __slots__ = ()
    1:     _role_name = "Column expression or string key"
       
       
    2: class StrAsPlainColumnRole(ColumnArgumentRole):
    1:     __slots__ = ()
    1:     _role_name = "Column expression or string key"
       
       
    2: class ColumnListRole(SQLRole):
    1:     """Elements suitable for forming comma separated lists of expressions."""
       
    1:     __slots__ = ()
       
       
    2: class StringRole(SQLRole):
    1:     """mixin indicating a role that results in strings"""
       
    1:     __slots__ = ()
       
       
    2: class TruncatedLabelRole(StringRole, SQLRole):
    1:     __slots__ = ()
    1:     _role_name = "String SQL identifier"
       
       
    2: class ColumnsClauseRole(AllowsLambdaRole, UsesInspection, ColumnListRole):
    1:     __slots__ = ()
    1:     _role_name = (
    1:         "Column expression, FROM clause, or other columns clause element"
           )
       
    1:     @property
    1:     def _select_iterable(self) -> _SelectIterable:
>>>>>>         raise NotImplementedError()
       
       
    2: class TypedColumnsClauseRole(Generic[_T_co], SQLRole):
    1:     """element-typed form of ColumnsClauseRole"""
       
    1:     __slots__ = ()
       
       
    2: class LimitOffsetRole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = "LIMIT / OFFSET expression"
       
       
    2: class ByOfRole(ColumnListRole):
    1:     __slots__ = ()
    1:     _role_name = "GROUP BY / OF / etc. expression"
       
       
    2: class GroupByRole(AllowsLambdaRole, UsesInspection, ByOfRole):
    1:     __slots__ = ()
           # note there's a special case right now where you can pass a whole
           # ORM entity to group_by() and it splits out.   we may not want to keep
           # this around
       
    1:     _role_name = "GROUP BY expression"
       
       
    2: class OrderByRole(AllowsLambdaRole, ByOfRole):
    1:     __slots__ = ()
    1:     _role_name = "ORDER BY expression"
       
       
    2: class StructuralRole(SQLRole):
    1:     __slots__ = ()
       
       
    2: class StatementOptionRole(StructuralRole):
    1:     __slots__ = ()
    1:     _role_name = "statement sub-expression element"
       
       
    2: class OnClauseRole(AllowsLambdaRole, StructuralRole):
    1:     __slots__ = ()
    1:     _role_name = (
    1:         "ON clause, typically a SQL expression or "
               "ORM relationship attribute"
           )
       
       
    2: class WhereHavingRole(OnClauseRole):
    1:     __slots__ = ()
    1:     _role_name = "SQL expression for WHERE/HAVING role"
       
       
    2: class ExpressionElementRole(TypedColumnsClauseRole[_T_co]):
           # note when using generics for ExpressionElementRole,
           # the generic type needs to be in
           # sqlalchemy.sql.coercions._impl_lookup mapping also.
           # these are set up for basic types like int, bool, str, float
           # right now
       
    1:     __slots__ = ()
    1:     _role_name = "SQL expression element"
       
    1:     def label(self, name: Optional[str]) -> Label[_T]:
>>>>>>         raise NotImplementedError()
       
       
    2: class ConstExprRole(ExpressionElementRole[_T]):
    1:     __slots__ = ()
    1:     _role_name = "Constant True/False/None expression"
       
       
    2: class LabeledColumnExprRole(ExpressionElementRole[_T]):
    1:     __slots__ = ()
       
       
    2: class BinaryElementRole(ExpressionElementRole[_T]):
    1:     __slots__ = ()
    1:     _role_name = "SQL expression element or literal value"
       
       
    2: class InElementRole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = (
    1:         "IN expression list, SELECT construct, or bound parameter object"
           )
       
       
    2: class JoinTargetRole(AllowsLambdaRole, UsesInspection, StructuralRole):
    1:     __slots__ = ()
    1:     _role_name = (
    1:         "Join target, typically a FROM expression, or ORM "
               "relationship attribute"
           )
       
       
    2: class FromClauseRole(ColumnsClauseRole, JoinTargetRole):
    1:     __slots__ = ()
    1:     _role_name = "FROM expression, such as a Table or alias() object"
       
    1:     _is_subquery = False
       
    1:     named_with_column: bool
       
       
    2: class StrictFromClauseRole(FromClauseRole):
    1:     __slots__ = ()
           # does not allow text() or select() objects
       
       
    2: class AnonymizedFromClauseRole(StrictFromClauseRole):
    1:     __slots__ = ()
       
    1:     if TYPE_CHECKING:
       
>>>>>>         def _anonymous_fromclause(
>>>>>>             self, *, name: Optional[str] = None, flat: bool = False
>>>>>>         ) -> FromClause: ...
       
       
    2: class ReturnsRowsRole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = (
    1:         "Row returning expression such as a SELECT, a FROM clause, or an "
               "INSERT/UPDATE/DELETE with RETURNING"
           )
       
       
    2: class StatementRole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = "Executable SQL or text() construct"
       
    1:     if TYPE_CHECKING:
       
>>>>>>         @util.memoized_property
>>>>>>         def _propagate_attrs(self) -> _PropagateAttrsType: ...
       
           else:
    1:         _propagate_attrs = util.EMPTY_DICT
       
       
    2: class SelectStatementRole(StatementRole, ReturnsRowsRole):
    1:     __slots__ = ()
    1:     _role_name = "SELECT construct or equivalent text() construct"
       
    1:     def subquery(self) -> Subquery:
>>>>>>         raise NotImplementedError(
>>>>>>             "All SelectStatementRole objects should implement a "
                   ".subquery() method."
               )
       
       
    2: class HasCTERole(ReturnsRowsRole):
    1:     __slots__ = ()
       
       
    2: class IsCTERole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = "CTE object"
       
       
    2: class CompoundElementRole(AllowsLambdaRole, SQLRole):
    1:     """SELECT statements inside a CompoundSelect, e.g. UNION, EXTRACT, etc."""
       
    1:     __slots__ = ()
    1:     _role_name = (
    1:         "SELECT construct for inclusion in a UNION or other set construct"
           )
       
       
       # TODO: are we using this?
    2: class DMLRole(StatementRole):
    1:     __slots__ = ()
       
       
    2: class DMLTableRole(FromClauseRole):
    1:     __slots__ = ()
    1:     _role_name = "subject table for an INSERT, UPDATE or DELETE"
       
       
    2: class DMLColumnRole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = "SET/VALUES column expression or string key"
       
       
    2: class DMLSelectRole(SQLRole):
    1:     """A SELECT statement embedded in DML, typically INSERT from SELECT"""
       
    1:     __slots__ = ()
    1:     _role_name = "SELECT statement or equivalent textual object"
       
       
    2: class DDLRole(StatementRole):
    1:     __slots__ = ()
       
       
    2: class DDLExpressionRole(StructuralRole):
    1:     __slots__ = ()
    1:     _role_name = "SQL expression element for DDL constraint"
       
       
    2: class DDLConstraintColumnRole(SQLRole):
    1:     __slots__ = ()
    1:     _role_name = "String column name or column expression for DDL constraint"
       
       
    2: class DDLReferredColumnRole(DDLConstraintColumnRole):
    1:     __slots__ = ()
    1:     _role_name = (
    1:         "String column name or Column object for DDL foreign key constraint"
           )
