    1: import inspect
    1: from contextlib import AsyncExitStack, contextmanager
    1: from copy import deepcopy
    1: from typing import (
           Any,
           Callable,
           Coroutine,
           Dict,
           ForwardRef,
           List,
           Mapping,
           Optional,
           Sequence,
           Tuple,
           Type,
           Union,
           cast,
       )
       
    1: import anyio
    1: from fastapi import params
    1: from fastapi._compat import (
           PYDANTIC_V2,
           ErrorWrapper,
           ModelField,
           Required,
           Undefined,
           _regenerate_error_with_loc,
           copy_field_info,
           create_body_model,
           evaluate_forwardref,
           field_annotation_is_scalar,
           get_annotation_from_field_info,
           get_missing_field_error,
           is_bytes_field,
           is_bytes_sequence_field,
           is_scalar_field,
           is_scalar_sequence_field,
           is_sequence_field,
           is_uploadfile_or_nonable_uploadfile_annotation,
           is_uploadfile_sequence_annotation,
           lenient_issubclass,
           sequence_types,
           serialize_sequence_value,
           value_is_sequence,
       )
    1: from fastapi.background import BackgroundTasks
    1: from fastapi.concurrency import (
           asynccontextmanager,
           contextmanager_in_threadpool,
       )
    1: from fastapi.dependencies.models import Dependant, SecurityRequirement
    1: from fastapi.logger import logger
    1: from fastapi.security.base import SecurityBase
    1: from fastapi.security.oauth2 import OAuth2, SecurityScopes
    1: from fastapi.security.open_id_connect_url import OpenIdConnect
    1: from fastapi.utils import create_response_field, get_path_param_names
    1: from pydantic.fields import FieldInfo
    1: from starlette.background import BackgroundTasks as StarletteBackgroundTasks
    1: from starlette.concurrency import run_in_threadpool
    1: from starlette.datastructures import FormData, Headers, QueryParams, UploadFile
    1: from starlette.requests import HTTPConnection, Request
    1: from starlette.responses import Response
    1: from starlette.websockets import WebSocket
    1: from typing_extensions import Annotated, get_args, get_origin
       
    1: multipart_not_installed_error = (
    1:     'Form data requires "python-multipart" to be installed. \n'
           'You can install "python-multipart" with: \n\n'
           "pip install python-multipart\n"
       )
    1: multipart_incorrect_install_error = (
    1:     'Form data requires "python-multipart" to be installed. '
           'It seems you installed "multipart" instead. \n'
           'You can remove "multipart" with: \n\n'
           "pip uninstall multipart\n\n"
           'And then install "python-multipart" with: \n\n'
           "pip install python-multipart\n"
       )
       
       
    1: def check_file_field(field: ModelField) -> None:
>>>>>>     field_info = field.field_info
>>>>>>     if isinstance(field_info, params.Form):
>>>>>>         try:
                   # __version__ is available in both multiparts, and can be mocked
>>>>>>             from multipart import __version__  # type: ignore
       
>>>>>>             assert __version__
>>>>>>             try:
                       # parse_options_header is only available in the right multipart
>>>>>>                 from multipart.multipart import parse_options_header  # type: ignore
       
>>>>>>                 assert parse_options_header
>>>>>>             except ImportError:
>>>>>>                 logger.error(multipart_incorrect_install_error)
>>>>>>                 raise RuntimeError(multipart_incorrect_install_error) from None
>>>>>>         except ImportError:
>>>>>>             logger.error(multipart_not_installed_error)
>>>>>>             raise RuntimeError(multipart_not_installed_error) from None
       
       
    2: def get_param_sub_dependant(
           *,
    1:     param_name: str,
    1:     depends: params.Depends,
    1:     path: str,
    2:     security_scopes: Optional[List[str]] = None,
    1: ) -> Dependant:
    6:     assert depends.dependency
   12:     return get_sub_dependant(
    6:         depends=depends,
    6:         dependency=depends.dependency,
    6:         path=path,
    6:         name=param_name,
    6:         security_scopes=security_scopes,
           )
       
       
    1: def get_parameterless_sub_dependant(*, depends: params.Depends, path: str) -> Dependant:
>>>>>>     assert callable(
>>>>>>         depends.dependency
>>>>>>     ), "A parameter-less dependency must have a callable dependency"
>>>>>>     return get_sub_dependant(depends=depends, dependency=depends.dependency, path=path)
       
       
    2: def get_sub_dependant(
           *,
    1:     depends: params.Depends,
    1:     dependency: Callable[..., Any],
    1:     path: str,
    2:     name: Optional[str] = None,
    2:     security_scopes: Optional[List[str]] = None,
    1: ) -> Dependant:
    6:     security_requirement = None
    6:     security_scopes = security_scopes or []
    6:     if isinstance(depends, params.Security):
>>>>>>         dependency_scopes = depends.scopes
>>>>>>         security_scopes.extend(dependency_scopes)
    6:     if isinstance(dependency, SecurityBase):
>>>>>>         use_scopes: List[str] = []
>>>>>>         if isinstance(dependency, (OAuth2, OpenIdConnect)):
>>>>>>             use_scopes = security_scopes
>>>>>>         security_requirement = SecurityRequirement(
>>>>>>             security_scheme=dependency, scopes=use_scopes
               )
   12:     sub_dependant = get_dependant(
    6:         path=path,
    6:         call=dependency,
    6:         name=name,
    6:         security_scopes=security_scopes,
    6:         use_cache=depends.use_cache,
           )
    6:     if security_requirement:
>>>>>>         sub_dependant.security_requirements.append(security_requirement)
    6:     return sub_dependant
       
       
    1: CacheKey = Tuple[Optional[Callable[..., Any]], Tuple[str, ...]]
       
       
    2: def get_flat_dependant(
    1:     dependant: Dependant,
           *,
    2:     skip_repeats: bool = False,
    2:     visited: Optional[List[CacheKey]] = None,
    1: ) -> Dependant:
    8:     if visited is None:
    2:         visited = []
    8:     visited.append(dependant.cache_key)
       
   16:     flat_dependant = Dependant(
    8:         path_params=dependant.path_params.copy(),
    8:         query_params=dependant.query_params.copy(),
    8:         header_params=dependant.header_params.copy(),
    8:         cookie_params=dependant.cookie_params.copy(),
    8:         body_params=dependant.body_params.copy(),
    8:         security_schemes=dependant.security_requirements.copy(),
    8:         use_cache=dependant.use_cache,
    8:         path=dependant.path,
           )
   14:     for sub_dependant in dependant.dependencies:
    6:         if skip_repeats and sub_dependant.cache_key in visited:
>>>>>>             continue
   12:         flat_sub = get_flat_dependant(
    6:             sub_dependant, skip_repeats=skip_repeats, visited=visited
               )
    6:         flat_dependant.path_params.extend(flat_sub.path_params)
    6:         flat_dependant.query_params.extend(flat_sub.query_params)
    6:         flat_dependant.header_params.extend(flat_sub.header_params)
    6:         flat_dependant.cookie_params.extend(flat_sub.cookie_params)
    6:         flat_dependant.body_params.extend(flat_sub.body_params)
    6:         flat_dependant.security_requirements.extend(flat_sub.security_requirements)
    8:     return flat_dependant
       
       
    1: def get_flat_params(dependant: Dependant) -> List[ModelField]:
>>>>>>     flat_dependant = get_flat_dependant(dependant, skip_repeats=True)
>>>>>>     return (
>>>>>>         flat_dependant.path_params
>>>>>>         + flat_dependant.query_params
>>>>>>         + flat_dependant.header_params
>>>>>>         + flat_dependant.cookie_params
           )
       
       
    1: def get_typed_signature(call: Callable[..., Any]) -> inspect.Signature:
   12:     signature = inspect.signature(call)
   12:     globalns = getattr(call, "__globals__", {})
   44:     typed_params = [
   16:         inspect.Parameter(
    8:             name=param.name,
    8:             kind=param.kind,
    8:             default=param.default,
    8:             annotation=get_typed_annotation(param.annotation, globalns),
               )
   20:         for param in signature.parameters.values()
           ]
   12:     typed_signature = inspect.Signature(typed_params)
   12:     return typed_signature
       
       
    1: def get_typed_annotation(annotation: Any, globalns: Dict[str, Any]) -> Any:
    8:     if isinstance(annotation, str):
>>>>>>         annotation = ForwardRef(annotation)
>>>>>>         annotation = evaluate_forwardref(annotation, globalns, globalns)
    8:     return annotation
       
       
    1: def get_typed_return_annotation(call: Callable[..., Any]) -> Any:
    1:     signature = inspect.signature(call)
    1:     annotation = signature.return_annotation
       
    1:     if annotation is inspect.Signature.empty:
    1:         return None
       
>>>>>>     globalns = getattr(call, "__globals__", {})
>>>>>>     return get_typed_annotation(annotation, globalns)
       
       
    2: def get_dependant(
           *,
    1:     path: str,
    1:     call: Callable[..., Any],
    2:     name: Optional[str] = None,
    2:     security_scopes: Optional[List[str]] = None,
    2:     use_cache: bool = True,
    1: ) -> Dependant:
   12:     path_param_names = get_path_param_names(path)
   12:     endpoint_signature = get_typed_signature(call)
   12:     signature_params = endpoint_signature.parameters
   24:     dependant = Dependant(
   12:         call=call,
   12:         name=name,
   12:         path=path,
   12:         security_scopes=security_scopes,
   12:         use_cache=use_cache,
           )
   20:     for param_name, param in signature_params.items():
    8:         is_path_param = param_name in path_param_names
   16:         type_annotation, depends, param_field = analyze_param(
    8:             param_name=param_name,
    8:             annotation=param.annotation,
    8:             value=param.default,
    8:             is_path_param=is_path_param,
               )
    8:         if depends is not None:
   12:             sub_dependant = get_param_sub_dependant(
    6:                 param_name=param_name,
    6:                 depends=depends,
    6:                 path=path,
    6:                 security_scopes=security_scopes,
                   )
    6:             dependant.dependencies.append(sub_dependant)
    6:             continue
    4:         if add_non_field_param_to_dependency(
    2:             param_name=param_name,
    2:             type_annotation=type_annotation,
    2:             dependant=dependant,
               ):
    2:             assert (
    2:                 param_field is None
>>>>>>             ), f"Cannot specify multiple FastAPI annotations for {param_name!r}"
>>>>>>             continue
>>>>>>         assert param_field is not None
>>>>>>         if is_body_param(param_field=param_field, is_path_param=is_path_param):
>>>>>>             dependant.body_params.append(param_field)
               else:
>>>>>>             add_param_to_fields(field=param_field, dependant=dependant)
   12:     return dependant
       
       
    1: def add_non_field_param_to_dependency(
    1:     *, param_name: str, type_annotation: Any, dependant: Dependant
    1: ) -> Optional[bool]:
    2:     if lenient_issubclass(type_annotation, Request):
    2:         dependant.request_param_name = param_name
    2:         return True
>>>>>>     elif lenient_issubclass(type_annotation, WebSocket):
>>>>>>         dependant.websocket_param_name = param_name
>>>>>>         return True
>>>>>>     elif lenient_issubclass(type_annotation, HTTPConnection):
>>>>>>         dependant.http_connection_param_name = param_name
>>>>>>         return True
>>>>>>     elif lenient_issubclass(type_annotation, Response):
>>>>>>         dependant.response_param_name = param_name
>>>>>>         return True
>>>>>>     elif lenient_issubclass(type_annotation, StarletteBackgroundTasks):
>>>>>>         dependant.background_tasks_param_name = param_name
>>>>>>         return True
>>>>>>     elif lenient_issubclass(type_annotation, SecurityScopes):
>>>>>>         dependant.security_scopes_param_name = param_name
>>>>>>         return True
>>>>>>     return None
       
       
    1: def analyze_param(
           *,
    1:     param_name: str,
    1:     annotation: Any,
    1:     value: Any,
    1:     is_path_param: bool,
    1: ) -> Tuple[Any, Optional[params.Depends], Optional[ModelField]]:
    8:     field_info = None
    8:     depends = None
    8:     type_annotation: Any = Any
    8:     use_annotation: Any = Any
    8:     if annotation is not inspect.Signature.empty:
    6:         use_annotation = annotation
    6:         type_annotation = annotation
    8:     if get_origin(use_annotation) is Annotated:
>>>>>>         annotated_args = get_args(annotation)
>>>>>>         type_annotation = annotated_args[0]
>>>>>>         fastapi_annotations = [
>>>>>>             arg
>>>>>>             for arg in annotated_args[1:]
>>>>>>             if isinstance(arg, (FieldInfo, params.Depends))
               ]
>>>>>>         fastapi_specific_annotations = [
>>>>>>             arg
>>>>>>             for arg in fastapi_annotations
>>>>>>             if isinstance(arg, (params.Param, params.Body, params.Depends))
               ]
>>>>>>         if fastapi_specific_annotations:
>>>>>>             fastapi_annotation: Union[
                       FieldInfo, params.Depends, None
>>>>>>             ] = fastapi_specific_annotations[-1]
               else:
>>>>>>             fastapi_annotation = None
>>>>>>         if isinstance(fastapi_annotation, FieldInfo):
                   # Copy `field_info` because we mutate `field_info.default` below.
>>>>>>             field_info = copy_field_info(
>>>>>>                 field_info=fastapi_annotation, annotation=use_annotation
                   )
>>>>>>             assert field_info.default is Undefined or field_info.default is Required, (
>>>>>>                 f"`{field_info.__class__.__name__}` default value cannot be set in"
>>>>>>                 f" `Annotated` for {param_name!r}. Set the default value with `=` instead."
                   )
>>>>>>             if value is not inspect.Signature.empty:
>>>>>>                 assert not is_path_param, "Path parameters cannot have default values"
>>>>>>                 field_info.default = value
                   else:
>>>>>>                 field_info.default = Required
>>>>>>         elif isinstance(fastapi_annotation, params.Depends):
>>>>>>             depends = fastapi_annotation
       
    8:     if isinstance(value, params.Depends):
    6:         assert depends is None, (
>>>>>>             "Cannot specify `Depends` in `Annotated` and default value"
>>>>>>             f" together for {param_name!r}"
               )
    6:         assert field_info is None, (
>>>>>>             "Cannot specify a FastAPI annotation in `Annotated` and `Depends` as a"
>>>>>>             f" default value together for {param_name!r}"
               )
    6:         depends = value
    2:     elif isinstance(value, FieldInfo):
>>>>>>         assert field_info is None, (
>>>>>>             "Cannot specify FastAPI annotations in `Annotated` and default value"
>>>>>>             f" together for {param_name!r}"
               )
>>>>>>         field_info = value
>>>>>>         if PYDANTIC_V2:
>>>>>>             field_info.annotation = type_annotation
       
    8:     if depends is not None and depends.dependency is None:
>>>>>>         depends.dependency = type_annotation
       
   16:     if lenient_issubclass(
    8:         type_annotation,
    8:         (
    8:             Request,
    8:             WebSocket,
    8:             HTTPConnection,
    8:             Response,
    8:             StarletteBackgroundTasks,
    8:             SecurityScopes,
               ),
           ):
    2:         assert depends is None, f"Cannot specify `Depends` for type {type_annotation!r}"
    2:         assert (
    2:             field_info is None
>>>>>>         ), f"Cannot specify FastAPI annotation for type {type_annotation!r}"
    6:     elif field_info is None and depends is None:
>>>>>>         default_value = value if value is not inspect.Signature.empty else Required
>>>>>>         if is_path_param:
                   # We might check here that `default_value is Required`, but the fact is that the same
                   # parameter might sometimes be a path parameter and sometimes not. See
                   # `tests/test_infer_param_optionality.py` for an example.
>>>>>>             field_info = params.Path(annotation=use_annotation)
>>>>>>         elif is_uploadfile_or_nonable_uploadfile_annotation(
>>>>>>             type_annotation
>>>>>>         ) or is_uploadfile_sequence_annotation(type_annotation):
>>>>>>             field_info = params.File(annotation=use_annotation, default=default_value)
>>>>>>         elif not field_annotation_is_scalar(annotation=type_annotation):
>>>>>>             field_info = params.Body(annotation=use_annotation, default=default_value)
               else:
>>>>>>             field_info = params.Query(annotation=use_annotation, default=default_value)
       
    8:     field = None
    8:     if field_info is not None:
>>>>>>         if is_path_param:
>>>>>>             assert isinstance(field_info, params.Path), (
>>>>>>                 f"Cannot use `{field_info.__class__.__name__}` for path param"
>>>>>>                 f" {param_name!r}"
                   )
>>>>>>         elif (
>>>>>>             isinstance(field_info, params.Param)
>>>>>>             and getattr(field_info, "in_", None) is None
               ):
>>>>>>             field_info.in_ = params.ParamTypes.query
>>>>>>         use_annotation_from_field_info = get_annotation_from_field_info(
>>>>>>             use_annotation,
>>>>>>             field_info,
>>>>>>             param_name,
               )
>>>>>>         if not field_info.alias and getattr(field_info, "convert_underscores", None):
>>>>>>             alias = param_name.replace("_", "-")
               else:
>>>>>>             alias = field_info.alias or param_name
>>>>>>         field_info.alias = alias
>>>>>>         field = create_response_field(
>>>>>>             name=param_name,
>>>>>>             type_=use_annotation_from_field_info,
>>>>>>             default=field_info.default,
>>>>>>             alias=alias,
>>>>>>             required=field_info.default in (Required, Undefined),
>>>>>>             field_info=field_info,
               )
       
    8:     return type_annotation, depends, field
       
       
    1: def is_body_param(*, param_field: ModelField, is_path_param: bool) -> bool:
>>>>>>     if is_path_param:
>>>>>>         assert is_scalar_field(
>>>>>>             field=param_field
>>>>>>         ), "Path params must be of one of the supported types"
>>>>>>         return False
>>>>>>     elif is_scalar_field(field=param_field):
>>>>>>         return False
>>>>>>     elif isinstance(
>>>>>>         param_field.field_info, (params.Query, params.Header)
>>>>>>     ) and is_scalar_sequence_field(param_field):
>>>>>>         return False
           else:
>>>>>>         assert isinstance(
>>>>>>             param_field.field_info, params.Body
>>>>>>         ), f"Param: {param_field.name} can only be a request body, using Body()"
>>>>>>         return True
       
       
    1: def add_param_to_fields(*, field: ModelField, dependant: Dependant) -> None:
>>>>>>     field_info = field.field_info
>>>>>>     field_info_in = getattr(field_info, "in_", None)
>>>>>>     if field_info_in == params.ParamTypes.path:
>>>>>>         dependant.path_params.append(field)
>>>>>>     elif field_info_in == params.ParamTypes.query:
>>>>>>         dependant.query_params.append(field)
>>>>>>     elif field_info_in == params.ParamTypes.header:
>>>>>>         dependant.header_params.append(field)
           else:
>>>>>>         assert (
>>>>>>             field_info_in == params.ParamTypes.cookie
>>>>>>         ), f"non-body parameters must be in path, query, header or cookie: {field.name}"
>>>>>>         dependant.cookie_params.append(field)
       
       
    1: def is_coroutine_callable(call: Callable[..., Any]) -> bool:
    2:     if inspect.isroutine(call):
    2:         return inspect.iscoroutinefunction(call)
>>>>>>     if inspect.isclass(call):
>>>>>>         return False
>>>>>>     dunder_call = getattr(call, "__call__", None)  # noqa: B004
>>>>>>     return inspect.iscoroutinefunction(dunder_call)
       
       
    1: def is_async_gen_callable(call: Callable[..., Any]) -> bool:
    2:     if inspect.isasyncgenfunction(call):
>>>>>>         return True
    2:     dunder_call = getattr(call, "__call__", None)  # noqa: B004
    2:     return inspect.isasyncgenfunction(dunder_call)
       
       
    1: def is_gen_callable(call: Callable[..., Any]) -> bool:
    6:     if inspect.isgeneratorfunction(call):
    4:         return True
    2:     dunder_call = getattr(call, "__call__", None)  # noqa: B004
    2:     return inspect.isgeneratorfunction(dunder_call)
       
       
    1: async def solve_generator(
    1:     *, call: Callable[..., Any], stack: AsyncExitStack, sub_values: Dict[str, Any]
    1: ) -> Any:
    2:     if is_gen_callable(call):
    2:         cm = contextmanager_in_threadpool(contextmanager(call)(**sub_values))
>>>>>>     elif is_async_gen_callable(call):
>>>>>>         cm = asynccontextmanager(call)(**sub_values)
    2:     return await stack.enter_async_context(cm)
       
       
    2: async def solve_dependencies(
           *,
    1:     request: Union[Request, WebSocket],
    1:     dependant: Dependant,
    2:     body: Optional[Union[Dict[str, Any], FormData]] = None,
    2:     background_tasks: Optional[StarletteBackgroundTasks] = None,
    2:     response: Optional[Response] = None,
    2:     dependency_overrides_provider: Optional[Any] = None,
    2:     dependency_cache: Optional[Dict[Tuple[Callable[..., Any], Tuple[str]], Any]] = None,
    1:     async_exit_stack: AsyncExitStack,
    2: ) -> Tuple[
    2:     Dict[str, Any],
    1:     List[Any],
    1:     Optional[StarletteBackgroundTasks],
    1:     Response,
    1:     Dict[Tuple[Callable[..., Any], Tuple[str]], Any],
       ]:
    6:     values: Dict[str, Any] = {}
    6:     errors: List[Any] = []
    6:     if response is None:
    2:         response = Response()
    2:         del response.headers["content-length"]
    2:         response.status_code = None  # type: ignore
    6:     dependency_cache = dependency_cache or {}
           sub_dependant: Dependant
   10:     for sub_dependant in dependant.dependencies:
    4:         sub_dependant.call = cast(Callable[..., Any], sub_dependant.call)
    8:         sub_dependant.cache_key = cast(
    4:             Tuple[Callable[..., Any], Tuple[str]], sub_dependant.cache_key
               )
    4:         call = sub_dependant.call
    4:         use_sub_dependant = sub_dependant
    8:         if (
    4:             dependency_overrides_provider
    4:             and dependency_overrides_provider.dependency_overrides
               ):
    4:             original_call = sub_dependant.call
   12:             call = getattr(
    4:                 dependency_overrides_provider, "dependency_overrides", {}
    4:             ).get(original_call, original_call)
    4:             use_path: str = sub_dependant.path  # type: ignore
    8:             use_sub_dependant = get_dependant(
    4:                 path=use_path,
    4:                 call=call,
    4:                 name=sub_dependant.name,
    4:                 security_scopes=sub_dependant.security_scopes,
                   )
       
    8:         solved_result = await solve_dependencies(
    4:             request=request,
    4:             dependant=use_sub_dependant,
    4:             body=body,
    4:             background_tasks=background_tasks,
    4:             response=response,
    4:             dependency_overrides_provider=dependency_overrides_provider,
    4:             dependency_cache=dependency_cache,
    4:             async_exit_stack=async_exit_stack,
               )
    4:         (
    4:             sub_values,
    4:             sub_errors,
    4:             background_tasks,
    4:             _,  # the subdependency returns the same response we have
    4:             sub_dependency_cache,
    4:         ) = solved_result
    4:         dependency_cache.update(sub_dependency_cache)
    4:         if sub_errors:
>>>>>>             errors.extend(sub_errors)
>>>>>>             continue
    4:         if sub_dependant.use_cache and sub_dependant.cache_key in dependency_cache:
>>>>>>             solved = dependency_cache[sub_dependant.cache_key]
    4:         elif is_gen_callable(call) or is_async_gen_callable(call):
    4:             solved = await solve_generator(
    2:                 call=call, stack=async_exit_stack, sub_values=sub_values
                   )
    2:         elif is_coroutine_callable(call):
>>>>>>             solved = await call(**sub_values)
               else:
    2:             solved = await run_in_threadpool(call, **sub_values)
    4:         if sub_dependant.name is not None:
    4:             values[sub_dependant.name] = solved
    4:         if sub_dependant.cache_key not in dependency_cache:
    4:             dependency_cache[sub_dependant.cache_key] = solved
   12:     path_values, path_errors = request_params_to_args(
    6:         dependant.path_params, request.path_params
           )
   12:     query_values, query_errors = request_params_to_args(
    6:         dependant.query_params, request.query_params
           )
   12:     header_values, header_errors = request_params_to_args(
    6:         dependant.header_params, request.headers
           )
   12:     cookie_values, cookie_errors = request_params_to_args(
    6:         dependant.cookie_params, request.cookies
           )
    6:     values.update(path_values)
    6:     values.update(query_values)
    6:     values.update(header_values)
    6:     values.update(cookie_values)
    6:     errors += path_errors + query_errors + header_errors + cookie_errors
    6:     if dependant.body_params:
>>>>>>         (
>>>>>>             body_values,
>>>>>>             body_errors,
>>>>>>         ) = await request_body_to_args(  # body_params checked above
>>>>>>             required_params=dependant.body_params, received_body=body
               )
>>>>>>         values.update(body_values)
>>>>>>         errors.extend(body_errors)
    6:     if dependant.http_connection_param_name:
>>>>>>         values[dependant.http_connection_param_name] = request
    6:     if dependant.request_param_name and isinstance(request, Request):
>>>>>>         values[dependant.request_param_name] = request
    6:     elif dependant.websocket_param_name and isinstance(request, WebSocket):
>>>>>>         values[dependant.websocket_param_name] = request
    6:     if dependant.background_tasks_param_name:
>>>>>>         if background_tasks is None:
>>>>>>             background_tasks = BackgroundTasks()
>>>>>>         values[dependant.background_tasks_param_name] = background_tasks
    6:     if dependant.response_param_name:
>>>>>>         values[dependant.response_param_name] = response
    6:     if dependant.security_scopes_param_name:
>>>>>>         values[dependant.security_scopes_param_name] = SecurityScopes(
>>>>>>             scopes=dependant.security_scopes
               )
    6:     return values, errors, background_tasks, response, dependency_cache
       
       
    1: def request_params_to_args(
    1:     required_params: Sequence[ModelField],
    1:     received_params: Union[Mapping[str, Any], QueryParams, Headers],
    1: ) -> Tuple[Dict[str, Any], List[Any]]:
   24:     values = {}
   24:     errors = []
   24:     for field in required_params:
>>>>>>         if is_scalar_sequence_field(field) and isinstance(
>>>>>>             received_params, (QueryParams, Headers)
               ):
>>>>>>             value = received_params.getlist(field.alias) or field.default
               else:
>>>>>>             value = received_params.get(field.alias)
>>>>>>         field_info = field.field_info
>>>>>>         assert isinstance(
>>>>>>             field_info, params.Param
>>>>>>         ), "Params must be subclasses of Param"
>>>>>>         loc = (field_info.in_.value, field.alias)
>>>>>>         if value is None:
>>>>>>             if field.required:
>>>>>>                 errors.append(get_missing_field_error(loc=loc))
                   else:
>>>>>>                 values[field.name] = deepcopy(field.default)
>>>>>>             continue
>>>>>>         v_, errors_ = field.validate(value, values, loc=loc)
>>>>>>         if isinstance(errors_, ErrorWrapper):
>>>>>>             errors.append(errors_)
>>>>>>         elif isinstance(errors_, list):
>>>>>>             new_errors = _regenerate_error_with_loc(errors=errors_, loc_prefix=())
>>>>>>             errors.extend(new_errors)
               else:
>>>>>>             values[field.name] = v_
   24:     return values, errors
       
       
    1: async def request_body_to_args(
    1:     required_params: List[ModelField],
    1:     received_body: Optional[Union[Dict[str, Any], FormData]],
    1: ) -> Tuple[Dict[str, Any], List[Dict[str, Any]]]:
>>>>>>     values = {}
>>>>>>     errors: List[Dict[str, Any]] = []
>>>>>>     if required_params:
>>>>>>         field = required_params[0]
>>>>>>         field_info = field.field_info
>>>>>>         embed = getattr(field_info, "embed", None)
>>>>>>         field_alias_omitted = len(required_params) == 1 and not embed
>>>>>>         if field_alias_omitted:
>>>>>>             received_body = {field.alias: received_body}
       
>>>>>>         for field in required_params:
                   loc: Tuple[str, ...]
>>>>>>             if field_alias_omitted:
>>>>>>                 loc = ("body",)
                   else:
>>>>>>                 loc = ("body", field.alias)
       
>>>>>>             value: Optional[Any] = None
>>>>>>             if received_body is not None:
>>>>>>                 if (is_sequence_field(field)) and isinstance(received_body, FormData):
>>>>>>                     value = received_body.getlist(field.alias)
                       else:
>>>>>>                     try:
>>>>>>                         value = received_body.get(field.alias)
>>>>>>                     except AttributeError:
>>>>>>                         errors.append(get_missing_field_error(loc))
>>>>>>                         continue
>>>>>>             if (
>>>>>>                 value is None
>>>>>>                 or (isinstance(field_info, params.Form) and value == "")
                       or (
>>>>>>                     isinstance(field_info, params.Form)
>>>>>>                     and is_sequence_field(field)
>>>>>>                     and len(value) == 0
                       )
                   ):
>>>>>>                 if field.required:
>>>>>>                     errors.append(get_missing_field_error(loc))
                       else:
>>>>>>                     values[field.name] = deepcopy(field.default)
>>>>>>                 continue
>>>>>>             if (
>>>>>>                 isinstance(field_info, params.File)
>>>>>>                 and is_bytes_field(field)
>>>>>>                 and isinstance(value, UploadFile)
                   ):
>>>>>>                 value = await value.read()
>>>>>>             elif (
>>>>>>                 is_bytes_sequence_field(field)
>>>>>>                 and isinstance(field_info, params.File)
>>>>>>                 and value_is_sequence(value)
                   ):
                       # For types
>>>>>>                 assert isinstance(value, sequence_types)  # type: ignore[arg-type]
>>>>>>                 results: List[Union[bytes, str]] = []
       
>>>>>>                 async def process_fn(
>>>>>>                     fn: Callable[[], Coroutine[Any, Any, Any]]
>>>>>>                 ) -> None:
>>>>>>                     result = await fn()
>>>>>>                     results.append(result)  # noqa: B023
       
>>>>>>                 async with anyio.create_task_group() as tg:
>>>>>>                     for sub_value in value:
>>>>>>                         tg.start_soon(process_fn, sub_value.read)
>>>>>>                 value = serialize_sequence_value(field=field, value=results)
       
>>>>>>             v_, errors_ = field.validate(value, values, loc=loc)
       
>>>>>>             if isinstance(errors_, list):
>>>>>>                 errors.extend(errors_)
>>>>>>             elif errors_:
>>>>>>                 errors.append(errors_)
                   else:
>>>>>>                 values[field.name] = v_
>>>>>>     return values, errors
       
       
    1: def get_body_field(*, dependant: Dependant, name: str) -> Optional[ModelField]:
    2:     flat_dependant = get_flat_dependant(dependant)
    2:     if not flat_dependant.body_params:
    2:         return None
>>>>>>     first_param = flat_dependant.body_params[0]
>>>>>>     field_info = first_param.field_info
>>>>>>     embed = getattr(field_info, "embed", None)
>>>>>>     body_param_names_set = {param.name for param in flat_dependant.body_params}
>>>>>>     if len(body_param_names_set) == 1 and not embed:
>>>>>>         check_file_field(first_param)
>>>>>>         return first_param
           # If one field requires to embed, all have to be embedded
           # in case a sub-dependency is evaluated with a single unique body field
           # That is combined (embedded) with other body fields
>>>>>>     for param in flat_dependant.body_params:
>>>>>>         setattr(param.field_info, "embed", True)  # noqa: B010
>>>>>>     model_name = "Body_" + name
>>>>>>     BodyModel = create_body_model(
>>>>>>         fields=flat_dependant.body_params, model_name=model_name
           )
>>>>>>     required = any(True for f in flat_dependant.body_params if f.required)
>>>>>>     BodyFieldInfo_kwargs: Dict[str, Any] = {
>>>>>>         "annotation": BodyModel,
>>>>>>         "alias": "body",
           }
>>>>>>     if not required:
>>>>>>         BodyFieldInfo_kwargs["default"] = None
>>>>>>     if any(isinstance(f.field_info, params.File) for f in flat_dependant.body_params):
>>>>>>         BodyFieldInfo: Type[params.Body] = params.File
>>>>>>     elif any(isinstance(f.field_info, params.Form) for f in flat_dependant.body_params):
>>>>>>         BodyFieldInfo = params.Form
           else:
>>>>>>         BodyFieldInfo = params.Body
       
>>>>>>         body_param_media_types = [
>>>>>>             f.field_info.media_type
>>>>>>             for f in flat_dependant.body_params
>>>>>>             if isinstance(f.field_info, params.Body)
               ]
>>>>>>         if len(set(body_param_media_types)) == 1:
>>>>>>             BodyFieldInfo_kwargs["media_type"] = body_param_media_types[0]
>>>>>>     final_field = create_response_field(
>>>>>>         name="body",
>>>>>>         type_=BodyModel,
>>>>>>         required=required,
>>>>>>         alias="body",
>>>>>>         field_info=BodyFieldInfo(**BodyFieldInfo_kwargs),
           )
>>>>>>     check_file_field(final_field)
>>>>>>     return final_field
