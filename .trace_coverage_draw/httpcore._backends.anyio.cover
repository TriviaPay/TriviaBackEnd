    1: import ssl
    1: import typing
       
    1: import anyio
       
    1: from .._exceptions import (
           ConnectError,
           ConnectTimeout,
           ReadError,
           ReadTimeout,
           WriteError,
           WriteTimeout,
           map_exceptions,
       )
    1: from .._utils import is_socket_readable
    1: from .base import SOCKET_OPTION, AsyncNetworkBackend, AsyncNetworkStream
       
       
    2: class AnyIOStream(AsyncNetworkStream):
    1:     def __init__(self, stream: anyio.abc.ByteStream) -> None:
>>>>>>         self._stream = stream
       
    2:     async def read(
    1:         self, max_bytes: int, timeout: typing.Optional[float] = None
    1:     ) -> bytes:
>>>>>>         exc_map = {
>>>>>>             TimeoutError: ReadTimeout,
>>>>>>             anyio.BrokenResourceError: ReadError,
>>>>>>             anyio.ClosedResourceError: ReadError,
               }
>>>>>>         with map_exceptions(exc_map):
>>>>>>             with anyio.fail_after(timeout):
>>>>>>                 try:
>>>>>>                     return await self._stream.receive(max_bytes=max_bytes)
>>>>>>                 except anyio.EndOfStream:  # pragma: nocover
>>>>>>                     return b""
       
    2:     async def write(
    1:         self, buffer: bytes, timeout: typing.Optional[float] = None
    1:     ) -> None:
>>>>>>         if not buffer:
>>>>>>             return
       
>>>>>>         exc_map = {
>>>>>>             TimeoutError: WriteTimeout,
>>>>>>             anyio.BrokenResourceError: WriteError,
>>>>>>             anyio.ClosedResourceError: WriteError,
               }
>>>>>>         with map_exceptions(exc_map):
>>>>>>             with anyio.fail_after(timeout):
>>>>>>                 await self._stream.send(item=buffer)
       
    1:     async def aclose(self) -> None:
>>>>>>         await self._stream.aclose()
       
    2:     async def start_tls(
               self,
    1:         ssl_context: ssl.SSLContext,
    1:         server_hostname: typing.Optional[str] = None,
    1:         timeout: typing.Optional[float] = None,
    1:     ) -> AsyncNetworkStream:
>>>>>>         exc_map = {
>>>>>>             TimeoutError: ConnectTimeout,
>>>>>>             anyio.BrokenResourceError: ConnectError,
               }
>>>>>>         with map_exceptions(exc_map):
>>>>>>             try:
>>>>>>                 with anyio.fail_after(timeout):
>>>>>>                     ssl_stream = await anyio.streams.tls.TLSStream.wrap(
>>>>>>                         self._stream,
>>>>>>                         ssl_context=ssl_context,
>>>>>>                         hostname=server_hostname,
>>>>>>                         standard_compatible=False,
>>>>>>                         server_side=False,
                           )
>>>>>>             except Exception as exc:  # pragma: nocover
>>>>>>                 await self.aclose()
>>>>>>                 raise exc
>>>>>>         return AnyIOStream(ssl_stream)
       
    1:     def get_extra_info(self, info: str) -> typing.Any:
>>>>>>         if info == "ssl_object":
>>>>>>             return self._stream.extra(anyio.streams.tls.TLSAttribute.ssl_object, None)
>>>>>>         if info == "client_addr":
>>>>>>             return self._stream.extra(anyio.abc.SocketAttribute.local_address, None)
>>>>>>         if info == "server_addr":
>>>>>>             return self._stream.extra(anyio.abc.SocketAttribute.remote_address, None)
>>>>>>         if info == "socket":
>>>>>>             return self._stream.extra(anyio.abc.SocketAttribute.raw_socket, None)
>>>>>>         if info == "is_readable":
>>>>>>             sock = self._stream.extra(anyio.abc.SocketAttribute.raw_socket, None)
>>>>>>             return is_socket_readable(sock)
>>>>>>         return None
       
       
    2: class AnyIOBackend(AsyncNetworkBackend):
    2:     async def connect_tcp(
               self,
    1:         host: str,
    1:         port: int,
    1:         timeout: typing.Optional[float] = None,
    1:         local_address: typing.Optional[str] = None,
    1:         socket_options: typing.Optional[typing.Iterable[SOCKET_OPTION]] = None,
    1:     ) -> AsyncNetworkStream:
>>>>>>         if socket_options is None:
>>>>>>             socket_options = []  # pragma: no cover
>>>>>>         exc_map = {
>>>>>>             TimeoutError: ConnectTimeout,
>>>>>>             OSError: ConnectError,
>>>>>>             anyio.BrokenResourceError: ConnectError,
               }
>>>>>>         with map_exceptions(exc_map):
>>>>>>             with anyio.fail_after(timeout):
>>>>>>                 stream: anyio.abc.ByteStream = await anyio.connect_tcp(
>>>>>>                     remote_host=host,
>>>>>>                     remote_port=port,
>>>>>>                     local_host=local_address,
                       )
                       # By default TCP sockets opened in `asyncio` include TCP_NODELAY.
>>>>>>                 for option in socket_options:
>>>>>>                     stream._raw_socket.setsockopt(*option)  # type: ignore[attr-defined] # pragma: no cover
>>>>>>         return AnyIOStream(stream)
       
    2:     async def connect_unix_socket(
               self,
    1:         path: str,
    1:         timeout: typing.Optional[float] = None,
    1:         socket_options: typing.Optional[typing.Iterable[SOCKET_OPTION]] = None,
    1:     ) -> AsyncNetworkStream:  # pragma: nocover
>>>>>>         if socket_options is None:
>>>>>>             socket_options = []
>>>>>>         exc_map = {
>>>>>>             TimeoutError: ConnectTimeout,
>>>>>>             OSError: ConnectError,
>>>>>>             anyio.BrokenResourceError: ConnectError,
               }
>>>>>>         with map_exceptions(exc_map):
>>>>>>             with anyio.fail_after(timeout):
>>>>>>                 stream: anyio.abc.ByteStream = await anyio.connect_unix(path)
>>>>>>                 for option in socket_options:
>>>>>>                     stream._raw_socket.setsockopt(*option)  # type: ignore[attr-defined] # pragma: no cover
>>>>>>         return AnyIOStream(stream)
       
    1:     async def sleep(self, seconds: float) -> None:
>>>>>>         await anyio.sleep(seconds)  # pragma: nocover
