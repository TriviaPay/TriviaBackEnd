       # dialects/postgresql/types.py
       # Copyright (C) 2013-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
    1: from __future__ import annotations
       
    1: import datetime as dt
    1: from typing import Any
    1: from typing import Optional
    1: from typing import overload
    1: from typing import Type
    1: from typing import TYPE_CHECKING
    1: from uuid import UUID as _python_UUID
       
    1: from ...sql import sqltypes
    1: from ...sql import type_api
    1: from ...util.typing import Literal
       
    1: if TYPE_CHECKING:
>>>>>>     from ...engine.interfaces import Dialect
>>>>>>     from ...sql.operators import OperatorType
>>>>>>     from ...sql.type_api import _LiteralProcessorType
>>>>>>     from ...sql.type_api import TypeEngine
       
    1: _DECIMAL_TYPES = (1231, 1700)
    1: _FLOAT_TYPES = (700, 701, 1021, 1022)
    1: _INT_TYPES = (20, 21, 23, 26, 1005, 1007, 1016)
       
       
    2: class PGUuid(sqltypes.UUID[sqltypes._UUID_RETURN]):
    1:     render_bind_cast = True
    1:     render_literal_cast = True
       
    1:     if TYPE_CHECKING:
       
>>>>>>         @overload
>>>>>>         def __init__(
                   self: PGUuid[_python_UUID], as_uuid: Literal[True] = ...
>>>>>>         ) -> None: ...
       
>>>>>>         @overload
>>>>>>         def __init__(
                   self: PGUuid[str], as_uuid: Literal[False] = ...
>>>>>>         ) -> None: ...
       
>>>>>>         def __init__(self, as_uuid: bool = True) -> None: ...
       
       
    2: class BYTEA(sqltypes.LargeBinary):
    1:     __visit_name__ = "BYTEA"
       
       
    2: class INET(sqltypes.TypeEngine[str]):
    1:     __visit_name__ = "INET"
       
       
    1: PGInet = INET
       
       
    2: class CIDR(sqltypes.TypeEngine[str]):
    1:     __visit_name__ = "CIDR"
       
       
    1: PGCidr = CIDR
       
       
    2: class MACADDR(sqltypes.TypeEngine[str]):
    1:     __visit_name__ = "MACADDR"
       
       
    1: PGMacAddr = MACADDR
       
       
    2: class MACADDR8(sqltypes.TypeEngine[str]):
    1:     __visit_name__ = "MACADDR8"
       
       
    1: PGMacAddr8 = MACADDR8
       
       
    2: class MONEY(sqltypes.TypeEngine[str]):
    1:     r"""Provide the PostgreSQL MONEY type.
       
           Depending on driver, result rows using this type may return a
           string value which includes currency symbols.
       
           For this reason, it may be preferable to provide conversion to a
           numerically-based currency datatype using :class:`_types.TypeDecorator`::
       
               import re
               import decimal
               from sqlalchemy import Dialect
               from sqlalchemy import TypeDecorator
       
               class NumericMoney(TypeDecorator):
                   impl = MONEY
       
                   def process_result_value(
                       self, value: Any, dialect: Dialect
                   ) -> None:
                       if value is not None:
                           # adjust this for the currency and numeric
                           m = re.match(r"\$([\d.]+)", value)
                           if m:
                               value = decimal.Decimal(m.group(1))
                       return value
       
           Alternatively, the conversion may be applied as a CAST using
           the :meth:`_types.TypeDecorator.column_expression` method as follows::
       
               import decimal
               from sqlalchemy import cast
               from sqlalchemy import TypeDecorator
       
               class NumericMoney(TypeDecorator):
                   impl = MONEY
       
                   def column_expression(self, column: Any):
                       return cast(column, Numeric())
       
           .. versionadded:: 1.2
       
           """
       
    1:     __visit_name__ = "MONEY"
       
       
    2: class OID(sqltypes.TypeEngine[int]):
    1:     """Provide the PostgreSQL OID type."""
       
    1:     __visit_name__ = "OID"
       
       
    2: class REGCONFIG(sqltypes.TypeEngine[str]):
    1:     """Provide the PostgreSQL REGCONFIG type.
       
           .. versionadded:: 2.0.0rc1
       
           """
       
    1:     __visit_name__ = "REGCONFIG"
       
       
    2: class TSQUERY(sqltypes.TypeEngine[str]):
    1:     """Provide the PostgreSQL TSQUERY type.
       
           .. versionadded:: 2.0.0rc1
       
           """
       
    1:     __visit_name__ = "TSQUERY"
       
       
    2: class REGCLASS(sqltypes.TypeEngine[str]):
    1:     """Provide the PostgreSQL REGCLASS type.
       
           .. versionadded:: 1.2.7
       
           """
       
    1:     __visit_name__ = "REGCLASS"
       
       
    2: class TIMESTAMP(sqltypes.TIMESTAMP):
    1:     """Provide the PostgreSQL TIMESTAMP type."""
       
    1:     __visit_name__ = "TIMESTAMP"
       
    1:     def __init__(
               self, timezone: bool = False, precision: Optional[int] = None
           ) -> None:
               """Construct a TIMESTAMP.
       
               :param timezone: boolean value if timezone present, default False
               :param precision: optional integer precision value
       
                .. versionadded:: 1.4
       
               """
>>>>>>         super().__init__(timezone=timezone)
>>>>>>         self.precision = precision
       
       
    2: class TIME(sqltypes.TIME):
    1:     """PostgreSQL TIME type."""
       
    1:     __visit_name__ = "TIME"
       
    1:     def __init__(
               self, timezone: bool = False, precision: Optional[int] = None
           ) -> None:
               """Construct a TIME.
       
               :param timezone: boolean value if timezone present, default False
               :param precision: optional integer precision value
       
                .. versionadded:: 1.4
       
               """
>>>>>>         super().__init__(timezone=timezone)
>>>>>>         self.precision = precision
       
       
    2: class INTERVAL(type_api.NativeForEmulated, sqltypes._AbstractInterval):
    1:     """PostgreSQL INTERVAL type."""
       
    1:     __visit_name__ = "INTERVAL"
    1:     native = True
       
    1:     def __init__(
               self, precision: Optional[int] = None, fields: Optional[str] = None
           ) -> None:
               """Construct an INTERVAL.
       
               :param precision: optional integer precision value
               :param fields: string fields specifier.  allows storage of fields
                to be limited, such as ``"YEAR"``, ``"MONTH"``, ``"DAY TO HOUR"``,
                etc.
       
                .. versionadded:: 1.2
       
               """
>>>>>>         self.precision = precision
>>>>>>         self.fields = fields
       
    1:     @classmethod
    1:     def adapt_emulated_to_native(
               cls, interval: sqltypes.Interval, **kw: Any  # type: ignore[override]
           ) -> INTERVAL:
>>>>>>         return INTERVAL(precision=interval.second_precision)
       
    1:     @property
    1:     def _type_affinity(self) -> Type[sqltypes.Interval]:
>>>>>>         return sqltypes.Interval
       
    1:     def as_generic(self, allow_nulltype: bool = False) -> sqltypes.Interval:
>>>>>>         return sqltypes.Interval(native=True, second_precision=self.precision)
       
    1:     @property
    1:     def python_type(self) -> Type[dt.timedelta]:
>>>>>>         return dt.timedelta
       
    1:     def literal_processor(
               self, dialect: Dialect
           ) -> Optional[_LiteralProcessorType[dt.timedelta]]:
>>>>>>         def process(value: dt.timedelta) -> str:
>>>>>>             return f"make_interval(secs=>{value.total_seconds()})"
       
>>>>>>         return process
       
       
    1: PGInterval = INTERVAL
       
       
    2: class BIT(sqltypes.TypeEngine[int]):
    1:     __visit_name__ = "BIT"
       
    1:     def __init__(
               self, length: Optional[int] = None, varying: bool = False
           ) -> None:
>>>>>>         if varying:
                   # BIT VARYING can be unlimited-length, so no default
>>>>>>             self.length = length
               else:
                   # BIT without VARYING defaults to length 1
>>>>>>             self.length = length or 1
>>>>>>         self.varying = varying
       
       
    1: PGBit = BIT
       
       
    2: class TSVECTOR(sqltypes.TypeEngine[str]):
    1:     """The :class:`_postgresql.TSVECTOR` type implements the PostgreSQL
           text search type TSVECTOR.
       
           It can be used to do full text queries on natural language
           documents.
       
           .. seealso::
       
               :ref:`postgresql_match`
       
           """
       
    1:     __visit_name__ = "TSVECTOR"
       
       
    2: class CITEXT(sqltypes.TEXT):
    1:     """Provide the PostgreSQL CITEXT type.
       
           .. versionadded:: 2.0.7
       
           """
       
    1:     __visit_name__ = "CITEXT"
       
    1:     def coerce_compared_value(
               self, op: Optional[OperatorType], value: Any
           ) -> TypeEngine[Any]:
>>>>>>         return self
