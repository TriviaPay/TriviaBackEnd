       # util/topological.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: """Topological sorting algorithms."""
       
    1: from __future__ import annotations
       
    1: from typing import Any
    1: from typing import Collection
    1: from typing import DefaultDict
    1: from typing import Iterable
    1: from typing import Iterator
    1: from typing import Sequence
    1: from typing import Set
    1: from typing import Tuple
    1: from typing import TypeVar
       
    1: from .. import util
    1: from ..exc import CircularDependencyError
       
    1: _T = TypeVar("_T", bound=Any)
       
    1: __all__ = ["sort", "sort_as_subsets", "find_cycles"]
       
       
    1: def sort_as_subsets(
           tuples: Collection[Tuple[_T, _T]], allitems: Collection[_T]
       ) -> Iterator[Sequence[_T]]:
    3:     edges: DefaultDict[_T, Set[_T]] = util.defaultdict(set)
   48:     for parent, child in tuples:
   45:         edges[child].add(parent)
       
    3:     todo = list(allitems)
    3:     todo_set = set(allitems)
       
   10:     while todo_set:
    7:         output = []
  122:         for node in todo:
  115:             if todo_set.isdisjoint(edges[node]):
   48:                 output.append(node)
       
    7:         if not output:
>>>>>>             raise CircularDependencyError(
>>>>>>                 "Circular dependency detected.",
>>>>>>                 find_cycles(tuples, allitems),
>>>>>>                 _gen_edges(edges),
                   )
       
    7:         todo_set.difference_update(output)
  129:         todo = [t for t in todo if t in todo_set]
    7:         yield output
       
       
    1: def sort(
           tuples: Collection[Tuple[_T, _T]],
           allitems: Collection[_T],
           deterministic_order: bool = True,
       ) -> Iterator[_T]:
           """sort the given list of items by dependency.
       
           'tuples' is a list of tuples representing a partial ordering.
       
           deterministic_order is no longer used, the order is now always
           deterministic given the order of "allitems".    the flag is there
           for backwards compatibility with Alembic.
       
           """
       
   10:     for set_ in sort_as_subsets(tuples, allitems):
    7:         yield from set_
       
       
    1: def find_cycles(
           tuples: Iterable[Tuple[_T, _T]], allitems: Iterable[_T]
       ) -> Set[_T]:
           # adapted from:
           # https://neopythonic.blogspot.com/2009/01/detecting-cycles-in-directed-graph.html
       
    1:     edges: DefaultDict[_T, Set[_T]] = util.defaultdict(set)
    2:     for parent, child in tuples:
    1:         edges[parent].add(child)
    1:     nodes_to_test = set(edges)
       
    1:     output = set()
       
           # we'd like to find all nodes that are
           # involved in cycles, so we do the full
           # pass through the whole thing for each
           # node in the original list.
       
           # we can go just through parent edge nodes.
           # if a node is only a child and never a parent,
           # by definition it can't be part of a cycle.  same
           # if it's not in the edges at all.
    2:     for node in nodes_to_test:
    1:         stack = [node]
    1:         todo = nodes_to_test.difference(stack)
    2:         while stack:
    1:             top = stack[-1]
    2:             for node in edges[top]:
    1:                 if node in stack:
>>>>>>                     cyc = stack[stack.index(node) :]
>>>>>>                     todo.difference_update(cyc)
>>>>>>                     output.update(cyc)
       
    1:                 if node in todo:
>>>>>>                     stack.append(node)
>>>>>>                     todo.remove(node)
>>>>>>                     break
                   else:
    1:                 node = stack.pop()
    1:     return output
       
       
    1: def _gen_edges(edges: DefaultDict[_T, Set[_T]]) -> Set[Tuple[_T, _T]]:
>>>>>>     return {(right, left) for left in edges for right in edges[left]}
