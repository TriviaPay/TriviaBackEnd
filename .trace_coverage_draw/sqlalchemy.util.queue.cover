       # util/queue.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       # mypy: allow-untyped-defs, allow-untyped-calls
       
    1: """An adaptation of Py2.3/2.4's Queue module which supports reentrant
       behavior, using RLock instead of Lock for its mutex object.  The
       Queue object is used exclusively by the sqlalchemy.pool.QueuePool
       class.
       
       This is to support the connection pool's usage of weakref callbacks to return
       connections to the underlying Queue, which can in extremely
       rare cases be invoked within the ``get()`` method of the Queue itself,
       producing a ``put()`` inside the ``get()`` and therefore a reentrant
       condition.
       
       """
    1: from __future__ import annotations
       
    1: import asyncio
    1: from collections import deque
    1: import threading
    1: from time import time as _time
    1: import typing
    1: from typing import Any
    1: from typing import Awaitable
    1: from typing import Deque
    1: from typing import Generic
    1: from typing import Optional
    1: from typing import TypeVar
       
    1: from .concurrency import await_fallback
    1: from .concurrency import await_only
    1: from .langhelpers import memoized_property
       
       
    1: _T = TypeVar("_T", bound=Any)
    1: __all__ = ["Empty", "Full", "Queue"]
       
       
    2: class Empty(Exception):
    1:     "Exception raised by Queue.get(block=0)/get_nowait()."
       
    1:     pass
       
       
    2: class Full(Exception):
    1:     "Exception raised by Queue.put(block=0)/put_nowait()."
       
    1:     pass
       
       
    2: class QueueCommon(Generic[_T]):
    1:     maxsize: int
    1:     use_lifo: bool
       
    1:     def __init__(self, maxsize: int = 0, use_lifo: bool = False): ...
       
    1:     def empty(self) -> bool:
>>>>>>         raise NotImplementedError()
       
    1:     def full(self) -> bool:
>>>>>>         raise NotImplementedError()
       
    1:     def qsize(self) -> int:
>>>>>>         raise NotImplementedError()
       
    1:     def put_nowait(self, item: _T) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def put(
               self, item: _T, block: bool = True, timeout: Optional[float] = None
           ) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def get_nowait(self) -> _T:
>>>>>>         raise NotImplementedError()
       
    1:     def get(self, block: bool = True, timeout: Optional[float] = None) -> _T:
>>>>>>         raise NotImplementedError()
       
       
    2: class Queue(QueueCommon[_T]):
    1:     queue: Deque[_T]
       
    1:     def __init__(self, maxsize: int = 0, use_lifo: bool = False):
               """Initialize a queue object with a given maximum size.
       
               If `maxsize` is <= 0, the queue size is infinite.
       
               If `use_lifo` is True, this Queue acts like a Stack (LIFO).
               """
       
    2:         self._init(maxsize)
               # mutex must be held whenever the queue is mutating.  All methods
               # that acquire mutex must release it before returning.  mutex
               # is shared between the two conditions, so acquiring and
               # releasing the conditions also acquires and releases mutex.
    2:         self.mutex = threading.RLock()
               # Notify not_empty whenever an item is added to the queue; a
               # thread waiting to get is notified then.
    2:         self.not_empty = threading.Condition(self.mutex)
               # Notify not_full whenever an item is removed from the queue;
               # a thread waiting to put is notified then.
    2:         self.not_full = threading.Condition(self.mutex)
               # If this queue uses LIFO or FIFO
    2:         self.use_lifo = use_lifo
       
    1:     def qsize(self) -> int:
               """Return the approximate size of the queue (not reliable!)."""
       
>>>>>>         with self.mutex:
>>>>>>             return self._qsize()
       
    1:     def empty(self) -> bool:
               """Return True if the queue is empty, False otherwise (not
               reliable!)."""
       
>>>>>>         with self.mutex:
>>>>>>             return self._empty()
       
    1:     def full(self) -> bool:
               """Return True if the queue is full, False otherwise (not
               reliable!)."""
       
>>>>>>         with self.mutex:
>>>>>>             return self._full()
       
    1:     def put(
               self, item: _T, block: bool = True, timeout: Optional[float] = None
           ) -> None:
               """Put an item into the queue.
       
               If optional args `block` is True and `timeout` is None (the
               default), block if necessary until a free slot is
               available. If `timeout` is a positive number, it blocks at
               most `timeout` seconds and raises the ``Full`` exception if no
               free slot was available within that time.  Otherwise (`block`
               is false), put an item on the queue if a free slot is
               immediately available, else raise the ``Full`` exception
               (`timeout` is ignored in that case).
               """
       
    5:         with self.not_full:
    5:             if not block:
    5:                 if self._full():
>>>>>>                     raise Full
>>>>>>             elif timeout is None:
>>>>>>                 while self._full():
>>>>>>                     self.not_full.wait()
                   else:
>>>>>>                 if timeout < 0:
>>>>>>                     raise ValueError("'timeout' must be a positive number")
>>>>>>                 endtime = _time() + timeout
>>>>>>                 while self._full():
>>>>>>                     remaining = endtime - _time()
>>>>>>                     if remaining <= 0.0:
>>>>>>                         raise Full
>>>>>>                     self.not_full.wait(remaining)
    5:             self._put(item)
    5:             self.not_empty.notify()
       
    1:     def put_nowait(self, item: _T) -> None:
               """Put an item into the queue without blocking.
       
               Only enqueue the item if a free slot is immediately available.
               Otherwise raise the ``Full`` exception.
               """
>>>>>>         return self.put(item, False)
       
    1:     def get(self, block: bool = True, timeout: Optional[float] = None) -> _T:
               """Remove and return an item from the queue.
       
               If optional args `block` is True and `timeout` is None (the
               default), block if necessary until an item is available. If
               `timeout` is a positive number, it blocks at most `timeout`
               seconds and raises the ``Empty`` exception if no item was
               available within that time.  Otherwise (`block` is false),
               return an item if one is immediately available, else raise the
               ``Empty`` exception (`timeout` is ignored in that case).
       
               """
    5:         with self.not_empty:
    5:             if not block:
    5:                 if self._empty():
    1:                     raise Empty
>>>>>>             elif timeout is None:
>>>>>>                 while self._empty():
>>>>>>                     self.not_empty.wait()
                   else:
>>>>>>                 if timeout < 0:
>>>>>>                     raise ValueError("'timeout' must be a positive number")
>>>>>>                 endtime = _time() + timeout
>>>>>>                 while self._empty():
>>>>>>                     remaining = endtime - _time()
>>>>>>                     if remaining <= 0.0:
>>>>>>                         raise Empty
>>>>>>                     self.not_empty.wait(remaining)
    4:             item = self._get()
    4:             self.not_full.notify()
    5:             return item
       
    1:     def get_nowait(self) -> _T:
               """Remove and return an item from the queue without blocking.
       
               Only get an item if one is immediately available. Otherwise
               raise the ``Empty`` exception.
               """
       
>>>>>>         return self.get(False)
       
    1:     def _init(self, maxsize: int) -> None:
    2:         self.maxsize = maxsize
    2:         self.queue = deque()
       
    1:     def _qsize(self) -> int:
>>>>>>         return len(self.queue)
       
    1:     def _empty(self) -> bool:
    5:         return not self.queue
       
    1:     def _full(self) -> bool:
    5:         return self.maxsize > 0 and len(self.queue) == self.maxsize
       
    1:     def _put(self, item: _T) -> None:
    5:         self.queue.append(item)
       
    1:     def _get(self) -> _T:
    4:         if self.use_lifo:
                   # LIFO
>>>>>>             return self.queue.pop()
               else:
                   # FIFO
    4:             return self.queue.popleft()
       
       
    2: class AsyncAdaptedQueue(QueueCommon[_T]):
    1:     if typing.TYPE_CHECKING:
       
>>>>>>         @staticmethod
>>>>>>         def await_(coroutine: Awaitable[Any]) -> _T: ...
       
           else:
    1:         await_ = staticmethod(await_only)
       
    1:     def __init__(self, maxsize: int = 0, use_lifo: bool = False):
>>>>>>         self.use_lifo = use_lifo
>>>>>>         self.maxsize = maxsize
       
    1:     def empty(self) -> bool:
>>>>>>         return self._queue.empty()
       
    1:     def full(self):
>>>>>>         return self._queue.full()
       
    1:     def qsize(self):
>>>>>>         return self._queue.qsize()
       
    1:     @memoized_property
    1:     def _queue(self) -> asyncio.Queue[_T]:
               # Delay creation of the queue until it is first used, to avoid
               # binding it to a possibly wrong event loop.
               # By delaying the creation of the pool we accommodate the common
               # usage pattern of instantiating the engine at module level, where a
               # different event loop is in present compared to when the application
               # is actually run.
       
               queue: asyncio.Queue[_T]
       
>>>>>>         if self.use_lifo:
>>>>>>             queue = asyncio.LifoQueue(maxsize=self.maxsize)
               else:
>>>>>>             queue = asyncio.Queue(maxsize=self.maxsize)
>>>>>>         return queue
       
    1:     def put_nowait(self, item: _T) -> None:
>>>>>>         try:
>>>>>>             self._queue.put_nowait(item)
>>>>>>         except asyncio.QueueFull as err:
>>>>>>             raise Full() from err
       
    1:     def put(
               self, item: _T, block: bool = True, timeout: Optional[float] = None
           ) -> None:
>>>>>>         if not block:
>>>>>>             return self.put_nowait(item)
       
>>>>>>         try:
>>>>>>             if timeout is not None:
>>>>>>                 self.await_(asyncio.wait_for(self._queue.put(item), timeout))
                   else:
>>>>>>                 self.await_(self._queue.put(item))
>>>>>>         except (asyncio.QueueFull, asyncio.TimeoutError) as err:
>>>>>>             raise Full() from err
       
    1:     def get_nowait(self) -> _T:
>>>>>>         try:
>>>>>>             return self._queue.get_nowait()
>>>>>>         except asyncio.QueueEmpty as err:
>>>>>>             raise Empty() from err
       
    1:     def get(self, block: bool = True, timeout: Optional[float] = None) -> _T:
>>>>>>         if not block:
>>>>>>             return self.get_nowait()
       
>>>>>>         try:
>>>>>>             if timeout is not None:
>>>>>>                 return self.await_(
>>>>>>                     asyncio.wait_for(self._queue.get(), timeout)
                       )
                   else:
>>>>>>                 return self.await_(self._queue.get())
>>>>>>         except (asyncio.QueueEmpty, asyncio.TimeoutError) as err:
>>>>>>             raise Empty() from err
       
       
    2: class FallbackAsyncAdaptedQueue(AsyncAdaptedQueue[_T]):
    1:     if not typing.TYPE_CHECKING:
    1:         await_ = staticmethod(await_fallback)
