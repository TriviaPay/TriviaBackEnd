    1: from __future__ import annotations
       
    1: import array
    1: import asyncio
    1: import concurrent.futures
    1: import math
    1: import socket
    1: import sys
    1: from asyncio.base_events import _run_until_complete_cb  # type: ignore[attr-defined]
    1: from collections import OrderedDict, deque
    1: from concurrent.futures import Future
    1: from contextvars import Context, copy_context
    1: from dataclasses import dataclass
    1: from functools import partial, wraps
    1: from inspect import (
           CORO_RUNNING,
           CORO_SUSPENDED,
           GEN_RUNNING,
           GEN_SUSPENDED,
           getcoroutinestate,
           getgeneratorstate,
       )
    1: from io import IOBase
    1: from os import PathLike
    1: from queue import Queue
    1: from socket import AddressFamily, SocketKind
    1: from threading import Thread
    1: from types import TracebackType
    1: from typing import (
           IO,
           Any,
           AsyncGenerator,
           Awaitable,
           Callable,
           Collection,
           Coroutine,
           Generator,
           Iterable,
           Mapping,
           Optional,
           Sequence,
           Tuple,
           TypeVar,
           Union,
           cast,
       )
    1: from weakref import WeakKeyDictionary
       
    1: import sniffio
       
    1: from .. import CapacityLimiterStatistics, EventStatistics, TaskInfo, abc
    1: from .._core._compat import DeprecatedAsyncContextManager, DeprecatedAwaitable
    1: from .._core._eventloop import claim_worker_thread, threadlocals
    1: from .._core._exceptions import (
           BrokenResourceError,
           BusyResourceError,
           ClosedResourceError,
           EndOfStream,
           WouldBlock,
       )
    1: from .._core._exceptions import ExceptionGroup as BaseExceptionGroup
    1: from .._core._sockets import GetAddrInfoReturnType, convert_ipv6_sockaddr
    1: from .._core._synchronization import CapacityLimiter as BaseCapacityLimiter
    1: from .._core._synchronization import Event as BaseEvent
    1: from .._core._synchronization import ResourceGuard
    1: from .._core._tasks import CancelScope as BaseCancelScope
    1: from ..abc import IPSockAddrType, UDPPacketType
    1: from ..lowlevel import RunVar
       
    1: if sys.version_info >= (3, 8):
       
    1:     def get_coro(task: asyncio.Task) -> Generator | Awaitable[Any]:
>>>>>>         return task.get_coro()
       
       else:
       
>>>>>>     def get_coro(task: asyncio.Task) -> Generator | Awaitable[Any]:
>>>>>>         return task._coro
       
       
    1: from asyncio import all_tasks, create_task, current_task, get_running_loop
    1: from asyncio import run as native_run
       
       
    1: def _get_task_callbacks(task: asyncio.Task) -> Iterable[Callable]:
    3:     return [cb for cb, context in task._callbacks]
       
       
    1: T_Retval = TypeVar("T_Retval")
    1: T_contra = TypeVar("T_contra", contravariant=True)
       
       # Check whether there is native support for task names in asyncio (3.8+)
    1: _native_task_names = hasattr(asyncio.Task, "get_name")
       
       
    1: _root_task: RunVar[asyncio.Task | None] = RunVar("_root_task")
       
       
    1: def find_root_task() -> asyncio.Task:
    8:     root_task = _root_task.get(None)
    8:     if root_task is not None and not root_task.done():
    7:         return root_task
       
           # Look for a task that has been started via run_until_complete()
    1:     for task in all_tasks():
    1:         if task._callbacks and not task.done():
    1:             for cb in _get_task_callbacks(task):
    1:                 if (
    1:                     cb is _run_until_complete_cb
>>>>>>                     or getattr(cb, "__module__", None) == "uvloop.loop"
                       ):
    1:                     _root_task.set(task)
    1:                     return task
       
           # Look up the topmost task in the AnyIO task tree, if possible
>>>>>>     task = cast(asyncio.Task, current_task())
>>>>>>     state = _task_states.get(task)
>>>>>>     if state:
>>>>>>         cancel_scope = state.cancel_scope
>>>>>>         while cancel_scope and cancel_scope._parent_scope is not None:
>>>>>>             cancel_scope = cancel_scope._parent_scope
       
>>>>>>         if cancel_scope is not None:
>>>>>>             return cast(asyncio.Task, cancel_scope._host_task)
       
>>>>>>     return task
       
       
    1: def get_callable_name(func: Callable) -> str:
    9:     module = getattr(func, "__module__", None)
    9:     qualname = getattr(func, "__qualname__", None)
   36:     return ".".join([x for x in (module, qualname) if x])
       
       
       #
       # Event loop
       #
       
    1: _run_vars = (
    1:     WeakKeyDictionary()
       )  # type: WeakKeyDictionary[asyncio.AbstractEventLoop, Any]
       
    1: current_token = get_running_loop
       
       
    1: def _task_started(task: asyncio.Task) -> bool:
           """Return ``True`` if the task has been started and has not finished."""
>>>>>>     coro = cast(Coroutine[Any, Any, Any], get_coro(task))
>>>>>>     try:
>>>>>>         return getcoroutinestate(coro) in (CORO_RUNNING, CORO_SUSPENDED)
>>>>>>     except AttributeError:
>>>>>>         try:
>>>>>>             return getgeneratorstate(cast(Generator, coro)) in (
>>>>>>                 GEN_RUNNING,
>>>>>>                 GEN_SUSPENDED,
                   )
>>>>>>         except AttributeError:
                   # task coro is async_genenerator_asend https://bugs.python.org/issue37771
>>>>>>             raise Exception(f"Cannot determine if task {task} has started or not")
       
       
    1: def _maybe_set_event_loop_policy(
           policy: asyncio.AbstractEventLoopPolicy | None, use_uvloop: bool
       ) -> None:
           # On CPython, use uvloop when possible if no other policy has been given and if not
           # explicitly disabled
    1:     if policy is None and use_uvloop and sys.implementation.name == "cpython":
>>>>>>         try:
>>>>>>             import uvloop
>>>>>>         except ImportError:
>>>>>>             pass
               else:
                   # Test for missing shutdown_default_executor() (uvloop 0.14.0 and earlier)
>>>>>>             if not hasattr(
>>>>>>                 asyncio.AbstractEventLoop, "shutdown_default_executor"
>>>>>>             ) or hasattr(uvloop.loop.Loop, "shutdown_default_executor"):
>>>>>>                 policy = uvloop.EventLoopPolicy()
       
    1:     if policy is not None:
>>>>>>         asyncio.set_event_loop_policy(policy)
       
       
    1: def run(
           func: Callable[..., Awaitable[T_Retval]],
           *args: object,
    1:     debug: bool = False,
    1:     use_uvloop: bool = False,
    1:     policy: asyncio.AbstractEventLoopPolicy | None = None,
       ) -> T_Retval:
    1:     @wraps(func)
    1:     async def wrapper() -> T_Retval:
    1:         task = cast(asyncio.Task, current_task())
    1:         task_state = TaskState(None, get_callable_name(func), None)
    1:         _task_states[task] = task_state
    1:         if _native_task_names:
    1:             task.set_name(task_state.name)
       
    1:         try:
    2:             return await func(*args)
               finally:
    1:             del _task_states[task]
       
    1:     _maybe_set_event_loop_policy(policy, use_uvloop)
    1:     return native_run(wrapper(), debug=debug)
       
       
       #
       # Miscellaneous
       #
       
    1: sleep = asyncio.sleep
       
       
       #
       # Timeouts and cancellation
       #
       
    1: CancelledError = asyncio.CancelledError
       
       
    2: class CancelScope(BaseCancelScope):
    1:     def __new__(
    1:         cls, *, deadline: float = math.inf, shield: bool = False
           ) -> CancelScope:
   24:         return object.__new__(cls)
       
    1:     def __init__(self, deadline: float = math.inf, shield: bool = False):
   30:         self._deadline = deadline
   30:         self._shield = shield
   30:         self._parent_scope: CancelScope | None = None
   30:         self._cancel_called = False
   30:         self._active = False
   30:         self._timeout_handle: asyncio.TimerHandle | None = None
   30:         self._cancel_handle: asyncio.Handle | None = None
   30:         self._tasks: set[asyncio.Task] = set()
   30:         self._host_task: asyncio.Task | None = None
   30:         self._timeout_expired = False
   30:         self._cancel_calls: int = 0
       
    1:     def __enter__(self) -> CancelScope:
   23:         if self._active:
>>>>>>             raise RuntimeError(
>>>>>>                 "Each CancelScope may only be used for a single 'with' block"
                   )
       
   23:         self._host_task = host_task = cast(asyncio.Task, current_task())
   23:         self._tasks.add(host_task)
   23:         try:
   23:             task_state = _task_states[host_task]
>>>>>>         except KeyError:
>>>>>>             task_name = host_task.get_name() if _native_task_names else None
>>>>>>             task_state = TaskState(None, task_name, self)
>>>>>>             _task_states[host_task] = task_state
               else:
   23:             self._parent_scope = task_state.cancel_scope
   23:             task_state.cancel_scope = self
       
   23:         self._timeout()
   23:         self._active = True
       
               # Start cancelling the host task if the scope was cancelled before entering
   23:         if self._cancel_called:
>>>>>>             self._deliver_cancellation()
       
   23:         return self
       
    1:     def __exit__(
               self,
               exc_type: type[BaseException] | None,
               exc_val: BaseException | None,
               exc_tb: TracebackType | None,
           ) -> bool | None:
   23:         if not self._active:
>>>>>>             raise RuntimeError("This cancel scope is not active")
   23:         if current_task() is not self._host_task:
>>>>>>             raise RuntimeError(
>>>>>>                 "Attempted to exit cancel scope in a different task than it was "
                       "entered in"
                   )
       
   23:         assert self._host_task is not None
   23:         host_task_state = _task_states.get(self._host_task)
   23:         if host_task_state is None or host_task_state.cancel_scope is not self:
>>>>>>             raise RuntimeError(
>>>>>>                 "Attempted to exit a cancel scope that isn't the current tasks's "
                       "current cancel scope"
                   )
       
   23:         self._active = False
   23:         if self._timeout_handle:
>>>>>>             self._timeout_handle.cancel()
>>>>>>             self._timeout_handle = None
       
   23:         self._tasks.remove(self._host_task)
       
   23:         host_task_state.cancel_scope = self._parent_scope
       
               # Restart the cancellation effort in the farthest directly cancelled parent scope if this
               # one was shielded
   23:         if self._shield:
   16:             self._deliver_cancellation_to_parent()
       
   23:         if exc_val is not None:
>>>>>>             exceptions = (
>>>>>>                 exc_val.exceptions if isinstance(exc_val, ExceptionGroup) else [exc_val]
                   )
>>>>>>             if all(isinstance(exc, CancelledError) for exc in exceptions):
>>>>>>                 if self._timeout_expired:
>>>>>>                     return self._uncancel()
>>>>>>                 elif not self._cancel_called:
                           # Task was cancelled natively
>>>>>>                     return None
>>>>>>                 elif not self._parent_cancelled():
                           # This scope was directly cancelled
>>>>>>                     return self._uncancel()
       
   23:         return None
       
    1:     def _uncancel(self) -> bool:
>>>>>>         if sys.version_info < (3, 11) or self._host_task is None:
>>>>>>             self._cancel_calls = 0
>>>>>>             return True
       
               # Uncancel all AnyIO cancellations
>>>>>>         for i in range(self._cancel_calls):
>>>>>>             self._host_task.uncancel()
       
>>>>>>         self._cancel_calls = 0
>>>>>>         return not self._host_task.cancelling()
       
    1:     def _timeout(self) -> None:
   23:         if self._deadline != math.inf:
>>>>>>             loop = get_running_loop()
>>>>>>             if loop.time() >= self._deadline:
>>>>>>                 self._timeout_expired = True
>>>>>>                 self.cancel()
                   else:
>>>>>>                 self._timeout_handle = loop.call_at(self._deadline, self._timeout)
       
    1:     def _deliver_cancellation(self) -> None:
               """
               Deliver cancellation to directly contained tasks and nested cancel scopes.
       
               Schedule another run at the end if we still have tasks eligible for cancellation.
               """
>>>>>>         should_retry = False
>>>>>>         current = current_task()
>>>>>>         for task in self._tasks:
>>>>>>             if task._must_cancel:  # type: ignore[attr-defined]
>>>>>>                 continue
       
                   # The task is eligible for cancellation if it has started and is not in a cancel
                   # scope shielded from this one
>>>>>>             cancel_scope = _task_states[task].cancel_scope
>>>>>>             while cancel_scope is not self:
>>>>>>                 if cancel_scope is None or cancel_scope._shield:
>>>>>>                     break
                       else:
>>>>>>                     cancel_scope = cancel_scope._parent_scope
                   else:
>>>>>>                 should_retry = True
>>>>>>                 if task is not current and (
>>>>>>                     task is self._host_task or _task_started(task)
                       ):
>>>>>>                     self._cancel_calls += 1
>>>>>>                     task.cancel()
       
               # Schedule another callback if there are still tasks left
>>>>>>         if should_retry:
>>>>>>             self._cancel_handle = get_running_loop().call_soon(
>>>>>>                 self._deliver_cancellation
                   )
               else:
>>>>>>             self._cancel_handle = None
       
    1:     def _deliver_cancellation_to_parent(self) -> None:
               """Start cancellation effort in the farthest directly cancelled parent scope"""
   16:         scope = self._parent_scope
   16:         scope_to_cancel: CancelScope | None = None
   48:         while scope is not None:
   32:             if scope._cancel_called and scope._cancel_handle is None:
>>>>>>                 scope_to_cancel = scope
       
                   # No point in looking beyond any shielded scope
   32:             if scope._shield:
>>>>>>                 break
       
   32:             scope = scope._parent_scope
       
   16:         if scope_to_cancel is not None:
>>>>>>             scope_to_cancel._deliver_cancellation()
       
    1:     def _parent_cancelled(self) -> bool:
               # Check whether any parent has been cancelled
    1:         cancel_scope = self._parent_scope
    1:         while cancel_scope is not None and not cancel_scope._shield:
>>>>>>             if cancel_scope._cancel_called:
>>>>>>                 return True
                   else:
>>>>>>                 cancel_scope = cancel_scope._parent_scope
       
    1:         return False
       
    1:     def cancel(self) -> DeprecatedAwaitable:
>>>>>>         if not self._cancel_called:
>>>>>>             if self._timeout_handle:
>>>>>>                 self._timeout_handle.cancel()
>>>>>>                 self._timeout_handle = None
       
>>>>>>             self._cancel_called = True
>>>>>>             if self._host_task is not None:
>>>>>>                 self._deliver_cancellation()
       
>>>>>>         return DeprecatedAwaitable(self.cancel)
       
    1:     @property
    1:     def deadline(self) -> float:
>>>>>>         return self._deadline
       
    1:     @deadline.setter
    1:     def deadline(self, value: float) -> None:
>>>>>>         self._deadline = float(value)
>>>>>>         if self._timeout_handle is not None:
>>>>>>             self._timeout_handle.cancel()
>>>>>>             self._timeout_handle = None
       
>>>>>>         if self._active and not self._cancel_called:
>>>>>>             self._timeout()
       
    1:     @property
    1:     def cancel_called(self) -> bool:
   16:         return self._cancel_called
       
    1:     @property
    1:     def shield(self) -> bool:
   16:         return self._shield
       
    1:     @shield.setter
    1:     def shield(self, value: bool) -> None:
>>>>>>         if self._shield != value:
>>>>>>             self._shield = value
>>>>>>             if not value:
>>>>>>                 self._deliver_cancellation_to_parent()
       
       
    1: async def checkpoint() -> None:
   22:     await sleep(0)
       
       
    1: async def checkpoint_if_cancelled() -> None:
    8:     task = current_task()
    8:     if task is None:
>>>>>>         return
       
    8:     try:
    8:         cancel_scope = _task_states[task].cancel_scope
>>>>>>     except KeyError:
>>>>>>         return
       
   24:     while cancel_scope:
   16:         if cancel_scope.cancel_called:
>>>>>>             await sleep(0)
   16:         elif cancel_scope.shield:
>>>>>>             break
               else:
   16:             cancel_scope = cancel_scope._parent_scope
       
       
    1: async def cancel_shielded_checkpoint() -> None:
    8:     with CancelScope(shield=True):
    8:         await sleep(0)
       
       
    1: def current_effective_deadline() -> float:
>>>>>>     try:
>>>>>>         cancel_scope = _task_states[current_task()].cancel_scope  # type: ignore[index]
>>>>>>     except KeyError:
>>>>>>         return math.inf
       
>>>>>>     deadline = math.inf
>>>>>>     while cancel_scope:
>>>>>>         deadline = min(deadline, cancel_scope.deadline)
>>>>>>         if cancel_scope._cancel_called:
>>>>>>             deadline = -math.inf
>>>>>>             break
>>>>>>         elif cancel_scope.shield:
>>>>>>             break
               else:
>>>>>>             cancel_scope = cancel_scope._parent_scope
       
>>>>>>     return deadline
       
       
    1: def current_time() -> float:
   16:     return get_running_loop().time()
       
       
       #
       # Task states
       #
       
       
    2: class TaskState:
    1:     """
           Encapsulates auxiliary task information that cannot be added to the Task instance itself
           because there are no guarantees about its implementation.
           """
       
    1:     __slots__ = "parent_id", "name", "cancel_scope"
       
    1:     def __init__(
               self,
               parent_id: int | None,
               name: str | None,
               cancel_scope: CancelScope | None,
           ):
    9:         self.parent_id = parent_id
    9:         self.name = name
    9:         self.cancel_scope = cancel_scope
       
       
    1: _task_states = WeakKeyDictionary()  # type: WeakKeyDictionary[asyncio.Task, TaskState]
       
       
       #
       # Task groups
       #
       
       
    2: class ExceptionGroup(BaseExceptionGroup):
    1:     def __init__(self, exceptions: list[BaseException]):
>>>>>>         super().__init__()
>>>>>>         self.exceptions = exceptions
       
       
    2: class _AsyncioTaskStatus(abc.TaskStatus):
    1:     def __init__(self, future: asyncio.Future, parent_id: int):
>>>>>>         self._future = future
>>>>>>         self._parent_id = parent_id
       
    1:     def started(self, value: T_contra | None = None) -> None:
>>>>>>         try:
>>>>>>             self._future.set_result(value)
>>>>>>         except asyncio.InvalidStateError:
>>>>>>             raise RuntimeError(
>>>>>>                 "called 'started' twice on the same task status"
>>>>>>             ) from None
       
>>>>>>         task = cast(asyncio.Task, current_task())
>>>>>>         _task_states[task].parent_id = self._parent_id
       
       
    2: class TaskGroup(abc.TaskGroup):
    1:     def __init__(self) -> None:
    2:         self.cancel_scope: CancelScope = CancelScope()
    2:         self._active = False
    2:         self._exceptions: list[BaseException] = []
       
    1:     async def __aenter__(self) -> TaskGroup:
    1:         self.cancel_scope.__enter__()
    1:         self._active = True
    1:         return self
       
    1:     async def __aexit__(
               self,
               exc_type: type[BaseException] | None,
               exc_val: BaseException | None,
               exc_tb: TracebackType | None,
           ) -> bool | None:
    1:         ignore_exception = self.cancel_scope.__exit__(exc_type, exc_val, exc_tb)
    1:         if exc_val is not None:
>>>>>>             self.cancel_scope.cancel()
>>>>>>             self._exceptions.append(exc_val)
       
    1:         while self.cancel_scope._tasks:
>>>>>>             try:
>>>>>>                 await asyncio.wait(self.cancel_scope._tasks)
>>>>>>             except asyncio.CancelledError:
>>>>>>                 self.cancel_scope.cancel()
       
    1:         self._active = False
    1:         if not self.cancel_scope._parent_cancelled():
    1:             exceptions = self._filter_cancellation_errors(self._exceptions)
               else:
>>>>>>             exceptions = self._exceptions
       
    1:         try:
    1:             if len(exceptions) > 1:
>>>>>>                 if all(
>>>>>>                     isinstance(e, CancelledError) and not e.args for e in exceptions
                       ):
                           # Tasks were cancelled natively, without a cancellation message
>>>>>>                     raise CancelledError
                       else:
>>>>>>                     raise ExceptionGroup(exceptions)
    1:             elif exceptions and exceptions[0] is not exc_val:
>>>>>>                 raise exceptions[0]
>>>>>>         except BaseException as exc:
                   # Clear the context here, as it can only be done in-flight.
                   # If the context is not cleared, it can result in recursive tracebacks (see #145).
>>>>>>             exc.__context__ = None
>>>>>>             raise
       
    1:         return ignore_exception
       
    1:     @staticmethod
    1:     def _filter_cancellation_errors(
               exceptions: Sequence[BaseException],
           ) -> list[BaseException]:
    1:         filtered_exceptions: list[BaseException] = []
    1:         for exc in exceptions:
>>>>>>             if isinstance(exc, ExceptionGroup):
>>>>>>                 new_exceptions = TaskGroup._filter_cancellation_errors(exc.exceptions)
>>>>>>                 if len(new_exceptions) > 1:
>>>>>>                     filtered_exceptions.append(exc)
>>>>>>                 elif len(new_exceptions) == 1:
>>>>>>                     filtered_exceptions.append(new_exceptions[0])
>>>>>>                 elif new_exceptions:
>>>>>>                     new_exc = ExceptionGroup(new_exceptions)
>>>>>>                     new_exc.__cause__ = exc.__cause__
>>>>>>                     new_exc.__context__ = exc.__context__
>>>>>>                     new_exc.__traceback__ = exc.__traceback__
>>>>>>                     filtered_exceptions.append(new_exc)
>>>>>>             elif not isinstance(exc, CancelledError) or exc.args:
>>>>>>                 filtered_exceptions.append(exc)
       
    1:         return filtered_exceptions
       
    1:     async def _run_wrapped_task(
               self, coro: Coroutine, task_status_future: asyncio.Future | None
           ) -> None:
               # This is the code path for Python 3.7 on which asyncio freaks out if a task
               # raises a BaseException.
>>>>>>         __traceback_hide__ = __tracebackhide__ = True  # noqa: F841
>>>>>>         task = cast(asyncio.Task, current_task())
>>>>>>         try:
>>>>>>             await coro
>>>>>>         except BaseException as exc:
>>>>>>             if task_status_future is None or task_status_future.done():
>>>>>>                 self._exceptions.append(exc)
>>>>>>                 self.cancel_scope.cancel()
                   else:
>>>>>>                 task_status_future.set_exception(exc)
               else:
>>>>>>             if task_status_future is not None and not task_status_future.done():
>>>>>>                 task_status_future.set_exception(
>>>>>>                     RuntimeError("Child exited without calling task_status.started()")
                       )
               finally:
>>>>>>             if task in self.cancel_scope._tasks:
>>>>>>                 self.cancel_scope._tasks.remove(task)
>>>>>>                 del _task_states[task]
       
    1:     def _spawn(
               self,
               func: Callable[..., Awaitable[Any]],
               args: tuple,
               name: object,
               task_status_future: asyncio.Future | None = None,
           ) -> asyncio.Task:
    8:         def task_done(_task: asyncio.Task) -> None:
                   # This is the code path for Python 3.8+
    8:             assert _task in self.cancel_scope._tasks
    8:             self.cancel_scope._tasks.remove(_task)
    8:             del _task_states[_task]
       
    8:             try:
    8:                 exc = _task.exception()
>>>>>>             except CancelledError as e:
>>>>>>                 while isinstance(e.__context__, CancelledError):
>>>>>>                     e = e.__context__
       
>>>>>>                 exc = e
       
    8:             if exc is not None:
>>>>>>                 if task_status_future is None or task_status_future.done():
>>>>>>                     self._exceptions.append(exc)
>>>>>>                     self.cancel_scope.cancel()
                       else:
>>>>>>                     task_status_future.set_exception(exc)
    8:             elif task_status_future is not None and not task_status_future.done():
>>>>>>                 task_status_future.set_exception(
>>>>>>                     RuntimeError("Child exited without calling task_status.started()")
                       )
       
    8:         if not self._active:
>>>>>>             raise RuntimeError(
>>>>>>                 "This task group is not active; no new tasks can be started."
                   )
       
    8:         options: dict[str, Any] = {}
    8:         name = get_callable_name(func) if name is None else str(name)
    8:         if _native_task_names:
    8:             options["name"] = name
       
    8:         kwargs = {}
    8:         if task_status_future:
>>>>>>             parent_id = id(current_task())
>>>>>>             kwargs["task_status"] = _AsyncioTaskStatus(
>>>>>>                 task_status_future, id(self.cancel_scope._host_task)
                   )
               else:
    8:             parent_id = id(self.cancel_scope._host_task)
       
    8:         coro = func(*args, **kwargs)
    8:         if not asyncio.iscoroutine(coro):
>>>>>>             raise TypeError(
>>>>>>                 f"Expected an async function, but {func} appears to be synchronous"
                   )
       
    8:         foreign_coro = not hasattr(coro, "cr_frame") and not hasattr(coro, "gi_frame")
    8:         if foreign_coro or sys.version_info < (3, 8):
>>>>>>             coro = self._run_wrapped_task(coro, task_status_future)
       
    8:         task = create_task(coro, **options)
    8:         if not foreign_coro and sys.version_info >= (3, 8):
    8:             task.add_done_callback(task_done)
       
               # Make the spawned task inherit the task group's cancel scope
   16:         _task_states[task] = TaskState(
    8:             parent_id=parent_id, name=name, cancel_scope=self.cancel_scope
               )
    8:         self.cancel_scope._tasks.add(task)
    8:         return task
       
    1:     def start_soon(
    1:         self, func: Callable[..., Awaitable[Any]], *args: object, name: object = None
           ) -> None:
    8:         self._spawn(func, args, name)
       
    1:     async def start(
    1:         self, func: Callable[..., Awaitable[Any]], *args: object, name: object = None
           ) -> None:
>>>>>>         future: asyncio.Future = asyncio.Future()
>>>>>>         task = self._spawn(func, args, name, future)
       
               # If the task raises an exception after sending a start value without a switch point
               # between, the task group is cancelled and this method never proceeds to process the
               # completed future. That's why we have to have a shielded cancel scope here.
>>>>>>         with CancelScope(shield=True):
>>>>>>             try:
>>>>>>                 return await future
>>>>>>             except CancelledError:
>>>>>>                 task.cancel()
>>>>>>                 raise
       
       
       #
       # Threads
       #
       
    1: _Retval_Queue_Type = Tuple[Optional[T_Retval], Optional[BaseException]]
       
       
    2: class WorkerThread(Thread):
    1:     MAX_IDLE_TIME = 10  # seconds
       
    1:     def __init__(
               self,
               root_task: asyncio.Task,
               workers: set[WorkerThread],
               idle_workers: deque[WorkerThread],
           ):
    1:         super().__init__(name="AnyIO worker thread")
    1:         self.root_task = root_task
    1:         self.workers = workers
    1:         self.idle_workers = idle_workers
    1:         self.loop = root_task._loop
    1:         self.queue: Queue[
                   tuple[Context, Callable, tuple, asyncio.Future] | None
    1:         ] = Queue(2)
    1:         self.idle_since = current_time()
    1:         self.stopping = False
       
    1:     def _report_result(
               self, future: asyncio.Future, result: Any, exc: BaseException | None
           ) -> None:
    8:         self.idle_since = current_time()
    8:         if not self.stopping:
    8:             self.idle_workers.append(self)
       
    8:         if not future.cancelled():
    8:             if exc is not None:
>>>>>>                 if isinstance(exc, StopIteration):
>>>>>>                     new_exc = RuntimeError("coroutine raised StopIteration")
>>>>>>                     new_exc.__cause__ = exc
>>>>>>                     exc = new_exc
       
>>>>>>                 future.set_exception(exc)
                   else:
    8:                 future.set_result(result)
       
    1:     def run(self) -> None:
    1:         with claim_worker_thread("asyncio"):
    1:             threadlocals.loop = self.loop
                   while True:
    9:                 item = self.queue.get()
    9:                 if item is None:
                           # Shutdown command received
    1:                     return
       
    8:                 context, func, args, future = item
    8:                 if not future.cancelled():
    8:                     result = None
    8:                     exception: BaseException | None = None
    8:                     try:
    8:                         result = context.run(func, *args)
>>>>>>                     except BaseException as exc:
>>>>>>                         exception = exc
       
    8:                     if not self.loop.is_closed():
   16:                         self.loop.call_soon_threadsafe(
    8:                             self._report_result, future, result, exception
                               )
       
    8:                 self.queue.task_done()
       
    1:     def stop(self, f: asyncio.Task | None = None) -> None:
    1:         self.stopping = True
    1:         self.queue.put_nowait(None)
    1:         self.workers.discard(self)
    1:         try:
    1:             self.idle_workers.remove(self)
>>>>>>         except ValueError:
>>>>>>             pass
       
       
    2: _threadpool_idle_workers: RunVar[deque[WorkerThread]] = RunVar(
    1:     "_threadpool_idle_workers"
       )
    1: _threadpool_workers: RunVar[set[WorkerThread]] = RunVar("_threadpool_workers")
       
       
    1: async def run_sync_in_worker_thread(
           func: Callable[..., T_Retval],
           *args: object,
    1:     cancellable: bool = False,
    1:     limiter: CapacityLimiter | None = None,
       ) -> T_Retval:
    8:     await checkpoint()
       
           # If this is the first run in this event loop thread, set up the necessary variables
    8:     try:
    8:         idle_workers = _threadpool_idle_workers.get()
    7:         workers = _threadpool_workers.get()
    1:     except LookupError:
    1:         idle_workers = deque()
    1:         workers = set()
    1:         _threadpool_idle_workers.set(idle_workers)
    1:         _threadpool_workers.set(workers)
       
    8:     async with (limiter or current_default_thread_limiter()):
    8:         with CancelScope(shield=not cancellable):
    8:             future: asyncio.Future = asyncio.Future()
    8:             root_task = find_root_task()
    8:             if not idle_workers:
    1:                 worker = WorkerThread(root_task, workers, idle_workers)
    1:                 worker.start()
    1:                 workers.add(worker)
    1:                 root_task.add_done_callback(worker.stop)
                   else:
    7:                 worker = idle_workers.pop()
       
                       # Prune any other workers that have been idle for MAX_IDLE_TIME seconds or longer
    7:                 now = current_time()
    7:                 while idle_workers:
>>>>>>                     if now - idle_workers[0].idle_since < WorkerThread.MAX_IDLE_TIME:
>>>>>>                         break
       
>>>>>>                     expired_worker = idle_workers.popleft()
>>>>>>                     expired_worker.root_task.remove_done_callback(expired_worker.stop)
>>>>>>                     expired_worker.stop()
       
    8:             context = copy_context()
    8:             context.run(sniffio.current_async_library_cvar.set, None)
    8:             worker.queue.put_nowait((context, func, args, future))
    8:             return await future
       
       
    1: def run_sync_from_thread(
           func: Callable[..., T_Retval],
           *args: object,
    1:     loop: asyncio.AbstractEventLoop | None = None,
       ) -> T_Retval:
    8:     @wraps(func)
    8:     def wrapper() -> None:
    8:         try:
    8:             f.set_result(func(*args))
>>>>>>         except BaseException as exc:
>>>>>>             f.set_exception(exc)
>>>>>>             if not isinstance(exc, Exception):
>>>>>>                 raise
       
    8:     f: concurrent.futures.Future[T_Retval] = Future()
    8:     loop = loop or threadlocals.loop
    8:     loop.call_soon_threadsafe(wrapper)
    8:     return f.result()
       
       
    1: def run_async_from_thread(
           func: Callable[..., Awaitable[T_Retval]], *args: object
       ) -> T_Retval:
>>>>>>     f: concurrent.futures.Future[T_Retval] = asyncio.run_coroutine_threadsafe(
>>>>>>         func(*args), threadlocals.loop
           )
>>>>>>     return f.result()
       
       
    2: class BlockingPortal(abc.BlockingPortal):
    1:     def __new__(cls) -> BlockingPortal:
    1:         return object.__new__(cls)
       
    1:     def __init__(self) -> None:
    2:         super().__init__()
    2:         self._loop = get_running_loop()
       
    1:     def _spawn_task_from_thread(
               self,
               func: Callable,
               args: tuple,
               kwargs: dict[str, Any],
               name: object,
               future: Future,
           ) -> None:
   16:         run_sync_from_thread(
    8:             partial(self._task_group.start_soon, name=name),
    8:             self._call_func,
    8:             func,
    8:             args,
    8:             kwargs,
    8:             future,
    8:             loop=self._loop,
               )
       
       
       #
       # Subprocesses
       #
       
       
    2: @dataclass(eq=False)
    1: class StreamReaderWrapper(abc.ByteReceiveStream):
    1:     _stream: asyncio.StreamReader
       
    1:     async def receive(self, max_bytes: int = 65536) -> bytes:
>>>>>>         data = await self._stream.read(max_bytes)
>>>>>>         if data:
>>>>>>             return data
               else:
>>>>>>             raise EndOfStream
       
    1:     async def aclose(self) -> None:
>>>>>>         self._stream.feed_eof()
       
       
    2: @dataclass(eq=False)
    1: class StreamWriterWrapper(abc.ByteSendStream):
    1:     _stream: asyncio.StreamWriter
       
    1:     async def send(self, item: bytes) -> None:
>>>>>>         self._stream.write(item)
>>>>>>         await self._stream.drain()
       
    1:     async def aclose(self) -> None:
>>>>>>         self._stream.close()
       
       
    2: @dataclass(eq=False)
    1: class Process(abc.Process):
    1:     _process: asyncio.subprocess.Process
    1:     _stdin: StreamWriterWrapper | None
    1:     _stdout: StreamReaderWrapper | None
    1:     _stderr: StreamReaderWrapper | None
       
    1:     async def aclose(self) -> None:
>>>>>>         if self._stdin:
>>>>>>             await self._stdin.aclose()
>>>>>>         if self._stdout:
>>>>>>             await self._stdout.aclose()
>>>>>>         if self._stderr:
>>>>>>             await self._stderr.aclose()
       
>>>>>>         await self.wait()
       
    1:     async def wait(self) -> int:
>>>>>>         return await self._process.wait()
       
    1:     def terminate(self) -> None:
>>>>>>         self._process.terminate()
       
    1:     def kill(self) -> None:
>>>>>>         self._process.kill()
       
    1:     def send_signal(self, signal: int) -> None:
>>>>>>         self._process.send_signal(signal)
       
    1:     @property
    1:     def pid(self) -> int:
>>>>>>         return self._process.pid
       
    1:     @property
    1:     def returncode(self) -> int | None:
>>>>>>         return self._process.returncode
       
    1:     @property
    1:     def stdin(self) -> abc.ByteSendStream | None:
>>>>>>         return self._stdin
       
    1:     @property
    1:     def stdout(self) -> abc.ByteReceiveStream | None:
>>>>>>         return self._stdout
       
    1:     @property
    1:     def stderr(self) -> abc.ByteReceiveStream | None:
>>>>>>         return self._stderr
       
       
    1: async def open_process(
           command: str | bytes | Sequence[str | bytes],
           *,
           shell: bool,
           stdin: int | IO[Any] | None,
           stdout: int | IO[Any] | None,
           stderr: int | IO[Any] | None,
    1:     cwd: str | bytes | PathLike | None = None,
    1:     env: Mapping[str, str] | None = None,
    1:     start_new_session: bool = False,
       ) -> Process:
>>>>>>     await checkpoint()
>>>>>>     if shell:
>>>>>>         process = await asyncio.create_subprocess_shell(
>>>>>>             cast(Union[str, bytes], command),
>>>>>>             stdin=stdin,
>>>>>>             stdout=stdout,
>>>>>>             stderr=stderr,
>>>>>>             cwd=cwd,
>>>>>>             env=env,
>>>>>>             start_new_session=start_new_session,
               )
           else:
>>>>>>         process = await asyncio.create_subprocess_exec(
>>>>>>             *command,
>>>>>>             stdin=stdin,
>>>>>>             stdout=stdout,
>>>>>>             stderr=stderr,
>>>>>>             cwd=cwd,
>>>>>>             env=env,
>>>>>>             start_new_session=start_new_session,
               )
       
>>>>>>     stdin_stream = StreamWriterWrapper(process.stdin) if process.stdin else None
>>>>>>     stdout_stream = StreamReaderWrapper(process.stdout) if process.stdout else None
>>>>>>     stderr_stream = StreamReaderWrapper(process.stderr) if process.stderr else None
>>>>>>     return Process(process, stdin_stream, stdout_stream, stderr_stream)
       
       
    1: def _forcibly_shutdown_process_pool_on_exit(
           workers: set[Process], _task: object
       ) -> None:
           """
           Forcibly shuts down worker processes belonging to this event loop."""
           child_watcher: asyncio.AbstractChildWatcher | None
>>>>>>     try:
>>>>>>         child_watcher = asyncio.get_event_loop_policy().get_child_watcher()
>>>>>>     except NotImplementedError:
>>>>>>         child_watcher = None
       
           # Close as much as possible (w/o async/await) to avoid warnings
>>>>>>     for process in workers:
>>>>>>         if process.returncode is None:
>>>>>>             continue
       
>>>>>>         process._stdin._stream._transport.close()  # type: ignore[union-attr]
>>>>>>         process._stdout._stream._transport.close()  # type: ignore[union-attr]
>>>>>>         process._stderr._stream._transport.close()  # type: ignore[union-attr]
>>>>>>         process.kill()
>>>>>>         if child_watcher:
>>>>>>             child_watcher.remove_child_handler(process.pid)
       
       
    1: async def _shutdown_process_pool_on_exit(workers: set[Process]) -> None:
           """
           Shuts down worker processes belonging to this event loop.
       
           NOTE: this only works when the event loop was started using asyncio.run() or anyio.run().
       
           """
           process: Process
>>>>>>     try:
>>>>>>         await sleep(math.inf)
>>>>>>     except asyncio.CancelledError:
>>>>>>         for process in workers:
>>>>>>             if process.returncode is None:
>>>>>>                 process.kill()
       
>>>>>>         for process in workers:
>>>>>>             await process.aclose()
       
       
    1: def setup_process_pool_exit_at_shutdown(workers: set[Process]) -> None:
>>>>>>     kwargs: dict[str, Any] = (
>>>>>>         {"name": "AnyIO process pool shutdown task"} if _native_task_names else {}
           )
>>>>>>     create_task(_shutdown_process_pool_on_exit(workers), **kwargs)
>>>>>>     find_root_task().add_done_callback(
>>>>>>         partial(_forcibly_shutdown_process_pool_on_exit, workers)
           )
       
       
       #
       # Sockets and networking
       #
       
       
    2: class StreamProtocol(asyncio.Protocol):
    1:     read_queue: deque[bytes]
    1:     read_event: asyncio.Event
    1:     write_event: asyncio.Event
    1:     exception: Exception | None = None
       
    1:     def connection_made(self, transport: asyncio.BaseTransport) -> None:
>>>>>>         self.read_queue = deque()
>>>>>>         self.read_event = asyncio.Event()
>>>>>>         self.write_event = asyncio.Event()
>>>>>>         self.write_event.set()
>>>>>>         cast(asyncio.Transport, transport).set_write_buffer_limits(0)
       
    1:     def connection_lost(self, exc: Exception | None) -> None:
>>>>>>         if exc:
>>>>>>             self.exception = BrokenResourceError()
>>>>>>             self.exception.__cause__ = exc
       
>>>>>>         self.read_event.set()
>>>>>>         self.write_event.set()
       
    1:     def data_received(self, data: bytes) -> None:
>>>>>>         self.read_queue.append(data)
>>>>>>         self.read_event.set()
       
    1:     def eof_received(self) -> bool | None:
>>>>>>         self.read_event.set()
>>>>>>         return True
       
    1:     def pause_writing(self) -> None:
>>>>>>         self.write_event = asyncio.Event()
       
    1:     def resume_writing(self) -> None:
>>>>>>         self.write_event.set()
       
       
    2: class DatagramProtocol(asyncio.DatagramProtocol):
    1:     read_queue: deque[tuple[bytes, IPSockAddrType]]
    1:     read_event: asyncio.Event
    1:     write_event: asyncio.Event
    1:     exception: Exception | None = None
       
    1:     def connection_made(self, transport: asyncio.BaseTransport) -> None:
>>>>>>         self.read_queue = deque(maxlen=100)  # arbitrary value
>>>>>>         self.read_event = asyncio.Event()
>>>>>>         self.write_event = asyncio.Event()
>>>>>>         self.write_event.set()
       
    1:     def connection_lost(self, exc: Exception | None) -> None:
>>>>>>         self.read_event.set()
>>>>>>         self.write_event.set()
       
    1:     def datagram_received(self, data: bytes, addr: IPSockAddrType) -> None:
>>>>>>         addr = convert_ipv6_sockaddr(addr)
>>>>>>         self.read_queue.append((data, addr))
>>>>>>         self.read_event.set()
       
    1:     def error_received(self, exc: Exception) -> None:
>>>>>>         self.exception = exc
       
    1:     def pause_writing(self) -> None:
>>>>>>         self.write_event.clear()
       
    1:     def resume_writing(self) -> None:
>>>>>>         self.write_event.set()
       
       
    2: class SocketStream(abc.SocketStream):
    1:     def __init__(self, transport: asyncio.Transport, protocol: StreamProtocol):
>>>>>>         self._transport = transport
>>>>>>         self._protocol = protocol
>>>>>>         self._receive_guard = ResourceGuard("reading from")
>>>>>>         self._send_guard = ResourceGuard("writing to")
>>>>>>         self._closed = False
       
    1:     @property
    1:     def _raw_socket(self) -> socket.socket:
>>>>>>         return self._transport.get_extra_info("socket")
       
    1:     async def receive(self, max_bytes: int = 65536) -> bytes:
>>>>>>         with self._receive_guard:
>>>>>>             await checkpoint()
       
>>>>>>             if (
>>>>>>                 not self._protocol.read_event.is_set()
>>>>>>                 and not self._transport.is_closing()
                   ):
>>>>>>                 self._transport.resume_reading()
>>>>>>                 await self._protocol.read_event.wait()
>>>>>>                 self._transport.pause_reading()
       
>>>>>>             try:
>>>>>>                 chunk = self._protocol.read_queue.popleft()
>>>>>>             except IndexError:
>>>>>>                 if self._closed:
>>>>>>                     raise ClosedResourceError from None
>>>>>>                 elif self._protocol.exception:
>>>>>>                     raise self._protocol.exception
                       else:
>>>>>>                     raise EndOfStream from None
       
>>>>>>             if len(chunk) > max_bytes:
                       # Split the oversized chunk
>>>>>>                 chunk, leftover = chunk[:max_bytes], chunk[max_bytes:]
>>>>>>                 self._protocol.read_queue.appendleft(leftover)
       
                   # If the read queue is empty, clear the flag so that the next call will block until
                   # data is available
>>>>>>             if not self._protocol.read_queue:
>>>>>>                 self._protocol.read_event.clear()
       
>>>>>>         return chunk
       
    1:     async def send(self, item: bytes) -> None:
>>>>>>         with self._send_guard:
>>>>>>             await checkpoint()
       
>>>>>>             if self._closed:
>>>>>>                 raise ClosedResourceError
>>>>>>             elif self._protocol.exception is not None:
>>>>>>                 raise self._protocol.exception
       
>>>>>>             try:
>>>>>>                 self._transport.write(item)
>>>>>>             except RuntimeError as exc:
>>>>>>                 if self._transport.is_closing():
>>>>>>                     raise BrokenResourceError from exc
                       else:
>>>>>>                     raise
       
>>>>>>             await self._protocol.write_event.wait()
       
    1:     async def send_eof(self) -> None:
>>>>>>         try:
>>>>>>             self._transport.write_eof()
>>>>>>         except OSError:
>>>>>>             pass
       
    1:     async def aclose(self) -> None:
>>>>>>         if not self._transport.is_closing():
>>>>>>             self._closed = True
>>>>>>             try:
>>>>>>                 self._transport.write_eof()
>>>>>>             except OSError:
>>>>>>                 pass
       
>>>>>>             self._transport.close()
>>>>>>             await sleep(0)
>>>>>>             self._transport.abort()
       
       
    2: class UNIXSocketStream(abc.SocketStream):
    1:     _receive_future: asyncio.Future | None = None
    1:     _send_future: asyncio.Future | None = None
    1:     _closing = False
       
    1:     def __init__(self, raw_socket: socket.socket):
>>>>>>         self.__raw_socket = raw_socket
>>>>>>         self._loop = get_running_loop()
>>>>>>         self._receive_guard = ResourceGuard("reading from")
>>>>>>         self._send_guard = ResourceGuard("writing to")
       
    1:     @property
    1:     def _raw_socket(self) -> socket.socket:
>>>>>>         return self.__raw_socket
       
    1:     def _wait_until_readable(self, loop: asyncio.AbstractEventLoop) -> asyncio.Future:
>>>>>>         def callback(f: object) -> None:
>>>>>>             del self._receive_future
>>>>>>             loop.remove_reader(self.__raw_socket)
       
>>>>>>         f = self._receive_future = asyncio.Future()
>>>>>>         self._loop.add_reader(self.__raw_socket, f.set_result, None)
>>>>>>         f.add_done_callback(callback)
>>>>>>         return f
       
    1:     def _wait_until_writable(self, loop: asyncio.AbstractEventLoop) -> asyncio.Future:
>>>>>>         def callback(f: object) -> None:
>>>>>>             del self._send_future
>>>>>>             loop.remove_writer(self.__raw_socket)
       
>>>>>>         f = self._send_future = asyncio.Future()
>>>>>>         self._loop.add_writer(self.__raw_socket, f.set_result, None)
>>>>>>         f.add_done_callback(callback)
>>>>>>         return f
       
    1:     async def send_eof(self) -> None:
>>>>>>         with self._send_guard:
>>>>>>             self._raw_socket.shutdown(socket.SHUT_WR)
       
    1:     async def receive(self, max_bytes: int = 65536) -> bytes:
>>>>>>         loop = get_running_loop()
>>>>>>         await checkpoint()
>>>>>>         with self._receive_guard:
                   while True:
>>>>>>                 try:
>>>>>>                     data = self.__raw_socket.recv(max_bytes)
>>>>>>                 except BlockingIOError:
>>>>>>                     await self._wait_until_readable(loop)
>>>>>>                 except OSError as exc:
>>>>>>                     if self._closing:
>>>>>>                         raise ClosedResourceError from None
                           else:
>>>>>>                         raise BrokenResourceError from exc
                       else:
>>>>>>                     if not data:
>>>>>>                         raise EndOfStream
       
>>>>>>                     return data
       
    1:     async def send(self, item: bytes) -> None:
>>>>>>         loop = get_running_loop()
>>>>>>         await checkpoint()
>>>>>>         with self._send_guard:
>>>>>>             view = memoryview(item)
>>>>>>             while view:
>>>>>>                 try:
>>>>>>                     bytes_sent = self.__raw_socket.send(view)
>>>>>>                 except BlockingIOError:
>>>>>>                     await self._wait_until_writable(loop)
>>>>>>                 except OSError as exc:
>>>>>>                     if self._closing:
>>>>>>                         raise ClosedResourceError from None
                           else:
>>>>>>                         raise BrokenResourceError from exc
                       else:
>>>>>>                     view = view[bytes_sent:]
       
    1:     async def receive_fds(self, msglen: int, maxfds: int) -> tuple[bytes, list[int]]:
>>>>>>         if not isinstance(msglen, int) or msglen < 0:
>>>>>>             raise ValueError("msglen must be a non-negative integer")
>>>>>>         if not isinstance(maxfds, int) or maxfds < 1:
>>>>>>             raise ValueError("maxfds must be a positive integer")
       
>>>>>>         loop = get_running_loop()
>>>>>>         fds = array.array("i")
>>>>>>         await checkpoint()
>>>>>>         with self._receive_guard:
                   while True:
>>>>>>                 try:
>>>>>>                     message, ancdata, flags, addr = self.__raw_socket.recvmsg(
>>>>>>                         msglen, socket.CMSG_LEN(maxfds * fds.itemsize)
                           )
>>>>>>                 except BlockingIOError:
>>>>>>                     await self._wait_until_readable(loop)
>>>>>>                 except OSError as exc:
>>>>>>                     if self._closing:
>>>>>>                         raise ClosedResourceError from None
                           else:
>>>>>>                         raise BrokenResourceError from exc
                       else:
>>>>>>                     if not message and not ancdata:
>>>>>>                         raise EndOfStream
       
>>>>>>                     break
       
>>>>>>         for cmsg_level, cmsg_type, cmsg_data in ancdata:
>>>>>>             if cmsg_level != socket.SOL_SOCKET or cmsg_type != socket.SCM_RIGHTS:
>>>>>>                 raise RuntimeError(
>>>>>>                     f"Received unexpected ancillary data; message = {message!r}, "
>>>>>>                     f"cmsg_level = {cmsg_level}, cmsg_type = {cmsg_type}"
                       )
       
>>>>>>             fds.frombytes(cmsg_data[: len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])
       
>>>>>>         return message, list(fds)
       
    1:     async def send_fds(self, message: bytes, fds: Collection[int | IOBase]) -> None:
>>>>>>         if not message:
>>>>>>             raise ValueError("message must not be empty")
>>>>>>         if not fds:
>>>>>>             raise ValueError("fds must not be empty")
       
>>>>>>         loop = get_running_loop()
>>>>>>         filenos: list[int] = []
>>>>>>         for fd in fds:
>>>>>>             if isinstance(fd, int):
>>>>>>                 filenos.append(fd)
>>>>>>             elif isinstance(fd, IOBase):
>>>>>>                 filenos.append(fd.fileno())
       
>>>>>>         fdarray = array.array("i", filenos)
>>>>>>         await checkpoint()
>>>>>>         with self._send_guard:
                   while True:
>>>>>>                 try:
                           # The ignore can be removed after mypy picks up
                           # https://github.com/python/typeshed/pull/5545
>>>>>>                     self.__raw_socket.sendmsg(
>>>>>>                         [message], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, fdarray)]
                           )
>>>>>>                     break
>>>>>>                 except BlockingIOError:
>>>>>>                     await self._wait_until_writable(loop)
>>>>>>                 except OSError as exc:
>>>>>>                     if self._closing:
>>>>>>                         raise ClosedResourceError from None
                           else:
>>>>>>                         raise BrokenResourceError from exc
       
    1:     async def aclose(self) -> None:
>>>>>>         if not self._closing:
>>>>>>             self._closing = True
>>>>>>             if self.__raw_socket.fileno() != -1:
>>>>>>                 self.__raw_socket.close()
       
>>>>>>             if self._receive_future:
>>>>>>                 self._receive_future.set_result(None)
>>>>>>             if self._send_future:
>>>>>>                 self._send_future.set_result(None)
       
       
    2: class TCPSocketListener(abc.SocketListener):
    1:     _accept_scope: CancelScope | None = None
    1:     _closed = False
       
    1:     def __init__(self, raw_socket: socket.socket):
>>>>>>         self.__raw_socket = raw_socket
>>>>>>         self._loop = cast(asyncio.BaseEventLoop, get_running_loop())
>>>>>>         self._accept_guard = ResourceGuard("accepting connections from")
       
    1:     @property
    1:     def _raw_socket(self) -> socket.socket:
>>>>>>         return self.__raw_socket
       
    1:     async def accept(self) -> abc.SocketStream:
>>>>>>         if self._closed:
>>>>>>             raise ClosedResourceError
       
>>>>>>         with self._accept_guard:
>>>>>>             await checkpoint()
>>>>>>             with CancelScope() as self._accept_scope:
>>>>>>                 try:
>>>>>>                     client_sock, _addr = await self._loop.sock_accept(self._raw_socket)
>>>>>>                 except asyncio.CancelledError:
                           # Workaround for https://bugs.python.org/issue41317
>>>>>>                     try:
>>>>>>                         self._loop.remove_reader(self._raw_socket)
>>>>>>                     except (ValueError, NotImplementedError):
>>>>>>                         pass
       
>>>>>>                     if self._closed:
>>>>>>                         raise ClosedResourceError from None
       
>>>>>>                     raise
                       finally:
>>>>>>                     self._accept_scope = None
       
>>>>>>         client_sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
>>>>>>         transport, protocol = await self._loop.connect_accepted_socket(
>>>>>>             StreamProtocol, client_sock
               )
>>>>>>         return SocketStream(transport, protocol)
       
    1:     async def aclose(self) -> None:
>>>>>>         if self._closed:
>>>>>>             return
       
>>>>>>         self._closed = True
>>>>>>         if self._accept_scope:
                   # Workaround for https://bugs.python.org/issue41317
>>>>>>             try:
>>>>>>                 self._loop.remove_reader(self._raw_socket)
>>>>>>             except (ValueError, NotImplementedError):
>>>>>>                 pass
       
>>>>>>             self._accept_scope.cancel()
>>>>>>             await sleep(0)
       
>>>>>>         self._raw_socket.close()
       
       
    2: class UNIXSocketListener(abc.SocketListener):
    1:     def __init__(self, raw_socket: socket.socket):
>>>>>>         self.__raw_socket = raw_socket
>>>>>>         self._loop = get_running_loop()
>>>>>>         self._accept_guard = ResourceGuard("accepting connections from")
>>>>>>         self._closed = False
       
    1:     async def accept(self) -> abc.SocketStream:
>>>>>>         await checkpoint()
>>>>>>         with self._accept_guard:
                   while True:
>>>>>>                 try:
>>>>>>                     client_sock, _ = self.__raw_socket.accept()
>>>>>>                     client_sock.setblocking(False)
>>>>>>                     return UNIXSocketStream(client_sock)
>>>>>>                 except BlockingIOError:
>>>>>>                     f: asyncio.Future = asyncio.Future()
>>>>>>                     self._loop.add_reader(self.__raw_socket, f.set_result, None)
>>>>>>                     f.add_done_callback(
>>>>>>                         lambda _: self._loop.remove_reader(self.__raw_socket)
                           )
>>>>>>                     await f
>>>>>>                 except OSError as exc:
>>>>>>                     if self._closed:
>>>>>>                         raise ClosedResourceError from None
                           else:
>>>>>>                         raise BrokenResourceError from exc
       
    1:     async def aclose(self) -> None:
>>>>>>         self._closed = True
>>>>>>         self.__raw_socket.close()
       
    1:     @property
    1:     def _raw_socket(self) -> socket.socket:
>>>>>>         return self.__raw_socket
       
       
    2: class UDPSocket(abc.UDPSocket):
    1:     def __init__(
               self, transport: asyncio.DatagramTransport, protocol: DatagramProtocol
           ):
>>>>>>         self._transport = transport
>>>>>>         self._protocol = protocol
>>>>>>         self._receive_guard = ResourceGuard("reading from")
>>>>>>         self._send_guard = ResourceGuard("writing to")
>>>>>>         self._closed = False
       
    1:     @property
    1:     def _raw_socket(self) -> socket.socket:
>>>>>>         return self._transport.get_extra_info("socket")
       
    1:     async def aclose(self) -> None:
>>>>>>         if not self._transport.is_closing():
>>>>>>             self._closed = True
>>>>>>             self._transport.close()
       
    1:     async def receive(self) -> tuple[bytes, IPSockAddrType]:
>>>>>>         with self._receive_guard:
>>>>>>             await checkpoint()
       
                   # If the buffer is empty, ask for more data
>>>>>>             if not self._protocol.read_queue and not self._transport.is_closing():
>>>>>>                 self._protocol.read_event.clear()
>>>>>>                 await self._protocol.read_event.wait()
       
>>>>>>             try:
>>>>>>                 return self._protocol.read_queue.popleft()
>>>>>>             except IndexError:
>>>>>>                 if self._closed:
>>>>>>                     raise ClosedResourceError from None
                       else:
>>>>>>                     raise BrokenResourceError from None
       
    1:     async def send(self, item: UDPPacketType) -> None:
>>>>>>         with self._send_guard:
>>>>>>             await checkpoint()
>>>>>>             await self._protocol.write_event.wait()
>>>>>>             if self._closed:
>>>>>>                 raise ClosedResourceError
>>>>>>             elif self._transport.is_closing():
>>>>>>                 raise BrokenResourceError
                   else:
>>>>>>                 self._transport.sendto(*item)
       
       
    2: class ConnectedUDPSocket(abc.ConnectedUDPSocket):
    1:     def __init__(
               self, transport: asyncio.DatagramTransport, protocol: DatagramProtocol
           ):
>>>>>>         self._transport = transport
>>>>>>         self._protocol = protocol
>>>>>>         self._receive_guard = ResourceGuard("reading from")
>>>>>>         self._send_guard = ResourceGuard("writing to")
>>>>>>         self._closed = False
       
    1:     @property
    1:     def _raw_socket(self) -> socket.socket:
>>>>>>         return self._transport.get_extra_info("socket")
       
    1:     async def aclose(self) -> None:
>>>>>>         if not self._transport.is_closing():
>>>>>>             self._closed = True
>>>>>>             self._transport.close()
       
    1:     async def receive(self) -> bytes:
>>>>>>         with self._receive_guard:
>>>>>>             await checkpoint()
       
                   # If the buffer is empty, ask for more data
>>>>>>             if not self._protocol.read_queue and not self._transport.is_closing():
>>>>>>                 self._protocol.read_event.clear()
>>>>>>                 await self._protocol.read_event.wait()
       
>>>>>>             try:
>>>>>>                 packet = self._protocol.read_queue.popleft()
>>>>>>             except IndexError:
>>>>>>                 if self._closed:
>>>>>>                     raise ClosedResourceError from None
                       else:
>>>>>>                     raise BrokenResourceError from None
       
>>>>>>             return packet[0]
       
    1:     async def send(self, item: bytes) -> None:
>>>>>>         with self._send_guard:
>>>>>>             await checkpoint()
>>>>>>             await self._protocol.write_event.wait()
>>>>>>             if self._closed:
>>>>>>                 raise ClosedResourceError
>>>>>>             elif self._transport.is_closing():
>>>>>>                 raise BrokenResourceError
                   else:
>>>>>>                 self._transport.sendto(item)
       
       
    1: async def connect_tcp(
           host: str, port: int, local_addr: tuple[str, int] | None = None
       ) -> SocketStream:
>>>>>>     transport, protocol = cast(
>>>>>>         Tuple[asyncio.Transport, StreamProtocol],
>>>>>>         await get_running_loop().create_connection(
>>>>>>             StreamProtocol, host, port, local_addr=local_addr
               ),
           )
>>>>>>     transport.pause_reading()
>>>>>>     return SocketStream(transport, protocol)
       
       
    1: async def connect_unix(path: str) -> UNIXSocketStream:
>>>>>>     await checkpoint()
>>>>>>     loop = get_running_loop()
>>>>>>     raw_socket = socket.socket(socket.AF_UNIX)
>>>>>>     raw_socket.setblocking(False)
           while True:
>>>>>>         try:
>>>>>>             raw_socket.connect(path)
>>>>>>         except BlockingIOError:
>>>>>>             f: asyncio.Future = asyncio.Future()
>>>>>>             loop.add_writer(raw_socket, f.set_result, None)
>>>>>>             f.add_done_callback(lambda _: loop.remove_writer(raw_socket))
>>>>>>             await f
>>>>>>         except BaseException:
>>>>>>             raw_socket.close()
>>>>>>             raise
               else:
>>>>>>             return UNIXSocketStream(raw_socket)
       
       
    1: async def create_udp_socket(
           family: socket.AddressFamily,
           local_address: IPSockAddrType | None,
           remote_address: IPSockAddrType | None,
           reuse_port: bool,
       ) -> UDPSocket | ConnectedUDPSocket:
>>>>>>     result = await get_running_loop().create_datagram_endpoint(
>>>>>>         DatagramProtocol,
>>>>>>         local_addr=local_address,
>>>>>>         remote_addr=remote_address,
>>>>>>         family=family,
>>>>>>         reuse_port=reuse_port,
           )
>>>>>>     transport = result[0]
>>>>>>     protocol = result[1]
>>>>>>     if protocol.exception:
>>>>>>         transport.close()
>>>>>>         raise protocol.exception
       
>>>>>>     if not remote_address:
>>>>>>         return UDPSocket(transport, protocol)
           else:
>>>>>>         return ConnectedUDPSocket(transport, protocol)
       
       
    1: async def getaddrinfo(
           host: bytes | str,
           port: str | int | None,
           *,
    1:     family: int | AddressFamily = 0,
    1:     type: int | SocketKind = 0,
    1:     proto: int = 0,
    1:     flags: int = 0,
       ) -> GetAddrInfoReturnType:
           # https://github.com/python/typeshed/pull/4304
>>>>>>     result = await get_running_loop().getaddrinfo(
>>>>>>         host, port, family=family, type=type, proto=proto, flags=flags
           )
>>>>>>     return cast(GetAddrInfoReturnType, result)
       
       
    1: async def getnameinfo(sockaddr: IPSockAddrType, flags: int = 0) -> tuple[str, str]:
>>>>>>     return await get_running_loop().getnameinfo(sockaddr, flags)
       
       
    1: _read_events: RunVar[dict[Any, asyncio.Event]] = RunVar("read_events")
    1: _write_events: RunVar[dict[Any, asyncio.Event]] = RunVar("write_events")
       
       
    1: async def wait_socket_readable(sock: socket.socket) -> None:
>>>>>>     await checkpoint()
>>>>>>     try:
>>>>>>         read_events = _read_events.get()
>>>>>>     except LookupError:
>>>>>>         read_events = {}
>>>>>>         _read_events.set(read_events)
       
>>>>>>     if read_events.get(sock):
>>>>>>         raise BusyResourceError("reading from") from None
       
>>>>>>     loop = get_running_loop()
>>>>>>     event = read_events[sock] = asyncio.Event()
>>>>>>     loop.add_reader(sock, event.set)
>>>>>>     try:
>>>>>>         await event.wait()
           finally:
>>>>>>         if read_events.pop(sock, None) is not None:
>>>>>>             loop.remove_reader(sock)
>>>>>>             readable = True
               else:
>>>>>>             readable = False
       
>>>>>>     if not readable:
>>>>>>         raise ClosedResourceError
       
       
    1: async def wait_socket_writable(sock: socket.socket) -> None:
>>>>>>     await checkpoint()
>>>>>>     try:
>>>>>>         write_events = _write_events.get()
>>>>>>     except LookupError:
>>>>>>         write_events = {}
>>>>>>         _write_events.set(write_events)
       
>>>>>>     if write_events.get(sock):
>>>>>>         raise BusyResourceError("writing to") from None
       
>>>>>>     loop = get_running_loop()
>>>>>>     event = write_events[sock] = asyncio.Event()
>>>>>>     loop.add_writer(sock.fileno(), event.set)
>>>>>>     try:
>>>>>>         await event.wait()
           finally:
>>>>>>         if write_events.pop(sock, None) is not None:
>>>>>>             loop.remove_writer(sock)
>>>>>>             writable = True
               else:
>>>>>>             writable = False
       
>>>>>>     if not writable:
>>>>>>         raise ClosedResourceError
       
       
       #
       # Synchronization
       #
       
       
    2: class Event(BaseEvent):
    1:     def __new__(cls) -> Event:
    8:         return object.__new__(cls)
       
    1:     def __init__(self) -> None:
   16:         self._event = asyncio.Event()
       
    1:     def set(self) -> DeprecatedAwaitable:
    8:         self._event.set()
    8:         return DeprecatedAwaitable(self.set)
       
    1:     def is_set(self) -> bool:
    2:         return self._event.is_set()
       
    1:     async def wait(self) -> None:
    5:         if await self._event.wait():
    5:             await checkpoint()
       
    1:     def statistics(self) -> EventStatistics:
>>>>>>         return EventStatistics(len(self._event._waiters))  # type: ignore[attr-defined]
       
       
    2: class CapacityLimiter(BaseCapacityLimiter):
    1:     _total_tokens: float = 0
       
    1:     def __new__(cls, total_tokens: float) -> CapacityLimiter:
    3:         return object.__new__(cls)
       
    1:     def __init__(self, total_tokens: float):
    5:         self._borrowers: set[Any] = set()
    5:         self._wait_queue: OrderedDict[Any, asyncio.Event] = OrderedDict()
    5:         self.total_tokens = total_tokens
       
    1:     async def __aenter__(self) -> None:
    8:         await self.acquire()
       
    1:     async def __aexit__(
               self,
               exc_type: type[BaseException] | None,
               exc_val: BaseException | None,
               exc_tb: TracebackType | None,
           ) -> None:
    8:         self.release()
       
    1:     @property
    1:     def total_tokens(self) -> float:
>>>>>>         return self._total_tokens
       
    1:     @total_tokens.setter
    1:     def total_tokens(self, value: float) -> None:
    5:         if not isinstance(value, int) and not math.isinf(value):
>>>>>>             raise TypeError("total_tokens must be an int or math.inf")
    5:         if value < 1:
>>>>>>             raise ValueError("total_tokens must be >= 1")
       
    5:         old_value = self._total_tokens
    5:         self._total_tokens = value
    5:         events = []
    5:         for event in self._wait_queue.values():
>>>>>>             if value <= old_value:
>>>>>>                 break
       
>>>>>>             if not event.is_set():
>>>>>>                 events.append(event)
>>>>>>                 old_value += 1
       
    5:         for event in events:
>>>>>>             event.set()
       
    1:     @property
    1:     def borrowed_tokens(self) -> int:
>>>>>>         return len(self._borrowers)
       
    1:     @property
    1:     def available_tokens(self) -> float:
>>>>>>         return self._total_tokens - len(self._borrowers)
       
    1:     def acquire_nowait(self) -> DeprecatedAwaitable:
>>>>>>         self.acquire_on_behalf_of_nowait(current_task())
>>>>>>         return DeprecatedAwaitable(self.acquire_nowait)
       
    1:     def acquire_on_behalf_of_nowait(self, borrower: object) -> DeprecatedAwaitable:
    8:         if borrower in self._borrowers:
>>>>>>             raise RuntimeError(
>>>>>>                 "this borrower is already holding one of this CapacityLimiter's "
                       "tokens"
                   )
       
    8:         if self._wait_queue or len(self._borrowers) >= self._total_tokens:
>>>>>>             raise WouldBlock
       
    8:         self._borrowers.add(borrower)
    8:         return DeprecatedAwaitable(self.acquire_on_behalf_of_nowait)
       
    1:     async def acquire(self) -> None:
    8:         return await self.acquire_on_behalf_of(current_task())
       
    1:     async def acquire_on_behalf_of(self, borrower: object) -> None:
    8:         await checkpoint_if_cancelled()
    8:         try:
    8:             self.acquire_on_behalf_of_nowait(borrower)
>>>>>>         except WouldBlock:
>>>>>>             event = asyncio.Event()
>>>>>>             self._wait_queue[borrower] = event
>>>>>>             try:
>>>>>>                 await event.wait()
>>>>>>             except BaseException:
>>>>>>                 self._wait_queue.pop(borrower, None)
>>>>>>                 raise
       
>>>>>>             self._borrowers.add(borrower)
               else:
    8:             try:
    8:                 await cancel_shielded_checkpoint()
>>>>>>             except BaseException:
>>>>>>                 self.release()
>>>>>>                 raise
       
    1:     def release(self) -> None:
    8:         self.release_on_behalf_of(current_task())
       
    1:     def release_on_behalf_of(self, borrower: object) -> None:
    8:         try:
    8:             self._borrowers.remove(borrower)
>>>>>>         except KeyError:
>>>>>>             raise RuntimeError(
>>>>>>                 "this borrower isn't holding any of this CapacityLimiter's " "tokens"
>>>>>>             ) from None
       
               # Notify the next task in line if this limiter has free capacity now
    8:         if self._wait_queue and len(self._borrowers) < self._total_tokens:
>>>>>>             event = self._wait_queue.popitem(last=False)[1]
>>>>>>             event.set()
       
    1:     def statistics(self) -> CapacityLimiterStatistics:
>>>>>>         return CapacityLimiterStatistics(
>>>>>>             self.borrowed_tokens,
>>>>>>             self.total_tokens,
>>>>>>             tuple(self._borrowers),
>>>>>>             len(self._wait_queue),
               )
       
       
    1: _default_thread_limiter: RunVar[CapacityLimiter] = RunVar("_default_thread_limiter")
       
       
    1: def current_default_thread_limiter() -> CapacityLimiter:
    6:     try:
    6:         return _default_thread_limiter.get()
    1:     except LookupError:
    1:         limiter = CapacityLimiter(40)
    1:         _default_thread_limiter.set(limiter)
    1:         return limiter
       
       
       #
       # Operating system signals
       #
       
       
    2: class _SignalReceiver(DeprecatedAsyncContextManager["_SignalReceiver"]):
    1:     def __init__(self, signals: tuple[int, ...]):
>>>>>>         self._signals = signals
>>>>>>         self._loop = get_running_loop()
>>>>>>         self._signal_queue: deque[int] = deque()
>>>>>>         self._future: asyncio.Future = asyncio.Future()
>>>>>>         self._handled_signals: set[int] = set()
       
    1:     def _deliver(self, signum: int) -> None:
>>>>>>         self._signal_queue.append(signum)
>>>>>>         if not self._future.done():
>>>>>>             self._future.set_result(None)
       
    1:     def __enter__(self) -> _SignalReceiver:
>>>>>>         for sig in set(self._signals):
>>>>>>             self._loop.add_signal_handler(sig, self._deliver, sig)
>>>>>>             self._handled_signals.add(sig)
       
>>>>>>         return self
       
    1:     def __exit__(
               self,
               exc_type: type[BaseException] | None,
               exc_val: BaseException | None,
               exc_tb: TracebackType | None,
           ) -> bool | None:
>>>>>>         for sig in self._handled_signals:
>>>>>>             self._loop.remove_signal_handler(sig)
>>>>>>         return None
       
    1:     def __aiter__(self) -> _SignalReceiver:
>>>>>>         return self
       
    1:     async def __anext__(self) -> int:
>>>>>>         await checkpoint()
>>>>>>         if not self._signal_queue:
>>>>>>             self._future = asyncio.Future()
>>>>>>             await self._future
       
>>>>>>         return self._signal_queue.popleft()
       
       
    1: def open_signal_receiver(*signals: int) -> _SignalReceiver:
>>>>>>     return _SignalReceiver(signals)
       
       
       #
       # Testing and debugging
       #
       
       
    1: def _create_task_info(task: asyncio.Task) -> TaskInfo:
>>>>>>     task_state = _task_states.get(task)
>>>>>>     if task_state is None:
>>>>>>         name = task.get_name() if _native_task_names else None
>>>>>>         parent_id = None
           else:
>>>>>>         name = task_state.name
>>>>>>         parent_id = task_state.parent_id
       
>>>>>>     return TaskInfo(id(task), parent_id, name, get_coro(task))
       
       
    1: def get_current_task() -> TaskInfo:
>>>>>>     return _create_task_info(current_task())  # type: ignore[arg-type]
       
       
    1: def get_running_tasks() -> list[TaskInfo]:
>>>>>>     return [_create_task_info(task) for task in all_tasks() if not task.done()]
       
       
    1: async def wait_all_tasks_blocked() -> None:
>>>>>>     await checkpoint()
>>>>>>     this_task = current_task()
           while True:
>>>>>>         for task in all_tasks():
>>>>>>             if task is this_task:
>>>>>>                 continue
       
>>>>>>             if task._fut_waiter is None or task._fut_waiter.done():  # type: ignore[attr-defined]
>>>>>>                 await sleep(0.1)
>>>>>>                 break
               else:
>>>>>>             return
       
       
    2: class TestRunner(abc.TestRunner):
    1:     def __init__(
               self,
               debug: bool = False,
               use_uvloop: bool = False,
               policy: asyncio.AbstractEventLoopPolicy | None = None,
           ):
>>>>>>         self._exceptions: list[BaseException] = []
>>>>>>         _maybe_set_event_loop_policy(policy, use_uvloop)
>>>>>>         self._loop = asyncio.new_event_loop()
>>>>>>         self._loop.set_debug(debug)
>>>>>>         self._loop.set_exception_handler(self._exception_handler)
>>>>>>         asyncio.set_event_loop(self._loop)
       
    1:     def _cancel_all_tasks(self) -> None:
>>>>>>         to_cancel = all_tasks(self._loop)
>>>>>>         if not to_cancel:
>>>>>>             return
       
>>>>>>         for task in to_cancel:
>>>>>>             task.cancel()
       
>>>>>>         self._loop.run_until_complete(
>>>>>>             asyncio.gather(*to_cancel, return_exceptions=True)
               )
       
>>>>>>         for task in to_cancel:
>>>>>>             if task.cancelled():
>>>>>>                 continue
>>>>>>             if task.exception() is not None:
>>>>>>                 raise cast(BaseException, task.exception())
       
    1:     def _exception_handler(
               self, loop: asyncio.AbstractEventLoop, context: dict[str, Any]
           ) -> None:
>>>>>>         if isinstance(context.get("exception"), Exception):
>>>>>>             self._exceptions.append(context["exception"])
               else:
>>>>>>             loop.default_exception_handler(context)
       
    1:     def _raise_async_exceptions(self) -> None:
               # Re-raise any exceptions raised in asynchronous callbacks
>>>>>>         if self._exceptions:
>>>>>>             exceptions, self._exceptions = self._exceptions, []
>>>>>>             if len(exceptions) == 1:
>>>>>>                 raise exceptions[0]
>>>>>>             elif exceptions:
>>>>>>                 raise ExceptionGroup(exceptions)
       
    1:     def close(self) -> None:
>>>>>>         try:
>>>>>>             self._cancel_all_tasks()
>>>>>>             self._loop.run_until_complete(self._loop.shutdown_asyncgens())
               finally:
>>>>>>             asyncio.set_event_loop(None)
>>>>>>             self._loop.close()
       
    1:     def run_asyncgen_fixture(
               self,
               fixture_func: Callable[..., AsyncGenerator[T_Retval, Any]],
               kwargs: dict[str, Any],
           ) -> Iterable[T_Retval]:
>>>>>>         async def fixture_runner() -> None:
>>>>>>             agen = fixture_func(**kwargs)
>>>>>>             try:
>>>>>>                 retval = await agen.asend(None)
>>>>>>                 self._raise_async_exceptions()
>>>>>>             except BaseException as exc:
>>>>>>                 f.set_exception(exc)
>>>>>>                 return
                   else:
>>>>>>                 f.set_result(retval)
       
>>>>>>             await event.wait()
>>>>>>             try:
>>>>>>                 await agen.asend(None)
>>>>>>             except StopAsyncIteration:
>>>>>>                 pass
                   else:
>>>>>>                 await agen.aclose()
>>>>>>                 raise RuntimeError("Async generator fixture did not stop")
       
>>>>>>         f = self._loop.create_future()
>>>>>>         event = asyncio.Event()
>>>>>>         fixture_task = self._loop.create_task(fixture_runner())
>>>>>>         self._loop.run_until_complete(f)
>>>>>>         yield f.result()
>>>>>>         event.set()
>>>>>>         self._loop.run_until_complete(fixture_task)
>>>>>>         self._raise_async_exceptions()
       
    1:     def run_fixture(
               self,
               fixture_func: Callable[..., Coroutine[Any, Any, T_Retval]],
               kwargs: dict[str, Any],
           ) -> T_Retval:
>>>>>>         retval = self._loop.run_until_complete(fixture_func(**kwargs))
>>>>>>         self._raise_async_exceptions()
>>>>>>         return retval
       
    1:     def run_test(
               self, test_func: Callable[..., Coroutine[Any, Any, Any]], kwargs: dict[str, Any]
           ) -> None:
>>>>>>         try:
>>>>>>             self._loop.run_until_complete(test_func(**kwargs))
>>>>>>         except Exception as exc:
>>>>>>             self._exceptions.append(exc)
       
>>>>>>         self._raise_async_exceptions()
