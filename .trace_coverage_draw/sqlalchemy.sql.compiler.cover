       # sql/compiler.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       # mypy: allow-untyped-defs, allow-untyped-calls
       
    1: """Base SQL and DDL compiler implementations.
       
       Classes provided include:
       
       :class:`.compiler.SQLCompiler` - renders SQL
       strings
       
       :class:`.compiler.DDLCompiler` - renders DDL
       (data definition language) strings
       
       :class:`.compiler.GenericTypeCompiler` - renders
       type specification strings.
       
       To generate user-defined SQL strings, see
       :doc:`/ext/compiler`.
       
       """
    1: from __future__ import annotations
       
    1: import collections
    1: import collections.abc as collections_abc
    1: import contextlib
    1: from enum import IntEnum
    1: import itertools
    1: import operator
    1: import re
    1: from time import perf_counter
    1: import typing
    1: from typing import Any
    1: from typing import Callable
    1: from typing import cast
    1: from typing import ClassVar
    1: from typing import Dict
    1: from typing import FrozenSet
    1: from typing import Iterable
    1: from typing import Iterator
    1: from typing import List
    1: from typing import Mapping
    1: from typing import MutableMapping
    1: from typing import NamedTuple
    1: from typing import NoReturn
    1: from typing import Optional
    1: from typing import Pattern
    1: from typing import Sequence
    1: from typing import Set
    1: from typing import Tuple
    1: from typing import Type
    1: from typing import TYPE_CHECKING
    1: from typing import Union
       
    1: from . import base
    1: from . import coercions
    1: from . import crud
    1: from . import elements
    1: from . import functions
    1: from . import operators
    1: from . import roles
    1: from . import schema
    1: from . import selectable
    1: from . import sqltypes
    1: from . import util as sql_util
    1: from ._typing import is_column_element
    1: from ._typing import is_dml
    1: from .base import _de_clone
    1: from .base import _from_objects
    1: from .base import _NONE_NAME
    1: from .base import _SentinelDefaultCharacterization
    1: from .base import Executable
    1: from .base import NO_ARG
    1: from .elements import ClauseElement
    1: from .elements import quoted_name
    1: from .schema import Column
    1: from .sqltypes import TupleType
    1: from .type_api import TypeEngine
    1: from .visitors import prefix_anon_map
    1: from .visitors import Visitable
    1: from .. import exc
    1: from .. import util
    1: from ..util import FastIntFlag
    1: from ..util.typing import Literal
    1: from ..util.typing import Protocol
    1: from ..util.typing import TypedDict
       
    1: if typing.TYPE_CHECKING:
>>>>>>     from .annotation import _AnnotationDict
>>>>>>     from .base import _AmbiguousTableNameMap
>>>>>>     from .base import CompileState
>>>>>>     from .cache_key import CacheKey
>>>>>>     from .ddl import ExecutableDDLElement
>>>>>>     from .dml import Insert
>>>>>>     from .dml import UpdateBase
>>>>>>     from .dml import ValuesBase
>>>>>>     from .elements import _truncated_label
>>>>>>     from .elements import BindParameter
>>>>>>     from .elements import ColumnClause
>>>>>>     from .elements import ColumnElement
>>>>>>     from .elements import Label
>>>>>>     from .functions import Function
>>>>>>     from .schema import Table
>>>>>>     from .selectable import AliasedReturnsRows
>>>>>>     from .selectable import CompoundSelectState
>>>>>>     from .selectable import CTE
>>>>>>     from .selectable import FromClause
>>>>>>     from .selectable import NamedFromClause
>>>>>>     from .selectable import ReturnsRows
>>>>>>     from .selectable import Select
>>>>>>     from .selectable import SelectState
>>>>>>     from .type_api import _BindProcessorType
>>>>>>     from .type_api import _SentinelProcessorType
>>>>>>     from ..engine.cursor import CursorResultMetaData
>>>>>>     from ..engine.interfaces import _CoreSingleExecuteParams
>>>>>>     from ..engine.interfaces import _DBAPIAnyExecuteParams
>>>>>>     from ..engine.interfaces import _DBAPIMultiExecuteParams
>>>>>>     from ..engine.interfaces import _DBAPISingleExecuteParams
>>>>>>     from ..engine.interfaces import _ExecuteOptions
>>>>>>     from ..engine.interfaces import _GenericSetInputSizesType
>>>>>>     from ..engine.interfaces import _MutableCoreSingleExecuteParams
>>>>>>     from ..engine.interfaces import Dialect
>>>>>>     from ..engine.interfaces import SchemaTranslateMapType
       
    1: _FromHintsType = Dict["FromClause", str]
       
    1: RESERVED_WORDS = {
           "all",
           "analyse",
           "analyze",
           "and",
           "any",
           "array",
           "as",
           "asc",
           "asymmetric",
           "authorization",
           "between",
           "binary",
           "both",
           "case",
           "cast",
           "check",
           "collate",
           "column",
           "constraint",
           "create",
           "cross",
           "current_date",
           "current_role",
           "current_time",
           "current_timestamp",
           "current_user",
           "default",
           "deferrable",
           "desc",
           "distinct",
           "do",
           "else",
           "end",
           "except",
           "false",
           "for",
           "foreign",
           "freeze",
           "from",
           "full",
           "grant",
           "group",
           "having",
           "ilike",
           "in",
           "initially",
           "inner",
           "intersect",
           "into",
           "is",
           "isnull",
           "join",
           "leading",
           "left",
           "like",
           "limit",
           "localtime",
           "localtimestamp",
           "natural",
           "new",
           "not",
           "notnull",
           "null",
           "off",
           "offset",
           "old",
           "on",
           "only",
           "or",
           "order",
           "outer",
           "overlaps",
           "placing",
           "primary",
           "references",
           "right",
           "select",
           "session_user",
           "set",
           "similar",
           "some",
           "symmetric",
           "table",
           "then",
           "to",
           "trailing",
           "true",
           "union",
           "unique",
           "user",
           "using",
           "verbose",
           "when",
           "where",
       }
       
    1: LEGAL_CHARACTERS = re.compile(r"^[A-Z0-9_$]+$", re.I)
    1: LEGAL_CHARACTERS_PLUS_SPACE = re.compile(r"^[A-Z0-9_ $]+$", re.I)
   12: ILLEGAL_INITIAL_CHARACTERS = {str(x) for x in range(0, 10)}.union(["$"])
       
    2: FK_ON_DELETE = re.compile(
    1:     r"^(?:RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT)$", re.I
       )
    2: FK_ON_UPDATE = re.compile(
    1:     r"^(?:RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT)$", re.I
       )
    1: FK_INITIALLY = re.compile(r"^(?:DEFERRED|IMMEDIATE)$", re.I)
    1: BIND_PARAMS = re.compile(r"(?<![:\w\$\x5c]):([\w\$]+)(?![:\w\$])", re.UNICODE)
    1: BIND_PARAMS_ESC = re.compile(r"\x5c(:[\w\$]*)(?![:\w\$])", re.UNICODE)
       
    1: _pyformat_template = "%%(%(name)s)s"
    1: BIND_TEMPLATES = {
    1:     "pyformat": _pyformat_template,
    1:     "qmark": "?",
    1:     "format": "%%s",
    1:     "numeric": ":[_POSITION]",
    1:     "numeric_dollar": "$[_POSITION]",
    1:     "named": ":%(name)s",
       }
       
       
    1: OPERATORS = {
           # binary
    1:     operators.and_: " AND ",
    1:     operators.or_: " OR ",
    1:     operators.add: " + ",
    1:     operators.mul: " * ",
    1:     operators.sub: " - ",
    1:     operators.mod: " % ",
    1:     operators.neg: "-",
    1:     operators.lt: " < ",
    1:     operators.le: " <= ",
    1:     operators.ne: " != ",
    1:     operators.gt: " > ",
    1:     operators.ge: " >= ",
    1:     operators.eq: " = ",
    1:     operators.is_distinct_from: " IS DISTINCT FROM ",
    1:     operators.is_not_distinct_from: " IS NOT DISTINCT FROM ",
    1:     operators.concat_op: " || ",
    1:     operators.match_op: " MATCH ",
    1:     operators.not_match_op: " NOT MATCH ",
    1:     operators.in_op: " IN ",
    1:     operators.not_in_op: " NOT IN ",
    1:     operators.comma_op: ", ",
    1:     operators.from_: " FROM ",
    1:     operators.as_: " AS ",
    1:     operators.is_: " IS ",
    1:     operators.is_not: " IS NOT ",
    1:     operators.collate: " COLLATE ",
           # unary
    1:     operators.exists: "EXISTS ",
    1:     operators.distinct_op: "DISTINCT ",
    1:     operators.inv: "NOT ",
    1:     operators.any_op: "ANY ",
    1:     operators.all_op: "ALL ",
           # modifiers
    1:     operators.desc_op: " DESC",
    1:     operators.asc_op: " ASC",
    1:     operators.nulls_first_op: " NULLS FIRST",
    1:     operators.nulls_last_op: " NULLS LAST",
           # bitwise
    1:     operators.bitwise_xor_op: " ^ ",
    1:     operators.bitwise_or_op: " | ",
    1:     operators.bitwise_and_op: " & ",
    1:     operators.bitwise_not_op: "~",
    1:     operators.bitwise_lshift_op: " << ",
    1:     operators.bitwise_rshift_op: " >> ",
       }
       
    1: FUNCTIONS: Dict[Type[Function[Any]], str] = {
    1:     functions.coalesce: "coalesce",
    1:     functions.current_date: "CURRENT_DATE",
    1:     functions.current_time: "CURRENT_TIME",
    1:     functions.current_timestamp: "CURRENT_TIMESTAMP",
    1:     functions.current_user: "CURRENT_USER",
    1:     functions.localtime: "LOCALTIME",
    1:     functions.localtimestamp: "LOCALTIMESTAMP",
    1:     functions.random: "random",
    1:     functions.sysdate: "sysdate",
    1:     functions.session_user: "SESSION_USER",
    1:     functions.user: "USER",
    1:     functions.cube: "CUBE",
    1:     functions.rollup: "ROLLUP",
    1:     functions.grouping_sets: "GROUPING SETS",
       }
       
       
    1: EXTRACT_MAP = {
    1:     "month": "month",
    1:     "day": "day",
    1:     "year": "year",
    1:     "second": "second",
    1:     "hour": "hour",
    1:     "doy": "doy",
    1:     "minute": "minute",
    1:     "quarter": "quarter",
    1:     "dow": "dow",
    1:     "week": "week",
    1:     "epoch": "epoch",
    1:     "milliseconds": "milliseconds",
    1:     "microseconds": "microseconds",
    1:     "timezone_hour": "timezone_hour",
    1:     "timezone_minute": "timezone_minute",
       }
       
    1: COMPOUND_KEYWORDS = {
    1:     selectable._CompoundSelectKeyword.UNION: "UNION",
    1:     selectable._CompoundSelectKeyword.UNION_ALL: "UNION ALL",
    1:     selectable._CompoundSelectKeyword.EXCEPT: "EXCEPT",
    1:     selectable._CompoundSelectKeyword.EXCEPT_ALL: "EXCEPT ALL",
    1:     selectable._CompoundSelectKeyword.INTERSECT: "INTERSECT",
    1:     selectable._CompoundSelectKeyword.INTERSECT_ALL: "INTERSECT ALL",
       }
       
       
    2: class ResultColumnsEntry(NamedTuple):
    1:     """Tracks a column expression that is expected to be represented
           in the result rows for this statement.
       
           This normally refers to the columns clause of a SELECT statement
           but may also refer to a RETURNING clause, as well as for dialect-specific
           emulations.
       
           """
       
    1:     keyname: str
           """string name that's expected in cursor.description"""
       
    1:     name: str
           """column name, may be labeled"""
       
    1:     objects: Tuple[Any, ...]
           """sequence of objects that should be able to locate this column
           in a RowMapping.  This is typically string names and aliases
           as well as Column objects.
       
           """
       
    1:     type: TypeEngine[Any]
    1:     """Datatype to be associated with this column.   This is where
           the "result processing" logic directly links the compiled statement
           to the rows that come back from the cursor.
       
           """
       
       
    2: class _ResultMapAppender(Protocol):
    1:     def __call__(
               self,
               keyname: str,
               name: str,
               objects: Sequence[Any],
               type_: TypeEngine[Any],
>>>>>>     ) -> None: ...
       
       
       # integer indexes into ResultColumnsEntry used by cursor.py.
       # some profiling showed integer access faster than named tuple
    1: RM_RENDERED_NAME: Literal[0] = 0
    1: RM_NAME: Literal[1] = 1
    1: RM_OBJECTS: Literal[2] = 2
    1: RM_TYPE: Literal[3] = 3
       
       
    2: class _BaseCompilerStackEntry(TypedDict):
    1:     asfrom_froms: Set[FromClause]
    1:     correlate_froms: Set[FromClause]
    1:     selectable: ReturnsRows
       
       
    2: class _CompilerStackEntry(_BaseCompilerStackEntry, total=False):
    1:     compile_state: CompileState
    1:     need_result_map_for_nested: bool
    1:     need_result_map_for_compound: bool
    1:     select_0: ReturnsRows
    1:     insert_from_select: Select[Any]
       
       
    2: class ExpandedState(NamedTuple):
    1:     """represents state to use when producing "expanded" and
           "post compile" bound parameters for a statement.
       
           "expanded" parameters are parameters that are generated at
           statement execution time to suit a number of parameters passed, the most
           prominent example being the individual elements inside of an IN expression.
       
           "post compile" parameters are parameters where the SQL literal value
           will be rendered into the SQL statement at execution time, rather than
           being passed as separate parameters to the driver.
       
           To create an :class:`.ExpandedState` instance, use the
           :meth:`.SQLCompiler.construct_expanded_state` method on any
           :class:`.SQLCompiler` instance.
       
           """
       
    1:     statement: str
           """String SQL statement with parameters fully expanded"""
       
    1:     parameters: _CoreSingleExecuteParams
           """Parameter dictionary with parameters fully expanded.
       
           For a statement that uses named parameters, this dictionary will map
           exactly to the names in the statement.  For a statement that uses
           positional parameters, the :attr:`.ExpandedState.positional_parameters`
           will yield a tuple with the positional parameter set.
       
           """
       
    1:     processors: Mapping[str, _BindProcessorType[Any]]
           """mapping of bound value processors"""
       
    1:     positiontup: Optional[Sequence[str]]
           """Sequence of string names indicating the order of positional
           parameters"""
       
    1:     parameter_expansion: Mapping[str, List[str]]
           """Mapping representing the intermediary link from original parameter
           name to list of "expanded" parameter names, for those parameters that
           were expanded."""
       
    1:     @property
    1:     def positional_parameters(self) -> Tuple[Any, ...]:
               """Tuple of positional parameters, for statements that were compiled
               using a positional paramstyle.
       
               """
>>>>>>         if self.positiontup is None:
>>>>>>             raise exc.InvalidRequestError(
>>>>>>                 "statement does not use a positional paramstyle"
                   )
>>>>>>         return tuple(self.parameters[key] for key in self.positiontup)
       
    1:     @property
    1:     def additional_parameters(self) -> _CoreSingleExecuteParams:
               """synonym for :attr:`.ExpandedState.parameters`."""
>>>>>>         return self.parameters
       
       
    2: class _InsertManyValues(NamedTuple):
    1:     """represents state to use for executing an "insertmanyvalues" statement.
       
           The primary consumers of this object are the
           :meth:`.SQLCompiler._deliver_insertmanyvalues_batches` and
           :meth:`.DefaultDialect._deliver_insertmanyvalues_batches` methods.
       
           .. versionadded:: 2.0
       
           """
       
    1:     is_default_expr: bool
           """if True, the statement is of the form
           ``INSERT INTO TABLE DEFAULT VALUES``, and can't be rewritten as a "batch"
       
           """
       
    1:     single_values_expr: str
           """The rendered "values" clause of the INSERT statement.
       
           This is typically the parenthesized section e.g. "(?, ?, ?)" or similar.
           The insertmanyvalues logic uses this string as a search and replace
           target.
       
           """
       
    1:     insert_crud_params: List[crud._CrudParamElementStr]
           """List of Column / bind names etc. used while rewriting the statement"""
       
    1:     num_positional_params_counted: int
           """the number of bound parameters in a single-row statement.
       
           This count may be larger or smaller than the actual number of columns
           targeted in the INSERT, as it accommodates for SQL expressions
           in the values list that may have zero or more parameters embedded
           within them.
       
           This count is part of what's used to organize rewritten parameter lists
           when batching.
       
           """
       
    1:     sort_by_parameter_order: bool = False
           """if the deterministic_returnined_order parameter were used on the
           insert.
       
           All of the attributes following this will only be used if this is True.
       
           """
       
    1:     includes_upsert_behaviors: bool = False
           """if True, we have to accommodate for upsert behaviors.
       
           This will in some cases downgrade "insertmanyvalues" that requests
           deterministic ordering.
       
           """
       
    1:     sentinel_columns: Optional[Sequence[Column[Any]]] = None
           """List of sentinel columns that were located.
       
           This list is only here if the INSERT asked for
           sort_by_parameter_order=True,
           and dialect-appropriate sentinel columns were located.
       
           .. versionadded:: 2.0.10
       
           """
       
    1:     num_sentinel_columns: int = 0
           """how many sentinel columns are in the above list, if any.
       
           This is the same as
           ``len(sentinel_columns) if sentinel_columns is not None else 0``
       
           """
       
    1:     sentinel_param_keys: Optional[Sequence[Union[str, int]]] = None
           """parameter str keys / int indexes in each param dictionary / tuple
           that would link to the client side "sentinel" values for that row, which
           we can use to match up parameter sets to result rows.
       
           This is only present if sentinel_columns is present and the INSERT
           statement actually refers to client side values for these sentinel
           columns.
       
           .. versionadded:: 2.0.10
       
           """
       
    1:     implicit_sentinel: bool = False
           """if True, we have exactly one sentinel column and it uses a server side
           value, currently has to generate an incrementing integer value.
       
           The dialect in question would have asserted that it supports receiving
           these values back and sorting on that value as a means of guaranteeing
           correlation with the incoming parameter list.
       
           .. versionadded:: 2.0.10
       
           """
       
    1:     embed_values_counter: bool = False
    1:     """Whether to embed an incrementing integer counter in each parameter
           set within the VALUES clause as parameters are batched over.
       
           This is only used for a specific INSERT..SELECT..VALUES..RETURNING syntax
           where a subquery is used to produce value tuples.  Current support
           includes PostgreSQL, Microsoft SQL Server.
       
           .. versionadded:: 2.0.10
       
           """
       
       
    2: class _InsertManyValuesBatch(NamedTuple):
    1:     """represents an individual batch SQL statement for insertmanyvalues.
       
           This is passed through the
           :meth:`.SQLCompiler._deliver_insertmanyvalues_batches` and
           :meth:`.DefaultDialect._deliver_insertmanyvalues_batches` methods out
           to the :class:`.Connection` within the
           :meth:`.Connection._exec_insertmany_context` method.
       
           .. versionadded:: 2.0.10
       
           """
       
    1:     replaced_statement: str
    1:     replaced_parameters: _DBAPIAnyExecuteParams
    1:     processed_setinputsizes: Optional[_GenericSetInputSizesType]
    1:     batch: Sequence[_DBAPISingleExecuteParams]
    1:     batch_size: int
    1:     batchnum: int
    1:     total_batches: int
    1:     rows_sorted: bool
    1:     is_downgraded: bool
       
       
    2: class InsertmanyvaluesSentinelOpts(FastIntFlag):
    1:     """bitflag enum indicating styles of PK defaults
           which can work as implicit sentinel columns
       
           """
       
    1:     NOT_SUPPORTED = 1
    1:     AUTOINCREMENT = 2
    1:     IDENTITY = 4
    1:     SEQUENCE = 8
       
    1:     ANY_AUTOINCREMENT = AUTOINCREMENT | IDENTITY | SEQUENCE
    1:     _SUPPORTED_OR_NOT = NOT_SUPPORTED | ANY_AUTOINCREMENT
       
    1:     USE_INSERT_FROM_SELECT = 16
    1:     RENDER_SELECT_COL_CASTS = 64
       
       
    2: class CompilerState(IntEnum):
    1:     COMPILING = 0
           """statement is present, compilation phase in progress"""
       
    1:     STRING_APPLIED = 1
           """statement is present, string form of the statement has been applied.
       
           Additional processors by subclasses may still be pending.
       
           """
       
    1:     NO_STATEMENT = 2
    1:     """compiler does not have a statement to compile, is used
           for method access"""
       
       
    2: class Linting(IntEnum):
    1:     """represent preferences for the 'SQL linting' feature.
       
           this feature currently includes support for flagging cartesian products
           in SQL statements.
       
           """
       
    1:     NO_LINTING = 0
           "Disable all linting."
       
    1:     COLLECT_CARTESIAN_PRODUCTS = 1
           """Collect data on FROMs and cartesian products and gather into
           'self.from_linter'"""
       
    1:     WARN_LINTING = 2
           "Emit warnings for linters that find problems"
       
    1:     FROM_LINTING = COLLECT_CARTESIAN_PRODUCTS | WARN_LINTING
    1:     """Warn for cartesian products; combines COLLECT_CARTESIAN_PRODUCTS
           and WARN_LINTING"""
       
       
    2: NO_LINTING, COLLECT_CARTESIAN_PRODUCTS, WARN_LINTING, FROM_LINTING = tuple(
    1:     Linting
       )
       
       
    2: class FromLinter(collections.namedtuple("FromLinter", ["froms", "edges"])):
    1:     """represents current state for the "cartesian product" detection
           feature."""
       
    1:     def lint(self, start=None):
    2:         froms = self.froms
    2:         if not froms:
>>>>>>             return None, None
       
    2:         edges = set(self.edges)
    2:         the_rest = set(froms)
       
    2:         if start is not None:
>>>>>>             start_with = start
>>>>>>             the_rest.remove(start_with)
               else:
    2:             start_with = the_rest.pop()
       
    2:         stack = collections.deque([start_with])
       
    4:         while stack and the_rest:
    2:             node = stack.popleft()
    2:             the_rest.discard(node)
       
                   # comparison of nodes in edges here is based on hash equality, as
                   # there are "annotated" elements that match the non-annotated ones.
                   #   to remove the need for in-python hash() calls, use native
                   # containment routines (e.g. "node in edge", "edge.index(node)")
    6:             to_remove = {edge for edge in edges if node in edge}
       
                   # appendleft the node in each edge that is not
                   # the one that matched.
    6:             stack.extendleft(edge[not edge.index(node)] for edge in to_remove)
    2:             edges.difference_update(to_remove)
       
               # FROMS left over?  boom
    2:         if the_rest:
>>>>>>             return the_rest, start_with
               else:
    2:             return None, None
       
    1:     def warn(self, stmt_type="SELECT"):
    2:         the_rest, start_with = self.lint()
       
               # FROMS left over?  boom
    2:         if the_rest:
>>>>>>             froms = the_rest
>>>>>>             if froms:
>>>>>>                 template = (
>>>>>>                     "{stmt_type} statement has a cartesian product between "
                           "FROM element(s) {froms} and "
                           'FROM element "{start}".  Apply join condition(s) '
                           "between each element to resolve."
                       )
>>>>>>                 froms_str = ", ".join(
>>>>>>                     f'"{self.froms[from_]}"' for from_ in froms
                       )
>>>>>>                 message = template.format(
>>>>>>                     stmt_type=stmt_type,
>>>>>>                     froms=froms_str,
>>>>>>                     start=self.froms[start_with],
                       )
       
>>>>>>                 util.warn(message)
       
       
    2: class Compiled:
    1:     """Represent a compiled SQL or DDL expression.
       
           The ``__str__`` method of the ``Compiled`` object should produce
           the actual text of the statement.  ``Compiled`` objects are
           specific to their underlying database dialect, and also may
           or may not be specific to the columns referenced within a
           particular set of bind parameters.  In no case should the
           ``Compiled`` object be dependent on the actual values of those
           bind parameters, even though it may reference those values as
           defaults.
           """
       
    1:     statement: Optional[ClauseElement] = None
           "The statement to compile."
    1:     string: str = ""
           "The string representation of the ``statement``"
       
    1:     state: CompilerState
           """description of the compiler's state"""
       
    1:     is_sql = False
    1:     is_ddl = False
       
    1:     _cached_metadata: Optional[CursorResultMetaData] = None
       
    1:     _result_columns: Optional[List[ResultColumnsEntry]] = None
       
    1:     schema_translate_map: Optional[SchemaTranslateMapType] = None
       
    1:     execution_options: _ExecuteOptions = util.EMPTY_DICT
           """
           Execution options propagated from the statement.   In some cases,
           sub-elements of the statement can modify these.
           """
       
    1:     preparer: IdentifierPreparer
       
    1:     _annotations: _AnnotationDict = util.EMPTY_DICT
       
    1:     compile_state: Optional[CompileState] = None
           """Optional :class:`.CompileState` object that maintains additional
           state used by the compiler.
       
           Major executable objects such as :class:`_expression.Insert`,
           :class:`_expression.Update`, :class:`_expression.Delete`,
           :class:`_expression.Select` will generate this
           state when compiled in order to calculate additional information about the
           object.   For the top level object that is to be executed, the state can be
           stored here where it can also have applicability towards result set
           processing.
       
           .. versionadded:: 1.4
       
           """
       
    1:     dml_compile_state: Optional[CompileState] = None
           """Optional :class:`.CompileState` assigned at the same point that
           .isinsert, .isupdate, or .isdelete is assigned.
       
           This will normally be the same object as .compile_state, with the
           exception of cases like the :class:`.ORMFromStatementCompileState`
           object.
       
           .. versionadded:: 1.4.40
       
           """
       
    1:     cache_key: Optional[CacheKey] = None
           """The :class:`.CacheKey` that was generated ahead of creating this
           :class:`.Compiled` object.
       
           This is used for routines that need access to the original
           :class:`.CacheKey` instance generated when the :class:`.Compiled`
           instance was first cached, typically in order to reconcile
           the original list of :class:`.BindParameter` objects with a
           per-statement list that's generated on each call.
       
           """
       
    1:     _gen_time: float
           """Generation time of this :class:`.Compiled`, used for reporting
           cache stats."""
       
    1:     def __init__(
               self,
               dialect: Dialect,
               statement: Optional[ClauseElement],
    1:         schema_translate_map: Optional[SchemaTranslateMapType] = None,
    1:         render_schema_translate: bool = False,
    1:         compile_kwargs: Mapping[str, Any] = util.immutabledict(),
           ):
               """Construct a new :class:`.Compiled` object.
       
               :param dialect: :class:`.Dialect` to compile against.
       
               :param statement: :class:`_expression.ClauseElement` to be compiled.
       
               :param schema_translate_map: dictionary of schema names to be
                translated when forming the resultant SQL
       
                .. seealso::
       
                   :ref:`schema_translating`
       
               :param compile_kwargs: additional kwargs that will be
                passed to the initial call to :meth:`.Compiled.process`.
       
       
               """
  256:         self.dialect = dialect
  256:         self.preparer = self.dialect.identifier_preparer
  256:         if schema_translate_map:
>>>>>>             self.schema_translate_map = schema_translate_map
>>>>>>             self.preparer = self.preparer._with_schema_translate(
>>>>>>                 schema_translate_map
                   )
       
  256:         if statement is not None:
  176:             self.state = CompilerState.COMPILING
  176:             self.statement = statement
  176:             self.can_execute = statement.supports_execution
  176:             self._annotations = statement._annotations
  176:             if self.can_execute:
  176:                 if TYPE_CHECKING:
>>>>>>                     assert isinstance(statement, Executable)
  176:                 self.execution_options = statement._execution_options
  176:             self.string = self.process(self.statement, **compile_kwargs)
       
  176:             if render_schema_translate:
>>>>>>                 self.string = self.preparer._render_schema_translates(
>>>>>>                     self.string, schema_translate_map
                       )
       
  176:             self.state = CompilerState.STRING_APPLIED
               else:
   80:             self.state = CompilerState.NO_STATEMENT
       
  256:         self._gen_time = perf_counter()
       
    1:     def __init_subclass__(cls) -> None:
    8:         cls._init_compiler_cls()
    8:         return super().__init_subclass__()
       
    1:     @classmethod
    1:     def _init_compiler_cls(cls):
    2:         pass
       
    1:     def _execute_on_connection(
               self, connection, distilled_params, execution_options
           ):
>>>>>>         if self.can_execute:
>>>>>>             return connection._execute_compiled(
>>>>>>                 self, distilled_params, execution_options
                   )
               else:
>>>>>>             raise exc.ObjectNotExecutableError(self.statement)
       
    1:     def visit_unsupported_compilation(self, element, err, **kw):
>>>>>>         raise exc.UnsupportedCompilationError(self, type(element)) from err
       
    1:     @property
    1:     def sql_compiler(self):
               """Return a Compiled that is capable of processing SQL expressions.
       
               If this compiler is one, it would likely just return 'self'.
       
               """
       
>>>>>>         raise NotImplementedError()
       
    1:     def process(self, obj: Visitable, **kwargs: Any) -> str:
  808:         return obj._compiler_dispatch(self, **kwargs)
       
    1:     def __str__(self) -> str:
               """Return the string text of the generated SQL or DDL."""
       
  126:         if self.state is CompilerState.STRING_APPLIED:
  126:             return self.string
               else:
>>>>>>             return ""
       
    1:     def construct_params(
               self,
               params: Optional[_CoreSingleExecuteParams] = None,
               extracted_parameters: Optional[Sequence[BindParameter[Any]]] = None,
               escape_names: bool = True,
           ) -> Optional[_MutableCoreSingleExecuteParams]:
               """Return the bind params for this compiled object.
       
               :param params: a dict of string/object pairs whose values will
                              override bind values compiled in to the
                              statement.
               """
       
>>>>>>         raise NotImplementedError()
       
    1:     @property
    1:     def params(self):
               """Return the bind params for this compiled object."""
>>>>>>         return self.construct_params()
       
       
    2: class TypeCompiler(util.EnsureKWArg):
    1:     """Produces DDL specification for TypeEngine objects."""
       
    1:     ensure_kwarg = r"visit_\w+"
       
    1:     def __init__(self, dialect: Dialect):
    2:         self.dialect = dialect
       
    1:     def process(self, type_: TypeEngine[Any], **kw: Any) -> str:
  389:         if (
  389:             type_._variant_mapping
>>>>>>             and self.dialect.name in type_._variant_mapping
               ):
>>>>>>             type_ = type_._variant_mapping[self.dialect.name]
  389:         return type_._compiler_dispatch(self, **kw)
       
    1:     def visit_unsupported_compilation(
               self, element: Any, err: Exception, **kw: Any
           ) -> NoReturn:
>>>>>>         raise exc.UnsupportedCompilationError(self, element) from err
       
       
       # this was a Visitable, but to allow accurate detection of
       # column elements this is actually a column element
    3: class _CompileLabel(
    1:     roles.BinaryElementRole[Any], elements.CompilerColumnElement
       ):
    1:     """lightweight label object which acts as an expression.Label."""
       
    1:     __visit_name__ = "label"
    1:     __slots__ = "element", "name", "_alt_names"
       
    1:     def __init__(self, col, name, alt_names=()):
   45:         self.element = col
   45:         self.name = name
   45:         self._alt_names = (col,) + alt_names
       
    1:     @property
    1:     def proxy_set(self):
>>>>>>         return self.element.proxy_set
       
    1:     @property
    1:     def type(self):
   45:         return self.element.type
       
    1:     def self_group(self, **kw):
>>>>>>         return self
       
       
    3: class ilike_case_insensitive(
    1:     roles.BinaryElementRole[Any], elements.CompilerColumnElement
       ):
    1:     """produce a wrapping element for a case-insensitive portion of
           an ILIKE construct.
       
           The construct usually renders the ``lower()`` function, but on
           PostgreSQL will pass silently with the assumption that "ILIKE"
           is being used.
       
           .. versionadded:: 2.0
       
           """
       
    1:     __visit_name__ = "ilike_case_insensitive_operand"
    1:     __slots__ = "element", "comparator"
       
    1:     def __init__(self, element):
>>>>>>         self.element = element
>>>>>>         self.comparator = element.comparator
       
    1:     @property
    1:     def proxy_set(self):
>>>>>>         return self.element.proxy_set
       
    1:     @property
    1:     def type(self):
>>>>>>         return self.element.type
       
    1:     def self_group(self, **kw):
>>>>>>         return self
       
    1:     def _with_binary_element_type(self, type_):
>>>>>>         return ilike_case_insensitive(
>>>>>>             self.element._with_binary_element_type(type_)
               )
       
       
    2: class SQLCompiler(Compiled):
    1:     """Default implementation of :class:`.Compiled`.
       
           Compiles :class:`_expression.ClauseElement` objects into SQL strings.
       
           """
       
    1:     extract_map = EXTRACT_MAP
       
    1:     bindname_escape_characters: ClassVar[Mapping[str, str]] = (
    2:         util.immutabledict(
    1:             {
    1:                 "%": "P",
    1:                 "(": "A",
    1:                 ")": "Z",
    1:                 ":": "C",
    1:                 ".": "_",
    1:                 "[": "_",
    1:                 "]": "_",
    1:                 " ": "_",
                   }
               )
           )
           """A mapping (e.g. dict or similar) containing a lookup of
           characters keyed to replacement characters which will be applied to all
           'bind names' used in SQL statements as a form of 'escaping'; the given
           characters are replaced entirely with the 'replacement' character when
           rendered in the SQL statement, and a similar translation is performed
           on the incoming names used in parameter dictionaries passed to methods
           like :meth:`_engine.Connection.execute`.
       
           This allows bound parameter names used in :func:`_sql.bindparam` and
           other constructs to have any arbitrary characters present without any
           concern for characters that aren't allowed at all on the target database.
       
           Third party dialects can establish their own dictionary here to replace the
           default mapping, which will ensure that the particular characters in the
           mapping will never appear in a bound parameter name.
       
           The dictionary is evaluated at **class creation time**, so cannot be
           modified at runtime; it must be present on the class when the class
           is first declared.
       
           Note that for dialects that have additional bound parameter rules such
           as additional restrictions on leading characters, the
           :meth:`_sql.SQLCompiler.bindparam_string` method may need to be augmented.
           See the cx_Oracle compiler for an example of this.
       
           .. versionadded:: 2.0.0rc1
       
           """
       
    1:     _bind_translate_re: ClassVar[Pattern[str]]
    1:     _bind_translate_chars: ClassVar[Mapping[str, str]]
       
    1:     is_sql = True
       
    1:     compound_keywords = COMPOUND_KEYWORDS
       
    1:     isdelete: bool = False
    1:     isinsert: bool = False
    1:     isupdate: bool = False
           """class-level defaults which can be set at the instance
           level to define if this Compiled instance represents
           INSERT/UPDATE/DELETE
           """
       
    1:     postfetch: Optional[List[Column[Any]]]
           """list of columns that can be post-fetched after INSERT or UPDATE to
           receive server-updated values"""
       
    1:     insert_prefetch: Sequence[Column[Any]] = ()
           """list of columns for which default values should be evaluated before
           an INSERT takes place"""
       
    1:     update_prefetch: Sequence[Column[Any]] = ()
           """list of columns for which onupdate default values should be evaluated
           before an UPDATE takes place"""
       
    1:     implicit_returning: Optional[Sequence[ColumnElement[Any]]] = None
           """list of "implicit" returning columns for a toplevel INSERT or UPDATE
           statement, used to receive newly generated values of columns.
       
           .. versionadded:: 2.0  ``implicit_returning`` replaces the previous
              ``returning`` collection, which was not a generalized RETURNING
              collection and instead was in fact specific to the "implicit returning"
              feature.
       
           """
       
    1:     isplaintext: bool = False
       
    1:     binds: Dict[str, BindParameter[Any]]
           """a dictionary of bind parameter keys to BindParameter instances."""
       
    1:     bind_names: Dict[BindParameter[Any], str]
           """a dictionary of BindParameter instances to "compiled" names
           that are actually present in the generated SQL"""
       
    1:     stack: List[_CompilerStackEntry]
           """major statements such as SELECT, INSERT, UPDATE, DELETE are
           tracked in this stack using an entry format."""
       
    1:     returning_precedes_values: bool = False
           """set to True classwide to generate RETURNING
           clauses before the VALUES or WHERE clause (i.e. MSSQL)
           """
       
    1:     render_table_with_column_in_update_from: bool = False
           """set to True classwide to indicate the SET clause
           in a multi-table UPDATE statement should qualify
           columns with the table name (i.e. MySQL only)
           """
       
    1:     ansi_bind_rules: bool = False
           """SQL 92 doesn't allow bind parameters to be used
           in the columns clause of a SELECT, nor does it allow
           ambiguous expressions like "? = ?".  A compiler
           subclass can set this flag to False if the target
           driver/DB enforces this
           """
       
    1:     bindtemplate: str
           """template to render bound parameters based on paramstyle."""
       
    1:     compilation_bindtemplate: str
           """template used by compiler to render parameters before positional
           paramstyle application"""
       
    1:     _numeric_binds_identifier_char: str
           """Character that's used to as the identifier of a numerical bind param.
           For example if this char is set to ``$``, numerical binds will be rendered
           in the form ``$1, $2, $3``.
           """
       
    1:     _result_columns: List[ResultColumnsEntry]
           """relates label names in the final SQL to a tuple of local
           column/label name, ColumnElement object (if any) and
           TypeEngine. CursorResult uses this for type processing and
           column targeting"""
       
    1:     _textual_ordered_columns: bool = False
           """tell the result object that the column names as rendered are important,
           but they are also "ordered" vs. what is in the compiled object here.
       
           As of 1.4.42 this condition is only present when the statement is a
           TextualSelect, e.g. text("....").columns(...), where it is required
           that the columns are considered positionally and not by name.
       
           """
       
    1:     _ad_hoc_textual: bool = False
           """tell the result that we encountered text() or '*' constructs in the
           middle of the result columns, but we also have compiled columns, so
           if the number of columns in cursor.description does not match how many
           expressions we have, that means we can't rely on positional at all and
           should match on name.
       
           """
       
    1:     _ordered_columns: bool = True
           """
           if False, means we can't be sure the list of entries
           in _result_columns is actually the rendered order.  Usually
           True unless using an unordered TextualSelect.
           """
       
    1:     _loose_column_name_matching: bool = False
           """tell the result object that the SQL statement is textual, wants to match
           up to Column objects, and may be using the ._tq_label in the SELECT rather
           than the base name.
       
           """
       
    1:     _numeric_binds: bool = False
           """
           True if paramstyle is "numeric".  This paramstyle is trickier than
           all the others.
       
           """
       
    1:     _render_postcompile: bool = False
           """
           whether to render out POSTCOMPILE params during the compile phase.
       
           This attribute is used only for end-user invocation of stmt.compile();
           it's never used for actual statement execution, where instead the
           dialect internals access and render the internal postcompile structure
           directly.
       
           """
       
    1:     _post_compile_expanded_state: Optional[ExpandedState] = None
           """When render_postcompile is used, the ``ExpandedState`` used to create
           the "expanded" SQL is assigned here, and then used by the ``.params``
           accessor and ``.construct_params()`` methods for their return values.
       
           .. versionadded:: 2.0.0rc1
       
           """
       
    1:     _pre_expanded_string: Optional[str] = None
           """Stores the original string SQL before 'post_compile' is applied,
           for cases where 'post_compile' were used.
       
           """
       
    1:     _pre_expanded_positiontup: Optional[List[str]] = None
       
    1:     _insertmanyvalues: Optional[_InsertManyValues] = None
       
    1:     _insert_crud_params: Optional[crud._CrudParamSequence] = None
       
    1:     literal_execute_params: FrozenSet[BindParameter[Any]] = frozenset()
           """bindparameter objects that are rendered as literal values at statement
           execution time.
       
           """
       
    1:     post_compile_params: FrozenSet[BindParameter[Any]] = frozenset()
           """bindparameter objects that are rendered as bound parameter placeholders
           at statement execution time.
       
           """
       
    1:     escaped_bind_names: util.immutabledict[str, str] = util.EMPTY_DICT
           """Late escaping of bound parameter names that has to be converted
           to the original name when looking in the parameter dictionary.
       
           """
       
    1:     has_out_parameters = False
           """if True, there are bindparam() objects that have the isoutparam
           flag set."""
       
    1:     postfetch_lastrowid = False
           """if True, and this in insert, use cursor.lastrowid to populate
           result.inserted_primary_key. """
       
    1:     _cache_key_bind_match: Optional[
               Tuple[
                   Dict[
                       BindParameter[Any],
                       List[BindParameter[Any]],
                   ],
                   Dict[
                       str,
                       BindParameter[Any],
                   ],
               ]
    1:     ] = None
           """a mapping that will relate the BindParameter object we compile
           to those that are part of the extracted collection of parameters
           in the cache key, if we were given a cache key.
       
           """
       
    1:     positiontup: Optional[List[str]] = None
           """for a compiled construct that uses a positional paramstyle, will be
           a sequence of strings, indicating the names of bound parameters in order.
       
           This is used in order to render bound parameters in their correct order,
           and is combined with the :attr:`_sql.Compiled.params` dictionary to
           render parameters.
       
           This sequence always contains the unescaped name of the parameters.
       
           .. seealso::
       
               :ref:`faq_sql_expression_string` - includes a usage example for
               debugging use cases.
       
           """
    1:     _values_bindparam: Optional[List[str]] = None
       
    1:     _visited_bindparam: Optional[List[str]] = None
       
    1:     inline: bool = False
       
    1:     ctes: Optional[MutableMapping[CTE, str]]
       
           # Detect same CTE references - Dict[(level, name), cte]
           # Level is required for supporting nesting
    1:     ctes_by_level_name: Dict[Tuple[int, str], CTE]
       
           # To retrieve key/level in ctes_by_level_name -
           # Dict[cte_reference, (level, cte_name, cte_opts)]
    1:     level_name_by_cte: Dict[CTE, Tuple[int, str, selectable._CTEOpts]]
       
    1:     ctes_recursive: bool
       
    1:     _post_compile_pattern = re.compile(r"__\[POSTCOMPILE_(\S+?)(~~.+?~~)?\]")
    1:     _pyformat_pattern = re.compile(r"%\(([^)]+?)\)s")
    2:     _positional_pattern = re.compile(
    1:         f"{_pyformat_pattern.pattern}|{_post_compile_pattern.pattern}"
           )
       
    1:     @classmethod
    1:     def _init_compiler_cls(cls):
    6:         cls._init_bind_translate()
       
    1:     @classmethod
    1:     def _init_bind_translate(cls):
    6:         reg = re.escape("".join(cls.bindname_escape_characters))
    6:         cls._bind_translate_re = re.compile(f"[{reg}]")
    6:         cls._bind_translate_chars = cls.bindname_escape_characters
       
    1:     def __init__(
               self,
               dialect: Dialect,
               statement: Optional[ClauseElement],
    1:         cache_key: Optional[CacheKey] = None,
    1:         column_keys: Optional[Sequence[str]] = None,
    1:         for_executemany: bool = False,
    1:         linting: Linting = NO_LINTING,
    1:         _supporting_against: Optional[SQLCompiler] = None,
               **kwargs: Any,
           ):
               """Construct a new :class:`.SQLCompiler` object.
       
               :param dialect: :class:`.Dialect` to be used
       
               :param statement: :class:`_expression.ClauseElement` to be compiled
       
               :param column_keys:  a list of column names to be compiled into an
                INSERT or UPDATE statement.
       
               :param for_executemany: whether INSERT / UPDATE statements should
                expect that they are to be invoked in an "executemany" style,
                which may impact how the statement will be expected to return the
                values of defaults and autoincrement / sequences and similar.
                Depending on the backend and driver in use, support for retrieving
                these values may be disabled which means SQL expressions may
                be rendered inline, RETURNING may not be rendered, etc.
       
               :param kwargs: additional keyword arguments to be consumed by the
                superclass.
       
               """
  131:         self.column_keys = column_keys
       
  131:         self.cache_key = cache_key
       
  131:         if cache_key:
  108:             cksm = {b.key: b for b in cache_key[1]}
  108:             ckbm = {b: [b] for b in cache_key[1]}
   50:             self._cache_key_bind_match = (ckbm, cksm)
       
               # compile INSERT/UPDATE defaults/sequences to expect executemany
               # style execution, which may mean no pre-execute of defaults,
               # or no RETURNING
  131:         self.for_executemany = for_executemany
       
  131:         self.linting = linting
       
               # a dictionary of bind parameter keys to BindParameter
               # instances.
  131:         self.binds = {}
       
               # a dictionary of BindParameter instances to "compiled" names
               # that are actually present in the generated SQL
  131:         self.bind_names = util.column_dict()
       
               # stack which keeps track of nested SELECT statements
  131:         self.stack = []
       
  131:         self._result_columns = []
       
               # true if the paramstyle is positional
  131:         self.positional = dialect.positional
  131:         if self.positional:
>>>>>>             self._numeric_binds = nb = dialect.paramstyle.startswith("numeric")
>>>>>>             if nb:
>>>>>>                 self._numeric_binds_identifier_char = (
>>>>>>                     "$" if dialect.paramstyle == "numeric_dollar" else ":"
                       )
       
>>>>>>             self.compilation_bindtemplate = _pyformat_template
               else:
  131:             self.compilation_bindtemplate = BIND_TEMPLATES[dialect.paramstyle]
       
  131:         self.ctes = None
       
  131:         self.label_length = (
  131:             dialect.label_length or dialect.max_identifier_length
               )
       
               # a map which tracks "anonymous" identifiers that are created on
               # the fly here
  131:         self.anon_map = prefix_anon_map()
       
               # a map which tracks "truncated" names based on
               # dialect.label_length or dialect.max_identifier_length
  131:         self.truncated_names: Dict[Tuple[str, str], str] = {}
  131:         self._truncated_counters: Dict[str, int] = {}
       
  131:         Compiled.__init__(self, dialect, statement, **kwargs)
       
  131:         if self.isinsert or self.isupdate or self.isdelete:
    1:             if TYPE_CHECKING:
>>>>>>                 assert isinstance(statement, UpdateBase)
       
    1:             if self.isinsert or self.isupdate:
    1:                 if TYPE_CHECKING:
>>>>>>                     assert isinstance(statement, ValuesBase)
    1:                 if statement._inline:
>>>>>>                     self.inline = True
    4:                 elif self.for_executemany and (
    1:                     not self.isinsert
                           or (
    1:                         self.dialect.insert_executemany_returning
    1:                         and statement._return_defaults
                           )
                       ):
    1:                     self.inline = True
       
  131:         self.bindtemplate = BIND_TEMPLATES[dialect.paramstyle]
       
  131:         if _supporting_against:
>>>>>>             self.__dict__.update(
>>>>>>                 {
>>>>>>                     k: v
>>>>>>                     for k, v in _supporting_against.__dict__.items()
>>>>>>                     if k
>>>>>>                     not in {
                               "state",
                               "dialect",
                               "preparer",
                               "positional",
                               "_numeric_binds",
                               "compilation_bindtemplate",
                               "bindtemplate",
                           }
                       }
                   )
       
  131:         if self.state is CompilerState.STRING_APPLIED:
   51:             if self.positional:
>>>>>>                 if self._numeric_binds:
>>>>>>                     self._process_numeric()
                       else:
>>>>>>                     self._process_positional()
       
   51:             if self._render_postcompile:
>>>>>>                 parameters = self.construct_params(
>>>>>>                     escape_names=False,
>>>>>>                     _no_postcompile=True,
                       )
       
>>>>>>                 self._process_parameters_for_postcompile(
>>>>>>                     parameters, _populate_self=True
                       )
       
    1:     @property
    1:     def insert_single_values_expr(self) -> Optional[str]:
               """When an INSERT is compiled with a single set of parameters inside
               a VALUES expression, the string is assigned here, where it can be
               used for insert batching schemes to rewrite the VALUES expression.
       
               .. versionadded:: 1.3.8
       
               .. versionchanged:: 2.0 This collection is no longer used by
                  SQLAlchemy's built-in dialects, in favor of the currently
                  internal ``_insertmanyvalues`` collection that is used only by
                  :class:`.SQLCompiler`.
       
               """
>>>>>>         if self._insertmanyvalues is None:
>>>>>>             return None
               else:
>>>>>>             return self._insertmanyvalues.single_values_expr
       
    1:     @util.ro_memoized_property
    1:     def effective_returning(self) -> Optional[Sequence[ColumnElement[Any]]]:
               """The effective "returning" columns for INSERT, UPDATE or DELETE.
       
               This is either the so-called "implicit returning" columns which are
               calculated by the compiler on the fly, or those present based on what's
               present in ``self.statement._returning`` (expanded into individual
               columns using the ``._all_selected_columns`` attribute) i.e. those set
               explicitly using the :meth:`.UpdateBase.returning` method.
       
               .. versionadded:: 2.0
       
               """
    1:         if self.implicit_returning:
>>>>>>             return self.implicit_returning
    1:         elif self.statement is not None and is_dml(self.statement):
    3:             return [
>>>>>>                 c
    1:                 for c in self.statement._all_selected_columns
>>>>>>                 if is_column_element(c)
                   ]
       
               else:
>>>>>>             return None
       
    1:     @property
    1:     def returning(self):
               """backwards compatibility; returns the
               effective_returning collection.
       
               """
>>>>>>         return self.effective_returning
       
    1:     @property
    1:     def current_executable(self):
               """Return the current 'executable' that is being compiled.
       
               This is currently the :class:`_sql.Select`, :class:`_sql.Insert`,
               :class:`_sql.Update`, :class:`_sql.Delete`,
               :class:`_sql.CompoundSelect` object that is being compiled.
               Specifically it's assigned to the ``self.stack`` list of elements.
       
               When a statement like the above is being compiled, it normally
               is also assigned to the ``.statement`` attribute of the
               :class:`_sql.Compiler` object.   However, all SQL constructs are
               ultimately nestable, and this attribute should never be consulted
               by a ``visit_`` method, as it is not guaranteed to be assigned
               nor guaranteed to correspond to the current statement being compiled.
       
               .. versionadded:: 1.3.21
       
                   For compatibility with previous versions, use the following
                   recipe::
       
                       statement = getattr(self, "current_executable", False)
                       if statement is False:
                           statement = self.stack[-1]["selectable"]
       
                   For versions 1.4 and above, ensure only .current_executable
                   is used; the format of "self.stack" may change.
       
       
               """
>>>>>>         try:
>>>>>>             return self.stack[-1]["selectable"]
>>>>>>         except IndexError as ie:
>>>>>>             raise IndexError("Compiler does not have a stack entry") from ie
       
    1:     @property
    1:     def prefetch(self):
    2:         return list(self.insert_prefetch) + list(self.update_prefetch)
       
    1:     @util.memoized_property
    1:     def _global_attributes(self) -> Dict[Any, Any]:
    1:         return {}
       
    1:     @util.memoized_instancemethod
    1:     def _init_cte_state(self) -> MutableMapping[CTE, str]:
               """Initialize collections related to CTEs only if
               a CTE is located, to save on the overhead of
               these collections otherwise.
       
               """
               # collect CTEs to tack on top of a SELECT
               # To store the query to print - Dict[cte, text_query]
>>>>>>         ctes: MutableMapping[CTE, str] = util.OrderedDict()
>>>>>>         self.ctes = ctes
       
               # Detect same CTE references - Dict[(level, name), cte]
               # Level is required for supporting nesting
>>>>>>         self.ctes_by_level_name = {}
       
               # To retrieve key/level in ctes_by_level_name -
               # Dict[cte_reference, (level, cte_name, cte_opts)]
>>>>>>         self.level_name_by_cte = {}
       
>>>>>>         self.ctes_recursive = False
       
>>>>>>         return ctes
       
    1:     @contextlib.contextmanager
    1:     def _nested_result(self):
               """special API to support the use case of 'nested result sets'"""
>>>>>>         result_columns, ordered_columns = (
>>>>>>             self._result_columns,
>>>>>>             self._ordered_columns,
               )
>>>>>>         self._result_columns, self._ordered_columns = [], False
       
>>>>>>         try:
>>>>>>             if self.stack:
>>>>>>                 entry = self.stack[-1]
>>>>>>                 entry["need_result_map_for_nested"] = True
                   else:
>>>>>>                 entry = None
>>>>>>             yield self._result_columns, self._ordered_columns
               finally:
>>>>>>             if entry:
>>>>>>                 entry.pop("need_result_map_for_nested")
>>>>>>             self._result_columns, self._ordered_columns = (
>>>>>>                 result_columns,
>>>>>>                 ordered_columns,
                   )
       
    1:     def _process_positional(self):
>>>>>>         assert not self.positiontup
>>>>>>         assert self.state is CompilerState.STRING_APPLIED
>>>>>>         assert not self._numeric_binds
       
>>>>>>         if self.dialect.paramstyle == "format":
>>>>>>             placeholder = "%s"
               else:
>>>>>>             assert self.dialect.paramstyle == "qmark"
>>>>>>             placeholder = "?"
       
>>>>>>         positions = []
       
>>>>>>         def find_position(m: re.Match[str]) -> str:
>>>>>>             normal_bind = m.group(1)
>>>>>>             if normal_bind:
>>>>>>                 positions.append(normal_bind)
>>>>>>                 return placeholder
                   else:
                       # this a post-compile bind
>>>>>>                 positions.append(m.group(2))
>>>>>>                 return m.group(0)
       
>>>>>>         self.string = re.sub(
>>>>>>             self._positional_pattern, find_position, self.string
               )
       
>>>>>>         if self.escaped_bind_names:
>>>>>>             reverse_escape = {v: k for k, v in self.escaped_bind_names.items()}
>>>>>>             assert len(self.escaped_bind_names) == len(reverse_escape)
>>>>>>             self.positiontup = [
>>>>>>                 reverse_escape.get(name, name) for name in positions
                   ]
               else:
>>>>>>             self.positiontup = positions
       
>>>>>>         if self._insertmanyvalues:
>>>>>>             positions = []
       
>>>>>>             single_values_expr = re.sub(
>>>>>>                 self._positional_pattern,
>>>>>>                 find_position,
>>>>>>                 self._insertmanyvalues.single_values_expr,
                   )
>>>>>>             insert_crud_params = [
>>>>>>                 (
>>>>>>                     v[0],
>>>>>>                     v[1],
>>>>>>                     re.sub(self._positional_pattern, find_position, v[2]),
>>>>>>                     v[3],
                       )
>>>>>>                 for v in self._insertmanyvalues.insert_crud_params
                   ]
       
>>>>>>             sentinel_param_int_idxs = (
>>>>>>                 [
>>>>>>                     self.positiontup.index(cast(str, _param_key))
>>>>>>                     for _param_key in self._insertmanyvalues.sentinel_param_keys  # noqa: E501
                       ]
>>>>>>                 if self._insertmanyvalues.sentinel_param_keys is not None
>>>>>>                 else None
                   )
       
>>>>>>             self._insertmanyvalues = self._insertmanyvalues._replace(
>>>>>>                 single_values_expr=single_values_expr,
>>>>>>                 insert_crud_params=insert_crud_params,
>>>>>>                 sentinel_param_keys=sentinel_param_int_idxs,
                   )
       
    1:     def _process_numeric(self):
>>>>>>         assert self._numeric_binds
>>>>>>         assert self.state is CompilerState.STRING_APPLIED
       
>>>>>>         num = 1
>>>>>>         param_pos: Dict[str, str] = {}
               order: Iterable[str]
>>>>>>         if self._insertmanyvalues and self._values_bindparam is not None:
                   # bindparams that are not in values are always placed first.
                   # this avoids the need of changing them when using executemany
                   # values () ()
>>>>>>             order = itertools.chain(
>>>>>>                 (
>>>>>>                     name
>>>>>>                     for name in self.bind_names.values()
>>>>>>                     if name not in self._values_bindparam
                       ),
>>>>>>                 self.bind_names.values(),
                   )
               else:
>>>>>>             order = self.bind_names.values()
       
>>>>>>         for bind_name in order:
>>>>>>             if bind_name in param_pos:
>>>>>>                 continue
>>>>>>             bind = self.binds[bind_name]
>>>>>>             if (
>>>>>>                 bind in self.post_compile_params
>>>>>>                 or bind in self.literal_execute_params
                   ):
                       # set to None to just mark the in positiontup, it will not
                       # be replaced below.
>>>>>>                 param_pos[bind_name] = None  # type: ignore
                   else:
>>>>>>                 ph = f"{self._numeric_binds_identifier_char}{num}"
>>>>>>                 num += 1
>>>>>>                 param_pos[bind_name] = ph
       
>>>>>>         self.next_numeric_pos = num
       
>>>>>>         self.positiontup = list(param_pos)
>>>>>>         if self.escaped_bind_names:
>>>>>>             len_before = len(param_pos)
>>>>>>             param_pos = {
>>>>>>                 self.escaped_bind_names.get(name, name): pos
>>>>>>                 for name, pos in param_pos.items()
                   }
>>>>>>             assert len(param_pos) == len_before
       
               # Can't use format here since % chars are not escaped.
>>>>>>         self.string = self._pyformat_pattern.sub(
>>>>>>             lambda m: param_pos[m.group(1)], self.string
               )
       
>>>>>>         if self._insertmanyvalues:
>>>>>>             single_values_expr = (
                       # format is ok here since single_values_expr includes only
                       # place-holders
>>>>>>                 self._insertmanyvalues.single_values_expr
>>>>>>                 % param_pos
                   )
>>>>>>             insert_crud_params = [
>>>>>>                 (v[0], v[1], "%s", v[3])
>>>>>>                 for v in self._insertmanyvalues.insert_crud_params
                   ]
       
>>>>>>             sentinel_param_int_idxs = (
>>>>>>                 [
>>>>>>                     self.positiontup.index(cast(str, _param_key))
>>>>>>                     for _param_key in self._insertmanyvalues.sentinel_param_keys  # noqa: E501
                       ]
>>>>>>                 if self._insertmanyvalues.sentinel_param_keys is not None
>>>>>>                 else None
                   )
       
>>>>>>             self._insertmanyvalues = self._insertmanyvalues._replace(
                       # This has the numbers (:1, :2)
>>>>>>                 single_values_expr=single_values_expr,
                       # The single binds are instead %s so they can be formatted
>>>>>>                 insert_crud_params=insert_crud_params,
>>>>>>                 sentinel_param_keys=sentinel_param_int_idxs,
                   )
       
    1:     @util.memoized_property
    1:     def _bind_processors(
               self,
           ) -> MutableMapping[
               str, Union[_BindProcessorType[Any], Sequence[_BindProcessorType[Any]]]
           ]:
               # mypy is not able to see the two value types as the above Union,
               # it just sees "object".  don't know how to resolve
  203:         return {
    6:             key: value  # type: ignore
  256:             for key, value in (
   53:                 (
   53:                     self.bind_names[bindparam],
                           (
   53:                         bindparam.type._cached_bind_processor(self.dialect)
   53:                         if not bindparam.type._is_tuple_type
>>>>>>                         else tuple(
>>>>>>                             elem_type._cached_bind_processor(self.dialect)
>>>>>>                             for elem_type in cast(
>>>>>>                                 TupleType, bindparam.type
                                   ).types
                               )
                           ),
                       )
  103:                 for bindparam in self.bind_names
                   )
   53:             if value is not None
               }
       
    1:     @util.memoized_property
    1:     def _imv_sentinel_value_resolvers(
               self,
           ) -> Optional[Sequence[Optional[_SentinelProcessorType[Any]]]]:
>>>>>>         imv = self._insertmanyvalues
>>>>>>         if imv is None or imv.sentinel_columns is None:
>>>>>>             return None
       
>>>>>>         sentinel_value_resolvers = [
>>>>>>             _scol.type._cached_sentinel_value_processor(self.dialect)
>>>>>>             for _scol in imv.sentinel_columns
               ]
>>>>>>         if util.NONE_SET.issuperset(sentinel_value_resolvers):
>>>>>>             return None
               else:
>>>>>>             return sentinel_value_resolvers
       
    1:     def is_subquery(self):
>>>>>>         return len(self.stack) > 1
       
    1:     @property
    1:     def sql_compiler(self):
>>>>>>         return self
       
>>>>>>     def construct_expanded_state(
               self,
               params: Optional[_CoreSingleExecuteParams] = None,
    1:         escape_names: bool = True,
           ) -> ExpandedState:
               """Return a new :class:`.ExpandedState` for a given parameter set.
       
               For queries that use "expanding" or other late-rendered parameters,
               this method will provide for both the finalized SQL string as well
               as the parameters that would be used for a particular parameter set.
       
               .. versionadded:: 2.0.0rc1
       
               """
>>>>>>         parameters = self.construct_params(
>>>>>>             params,
>>>>>>             escape_names=escape_names,
>>>>>>             _no_postcompile=True,
               )
>>>>>>         return self._process_parameters_for_postcompile(
>>>>>>             parameters,
               )
       
>>>>>>     def construct_params(
               self,
               params: Optional[_CoreSingleExecuteParams] = None,
               extracted_parameters: Optional[Sequence[BindParameter[Any]]] = None,
               escape_names: bool = True,
               _group_number: Optional[int] = None,
               _check: bool = True,
    1:         _no_postcompile: bool = False,
           ) -> _MutableCoreSingleExecuteParams:
               """return a dictionary of bind parameter keys and values"""
       
   95:         if self._render_postcompile and not _no_postcompile:
>>>>>>             assert self._post_compile_expanded_state is not None
>>>>>>             if not params:
>>>>>>                 return dict(self._post_compile_expanded_state.parameters)
                   else:
>>>>>>                 raise exc.InvalidRequestError(
>>>>>>                     "can't construct new parameters when render_postcompile "
                           "is used; the statement is hard-linked to the original "
                           "parameters.  Use construct_expanded_state to generate a "
                           "new statement and parameters."
                       )
       
   95:         has_escaped_names = escape_names and bool(self.escaped_bind_names)
       
   95:         if extracted_parameters:
                   # related the bound parameters collected in the original cache key
                   # to those collected in the incoming cache key.  They will not have
                   # matching names but they will line up positionally in the same
                   # way.   The parameters present in self.bind_names may be clones of
                   # these original cache key params in the case of DML but the .key
                   # will be guaranteed to match.
   46:             if self.cache_key is None:
>>>>>>                 raise exc.CompileError(
>>>>>>                     "This compiled object has no original cache key; "
                           "can't pass extracted_parameters to construct_params"
                       )
                   else:
   46:                 orig_extracted = self.cache_key[1]
       
   46:             ckbm_tuple = self._cache_key_bind_match
   46:             assert ckbm_tuple is not None
   46:             ckbm, _ = ckbm_tuple
  454:             resolved_extracted = {
  677:                 bind: extracted
  362:                 for b, extracted in zip(orig_extracted, extracted_parameters)
  993:                 for bind in ckbm[b]
                   }
               else:
   49:             resolved_extracted = None
       
   95:         if params:
   47:             pd = {}
  452:             for bindparam, name in self.bind_names.items():
  405:                 escaped_name = (
  405:                     self.escaped_bind_names.get(name, name)
  405:                     if has_escaped_names
  405:                     else name
                       )
       
  405:                 if bindparam.key in params:
  105:                     pd[escaped_name] = params[bindparam.key]
  300:                 elif name in params:
>>>>>>                     pd[escaped_name] = params[name]
       
  300:                 elif _check and bindparam.required:
>>>>>>                     if _group_number:
>>>>>>                         raise exc.InvalidRequestError(
>>>>>>                             "A value is required for bind parameter %r, "
                                   "in parameter group %d"
>>>>>>                             % (bindparam.key, _group_number),
>>>>>>                             code="cd3x",
                               )
                           else:
>>>>>>                         raise exc.InvalidRequestError(
>>>>>>                             "A value is required for bind parameter %r"
>>>>>>                             % bindparam.key,
>>>>>>                             code="cd3x",
                               )
                       else:
  300:                     if resolved_extracted:
  540:                         value_param = resolved_extracted.get(
  270:                             bindparam, bindparam
                               )
                           else:
   30:                         value_param = bindparam
       
  300:                     if bindparam.callable:
>>>>>>                         pd[escaped_name] = value_param.effective_value
                           else:
  300:                         pd[escaped_name] = value_param.value
   47:             return pd
               else:
   48:             pd = {}
   49:             for bindparam, name in self.bind_names.items():
    1:                 escaped_name = (
    1:                     self.escaped_bind_names.get(name, name)
    1:                     if has_escaped_names
    1:                     else name
                       )
       
    1:                 if _check and bindparam.required:
>>>>>>                     if _group_number:
>>>>>>                         raise exc.InvalidRequestError(
>>>>>>                             "A value is required for bind parameter %r, "
                                   "in parameter group %d"
>>>>>>                             % (bindparam.key, _group_number),
>>>>>>                             code="cd3x",
                               )
                           else:
>>>>>>                         raise exc.InvalidRequestError(
>>>>>>                             "A value is required for bind parameter %r"
>>>>>>                             % bindparam.key,
>>>>>>                             code="cd3x",
                               )
       
    1:                 if resolved_extracted:
    1:                     value_param = resolved_extracted.get(bindparam, bindparam)
                       else:
>>>>>>                     value_param = bindparam
       
    1:                 if bindparam.callable:
>>>>>>                     pd[escaped_name] = value_param.effective_value
                       else:
    1:                     pd[escaped_name] = value_param.value
       
   48:             return pd
       
    1:     @util.memoized_instancemethod
    1:     def _get_set_input_sizes_lookup(self):
>>>>>>         dialect = self.dialect
       
>>>>>>         include_types = dialect.include_set_input_sizes
>>>>>>         exclude_types = dialect.exclude_set_input_sizes
       
>>>>>>         dbapi = dialect.dbapi
       
>>>>>>         def lookup_type(typ):
>>>>>>             dbtype = typ._unwrapped_dialect_impl(dialect).get_dbapi_type(dbapi)
       
>>>>>>             if (
>>>>>>                 dbtype is not None
>>>>>>                 and (exclude_types is None or dbtype not in exclude_types)
>>>>>>                 and (include_types is None or dbtype in include_types)
                   ):
>>>>>>                 return dbtype
                   else:
>>>>>>                 return None
       
>>>>>>         inputsizes = {}
       
>>>>>>         literal_execute_params = self.literal_execute_params
       
>>>>>>         for bindparam in self.bind_names:
>>>>>>             if bindparam in literal_execute_params:
>>>>>>                 continue
       
>>>>>>             if bindparam.type._is_tuple_type:
>>>>>>                 inputsizes[bindparam] = [
>>>>>>                     lookup_type(typ)
>>>>>>                     for typ in cast(TupleType, bindparam.type).types
                       ]
                   else:
>>>>>>                 inputsizes[bindparam] = lookup_type(bindparam.type)
       
>>>>>>         return inputsizes
       
    1:     @property
    1:     def params(self):
               """Return the bind param dictionary embedded into this
               compiled object, for those values that are present.
       
               .. seealso::
       
                   :ref:`faq_sql_expression_string` - includes a usage example for
                   debugging use cases.
       
               """
>>>>>>         return self.construct_params(_check=False)
       
>>>>>>     def _process_parameters_for_postcompile(
               self,
               parameters: _MutableCoreSingleExecuteParams,
    1:         _populate_self: bool = False,
           ) -> ExpandedState:
               """handle special post compile parameters.
       
               These include:
       
               * "expanding" parameters -typically IN tuples that are rendered
                 on a per-parameter basis for an otherwise fixed SQL statement string.
       
               * literal_binds compiled with the literal_execute flag.  Used for
                 things like SQL Server "TOP N" where the driver does not accommodate
                 N as a bound parameter.
       
               """
       
>>>>>>         expanded_parameters = {}
               new_positiontup: Optional[List[str]]
       
>>>>>>         pre_expanded_string = self._pre_expanded_string
>>>>>>         if pre_expanded_string is None:
>>>>>>             pre_expanded_string = self.string
       
>>>>>>         if self.positional:
>>>>>>             new_positiontup = []
       
>>>>>>             pre_expanded_positiontup = self._pre_expanded_positiontup
>>>>>>             if pre_expanded_positiontup is None:
>>>>>>                 pre_expanded_positiontup = self.positiontup
       
               else:
>>>>>>             new_positiontup = pre_expanded_positiontup = None
       
>>>>>>         processors = self._bind_processors
>>>>>>         single_processors = cast(
>>>>>>             "Mapping[str, _BindProcessorType[Any]]", processors
               )
>>>>>>         tuple_processors = cast(
>>>>>>             "Mapping[str, Sequence[_BindProcessorType[Any]]]", processors
               )
       
>>>>>>         new_processors: Dict[str, _BindProcessorType[Any]] = {}
       
>>>>>>         replacement_expressions: Dict[str, Any] = {}
>>>>>>         to_update_sets: Dict[str, Any] = {}
       
               # notes:
               # *unescaped* parameter names in:
               # self.bind_names, self.binds, self._bind_processors, self.positiontup
               #
               # *escaped* parameter names in:
               # construct_params(), replacement_expressions
       
>>>>>>         numeric_positiontup: Optional[List[str]] = None
       
>>>>>>         if self.positional and pre_expanded_positiontup is not None:
>>>>>>             names: Iterable[str] = pre_expanded_positiontup
>>>>>>             if self._numeric_binds:
>>>>>>                 numeric_positiontup = []
               else:
>>>>>>             names = self.bind_names.values()
       
>>>>>>         ebn = self.escaped_bind_names
>>>>>>         for name in names:
>>>>>>             escaped_name = ebn.get(name, name) if ebn else name
>>>>>>             parameter = self.binds[name]
       
>>>>>>             if parameter in self.literal_execute_params:
>>>>>>                 if escaped_name not in replacement_expressions:
>>>>>>                     replacement_expressions[escaped_name] = (
>>>>>>                         self.render_literal_bindparam(
>>>>>>                             parameter,
>>>>>>                             render_literal_value=parameters.pop(escaped_name),
                               )
                           )
>>>>>>                 continue
       
>>>>>>             if parameter in self.post_compile_params:
>>>>>>                 if escaped_name in replacement_expressions:
>>>>>>                     to_update = to_update_sets[escaped_name]
>>>>>>                     values = None
                       else:
                           # we are removing the parameter from parameters
                           # because it is a list value, which is not expected by
                           # TypeEngine objects that would otherwise be asked to
                           # process it. the single name is being replaced with
                           # individual numbered parameters for each value in the
                           # param.
                           #
                           # note we are also inserting *escaped* parameter names
                           # into the given dictionary.   default dialect will
                           # use these param names directly as they will not be
                           # in the escaped_bind_names dictionary.
>>>>>>                     values = parameters.pop(name)
       
>>>>>>                     leep_res = self._literal_execute_expanding_parameter(
>>>>>>                         escaped_name, parameter, values
                           )
>>>>>>                     (to_update, replacement_expr) = leep_res
       
>>>>>>                     to_update_sets[escaped_name] = to_update
>>>>>>                     replacement_expressions[escaped_name] = replacement_expr
       
>>>>>>                 if not parameter.literal_execute:
>>>>>>                     parameters.update(to_update)
>>>>>>                     if parameter.type._is_tuple_type:
>>>>>>                         assert values is not None
>>>>>>                         new_processors.update(
>>>>>>                             (
>>>>>>                                 "%s_%s_%s" % (name, i, j),
>>>>>>                                 tuple_processors[name][j - 1],
                                   )
>>>>>>                             for i, tuple_element in enumerate(values, 1)
>>>>>>                             for j, _ in enumerate(tuple_element, 1)
>>>>>>                             if name in tuple_processors
>>>>>>                             and tuple_processors[name][j - 1] is not None
                               )
                           else:
>>>>>>                         new_processors.update(
>>>>>>                             (key, single_processors[name])
>>>>>>                             for key, _ in to_update
>>>>>>                             if name in single_processors
                               )
>>>>>>                     if numeric_positiontup is not None:
>>>>>>                         numeric_positiontup.extend(
>>>>>>                             name for name, _ in to_update
                               )
>>>>>>                     elif new_positiontup is not None:
                               # to_update has escaped names, but that's ok since
                               # these are new names, that aren't in the
                               # escaped_bind_names dict.
>>>>>>                         new_positiontup.extend(name for name, _ in to_update)
>>>>>>                     expanded_parameters[name] = [
>>>>>>                         expand_key for expand_key, _ in to_update
                           ]
>>>>>>             elif new_positiontup is not None:
>>>>>>                 new_positiontup.append(name)
       
>>>>>>         def process_expanding(m):
>>>>>>             key = m.group(1)
>>>>>>             expr = replacement_expressions[key]
       
                   # if POSTCOMPILE included a bind_expression, render that
                   # around each element
>>>>>>             if m.group(2):
>>>>>>                 tok = m.group(2).split("~~")
>>>>>>                 be_left, be_right = tok[1], tok[3]
>>>>>>                 expr = ", ".join(
>>>>>>                     "%s%s%s" % (be_left, exp, be_right)
>>>>>>                     for exp in expr.split(", ")
                       )
>>>>>>             return expr
       
>>>>>>         statement = re.sub(
>>>>>>             self._post_compile_pattern, process_expanding, pre_expanded_string
               )
       
>>>>>>         if numeric_positiontup is not None:
>>>>>>             assert new_positiontup is not None
>>>>>>             param_pos = {
>>>>>>                 key: f"{self._numeric_binds_identifier_char}{num}"
>>>>>>                 for num, key in enumerate(
>>>>>>                     numeric_positiontup, self.next_numeric_pos
                       )
                   }
                   # Can't use format here since % chars are not escaped.
>>>>>>             statement = self._pyformat_pattern.sub(
>>>>>>                 lambda m: param_pos[m.group(1)], statement
                   )
>>>>>>             new_positiontup.extend(numeric_positiontup)
       
>>>>>>         expanded_state = ExpandedState(
>>>>>>             statement,
>>>>>>             parameters,
>>>>>>             new_processors,
>>>>>>             new_positiontup,
>>>>>>             expanded_parameters,
               )
       
>>>>>>         if _populate_self:
                   # this is for the "render_postcompile" flag, which is not
                   # otherwise used internally and is for end-user debugging and
                   # special use cases.
>>>>>>             self._pre_expanded_string = pre_expanded_string
>>>>>>             self._pre_expanded_positiontup = pre_expanded_positiontup
>>>>>>             self.string = expanded_state.statement
>>>>>>             self.positiontup = (
>>>>>>                 list(expanded_state.positiontup or ())
>>>>>>                 if self.positional
>>>>>>                 else None
                   )
>>>>>>             self._post_compile_expanded_state = expanded_state
       
>>>>>>         return expanded_state
       
    1:     @util.preload_module("sqlalchemy.engine.cursor")
    1:     def _create_result_map(self):
               """utility method used for unit tests only."""
>>>>>>         cursor = util.preloaded.engine_cursor
>>>>>>         return cursor.CursorResultMetaData._create_description_match_map(
>>>>>>             self._result_columns
               )
       
           # assigned by crud.py for insert/update statements
    1:     _get_bind_name_for_col: _BindNameForColProtocol
       
    1:     @util.memoized_property
    1:     def _within_exec_param_key_getter(self) -> Callable[[Any], str]:
    1:         getter = self._get_bind_name_for_col
    1:         return getter
       
    1:     @util.memoized_property
    1:     @util.preload_module("sqlalchemy.engine.result")
    1:     def _inserted_primary_key_from_lastrowid_getter(self):
    1:         result = util.preloaded.engine_result
       
    1:         param_key_getter = self._within_exec_param_key_getter
       
    1:         assert self.compile_state is not None
    1:         statement = self.compile_state.statement
       
    1:         if TYPE_CHECKING:
>>>>>>             assert isinstance(statement, Insert)
       
    1:         table = statement.table
       
    4:         getters = [
    1:             (operator.methodcaller("get", param_key_getter(col), None), col)
    2:             for col in table.primary_key
               ]
       
    1:         autoinc_getter = None
    1:         autoinc_col = table._autoincrement_column
    1:         if autoinc_col is not None:
                   # apply type post processors to the lastrowid
>>>>>>             lastrowid_processor = autoinc_col.type._cached_result_processor(
>>>>>>                 self.dialect, None
                   )
>>>>>>             autoinc_key = param_key_getter(autoinc_col)
       
                   # if a bind value is present for the autoincrement column
                   # in the parameters, we need to do the logic dictated by
                   # #7998; honor a non-None user-passed parameter over lastrowid.
                   # previously in the 1.4 series we weren't fetching lastrowid
                   # at all if the key were present in the parameters
>>>>>>             if autoinc_key in self.binds:
       
>>>>>>                 def _autoinc_getter(lastrowid, parameters):
>>>>>>                     param_value = parameters.get(autoinc_key, lastrowid)
>>>>>>                     if param_value is not None:
                               # they supplied non-None parameter, use that.
                               # SQLite at least is observed to return the wrong
                               # cursor.lastrowid for INSERT..ON CONFLICT so it
                               # can't be used in all cases
>>>>>>                         return param_value
                           else:
                               # use lastrowid
>>>>>>                         return lastrowid
       
                       # work around mypy https://github.com/python/mypy/issues/14027
>>>>>>                 autoinc_getter = _autoinc_getter
       
               else:
    1:             lastrowid_processor = None
       
    3:         row_fn = result.result_tuple([col.key for col in table.primary_key])
       
    1:         def get(lastrowid, parameters):
                   """given cursor.lastrowid value and the parameters used for INSERT,
                   return a "row" that represents the primary key, either by
                   using the "lastrowid" or by extracting values from the parameters
                   that were sent along with the INSERT.
       
                   """
    2:             if lastrowid_processor is not None:
>>>>>>                 lastrowid = lastrowid_processor(lastrowid)
       
    2:             if lastrowid is None:
    6:                 return row_fn(getter(parameters) for getter, col in getters)
                   else:
>>>>>>                 return row_fn(
                           (
>>>>>>                         (
>>>>>>                             autoinc_getter(lastrowid, parameters)
>>>>>>                             if autoinc_getter is not None
>>>>>>                             else lastrowid
                               )
>>>>>>                         if col is autoinc_col
>>>>>>                         else getter(parameters)
                           )
>>>>>>                     for getter, col in getters
                       )
       
    1:         return get
       
    1:     @util.memoized_property
    1:     @util.preload_module("sqlalchemy.engine.result")
    1:     def _inserted_primary_key_from_returning_getter(self):
>>>>>>         if typing.TYPE_CHECKING:
>>>>>>             from ..engine import result
               else:
>>>>>>             result = util.preloaded.engine_result
       
>>>>>>         assert self.compile_state is not None
>>>>>>         statement = self.compile_state.statement
       
>>>>>>         if TYPE_CHECKING:
>>>>>>             assert isinstance(statement, Insert)
       
>>>>>>         param_key_getter = self._within_exec_param_key_getter
>>>>>>         table = statement.table
       
>>>>>>         returning = self.implicit_returning
>>>>>>         assert returning is not None
>>>>>>         ret = {col: idx for idx, col in enumerate(returning)}
       
>>>>>>         getters = cast(
>>>>>>             "List[Tuple[Callable[[Any], Any], bool]]",
>>>>>>             [
                       (
>>>>>>                     (operator.itemgetter(ret[col]), True)
>>>>>>                     if col in ret
>>>>>>                     else (
>>>>>>                         operator.methodcaller(
>>>>>>                             "get", param_key_getter(col), None
                               ),
>>>>>>                         False,
                           )
                       )
>>>>>>                 for col in table.primary_key
                   ],
               )
       
>>>>>>         row_fn = result.result_tuple([col.key for col in table.primary_key])
       
>>>>>>         def get(row, parameters):
>>>>>>             return row_fn(
>>>>>>                 getter(row) if use_row else getter(parameters)
>>>>>>                 for getter, use_row in getters
                   )
       
>>>>>>         return get
       
    1:     def default_from(self):
               """Called when a SELECT statement has no froms, and no FROM clause is
               to be appended.
       
               Gives Oracle a chance to tack on a ``FROM DUAL`` to the string output.
       
               """
    1:         return ""
       
    1:     def visit_grouping(self, grouping, asfrom=False, **kwargs):
    2:         return "(" + grouping.element._compiler_dispatch(self, **kwargs) + ")"
       
    1:     def visit_select_statement_grouping(self, grouping, **kwargs):
>>>>>>         return "(" + grouping.element._compiler_dispatch(self, **kwargs) + ")"
       
>>>>>>     def visit_label_reference(
    1:         self, element, within_columns_clause=False, **kwargs
           ):
>>>>>>         if self.stack and self.dialect.supports_simple_order_by_label:
>>>>>>             try:
>>>>>>                 compile_state = cast(
>>>>>>                     "Union[SelectState, CompoundSelectState]",
>>>>>>                     self.stack[-1]["compile_state"],
                       )
>>>>>>             except KeyError as ke:
>>>>>>                 raise exc.CompileError(
>>>>>>                     "Can't resolve label reference for ORDER BY / "
                           "GROUP BY / DISTINCT etc."
>>>>>>                 ) from ke
       
>>>>>>             (
>>>>>>                 with_cols,
>>>>>>                 only_froms,
>>>>>>                 only_cols,
>>>>>>             ) = compile_state._label_resolve_dict
>>>>>>             if within_columns_clause:
>>>>>>                 resolve_dict = only_froms
                   else:
>>>>>>                 resolve_dict = only_cols
       
                   # this can be None in the case that a _label_reference()
                   # were subject to a replacement operation, in which case
                   # the replacement of the Label element may have changed
                   # to something else like a ColumnClause expression.
>>>>>>             order_by_elem = element.element._order_by_label_element
       
>>>>>>             if (
>>>>>>                 order_by_elem is not None
>>>>>>                 and order_by_elem.name in resolve_dict
>>>>>>                 and order_by_elem.shares_lineage(
>>>>>>                     resolve_dict[order_by_elem.name]
                       )
                   ):
>>>>>>                 kwargs["render_label_as_label"] = (
>>>>>>                     element.element._order_by_label_element
                       )
>>>>>>         return self.process(
>>>>>>             element.element,
>>>>>>             within_columns_clause=within_columns_clause,
>>>>>>             **kwargs,
               )
       
>>>>>>     def visit_textual_label_reference(
    1:         self, element, within_columns_clause=False, **kwargs
           ):
>>>>>>         if not self.stack:
                   # compiling the element outside of the context of a SELECT
>>>>>>             return self.process(element._text_clause)
       
>>>>>>         try:
>>>>>>             compile_state = cast(
>>>>>>                 "Union[SelectState, CompoundSelectState]",
>>>>>>                 self.stack[-1]["compile_state"],
                   )
>>>>>>         except KeyError as ke:
>>>>>>             coercions._no_text_coercion(
>>>>>>                 element.element,
                       extra=(
>>>>>>                     "Can't resolve label reference for ORDER BY / "
                           "GROUP BY / DISTINCT etc."
                       ),
>>>>>>                 exc_cls=exc.CompileError,
>>>>>>                 err=ke,
                   )
       
>>>>>>         with_cols, only_froms, only_cols = compile_state._label_resolve_dict
>>>>>>         try:
>>>>>>             if within_columns_clause:
>>>>>>                 col = only_froms[element.element]
                   else:
>>>>>>                 col = with_cols[element.element]
>>>>>>         except KeyError as err:
>>>>>>             coercions._no_text_coercion(
>>>>>>                 element.element,
                       extra=(
>>>>>>                     "Can't resolve label reference for ORDER BY / "
                           "GROUP BY / DISTINCT etc."
                       ),
>>>>>>                 exc_cls=exc.CompileError,
>>>>>>                 err=err,
                   )
               else:
>>>>>>             kwargs["render_label_as_label"] = col
>>>>>>             return self.process(
>>>>>>                 col, within_columns_clause=within_columns_clause, **kwargs
                   )
       
>>>>>>     def visit_label(
               self,
               label,
               add_to_result_map=None,
               within_label_clause=False,
               within_columns_clause=False,
               render_label_as_label=None,
    1:         result_map_targets=(),
               **kw,
           ):
               # only render labels within the columns clause
               # or ORDER BY clause of a select.  dialect-specific compilers
               # can modify this behavior.
   45:         render_label_with_as = (
   45:             within_columns_clause and not within_label_clause
               )
   45:         render_label_only = render_label_as_label is label
       
   45:         if render_label_only or render_label_with_as:
   45:             if isinstance(label.name, elements._truncated_label):
   45:                 labelname = self._truncated_identifier("colident", label.name)
                   else:
>>>>>>                 labelname = label.name
       
   45:         if render_label_with_as:
   45:             if add_to_result_map is not None:
   90:                 add_to_result_map(
   45:                     labelname,
   45:                     label.name,
   45:                     (label, labelname) + label._alt_names + result_map_targets,
   45:                     label.type,
                       )
   45:             return (
  270:                 label.element._compiler_dispatch(
   45:                     self,
   45:                     within_columns_clause=True,
   45:                     within_label_clause=True,
   45:                     **kw,
                       )
   45:                 + OPERATORS[operators.as_]
   45:                 + self.preparer.format_label(label, labelname)
                   )
>>>>>>         elif render_label_only:
>>>>>>             return self.preparer.format_label(label, labelname)
               else:
>>>>>>             return label.element._compiler_dispatch(
>>>>>>                 self, within_columns_clause=False, **kw
                   )
       
    1:     def _fallback_column_name(self, column):
>>>>>>         raise exc.CompileError(
>>>>>>             "Cannot compile Column object until its 'name' is assigned."
               )
       
    1:     def visit_lambda_element(self, element, **kw):
>>>>>>         sql_element = element._resolved
>>>>>>         return self.process(sql_element, **kw)
       
>>>>>>     def visit_column(
               self,
               column: ColumnClause[Any],
               add_to_result_map: Optional[_ResultMapAppender] = None,
               include_table: bool = True,
               result_map_targets: Tuple[Any, ...] = (),
    1:         ambiguous_table_name_map: Optional[_AmbiguousTableNameMap] = None,
               **kwargs: Any,
           ) -> str:
  139:         name = orig_name = column.name
  139:         if name is None:
>>>>>>             name = self._fallback_column_name(column)
       
  139:         is_literal = column.is_literal
  139:         if not is_literal and isinstance(name, elements._truncated_label):
>>>>>>             name = self._truncated_identifier("colident", name)
       
  139:         if add_to_result_map is not None:
    2:             targets = (column, name, column.key) + result_map_targets
    2:             if column._tq_label:
    1:                 targets += (column._tq_label,)
       
    2:             add_to_result_map(name, orig_name, targets, column.type)
       
  139:         if is_literal:
                   # note we are not currently accommodating for
                   # literal_column(quoted_name('ident', True)) here
    1:             name = self.escape_literal_column(name)
               else:
  138:             name = self.preparer.quote(name)
  139:         table = column.table
  139:         if table is None or not include_table or not table.named_with_column:
   87:             return name
               else:
   52:             effective_schema = self.preparer.schema_for_object(table)
       
   52:             if effective_schema:
    7:                 schema_prefix = (
    7:                     self.preparer.quote_schema(effective_schema) + "."
                       )
                   else:
   45:                 schema_prefix = ""
       
   52:             if TYPE_CHECKING:
>>>>>>                 assert isinstance(table, NamedFromClause)
   52:             tablename = table.name
       
   97:             if (
   52:                 not effective_schema
   45:                 and ambiguous_table_name_map
>>>>>>                 and tablename in ambiguous_table_name_map
                   ):
>>>>>>                 tablename = ambiguous_table_name_map[tablename]
       
   52:             if isinstance(tablename, elements._truncated_label):
>>>>>>                 tablename = self._truncated_identifier("alias", tablename)
       
   52:             return schema_prefix + self.preparer.quote(tablename) + "." + name
       
    1:     def visit_collation(self, element, **kw):
>>>>>>         return self.preparer.format_collation(element.collation)
       
    1:     def visit_fromclause(self, fromclause, **kwargs):
>>>>>>         return fromclause.name
       
    1:     def visit_index(self, index, **kwargs):
>>>>>>         return index.name
       
    1:     def visit_typeclause(self, typeclause, **kw):
>>>>>>         kw["type_expression"] = typeclause
>>>>>>         kw["identifier_preparer"] = self.preparer
>>>>>>         return self.dialect.type_compiler_instance.process(
>>>>>>             typeclause.type, **kw
               )
       
    1:     def post_process_text(self, text):
   47:         if self.preparer._double_percents:
   47:             text = text.replace("%", "%%")
   47:         return text
       
    1:     def escape_literal_column(self, text):
    1:         if self.preparer._double_percents:
    1:             text = text.replace("%", "%%")
    1:         return text
       
    1:     def visit_textclause(self, textclause, add_to_result_map=None, **kw):
   47:         def do_bindparam(m):
>>>>>>             name = m.group(1)
>>>>>>             if name in textclause._bindparams:
>>>>>>                 return self.process(textclause._bindparams[name], **kw)
                   else:
>>>>>>                 return self.bindparam_string(name, **kw)
       
   47:         if not self.stack:
   47:             self.isplaintext = True
       
   47:         if add_to_result_map:
                   # text() object is present in the columns clause of a
                   # select().   Add a no-name entry to the result map so that
                   # row[text()] produces a result
>>>>>>             add_to_result_map(None, None, (textclause,), sqltypes.NULLTYPE)
       
               # un-escape any \:params
   94:         return BIND_PARAMS_ESC.sub(
   47:             lambda m: m.group(1),
   94:             BIND_PARAMS.sub(
   47:                 do_bindparam, self.post_process_text(textclause.text)
                   ),
               )
       
>>>>>>     def visit_textual_select(
    1:         self, taf, compound_index=None, asfrom=False, **kw
           ):
>>>>>>         toplevel = not self.stack
>>>>>>         entry = self._default_stack_entry if toplevel else self.stack[-1]
       
>>>>>>         new_entry: _CompilerStackEntry = {
>>>>>>             "correlate_froms": set(),
>>>>>>             "asfrom_froms": set(),
>>>>>>             "selectable": taf,
               }
>>>>>>         self.stack.append(new_entry)
       
>>>>>>         if taf._independent_ctes:
>>>>>>             self._dispatch_independent_ctes(taf, kw)
       
>>>>>>         populate_result_map = (
>>>>>>             toplevel
                   or (
>>>>>>                 compound_index == 0
>>>>>>                 and entry.get("need_result_map_for_compound", False)
                   )
>>>>>>             or entry.get("need_result_map_for_nested", False)
               )
       
>>>>>>         if populate_result_map:
>>>>>>             self._ordered_columns = self._textual_ordered_columns = (
>>>>>>                 taf.positional
                   )
       
                   # enable looser result column matching when the SQL text links to
                   # Column objects by name only
>>>>>>             self._loose_column_name_matching = not taf.positional and bool(
>>>>>>                 taf.column_args
                   )
       
>>>>>>             for c in taf.column_args:
>>>>>>                 self.process(
>>>>>>                     c,
>>>>>>                     within_columns_clause=True,
>>>>>>                     add_to_result_map=self._add_to_result_map,
                       )
       
>>>>>>         text = self.process(taf.element, **kw)
>>>>>>         if self.ctes:
>>>>>>             nesting_level = len(self.stack) if not toplevel else None
>>>>>>             text = self._render_cte_clause(nesting_level=nesting_level) + text
       
>>>>>>         self.stack.pop(-1)
       
>>>>>>         return text
       
    1:     def visit_null(self, expr, **kw):
>>>>>>         return "NULL"
       
    1:     def visit_true(self, expr, **kw):
>>>>>>         if self.dialect.supports_native_boolean:
>>>>>>             return "true"
               else:
>>>>>>             return "1"
       
    1:     def visit_false(self, expr, **kw):
>>>>>>         if self.dialect.supports_native_boolean:
>>>>>>             return "false"
               else:
>>>>>>             return "0"
       
    1:     def _generate_delimited_list(self, elements, separator, **kw):
   12:         return separator.join(
    6:             s
   16:             for s in (c._compiler_dispatch(self, **kw) for c in elements)
    6:             if s
               )
       
    1:     def _generate_delimited_and_list(self, clauses, **kw):
    2:         lcc, clauses = elements.BooleanClauseList._process_clauses_for_boolean(
    1:             operators.and_,
    1:             elements.True_._singleton,
    1:             elements.False_._singleton,
    1:             clauses,
               )
    1:         if lcc == 1:
>>>>>>             return clauses[0]._compiler_dispatch(self, **kw)
               else:
    1:             separator = OPERATORS[operators.and_]
    7:             return separator.join(
    4:                 s
   10:                 for s in (c._compiler_dispatch(self, **kw) for c in clauses)
    4:                 if s
                   )
       
    1:     def visit_tuple(self, clauselist, **kw):
>>>>>>         return "(%s)" % self.visit_clauselist(clauselist, **kw)
       
    1:     def visit_clauselist(self, clauselist, **kw):
    2:         sep = clauselist.operator
    2:         if sep is None:
>>>>>>             sep = " "
               else:
    2:             sep = OPERATORS[clauselist.operator]
       
    2:         return self._generate_delimited_list(clauselist.clauses, sep, **kw)
       
    1:     def visit_expression_clauselist(self, clauselist, **kw):
>>>>>>         operator_ = clauselist.operator
       
>>>>>>         disp = self._get_operator_dispatch(
>>>>>>             operator_, "expression_clauselist", None
               )
>>>>>>         if disp:
>>>>>>             return disp(clauselist, operator_, **kw)
       
>>>>>>         try:
>>>>>>             opstring = OPERATORS[operator_]
>>>>>>         except KeyError as err:
>>>>>>             raise exc.UnsupportedCompilationError(self, operator_) from err
               else:
>>>>>>             kw["_in_operator_expression"] = True
>>>>>>             return self._generate_delimited_list(
>>>>>>                 clauselist.clauses, opstring, **kw
                   )
       
    1:     def visit_case(self, clause, **kwargs):
>>>>>>         x = "CASE "
>>>>>>         if clause.value is not None:
>>>>>>             x += clause.value._compiler_dispatch(self, **kwargs) + " "
>>>>>>         for cond, result in clause.whens:
>>>>>>             x += (
>>>>>>                 "WHEN "
>>>>>>                 + cond._compiler_dispatch(self, **kwargs)
>>>>>>                 + " THEN "
>>>>>>                 + result._compiler_dispatch(self, **kwargs)
>>>>>>                 + " "
                   )
>>>>>>         if clause.else_ is not None:
>>>>>>             x += (
>>>>>>                 "ELSE " + clause.else_._compiler_dispatch(self, **kwargs) + " "
                   )
>>>>>>         x += "END"
>>>>>>         return x
       
    1:     def visit_type_coerce(self, type_coerce, **kw):
>>>>>>         return type_coerce.typed_expression._compiler_dispatch(self, **kw)
       
    1:     def visit_cast(self, cast, **kwargs):
>>>>>>         type_clause = cast.typeclause._compiler_dispatch(self, **kwargs)
>>>>>>         match = re.match("(.*)( COLLATE .*)", type_clause)
>>>>>>         return "CAST(%s AS %s)%s" % (
>>>>>>             cast.clause._compiler_dispatch(self, **kwargs),
>>>>>>             match.group(1) if match else type_clause,
>>>>>>             match.group(2) if match else "",
               )
       
    1:     def _format_frame_clause(self, range_, **kw):
>>>>>>         return "%s AND %s" % (
                   (
>>>>>>                 "UNBOUNDED PRECEDING"
>>>>>>                 if range_[0] is elements.RANGE_UNBOUNDED
                       else (
>>>>>>                     "CURRENT ROW"
>>>>>>                     if range_[0] is elements.RANGE_CURRENT
                           else (
>>>>>>                         "%s PRECEDING"
>>>>>>                         % (
>>>>>>                             self.process(
>>>>>>                                 elements.literal(abs(range_[0])), **kw
                                   ),
                               )
>>>>>>                         if range_[0] < 0
>>>>>>                         else "%s FOLLOWING"
>>>>>>                         % (self.process(elements.literal(range_[0]), **kw),)
                           )
                       )
                   ),
                   (
>>>>>>                 "UNBOUNDED FOLLOWING"
>>>>>>                 if range_[1] is elements.RANGE_UNBOUNDED
                       else (
>>>>>>                     "CURRENT ROW"
>>>>>>                     if range_[1] is elements.RANGE_CURRENT
                           else (
>>>>>>                         "%s PRECEDING"
>>>>>>                         % (
>>>>>>                             self.process(
>>>>>>                                 elements.literal(abs(range_[1])), **kw
                                   ),
                               )
>>>>>>                         if range_[1] < 0
>>>>>>                         else "%s FOLLOWING"
>>>>>>                         % (self.process(elements.literal(range_[1]), **kw),)
                           )
                       )
                   ),
               )
       
    1:     def visit_over(self, over, **kwargs):
>>>>>>         text = over.element._compiler_dispatch(self, **kwargs)
>>>>>>         if over.range_:
>>>>>>             range_ = "RANGE BETWEEN %s" % self._format_frame_clause(
>>>>>>                 over.range_, **kwargs
                   )
>>>>>>         elif over.rows:
>>>>>>             range_ = "ROWS BETWEEN %s" % self._format_frame_clause(
>>>>>>                 over.rows, **kwargs
                   )
               else:
>>>>>>             range_ = None
       
>>>>>>         return "%s OVER (%s)" % (
>>>>>>             text,
>>>>>>             " ".join(
>>>>>>                 [
>>>>>>                     "%s BY %s"
>>>>>>                     % (word, clause._compiler_dispatch(self, **kwargs))
>>>>>>                     for word, clause in (
>>>>>>                         ("PARTITION", over.partition_by),
>>>>>>                         ("ORDER", over.order_by),
                           )
>>>>>>                     if clause is not None and len(clause)
                       ]
>>>>>>                 + ([range_] if range_ else [])
                   ),
               )
       
    1:     def visit_withingroup(self, withingroup, **kwargs):
>>>>>>         return "%s WITHIN GROUP (ORDER BY %s)" % (
>>>>>>             withingroup.element._compiler_dispatch(self, **kwargs),
>>>>>>             withingroup.order_by._compiler_dispatch(self, **kwargs),
               )
       
    1:     def visit_funcfilter(self, funcfilter, **kwargs):
>>>>>>         return "%s FILTER (WHERE %s)" % (
>>>>>>             funcfilter.func._compiler_dispatch(self, **kwargs),
>>>>>>             funcfilter.criterion._compiler_dispatch(self, **kwargs),
               )
       
    1:     def visit_extract(self, extract, **kwargs):
>>>>>>         field = self.extract_map.get(extract.field, extract.field)
>>>>>>         return "EXTRACT(%s FROM %s)" % (
>>>>>>             field,
>>>>>>             extract.expr._compiler_dispatch(self, **kwargs),
               )
       
    1:     def visit_scalar_function_column(self, element, **kw):
>>>>>>         compiled_fn = self.visit_function(element.fn, **kw)
>>>>>>         compiled_col = self.visit_column(element, **kw)
>>>>>>         return "(%s).%s" % (compiled_fn, compiled_col)
       
>>>>>>     def visit_function(
               self,
               func: Function[Any],
    1:         add_to_result_map: Optional[_ResultMapAppender] = None,
               **kwargs: Any,
           ) -> str:
    1:         if add_to_result_map is not None:
>>>>>>             add_to_result_map(func.name, func.name, (), func.type)
       
    1:         disp = getattr(self, "visit_%s_func" % func.name.lower(), None)
       
               text: str
       
    1:         if disp:
>>>>>>             text = disp(func, **kwargs)
               else:
    1:             name = FUNCTIONS.get(func._deannotate().__class__, None)
    1:             if name:
>>>>>>                 if func._has_args:
>>>>>>                     name += "%(expr)s"
                   else:
    1:                 name = func.name
    1:                 name = (
    2:                     self.preparer.quote(name)
    1:                     if self.preparer._requires_quotes_illegal_chars(name)
    1:                     or isinstance(name, elements.quoted_name)
    1:                     else name
                       )
    1:                 name = name + "%(expr)s"
    3:             text = ".".join(
    5:                 [
                           (
    2:                         self.preparer.quote(tok)
    1:                         if self.preparer._requires_quotes_illegal_chars(tok)
    1:                         or isinstance(name, elements.quoted_name)
    1:                         else tok
                           )
    2:                     for tok in func.packagenames
                       ]
    1:                 + [name]
    1:             ) % {"expr": self.function_argspec(func, **kwargs)}
       
    1:         if func._with_ordinality:
>>>>>>             text += " WITH ORDINALITY"
    1:         return text
       
    1:     def visit_next_value_func(self, next_value, **kw):
>>>>>>         return self.visit_sequence(next_value.sequence)
       
    1:     def visit_sequence(self, sequence, **kw):
>>>>>>         raise NotImplementedError(
>>>>>>             "Dialect '%s' does not support sequence increments."
>>>>>>             % self.dialect.name
               )
       
    1:     def function_argspec(self, func, **kwargs):
    1:         return func.clause_expr._compiler_dispatch(self, **kwargs)
       
>>>>>>     def visit_compound_select(
    1:         self, cs, asfrom=False, compound_index=None, **kwargs
           ):
>>>>>>         toplevel = not self.stack
       
>>>>>>         compile_state = cs._compile_state_factory(cs, self, **kwargs)
       
>>>>>>         if toplevel and not self.compile_state:
>>>>>>             self.compile_state = compile_state
       
>>>>>>         compound_stmt = compile_state.statement
       
>>>>>>         entry = self._default_stack_entry if toplevel else self.stack[-1]
>>>>>>         need_result_map = toplevel or (
>>>>>>             not compound_index
>>>>>>             and entry.get("need_result_map_for_compound", False)
               )
       
               # indicates there is already a CompoundSelect in play
>>>>>>         if compound_index == 0:
>>>>>>             entry["select_0"] = cs
       
>>>>>>         self.stack.append(
>>>>>>             {
>>>>>>                 "correlate_froms": entry["correlate_froms"],
>>>>>>                 "asfrom_froms": entry["asfrom_froms"],
>>>>>>                 "selectable": cs,
>>>>>>                 "compile_state": compile_state,
>>>>>>                 "need_result_map_for_compound": need_result_map,
                   }
               )
       
>>>>>>         if compound_stmt._independent_ctes:
>>>>>>             self._dispatch_independent_ctes(compound_stmt, kwargs)
       
>>>>>>         keyword = self.compound_keywords[cs.keyword]
       
>>>>>>         text = (" " + keyword + " ").join(
>>>>>>             (
>>>>>>                 c._compiler_dispatch(
>>>>>>                     self, asfrom=asfrom, compound_index=i, **kwargs
                       )
>>>>>>                 for i, c in enumerate(cs.selects)
                   )
               )
       
>>>>>>         kwargs["include_table"] = False
>>>>>>         text += self.group_by_clause(cs, **dict(asfrom=asfrom, **kwargs))
>>>>>>         text += self.order_by_clause(cs, **kwargs)
>>>>>>         if cs._has_row_limiting_clause:
>>>>>>             text += self._row_limit_clause(cs, **kwargs)
       
>>>>>>         if self.ctes:
>>>>>>             nesting_level = len(self.stack) if not toplevel else None
>>>>>>             text = (
>>>>>>                 self._render_cte_clause(
>>>>>>                     nesting_level=nesting_level,
>>>>>>                     include_following_stack=True,
                       )
>>>>>>                 + text
                   )
       
>>>>>>         self.stack.pop(-1)
>>>>>>         return text
       
    1:     def _row_limit_clause(self, cs, **kwargs):
    1:         if cs._fetch_clause is not None:
>>>>>>             return self.fetch_clause(cs, **kwargs)
               else:
    1:             return self.limit_clause(cs, **kwargs)
       
    1:     def _get_operator_dispatch(self, operator_, qualifier1, qualifier2):
   10:         attrname = "visit_%s_%s%s" % (
    5:             operator_.__name__,
    5:             qualifier1,
    5:             "_" + qualifier2 if qualifier2 else "",
               )
    5:         return getattr(self, attrname, None)
       
>>>>>>     def visit_unary(
    1:         self, unary, add_to_result_map=None, result_map_targets=(), **kw
           ):
    1:         if add_to_result_map is not None:
>>>>>>             result_map_targets += (unary,)
>>>>>>             kw["add_to_result_map"] = add_to_result_map
>>>>>>             kw["result_map_targets"] = result_map_targets
       
    1:         if unary.operator:
    1:             if unary.modifier:
>>>>>>                 raise exc.CompileError(
>>>>>>                     "Unary expression does not support operator "
                           "and modifier simultaneously"
                       )
    2:             disp = self._get_operator_dispatch(
    1:                 unary.operator, "unary", "operator"
                   )
    1:             if disp:
>>>>>>                 return disp(unary, unary.operator, **kw)
                   else:
    3:                 return self._generate_generic_unary_operator(
    2:                     unary, OPERATORS[unary.operator], **kw
                       )
>>>>>>         elif unary.modifier:
>>>>>>             disp = self._get_operator_dispatch(
>>>>>>                 unary.modifier, "unary", "modifier"
                   )
>>>>>>             if disp:
>>>>>>                 return disp(unary, unary.modifier, **kw)
                   else:
>>>>>>                 return self._generate_generic_unary_modifier(
>>>>>>                     unary, OPERATORS[unary.modifier], **kw
                       )
               else:
>>>>>>             raise exc.CompileError(
>>>>>>                 "Unary expression has no operator or modifier"
                   )
       
    1:     def visit_truediv_binary(self, binary, operator, **kw):
>>>>>>         if self.dialect.div_is_floordiv:
>>>>>>             return (
>>>>>>                 self.process(binary.left, **kw)
>>>>>>                 + " / "
                       # TODO: would need a fast cast again here,
                       # unless we want to use an implicit cast like "+ 0.0"
>>>>>>                 + self.process(
>>>>>>                     elements.Cast(
>>>>>>                         binary.right,
                               (
>>>>>>                             binary.right.type
>>>>>>                             if binary.right.type._type_affinity
>>>>>>                             is sqltypes.Numeric
>>>>>>                             else sqltypes.Numeric()
                               ),
                           ),
>>>>>>                     **kw,
                       )
                   )
               else:
>>>>>>             return (
>>>>>>                 self.process(binary.left, **kw)
>>>>>>                 + " / "
>>>>>>                 + self.process(binary.right, **kw)
                   )
       
    1:     def visit_floordiv_binary(self, binary, operator, **kw):
>>>>>>         if (
>>>>>>             self.dialect.div_is_floordiv
>>>>>>             and binary.right.type._type_affinity is sqltypes.Integer
               ):
>>>>>>             return (
>>>>>>                 self.process(binary.left, **kw)
>>>>>>                 + " / "
>>>>>>                 + self.process(binary.right, **kw)
                   )
               else:
>>>>>>             return "FLOOR(%s)" % (
>>>>>>                 self.process(binary.left, **kw)
>>>>>>                 + " / "
>>>>>>                 + self.process(binary.right, **kw)
                   )
       
    1:     def visit_is_true_unary_operator(self, element, operator, **kw):
>>>>>>         if (
>>>>>>             element._is_implicitly_boolean
>>>>>>             or self.dialect.supports_native_boolean
               ):
>>>>>>             return self.process(element.element, **kw)
               else:
>>>>>>             return "%s = 1" % self.process(element.element, **kw)
       
    1:     def visit_is_false_unary_operator(self, element, operator, **kw):
>>>>>>         if (
>>>>>>             element._is_implicitly_boolean
>>>>>>             or self.dialect.supports_native_boolean
               ):
>>>>>>             return "NOT %s" % self.process(element.element, **kw)
               else:
>>>>>>             return "%s = 0" % self.process(element.element, **kw)
       
    1:     def visit_not_match_op_binary(self, binary, operator, **kw):
>>>>>>         return "NOT %s" % self.visit_binary(
>>>>>>             binary, override_operator=operators.match_op
               )
       
    1:     def visit_not_in_op_binary(self, binary, operator, **kw):
               # The brackets are required in the NOT IN operation because the empty
               # case is handled using the form "(col NOT IN (null) OR 1 = 1)".
               # The presence of the OR makes the brackets required.
>>>>>>         return "(%s)" % self._generate_generic_binary(
>>>>>>             binary, OPERATORS[operator], **kw
               )
       
    1:     def visit_empty_set_op_expr(self, type_, expand_op, **kw):
>>>>>>         if expand_op is operators.not_in_op:
>>>>>>             if len(type_) > 1:
>>>>>>                 return "(%s)) OR (1 = 1" % (
>>>>>>                     ", ".join("NULL" for element in type_)
                       )
                   else:
>>>>>>                 return "NULL) OR (1 = 1"
>>>>>>         elif expand_op is operators.in_op:
>>>>>>             if len(type_) > 1:
>>>>>>                 return "(%s)) AND (1 != 1" % (
>>>>>>                     ", ".join("NULL" for element in type_)
                       )
                   else:
>>>>>>                 return "NULL) AND (1 != 1"
               else:
>>>>>>             return self.visit_empty_set_expr(type_)
       
    1:     def visit_empty_set_expr(self, element_types, **kw):
>>>>>>         raise NotImplementedError(
>>>>>>             "Dialect '%s' does not support empty set expression."
>>>>>>             % self.dialect.name
               )
       
>>>>>>     def _literal_execute_expanding_parameter_literal_binds(
    1:         self, parameter, values, bind_expression_template=None
           ):
>>>>>>         typ_dialect_impl = parameter.type._unwrapped_dialect_impl(self.dialect)
       
>>>>>>         if not values:
                   # empty IN expression.  note we don't need to use
                   # bind_expression_template here because there are no
                   # expressions to render.
       
>>>>>>             if typ_dialect_impl._is_tuple_type:
>>>>>>                 replacement_expression = (
>>>>>>                     "VALUES " if self.dialect.tuple_in_values else ""
>>>>>>                 ) + self.visit_empty_set_op_expr(
>>>>>>                     parameter.type.types, parameter.expand_op
                       )
       
                   else:
>>>>>>                 replacement_expression = self.visit_empty_set_op_expr(
>>>>>>                     [parameter.type], parameter.expand_op
                       )
       
>>>>>>         elif typ_dialect_impl._is_tuple_type or (
>>>>>>             typ_dialect_impl._isnull
>>>>>>             and isinstance(values[0], collections_abc.Sequence)
>>>>>>             and not isinstance(values[0], (str, bytes))
               ):
>>>>>>             if typ_dialect_impl._has_bind_expression:
>>>>>>                 raise NotImplementedError(
>>>>>>                     "bind_expression() on TupleType not supported with "
                           "literal_binds"
                       )
       
>>>>>>             replacement_expression = (
>>>>>>                 "VALUES " if self.dialect.tuple_in_values else ""
>>>>>>             ) + ", ".join(
>>>>>>                 "(%s)"
                       % (
>>>>>>                     ", ".join(
>>>>>>                         self.render_literal_value(value, param_type)
>>>>>>                         for value, param_type in zip(
>>>>>>                             tuple_element, parameter.type.types
                               )
                           )
                       )
>>>>>>                 for i, tuple_element in enumerate(values)
                   )
               else:
>>>>>>             if bind_expression_template:
>>>>>>                 post_compile_pattern = self._post_compile_pattern
>>>>>>                 m = post_compile_pattern.search(bind_expression_template)
>>>>>>                 assert m and m.group(
>>>>>>                     2
>>>>>>                 ), "unexpected format for expanding parameter"
       
>>>>>>                 tok = m.group(2).split("~~")
>>>>>>                 be_left, be_right = tok[1], tok[3]
>>>>>>                 replacement_expression = ", ".join(
>>>>>>                     "%s%s%s"
>>>>>>                     % (
>>>>>>                         be_left,
>>>>>>                         self.render_literal_value(value, parameter.type),
>>>>>>                         be_right,
                           )
>>>>>>                     for value in values
                       )
                   else:
>>>>>>                 replacement_expression = ", ".join(
>>>>>>                     self.render_literal_value(value, parameter.type)
>>>>>>                     for value in values
                       )
       
>>>>>>         return (), replacement_expression
       
    1:     def _literal_execute_expanding_parameter(self, name, parameter, values):
>>>>>>         if parameter.literal_execute:
>>>>>>             return self._literal_execute_expanding_parameter_literal_binds(
>>>>>>                 parameter, values
                   )
       
>>>>>>         dialect = self.dialect
>>>>>>         typ_dialect_impl = parameter.type._unwrapped_dialect_impl(dialect)
       
>>>>>>         if self._numeric_binds:
>>>>>>             bind_template = self.compilation_bindtemplate
               else:
>>>>>>             bind_template = self.bindtemplate
       
>>>>>>         if (
>>>>>>             self.dialect._bind_typing_render_casts
>>>>>>             and typ_dialect_impl.render_bind_cast
               ):
       
>>>>>>             def _render_bindtemplate(name):
>>>>>>                 return self.render_bind_cast(
>>>>>>                     parameter.type,
>>>>>>                     typ_dialect_impl,
>>>>>>                     bind_template % {"name": name},
                       )
       
               else:
       
>>>>>>             def _render_bindtemplate(name):
>>>>>>                 return bind_template % {"name": name}
       
>>>>>>         if not values:
>>>>>>             to_update = []
>>>>>>             if typ_dialect_impl._is_tuple_type:
>>>>>>                 replacement_expression = self.visit_empty_set_op_expr(
>>>>>>                     parameter.type.types, parameter.expand_op
                       )
                   else:
>>>>>>                 replacement_expression = self.visit_empty_set_op_expr(
>>>>>>                     [parameter.type], parameter.expand_op
                       )
       
>>>>>>         elif typ_dialect_impl._is_tuple_type or (
>>>>>>             typ_dialect_impl._isnull
>>>>>>             and isinstance(values[0], collections_abc.Sequence)
>>>>>>             and not isinstance(values[0], (str, bytes))
               ):
>>>>>>             assert not typ_dialect_impl._is_array
>>>>>>             to_update = [
>>>>>>                 ("%s_%s_%s" % (name, i, j), value)
>>>>>>                 for i, tuple_element in enumerate(values, 1)
>>>>>>                 for j, value in enumerate(tuple_element, 1)
                   ]
       
>>>>>>             replacement_expression = (
>>>>>>                 "VALUES " if dialect.tuple_in_values else ""
>>>>>>             ) + ", ".join(
>>>>>>                 "(%s)"
                       % (
>>>>>>                     ", ".join(
>>>>>>                         _render_bindtemplate(
>>>>>>                             to_update[i * len(tuple_element) + j][0]
                               )
>>>>>>                         for j, value in enumerate(tuple_element)
                           )
                       )
>>>>>>                 for i, tuple_element in enumerate(values)
                   )
               else:
>>>>>>             to_update = [
>>>>>>                 ("%s_%s" % (name, i), value)
>>>>>>                 for i, value in enumerate(values, 1)
                   ]
>>>>>>             replacement_expression = ", ".join(
>>>>>>                 _render_bindtemplate(key) for key, value in to_update
                   )
       
>>>>>>         return to_update, replacement_expression
       
>>>>>>     def visit_binary(
               self,
               binary,
               override_operator=None,
               eager_grouping=False,
               from_linter=None,
    1:         lateral_from_linter=None,
               **kw,
           ):
    4:         if from_linter and operators.is_comparison(binary.operator):
    4:             if lateral_from_linter is not None:
>>>>>>                 enclosing_lateral = kw["enclosing_lateral"]
>>>>>>                 lateral_from_linter.edges.update(
>>>>>>                     itertools.product(
>>>>>>                         _de_clone(
>>>>>>                             binary.left._from_objects + [enclosing_lateral]
                               ),
>>>>>>                         _de_clone(
>>>>>>                             binary.right._from_objects + [enclosing_lateral]
                               ),
                           )
                       )
                   else:
    8:                 from_linter.edges.update(
    8:                     itertools.product(
    4:                         _de_clone(binary.left._from_objects),
    4:                         _de_clone(binary.right._from_objects),
                           )
                       )
       
               # don't allow "? = ?" to render
    4:         if (
    4:             self.ansi_bind_rules
>>>>>>             and isinstance(binary.left, elements.BindParameter)
>>>>>>             and isinstance(binary.right, elements.BindParameter)
               ):
>>>>>>             kw["literal_execute"] = True
       
    4:         operator_ = override_operator or binary.operator
    4:         disp = self._get_operator_dispatch(operator_, "binary", None)
    4:         if disp:
>>>>>>             return disp(binary, operator_, **kw)
               else:
    4:             try:
    4:                 opstring = OPERATORS[operator_]
>>>>>>             except KeyError as err:
>>>>>>                 raise exc.UnsupportedCompilationError(self, operator_) from err
                   else:
   16:                 return self._generate_generic_binary(
    4:                     binary,
    4:                     opstring,
    4:                     from_linter=from_linter,
    4:                     lateral_from_linter=lateral_from_linter,
    4:                     **kw,
                       )
       
    1:     def visit_function_as_comparison_op_binary(self, element, operator, **kw):
>>>>>>         return self.process(element.sql_function, **kw)
       
    1:     def visit_mod_binary(self, binary, operator, **kw):
>>>>>>         if self.preparer._double_percents:
>>>>>>             return (
>>>>>>                 self.process(binary.left, **kw)
>>>>>>                 + " %% "
>>>>>>                 + self.process(binary.right, **kw)
                   )
               else:
>>>>>>             return (
>>>>>>                 self.process(binary.left, **kw)
>>>>>>                 + " % "
>>>>>>                 + self.process(binary.right, **kw)
                   )
       
    1:     def visit_custom_op_binary(self, element, operator, **kw):
>>>>>>         kw["eager_grouping"] = operator.eager_grouping
>>>>>>         return self._generate_generic_binary(
>>>>>>             element,
>>>>>>             " " + self.escape_literal_column(operator.opstring) + " ",
>>>>>>             **kw,
               )
       
    1:     def visit_custom_op_unary_operator(self, element, operator, **kw):
>>>>>>         return self._generate_generic_unary_operator(
>>>>>>             element, self.escape_literal_column(operator.opstring) + " ", **kw
               )
       
    1:     def visit_custom_op_unary_modifier(self, element, operator, **kw):
>>>>>>         return self._generate_generic_unary_modifier(
>>>>>>             element, " " + self.escape_literal_column(operator.opstring), **kw
               )
       
>>>>>>     def _generate_generic_binary(
    1:         self, binary, opstring, eager_grouping=False, **kw
           ):
    4:         _in_operator_expression = kw.get("_in_operator_expression", False)
       
    4:         kw["_in_operator_expression"] = True
    4:         kw["_binary_op"] = binary.operator
    4:         text = (
   24:             binary.left._compiler_dispatch(
   12:                 self, eager_grouping=eager_grouping, **kw
                   )
    4:             + opstring
   16:             + binary.right._compiler_dispatch(
   12:                 self, eager_grouping=eager_grouping, **kw
                   )
               )
       
    4:         if _in_operator_expression and eager_grouping:
>>>>>>             text = "(%s)" % text
    4:         return text
       
    1:     def _generate_generic_unary_operator(self, unary, opstring, **kw):
    1:         return opstring + unary.element._compiler_dispatch(self, **kw)
       
    1:     def _generate_generic_unary_modifier(self, unary, opstring, **kw):
>>>>>>         return unary.element._compiler_dispatch(self, **kw) + opstring
       
    1:     @util.memoized_property
    1:     def _like_percent_literal(self):
>>>>>>         return elements.literal_column("'%'", type_=sqltypes.STRINGTYPE)
       
    1:     def visit_ilike_case_insensitive_operand(self, element, **kw):
>>>>>>         return f"lower({element.element._compiler_dispatch(self, **kw)})"
       
    1:     def visit_contains_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.right = percent.concat(binary.right).concat(percent)
>>>>>>         return self.visit_like_op_binary(binary, operator, **kw)
       
    1:     def visit_not_contains_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.right = percent.concat(binary.right).concat(percent)
>>>>>>         return self.visit_not_like_op_binary(binary, operator, **kw)
       
    1:     def visit_icontains_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.left = ilike_case_insensitive(binary.left)
>>>>>>         binary.right = percent.concat(
>>>>>>             ilike_case_insensitive(binary.right)
>>>>>>         ).concat(percent)
>>>>>>         return self.visit_ilike_op_binary(binary, operator, **kw)
       
    1:     def visit_not_icontains_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.left = ilike_case_insensitive(binary.left)
>>>>>>         binary.right = percent.concat(
>>>>>>             ilike_case_insensitive(binary.right)
>>>>>>         ).concat(percent)
>>>>>>         return self.visit_not_ilike_op_binary(binary, operator, **kw)
       
    1:     def visit_startswith_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.right = percent._rconcat(binary.right)
>>>>>>         return self.visit_like_op_binary(binary, operator, **kw)
       
    1:     def visit_not_startswith_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.right = percent._rconcat(binary.right)
>>>>>>         return self.visit_not_like_op_binary(binary, operator, **kw)
       
    1:     def visit_istartswith_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.left = ilike_case_insensitive(binary.left)
>>>>>>         binary.right = percent._rconcat(ilike_case_insensitive(binary.right))
>>>>>>         return self.visit_ilike_op_binary(binary, operator, **kw)
       
    1:     def visit_not_istartswith_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.left = ilike_case_insensitive(binary.left)
>>>>>>         binary.right = percent._rconcat(ilike_case_insensitive(binary.right))
>>>>>>         return self.visit_not_ilike_op_binary(binary, operator, **kw)
       
    1:     def visit_endswith_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.right = percent.concat(binary.right)
>>>>>>         return self.visit_like_op_binary(binary, operator, **kw)
       
    1:     def visit_not_endswith_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.right = percent.concat(binary.right)
>>>>>>         return self.visit_not_like_op_binary(binary, operator, **kw)
       
    1:     def visit_iendswith_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.left = ilike_case_insensitive(binary.left)
>>>>>>         binary.right = percent.concat(ilike_case_insensitive(binary.right))
>>>>>>         return self.visit_ilike_op_binary(binary, operator, **kw)
       
    1:     def visit_not_iendswith_op_binary(self, binary, operator, **kw):
>>>>>>         binary = binary._clone()
>>>>>>         percent = self._like_percent_literal
>>>>>>         binary.left = ilike_case_insensitive(binary.left)
>>>>>>         binary.right = percent.concat(ilike_case_insensitive(binary.right))
>>>>>>         return self.visit_not_ilike_op_binary(binary, operator, **kw)
       
    1:     def visit_like_op_binary(self, binary, operator, **kw):
>>>>>>         escape = binary.modifiers.get("escape", None)
       
>>>>>>         return "%s LIKE %s" % (
>>>>>>             binary.left._compiler_dispatch(self, **kw),
>>>>>>             binary.right._compiler_dispatch(self, **kw),
               ) + (
>>>>>>             " ESCAPE " + self.render_literal_value(escape, sqltypes.STRINGTYPE)
>>>>>>             if escape is not None
>>>>>>             else ""
               )
       
    1:     def visit_not_like_op_binary(self, binary, operator, **kw):
>>>>>>         escape = binary.modifiers.get("escape", None)
>>>>>>         return "%s NOT LIKE %s" % (
>>>>>>             binary.left._compiler_dispatch(self, **kw),
>>>>>>             binary.right._compiler_dispatch(self, **kw),
               ) + (
>>>>>>             " ESCAPE " + self.render_literal_value(escape, sqltypes.STRINGTYPE)
>>>>>>             if escape is not None
>>>>>>             else ""
               )
       
    1:     def visit_ilike_op_binary(self, binary, operator, **kw):
>>>>>>         if operator is operators.ilike_op:
>>>>>>             binary = binary._clone()
>>>>>>             binary.left = ilike_case_insensitive(binary.left)
>>>>>>             binary.right = ilike_case_insensitive(binary.right)
               # else we assume ilower() has been applied
       
>>>>>>         return self.visit_like_op_binary(binary, operator, **kw)
       
    1:     def visit_not_ilike_op_binary(self, binary, operator, **kw):
>>>>>>         if operator is operators.not_ilike_op:
>>>>>>             binary = binary._clone()
>>>>>>             binary.left = ilike_case_insensitive(binary.left)
>>>>>>             binary.right = ilike_case_insensitive(binary.right)
               # else we assume ilower() has been applied
       
>>>>>>         return self.visit_not_like_op_binary(binary, operator, **kw)
       
    1:     def visit_between_op_binary(self, binary, operator, **kw):
>>>>>>         symmetric = binary.modifiers.get("symmetric", False)
>>>>>>         return self._generate_generic_binary(
>>>>>>             binary, " BETWEEN SYMMETRIC " if symmetric else " BETWEEN ", **kw
               )
       
    1:     def visit_not_between_op_binary(self, binary, operator, **kw):
>>>>>>         symmetric = binary.modifiers.get("symmetric", False)
>>>>>>         return self._generate_generic_binary(
>>>>>>             binary,
>>>>>>             " NOT BETWEEN SYMMETRIC " if symmetric else " NOT BETWEEN ",
>>>>>>             **kw,
               )
       
    1:     def visit_regexp_match_op_binary(self, binary, operator, **kw):
>>>>>>         raise exc.CompileError(
>>>>>>             "%s dialect does not support regular expressions"
>>>>>>             % self.dialect.name
               )
       
    1:     def visit_not_regexp_match_op_binary(self, binary, operator, **kw):
>>>>>>         raise exc.CompileError(
>>>>>>             "%s dialect does not support regular expressions"
>>>>>>             % self.dialect.name
               )
       
    1:     def visit_regexp_replace_op_binary(self, binary, operator, **kw):
>>>>>>         raise exc.CompileError(
>>>>>>             "%s dialect does not support regular expression replacements"
>>>>>>             % self.dialect.name
               )
       
>>>>>>     def visit_bindparam(
               self,
               bindparam,
               within_columns_clause=False,
               literal_binds=False,
               skip_bind_expression=False,
               literal_execute=False,
    1:         render_postcompile=False,
               **kwargs,
           ):
   53:         if not skip_bind_expression:
   53:             impl = bindparam.type.dialect_impl(self.dialect)
   53:             if impl._has_bind_expression:
>>>>>>                 bind_expression = impl.bind_expression(bindparam)
>>>>>>                 wrapped = self.process(
>>>>>>                     bind_expression,
>>>>>>                     skip_bind_expression=True,
>>>>>>                     within_columns_clause=within_columns_clause,
>>>>>>                     literal_binds=literal_binds and not bindparam.expanding,
>>>>>>                     literal_execute=literal_execute,
>>>>>>                     render_postcompile=render_postcompile,
>>>>>>                     **kwargs,
                       )
>>>>>>                 if bindparam.expanding:
                           # for postcompile w/ expanding, move the "wrapped" part
                           # of this into the inside
       
>>>>>>                     m = re.match(
>>>>>>                         r"^(.*)\(__\[POSTCOMPILE_(\S+?)\]\)(.*)$", wrapped
                           )
>>>>>>                     assert m, "unexpected format for expanding parameter"
>>>>>>                     wrapped = "(__[POSTCOMPILE_%s~~%s~~REPL~~%s~~])" % (
>>>>>>                         m.group(2),
>>>>>>                         m.group(1),
>>>>>>                         m.group(3),
                           )
       
>>>>>>                     if literal_binds:
>>>>>>                         ret = self.render_literal_bindparam(
>>>>>>                             bindparam,
>>>>>>                             within_columns_clause=True,
>>>>>>                             bind_expression_template=wrapped,
>>>>>>                             **kwargs,
                               )
>>>>>>                         return "(%s)" % ret
       
>>>>>>                 return wrapped
       
   53:         if not literal_binds:
   53:             literal_execute = (
  106:                 literal_execute
   53:                 or bindparam.literal_execute
   53:                 or (within_columns_clause and self.ansi_bind_rules)
                   )
   53:             post_compile = literal_execute or bindparam.expanding
               else:
>>>>>>             post_compile = False
       
   53:         if literal_binds:
>>>>>>             ret = self.render_literal_bindparam(
>>>>>>                 bindparam, within_columns_clause=True, **kwargs
                   )
>>>>>>             if bindparam.expanding:
>>>>>>                 ret = "(%s)" % ret
>>>>>>             return ret
       
   53:         name = self._truncate_bindparam(bindparam)
       
   53:         if name in self.binds:
>>>>>>             existing = self.binds[name]
>>>>>>             if existing is not bindparam:
>>>>>>                 if (
>>>>>>                     (existing.unique or bindparam.unique)
>>>>>>                     and not existing.proxy_set.intersection(
>>>>>>                         bindparam.proxy_set
                           )
>>>>>>                     and not existing._cloned_set.intersection(
>>>>>>                         bindparam._cloned_set
                           )
                       ):
>>>>>>                     raise exc.CompileError(
>>>>>>                         "Bind parameter '%s' conflicts with "
>>>>>>                         "unique bind parameter of the same name" % name
                           )
>>>>>>                 elif existing.expanding != bindparam.expanding:
>>>>>>                     raise exc.CompileError(
>>>>>>                         "Can't reuse bound parameter name '%s' in both "
                               "'expanding' (e.g. within an IN expression) and "
                               "non-expanding contexts.  If this parameter is to "
                               "receive a list/array value, set 'expanding=True' on "
                               "it for expressions that aren't IN, otherwise use "
>>>>>>                         "a different parameter name." % (name,)
                           )
>>>>>>                 elif existing._is_crud or bindparam._is_crud:
>>>>>>                     if existing._is_crud and bindparam._is_crud:
                               # TODO: this condition is not well understood.
                               # see tests in test/sql/test_update.py
>>>>>>                         raise exc.CompileError(
>>>>>>                             "Encountered unsupported case when compiling an "
                                   "INSERT or UPDATE statement.  If this is a "
                                   "multi-table "
                                   "UPDATE statement, please provide string-named "
                                   "arguments to the "
                                   "values() method with distinct names; support for "
                                   "multi-table UPDATE statements that "
                                   "target multiple tables for UPDATE is very "
                                   "limited",
                               )
                           else:
>>>>>>                         raise exc.CompileError(
>>>>>>                             f"bindparam() name '{bindparam.key}' is reserved "
                                   "for automatic usage in the VALUES or SET "
                                   "clause of this "
                                   "insert/update statement.   Please use a "
                                   "name other than column name when using "
                                   "bindparam() "
                                   "with insert() or update() (for example, "
>>>>>>                             f"'b_{bindparam.key}')."
                               )
       
   53:         self.binds[bindparam.key] = self.binds[name] = bindparam
       
               # if we are given a cache key that we're going to match against,
               # relate the bindparam here to one that is most likely present
               # in the "extracted params" portion of the cache key.  this is used
               # to set up a positional mapping that is used to determine the
               # correct parameters for a subsequent use of this compiled with
               # a different set of parameter values.   here, we accommodate for
               # parameters that may have been cloned both before and after the cache
               # key was been generated.
   53:         ckbm_tuple = self._cache_key_bind_match
       
   53:         if ckbm_tuple:
   53:             ckbm, cksm = ckbm_tuple
  107:             for bp in bindparam._cloned_set:
   54:                 if bp.key in cksm:
    9:                     cb = cksm[bp.key]
    9:                     ckbm[cb].append(bindparam)
       
   53:         if bindparam.isoutparam:
>>>>>>             self.has_out_parameters = True
       
   53:         if post_compile:
>>>>>>             if render_postcompile:
>>>>>>                 self._render_postcompile = True
       
>>>>>>             if literal_execute:
>>>>>>                 self.literal_execute_params |= {bindparam}
                   else:
>>>>>>                 self.post_compile_params |= {bindparam}
       
  212:         ret = self.bindparam_string(
   53:             name,
   53:             post_compile=post_compile,
   53:             expanding=bindparam.expanding,
   53:             bindparam_type=bindparam.type,
   53:             **kwargs,
               )
       
   53:         if bindparam.expanding:
>>>>>>             ret = "(%s)" % ret
       
   53:         return ret
       
    1:     def render_bind_cast(self, type_, dbapi_type, sqltext):
>>>>>>         raise NotImplementedError()
       
    1:     def render_literal_bindparam(
               self,
               bindparam,
    1:         render_literal_value=NO_ARG,
    1:         bind_expression_template=None,
               **kw,
           ):
>>>>>>         if render_literal_value is not NO_ARG:
>>>>>>             value = render_literal_value
               else:
>>>>>>             if bindparam.value is None and bindparam.callable is None:
>>>>>>                 op = kw.get("_binary_op", None)
>>>>>>                 if op and op not in (operators.is_, operators.is_not):
>>>>>>                     util.warn_limited(
>>>>>>                         "Bound parameter '%s' rendering literal NULL in a SQL "
                               "expression; comparisons to NULL should not use "
                               "operators outside of 'is' or 'is not'",
>>>>>>                         (bindparam.key,),
                           )
>>>>>>                 return self.process(sqltypes.NULLTYPE, **kw)
>>>>>>             value = bindparam.effective_value
       
>>>>>>         if bindparam.expanding:
>>>>>>             leep = self._literal_execute_expanding_parameter_literal_binds
>>>>>>             to_update, replacement_expr = leep(
>>>>>>                 bindparam,
>>>>>>                 value,
>>>>>>                 bind_expression_template=bind_expression_template,
                   )
>>>>>>             return replacement_expr
               else:
>>>>>>             return self.render_literal_value(value, bindparam.type)
       
    1:     def render_literal_value(self, value, type_):
               """Render the value of a bind parameter as a quoted literal.
       
               This is used for statement sections that do not accept bind parameters
               on the target driver/database.
       
               This should be implemented by subclasses using the quoting services
               of the DBAPI.
       
               """
       
>>>>>>         if value is None and not type_.should_evaluate_none:
                   # issue #10535 - handle NULL in the compiler without placing
                   # this onto each type, except for "evaluate None" types
                   # (e.g. JSON)
>>>>>>             return self.process(elements.Null._instance())
       
>>>>>>         processor = type_._cached_literal_processor(self.dialect)
>>>>>>         if processor:
>>>>>>             try:
>>>>>>                 return processor(value)
>>>>>>             except Exception as e:
>>>>>>                 raise exc.CompileError(
>>>>>>                     f"Could not render literal value "
>>>>>>                     f'"{sql_util._repr_single_value(value)}" '
                           f"with datatype "
>>>>>>                     f"{type_}; see parent stack trace for "
                           "more detail."
>>>>>>                 ) from e
       
               else:
>>>>>>             raise exc.CompileError(
>>>>>>                 f"No literal value renderer is available for literal value "
>>>>>>                 f'"{sql_util._repr_single_value(value)}" '
>>>>>>                 f"with datatype {type_}"
                   )
       
    1:     def _truncate_bindparam(self, bindparam):
   53:         if bindparam in self.bind_names:
>>>>>>             return self.bind_names[bindparam]
       
   53:         bind_name = bindparam.key
   53:         if isinstance(bind_name, elements._truncated_label):
    7:             bind_name = self._truncated_identifier("bindparam", bind_name)
       
               # add to bind_names for translation
   53:         self.bind_names[bindparam] = bind_name
       
   53:         return bind_name
       
    1:     def _truncated_identifier(
               self, ident_class: str, name: _truncated_label
           ) -> str:
   52:         if (ident_class, name) in self.truncated_names:
>>>>>>             return self.truncated_names[(ident_class, name)]
       
   52:         anonname = name.apply_map(self.anon_map)
       
   52:         if len(anonname) > self.label_length - 6:
>>>>>>             counter = self._truncated_counters.get(ident_class, 1)
>>>>>>             truncname = (
>>>>>>                 anonname[0 : max(self.label_length - 6, 0)]
>>>>>>                 + "_"
>>>>>>                 + hex(counter)[2:]
                   )
>>>>>>             self._truncated_counters[ident_class] = counter + 1
               else:
   52:             truncname = anonname
   52:         self.truncated_names[(ident_class, name)] = truncname
   52:         return truncname
       
    1:     def _anonymize(self, name: str) -> str:
>>>>>>         return name % self.anon_map
       
>>>>>>     def bindparam_string(
               self,
               name: str,
               post_compile: bool = False,
               expanding: bool = False,
               escaped_from: Optional[str] = None,
               bindparam_type: Optional[TypeEngine[Any]] = None,
               accumulate_bind_names: Optional[Set[str]] = None,
    1:         visited_bindparam: Optional[List[str]] = None,
               **kw: Any,
           ) -> str:
               # TODO: accumulate_bind_names is passed by crud.py to gather
               # names on a per-value basis, visited_bindparam is passed by
               # visit_insert() to collect all parameters in the statement.
               # see if this gathering can be simplified somehow
   53:         if accumulate_bind_names is not None:
   30:             accumulate_bind_names.add(name)
   53:         if visited_bindparam is not None:
>>>>>>             visited_bindparam.append(name)
       
   53:         if not escaped_from:
   53:             if self._bind_translate_re.search(name):
                       # not quite the translate use case as we want to
                       # also get a quick boolean if we even found
                       # unusual characters in the name
>>>>>>                 new_name = self._bind_translate_re.sub(
>>>>>>                     lambda m: self._bind_translate_chars[m.group(0)],
>>>>>>                     name,
                       )
>>>>>>                 escaped_from = name
>>>>>>                 name = new_name
       
   53:         if escaped_from:
>>>>>>             self.escaped_bind_names = self.escaped_bind_names.union(
>>>>>>                 {escaped_from: name}
                   )
   53:         if post_compile:
>>>>>>             ret = "__[POSTCOMPILE_%s]" % name
>>>>>>             if expanding:
                       # for expanding, bound parameters or literal values will be
                       # rendered per item
>>>>>>                 return ret
       
                   # otherwise, for non-expanding "literal execute", apply
                   # bind casts as determined by the datatype
>>>>>>             if bindparam_type is not None:
>>>>>>                 type_impl = bindparam_type._unwrapped_dialect_impl(
>>>>>>                     self.dialect
                       )
>>>>>>                 if type_impl.render_literal_cast:
>>>>>>                     ret = self.render_bind_cast(bindparam_type, type_impl, ret)
>>>>>>             return ret
   53:         elif self.state is CompilerState.COMPILING:
   53:             ret = self.compilation_bindtemplate % {"name": name}
               else:
>>>>>>             ret = self.bindtemplate % {"name": name}
       
  106:         if (
   53:             bindparam_type is not None
   53:             and self.dialect._bind_typing_render_casts
               ):
   53:             type_impl = bindparam_type._unwrapped_dialect_impl(self.dialect)
   53:             if type_impl.render_bind_cast:
>>>>>>                 ret = self.render_bind_cast(bindparam_type, type_impl, ret)
       
   53:         return ret
       
    1:     def _dispatch_independent_ctes(self, stmt, kw):
>>>>>>         local_kw = kw.copy()
>>>>>>         local_kw.pop("cte_opts", None)
>>>>>>         for cte, opt in zip(
>>>>>>             stmt._independent_ctes, stmt._independent_ctes_opts
               ):
>>>>>>             cte._compiler_dispatch(self, cte_opts=opt, **local_kw)
       
    1:     def visit_cte(
               self,
               cte: CTE,
    1:         asfrom: bool = False,
    1:         ashint: bool = False,
    1:         fromhints: Optional[_FromHintsType] = None,
    1:         visiting_cte: Optional[CTE] = None,
    1:         from_linter: Optional[FromLinter] = None,
    1:         cte_opts: selectable._CTEOpts = selectable._CTEOpts(False),
               **kwargs: Any,
           ) -> Optional[str]:
>>>>>>         self_ctes = self._init_cte_state()
>>>>>>         assert self_ctes is self.ctes
       
>>>>>>         kwargs["visiting_cte"] = cte
       
>>>>>>         cte_name = cte.name
       
>>>>>>         if isinstance(cte_name, elements._truncated_label):
>>>>>>             cte_name = self._truncated_identifier("alias", cte_name)
       
>>>>>>         is_new_cte = True
>>>>>>         embedded_in_current_named_cte = False
       
>>>>>>         _reference_cte = cte._get_reference_cte()
       
>>>>>>         nesting = cte.nesting or cte_opts.nesting
       
               # check for CTE already encountered
>>>>>>         if _reference_cte in self.level_name_by_cte:
>>>>>>             cte_level, _, existing_cte_opts = self.level_name_by_cte[
>>>>>>                 _reference_cte
                   ]
>>>>>>             assert _ == cte_name
       
>>>>>>             cte_level_name = (cte_level, cte_name)
>>>>>>             existing_cte = self.ctes_by_level_name[cte_level_name]
       
                   # check if we are receiving it here with a specific
                   # "nest_here" location; if so, move it to this location
       
>>>>>>             if cte_opts.nesting:
>>>>>>                 if existing_cte_opts.nesting:
>>>>>>                     raise exc.CompileError(
>>>>>>                         "CTE is stated as 'nest_here' in "
                               "more than one location"
                           )
       
>>>>>>                 old_level_name = (cte_level, cte_name)
>>>>>>                 cte_level = len(self.stack) if nesting else 1
>>>>>>                 cte_level_name = new_level_name = (cte_level, cte_name)
       
>>>>>>                 del self.ctes_by_level_name[old_level_name]
>>>>>>                 self.ctes_by_level_name[new_level_name] = existing_cte
>>>>>>                 self.level_name_by_cte[_reference_cte] = new_level_name + (
>>>>>>                     cte_opts,
                       )
       
               else:
>>>>>>             cte_level = len(self.stack) if nesting else 1
>>>>>>             cte_level_name = (cte_level, cte_name)
       
>>>>>>             if cte_level_name in self.ctes_by_level_name:
>>>>>>                 existing_cte = self.ctes_by_level_name[cte_level_name]
                   else:
>>>>>>                 existing_cte = None
       
>>>>>>         if existing_cte is not None:
>>>>>>             embedded_in_current_named_cte = visiting_cte is existing_cte
       
                   # we've generated a same-named CTE that we are enclosed in,
                   # or this is the same CTE.  just return the name.
>>>>>>             if cte is existing_cte._restates or cte is existing_cte:
>>>>>>                 is_new_cte = False
>>>>>>             elif existing_cte is cte._restates:
                       # we've generated a same-named CTE that is
                       # enclosed in us - we take precedence, so
                       # discard the text for the "inner".
>>>>>>                 del self_ctes[existing_cte]
       
>>>>>>                 existing_cte_reference_cte = existing_cte._get_reference_cte()
       
>>>>>>                 assert existing_cte_reference_cte is _reference_cte
>>>>>>                 assert existing_cte_reference_cte is existing_cte
       
>>>>>>                 del self.level_name_by_cte[existing_cte_reference_cte]
                   else:
                       # if the two CTEs are deep-copy identical, consider them
                       # the same, **if** they are clones, that is, they came from
                       # the ORM or other visit method
>>>>>>                 if (
>>>>>>                     cte._is_clone_of is not None
>>>>>>                     or existing_cte._is_clone_of is not None
>>>>>>                 ) and cte.compare(existing_cte):
>>>>>>                     is_new_cte = False
                       else:
>>>>>>                     raise exc.CompileError(
>>>>>>                         "Multiple, unrelated CTEs found with "
>>>>>>                         "the same name: %r" % cte_name
                           )
       
>>>>>>         if not asfrom and not is_new_cte:
>>>>>>             return None
       
>>>>>>         if cte._cte_alias is not None:
>>>>>>             pre_alias_cte = cte._cte_alias
>>>>>>             cte_pre_alias_name = cte._cte_alias.name
>>>>>>             if isinstance(cte_pre_alias_name, elements._truncated_label):
>>>>>>                 cte_pre_alias_name = self._truncated_identifier(
>>>>>>                     "alias", cte_pre_alias_name
                       )
               else:
>>>>>>             pre_alias_cte = cte
>>>>>>             cte_pre_alias_name = None
       
>>>>>>         if is_new_cte:
>>>>>>             self.ctes_by_level_name[cte_level_name] = cte
>>>>>>             self.level_name_by_cte[_reference_cte] = cte_level_name + (
>>>>>>                 cte_opts,
                   )
       
>>>>>>             if pre_alias_cte not in self.ctes:
>>>>>>                 self.visit_cte(pre_alias_cte, **kwargs)
       
>>>>>>             if not cte_pre_alias_name and cte not in self_ctes:
>>>>>>                 if cte.recursive:
>>>>>>                     self.ctes_recursive = True
>>>>>>                 text = self.preparer.format_alias(cte, cte_name)
>>>>>>                 if cte.recursive:
>>>>>>                     col_source = cte.element
       
                           # TODO: can we get at the .columns_plus_names collection
                           # that is already (or will be?) generated for the SELECT
                           # rather than calling twice?
>>>>>>                     recur_cols = [
                               # TODO: proxy_name is not technically safe,
                               # see test_cte->
                               # test_with_recursive_no_name_currently_buggy.  not
                               # clear what should be done with such a case
>>>>>>                         fallback_label_name or proxy_name
>>>>>>                         for (
>>>>>>                             _,
>>>>>>                             proxy_name,
>>>>>>                             fallback_label_name,
>>>>>>                             c,
>>>>>>                             repeated,
>>>>>>                         ) in (col_source._generate_columns_plus_names(True))
>>>>>>                         if not repeated
                           ]
       
>>>>>>                     text += "(%s)" % (
>>>>>>                         ", ".join(
>>>>>>                             self.preparer.format_label_name(
>>>>>>                                 ident, anon_map=self.anon_map
                                   )
>>>>>>                             for ident in recur_cols
                               )
                           )
       
>>>>>>                 assert kwargs.get("subquery", False) is False
       
>>>>>>                 if not self.stack:
                           # toplevel, this is a stringify of the
                           # cte directly.  just compile the inner
                           # the way alias() does.
>>>>>>                     return cte.element._compiler_dispatch(
>>>>>>                         self, asfrom=asfrom, **kwargs
                           )
                       else:
>>>>>>                     prefixes = self._generate_prefixes(
>>>>>>                         cte, cte._prefixes, **kwargs
                           )
>>>>>>                     inner = cte.element._compiler_dispatch(
>>>>>>                         self, asfrom=True, **kwargs
                           )
       
>>>>>>                     text += " AS %s\n(%s)" % (prefixes, inner)
       
>>>>>>                 if cte._suffixes:
>>>>>>                     text += " " + self._generate_prefixes(
>>>>>>                         cte, cte._suffixes, **kwargs
                           )
       
>>>>>>                 self_ctes[cte] = text
       
>>>>>>         if asfrom:
>>>>>>             if from_linter:
>>>>>>                 from_linter.froms[cte._de_clone()] = cte_name
       
>>>>>>             if not is_new_cte and embedded_in_current_named_cte:
>>>>>>                 return self.preparer.format_alias(cte, cte_name)
       
>>>>>>             if cte_pre_alias_name:
>>>>>>                 text = self.preparer.format_alias(cte, cte_pre_alias_name)
>>>>>>                 if self.preparer._requires_quotes(cte_name):
>>>>>>                     cte_name = self.preparer.quote(cte_name)
>>>>>>                 text += self.get_render_as_alias_suffix(cte_name)
>>>>>>                 return text
                   else:
>>>>>>                 return self.preparer.format_alias(cte, cte_name)
       
>>>>>>         return None
       
    1:     def visit_table_valued_alias(self, element, **kw):
>>>>>>         if element.joins_implicitly:
>>>>>>             kw["from_linter"] = None
>>>>>>         if element._is_lateral:
>>>>>>             return self.visit_lateral(element, **kw)
               else:
>>>>>>             return self.visit_alias(element, **kw)
       
    1:     def visit_table_valued_column(self, element, **kw):
>>>>>>         return self.visit_column(element, **kw)
       
>>>>>>     def visit_alias(
               self,
               alias,
               asfrom=False,
               ashint=False,
               iscrud=False,
               fromhints=None,
               subquery=False,
               lateral=False,
               enclosing_alias=None,
    1:         from_linter=None,
               **kwargs,
           ):
>>>>>>         if lateral:
>>>>>>             if "enclosing_lateral" not in kwargs:
                       # if lateral is set and enclosing_lateral is not
                       # present, we assume we are being called directly
                       # from visit_lateral() and we need to set enclosing_lateral.
>>>>>>                 assert alias._is_lateral
>>>>>>                 kwargs["enclosing_lateral"] = alias
       
                   # for lateral objects, we track a second from_linter that is...
                   # lateral!  to the level above us.
>>>>>>             if (
>>>>>>                 from_linter
>>>>>>                 and "lateral_from_linter" not in kwargs
>>>>>>                 and "enclosing_lateral" in kwargs
                   ):
>>>>>>                 kwargs["lateral_from_linter"] = from_linter
       
>>>>>>         if enclosing_alias is not None and enclosing_alias.element is alias:
>>>>>>             inner = alias.element._compiler_dispatch(
>>>>>>                 self,
>>>>>>                 asfrom=asfrom,
>>>>>>                 ashint=ashint,
>>>>>>                 iscrud=iscrud,
>>>>>>                 fromhints=fromhints,
>>>>>>                 lateral=lateral,
>>>>>>                 enclosing_alias=alias,
>>>>>>                 **kwargs,
                   )
>>>>>>             if subquery and (asfrom or lateral):
>>>>>>                 inner = "(%s)" % (inner,)
>>>>>>             return inner
               else:
>>>>>>             enclosing_alias = kwargs["enclosing_alias"] = alias
       
>>>>>>         if asfrom or ashint:
>>>>>>             if isinstance(alias.name, elements._truncated_label):
>>>>>>                 alias_name = self._truncated_identifier("alias", alias.name)
                   else:
>>>>>>                 alias_name = alias.name
       
>>>>>>         if ashint:
>>>>>>             return self.preparer.format_alias(alias, alias_name)
>>>>>>         elif asfrom:
>>>>>>             if from_linter:
>>>>>>                 from_linter.froms[alias._de_clone()] = alias_name
       
>>>>>>             inner = alias.element._compiler_dispatch(
>>>>>>                 self, asfrom=True, lateral=lateral, **kwargs
                   )
>>>>>>             if subquery:
>>>>>>                 inner = "(%s)" % (inner,)
       
>>>>>>             ret = inner + self.get_render_as_alias_suffix(
>>>>>>                 self.preparer.format_alias(alias, alias_name)
                   )
       
>>>>>>             if alias._supports_derived_columns and alias._render_derived:
>>>>>>                 ret += "(%s)" % (
>>>>>>                     ", ".join(
>>>>>>                         "%s%s"
>>>>>>                         % (
>>>>>>                             self.preparer.quote(col.name),
                                   (
>>>>>>                                 " %s"
>>>>>>                                 % self.dialect.type_compiler_instance.process(
>>>>>>                                     col.type, **kwargs
                                       )
>>>>>>                                 if alias._render_derived_w_types
>>>>>>                                 else ""
                                   ),
                               )
>>>>>>                         for col in alias.c
                           )
                       )
       
>>>>>>             if fromhints and alias in fromhints:
>>>>>>                 ret = self.format_from_hint_text(
>>>>>>                     ret, alias, fromhints[alias], iscrud
                       )
       
>>>>>>             return ret
               else:
                   # note we cancel the "subquery" flag here as well
>>>>>>             return alias.element._compiler_dispatch(
>>>>>>                 self, lateral=lateral, **kwargs
                   )
       
    1:     def visit_subquery(self, subquery, **kw):
>>>>>>         kw["subquery"] = True
>>>>>>         return self.visit_alias(subquery, **kw)
       
    1:     def visit_lateral(self, lateral_, **kw):
>>>>>>         kw["lateral"] = True
>>>>>>         return "LATERAL %s" % self.visit_alias(lateral_, **kw)
       
    1:     def visit_tablesample(self, tablesample, asfrom=False, **kw):
>>>>>>         text = "%s TABLESAMPLE %s" % (
>>>>>>             self.visit_alias(tablesample, asfrom=True, **kw),
>>>>>>             tablesample._get_method()._compiler_dispatch(self, **kw),
               )
       
>>>>>>         if tablesample.seed is not None:
>>>>>>             text += " REPEATABLE (%s)" % (
>>>>>>                 tablesample.seed._compiler_dispatch(self, **kw)
                   )
       
>>>>>>         return text
       
    1:     def _render_values(self, element, **kw):
>>>>>>         kw.setdefault("literal_binds", element.literal_binds)
>>>>>>         tuples = ", ".join(
>>>>>>             self.process(
>>>>>>                 elements.Tuple(
>>>>>>                     types=element._column_types, *elem
                       ).self_group(),
>>>>>>                 **kw,
                   )
>>>>>>             for chunk in element._data
>>>>>>             for elem in chunk
               )
>>>>>>         return f"VALUES {tuples}"
       
    1:     def visit_values(self, element, asfrom=False, from_linter=None, **kw):
>>>>>>         v = self._render_values(element, **kw)
       
>>>>>>         if element._unnamed:
>>>>>>             name = None
>>>>>>         elif isinstance(element.name, elements._truncated_label):
>>>>>>             name = self._truncated_identifier("values", element.name)
               else:
>>>>>>             name = element.name
       
>>>>>>         if element._is_lateral:
>>>>>>             lateral = "LATERAL "
               else:
>>>>>>             lateral = ""
       
>>>>>>         if asfrom:
>>>>>>             if from_linter:
>>>>>>                 from_linter.froms[element._de_clone()] = (
>>>>>>                     name if name is not None else "(unnamed VALUES element)"
                       )
       
>>>>>>             if name:
>>>>>>                 kw["include_table"] = False
>>>>>>                 v = "%s(%s)%s (%s)" % (
>>>>>>                     lateral,
>>>>>>                     v,
>>>>>>                     self.get_render_as_alias_suffix(self.preparer.quote(name)),
                           (
>>>>>>                         ", ".join(
>>>>>>                             c._compiler_dispatch(self, **kw)
>>>>>>                             for c in element.columns
                               )
                           ),
                       )
                   else:
>>>>>>                 v = "%s(%s)" % (lateral, v)
>>>>>>         return v
       
    1:     def visit_scalar_values(self, element, **kw):
>>>>>>         return f"({self._render_values(element, **kw)})"
       
    1:     def get_render_as_alias_suffix(self, alias_name_text):
>>>>>>         return " AS " + alias_name_text
       
    1:     def _add_to_result_map(
               self,
               keyname: str,
               name: str,
               objects: Tuple[Any, ...],
               type_: TypeEngine[Any],
           ) -> None:
   47:         if keyname is None or keyname == "*":
>>>>>>             self._ordered_columns = False
>>>>>>             self._ad_hoc_textual = True
   47:         if type_._is_tuple_type:
>>>>>>             raise exc.CompileError(
>>>>>>                 "Most backends don't support SELECTing "
                       "from a tuple() object.  If this is an ORM query, "
                       "consider using the Bundle object."
                   )
   94:         self._result_columns.append(
   47:             ResultColumnsEntry(keyname, name, objects, type_)
               )
       
>>>>>>     def _label_returning_column(
    1:         self, stmt, column, populate_result_map, column_clause_args=None, **kw
           ):
               """Render a column with necessary labels inside of a RETURNING clause.
       
               This method is provided for individual dialects in place of calling
               the _label_select_column method directly, so that the two use cases
               of RETURNING vs. SELECT can be disambiguated going forward.
       
               .. versionadded:: 1.4.21
       
               """
>>>>>>         return self._label_select_column(
>>>>>>             None,
>>>>>>             column,
>>>>>>             populate_result_map,
>>>>>>             False,
>>>>>>             {} if column_clause_args is None else column_clause_args,
>>>>>>             **kw,
               )
       
>>>>>>     def _label_select_column(
               self,
               select,
               column,
               populate_result_map,
               asfrom,
               column_clause_args,
               name=None,
               proxy_name=None,
               fallback_label_name=None,
               within_columns_clause=True,
               column_is_repeated=False,
               need_column_expressions=False,
    1:         include_table=True,
           ):
               """produce labeled columns present in a select()."""
   47:         impl = column.type.dialect_impl(self.dialect)
       
   47:         if impl._has_column_expression and (
>>>>>>             need_column_expressions or populate_result_map
               ):
>>>>>>             col_expr = impl.column_expression(column)
               else:
   47:             col_expr = column
       
   47:         if populate_result_map:
                   # pass an "add_to_result_map" callable into the compilation
                   # of embedded columns.  this collects information about the
                   # column as it will be fetched in the result and is coordinated
                   # with cursor.description when the query is executed.
   47:             add_to_result_map = self._add_to_result_map
       
                   # if the SELECT statement told us this column is a repeat,
                   # wrap the callable with one that prevents the addition of the
                   # targets
   47:             if column_is_repeated:
>>>>>>                 _add_to_result_map = add_to_result_map
       
>>>>>>                 def add_to_result_map(keyname, name, objects, type_):
>>>>>>                     _add_to_result_map(keyname, name, (), type_)
       
                   # if we redefined col_expr for type expressions, wrap the
                   # callable with one that adds the original column to the targets
   47:             elif col_expr is not column:
>>>>>>                 _add_to_result_map = add_to_result_map
       
>>>>>>                 def add_to_result_map(keyname, name, objects, type_):
>>>>>>                     _add_to_result_map(
>>>>>>                         keyname, name, (column,) + objects, type_
                           )
       
               else:
>>>>>>             add_to_result_map = None
       
               # this method is used by some of the dialects for RETURNING,
               # which has different inputs.  _label_returning_column was added
               # as the better target for this now however for 1.4 we will keep
               # _label_select_column directly compatible with this use case.
               # these assertions right now set up the current expected inputs
   47:         assert within_columns_clause, (
>>>>>>             "_label_select_column is only relevant within "
                   "the columns clause of a SELECT or RETURNING"
               )
   47:         if isinstance(column, elements.Label):
>>>>>>             if col_expr is not column:
>>>>>>                 result_expr = _CompileLabel(
>>>>>>                     col_expr, column.name, alt_names=(column.element,)
                       )
                   else:
>>>>>>                 result_expr = col_expr
       
   47:         elif name:
                   # here, _columns_plus_names has determined there's an explicit
                   # label name we need to use.  this is the default for
                   # tablenames_plus_columnnames as well as when columns are being
                   # deduplicated on name
       
   45:             assert (
   45:                 proxy_name is not None
>>>>>>             ), "proxy_name is required if 'name' is passed"
       
   90:             result_expr = _CompileLabel(
   45:                 col_expr,
   45:                 name,
   45:                 alt_names=(
   45:                     proxy_name,
                           # this is a hack to allow legacy result column lookups
                           # to work as they did before; this goes away in 2.0.
                           # TODO: this only seems to be tested indirectly
                           # via test/orm/test_deprecations.py.   should be a
                           # resultset test for this
   45:                     column._tq_label,
                       ),
                   )
               else:
                   # determine here whether this column should be rendered in
                   # a labelled context or not, as we were given no required label
                   # name from the caller. Here we apply heuristics based on the kind
                   # of SQL expression involved.
       
    2:             if col_expr is not column:
                       # type-specific expression wrapping the given column,
                       # so we render a label
>>>>>>                 render_with_label = True
    2:             elif isinstance(column, elements.ColumnClause):
                       # table-bound column, we render its name as a label if we are
                       # inside of a subquery only
    2:                 render_with_label = (
    2:                     asfrom
>>>>>>                     and not column.is_literal
>>>>>>                     and column.table is not None
                       )
>>>>>>             elif isinstance(column, elements.TextClause):
>>>>>>                 render_with_label = False
>>>>>>             elif isinstance(column, elements.UnaryExpression):
>>>>>>                 render_with_label = column.wraps_column_expression or asfrom
>>>>>>             elif (
                       # general class of expressions that don't have a SQL-column
                       # addressible name.  includes scalar selects, bind parameters,
                       # SQL functions, others
>>>>>>                 not isinstance(column, elements.NamedColumn)
                       # deeper check that indicates there's no natural "name" to
                       # this element, which accommodates for custom SQL constructs
                       # that might have a ".name" attribute (but aren't SQL
                       # functions) but are not implementing this more recently added
                       # base class.  in theory the "NamedColumn" check should be
                       # enough, however here we seek to maintain legacy behaviors
                       # as well.
>>>>>>                 and column._non_anon_label is None
                   ):
>>>>>>                 render_with_label = True
                   else:
>>>>>>                 render_with_label = False
       
    2:             if render_with_label:
>>>>>>                 if not fallback_label_name:
                           # used by the RETURNING case right now.  we generate it
                           # here as 3rd party dialects may be referring to
                           # _label_select_column method directly instead of the
                           # just-added _label_returning_column method
>>>>>>                     assert not column_is_repeated
>>>>>>                     fallback_label_name = column._anon_name_label
       
>>>>>>                 fallback_label_name = (
>>>>>>                     elements._truncated_label(fallback_label_name)
>>>>>>                     if not isinstance(
>>>>>>                         fallback_label_name, elements._truncated_label
                           )
>>>>>>                     else fallback_label_name
                       )
       
>>>>>>                 result_expr = _CompileLabel(
>>>>>>                     col_expr, fallback_label_name, alt_names=(proxy_name,)
                       )
                   else:
    2:                 result_expr = col_expr
       
   94:         column_clause_args.update(
   47:             within_columns_clause=within_columns_clause,
   47:             add_to_result_map=add_to_result_map,
   47:             include_table=include_table,
               )
   47:         return result_expr._compiler_dispatch(self, **column_clause_args)
       
    1:     def format_from_hint_text(self, sqltext, table, hint, iscrud):
>>>>>>         hinttext = self.get_from_hint_text(table, hint)
>>>>>>         if hinttext:
>>>>>>             sqltext += " " + hinttext
>>>>>>         return sqltext
       
    1:     def get_select_hint_text(self, byfroms):
>>>>>>         return None
       
    1:     def get_from_hint_text(self, table, text):
>>>>>>         return None
       
    1:     def get_crud_hint_text(self, table, text):
>>>>>>         return None
       
    1:     def get_statement_hint_text(self, hint_texts):
>>>>>>         return " ".join(hint_texts)
       
    1:     _default_stack_entry: _CompilerStackEntry
       
    1:     if not typing.TYPE_CHECKING:
    2:         _default_stack_entry = util.immutabledict(
    1:             [("correlate_froms", frozenset()), ("asfrom_froms", frozenset())]
               )
       
>>>>>>     def _display_froms_for_select(
    1:         self, select_stmt, asfrom, lateral=False, **kw
           ):
               # utility method to help external dialects
               # get the correct from list for a select.
               # specifically the oracle dialect needs this feature
               # right now.
>>>>>>         toplevel = not self.stack
>>>>>>         entry = self._default_stack_entry if toplevel else self.stack[-1]
       
>>>>>>         compile_state = select_stmt._compile_state_factory(select_stmt, self)
       
>>>>>>         correlate_froms = entry["correlate_froms"]
>>>>>>         asfrom_froms = entry["asfrom_froms"]
       
>>>>>>         if asfrom and not lateral:
>>>>>>             froms = compile_state._get_display_froms(
>>>>>>                 explicit_correlate_froms=correlate_froms.difference(
>>>>>>                     asfrom_froms
                       ),
>>>>>>                 implicit_correlate_froms=(),
                   )
               else:
>>>>>>             froms = compile_state._get_display_froms(
>>>>>>                 explicit_correlate_froms=correlate_froms,
>>>>>>                 implicit_correlate_froms=asfrom_froms,
                   )
>>>>>>         return froms
       
    1:     translate_select_structure: Any = None
           """if not ``None``, should be a callable which accepts ``(select_stmt,
           **kw)`` and returns a select object.   this is used for structural changes
           mostly to accommodate for LIMIT/OFFSET schemes
       
           """
       
>>>>>>     def visit_select(
               self,
               select_stmt,
               asfrom=False,
               insert_into=False,
               fromhints=None,
               compound_index=None,
               select_wraps_for=None,
               lateral=False,
    1:         from_linter=None,
               **kwargs,
           ):
    3:         assert select_wraps_for is None, (
>>>>>>             "SQLAlchemy 1.4 requires use of "
                   "the translate_select_structure hook for structural "
                   "translations of SELECT objects"
               )
       
               # initial setup of SELECT.  the compile_state_factory may now
               # be creating a totally different SELECT from the one that was
               # passed in.  for ORM use this will convert from an ORM-state
               # SELECT to a regular "Core" SELECT.  other composed operations
               # such as computation of joins will be performed.
       
    3:         kwargs["within_columns_clause"] = False
       
    9:         compile_state = select_stmt._compile_state_factory(
    6:             select_stmt, self, **kwargs
               )
    3:         kwargs["ambiguous_table_name_map"] = (
    3:             compile_state._ambiguous_table_name_map
               )
       
    3:         select_stmt = compile_state.statement
       
    3:         toplevel = not self.stack
       
    3:         if toplevel and not self.compile_state:
    3:             self.compile_state = compile_state
       
    3:         is_embedded_select = compound_index is not None or insert_into
       
               # translate step for Oracle, SQL Server which often need to
               # restructure the SELECT to allow for LIMIT/OFFSET and possibly
               # other conditions
    3:         if self.translate_select_structure:
>>>>>>             new_select_stmt = self.translate_select_structure(
>>>>>>                 select_stmt, asfrom=asfrom, **kwargs
                   )
       
                   # if SELECT was restructured, maintain a link to the originals
                   # and assemble a new compile state
>>>>>>             if new_select_stmt is not select_stmt:
>>>>>>                 compile_state_wraps_for = compile_state
>>>>>>                 select_wraps_for = select_stmt
>>>>>>                 select_stmt = new_select_stmt
       
>>>>>>                 compile_state = select_stmt._compile_state_factory(
>>>>>>                     select_stmt, self, **kwargs
                       )
>>>>>>                 select_stmt = compile_state.statement
       
    3:         entry = self._default_stack_entry if toplevel else self.stack[-1]
       
    3:         populate_result_map = need_column_expressions = (
    3:             toplevel
>>>>>>             or entry.get("need_result_map_for_compound", False)
>>>>>>             or entry.get("need_result_map_for_nested", False)
               )
       
               # indicates there is a CompoundSelect in play and we are not the
               # first select
    3:         if compound_index:
>>>>>>             populate_result_map = False
       
               # this was first proposed as part of #3372; however, it is not
               # reached in current tests and could possibly be an assertion
               # instead.
    3:         if not populate_result_map and "add_to_result_map" in kwargs:
>>>>>>             del kwargs["add_to_result_map"]
       
    6:         froms = self._setup_select_stack(
    3:             select_stmt, compile_state, entry, asfrom, lateral, compound_index
               )
       
    3:         column_clause_args = kwargs.copy()
    6:         column_clause_args.update(
    3:             {"within_label_clause": False, "within_columns_clause": False}
               )
       
    3:         text = "SELECT "  # we're off to a good start !
       
    3:         if select_stmt._hints:
>>>>>>             hint_text, byfrom = self._setup_select_hints(select_stmt)
>>>>>>             if hint_text:
>>>>>>                 text += hint_text + " "
               else:
    3:             byfrom = None
       
    3:         if select_stmt._independent_ctes:
>>>>>>             self._dispatch_independent_ctes(select_stmt, kwargs)
       
    3:         if select_stmt._prefixes:
>>>>>>             text += self._generate_prefixes(
>>>>>>                 select_stmt, select_stmt._prefixes, **kwargs
                   )
       
    3:         text += self.get_select_precolumns(select_stmt, **kwargs)
               # the actual list of columns to print in the SELECT column list.
   56:         inner_columns = [
   47:             c
  103:             for c in [
   94:                 self._label_select_column(
   47:                     select_stmt,
   47:                     column,
   47:                     populate_result_map,
   47:                     asfrom,
   47:                     column_clause_args,
   47:                     name=name,
   47:                     proxy_name=proxy_name,
   47:                     fallback_label_name=fallback_label_name,
   47:                     column_is_repeated=repeated,
   47:                     need_column_expressions=need_column_expressions,
                       )
   47:                 for (
   47:                     name,
   47:                     proxy_name,
   47:                     fallback_label_name,
   47:                     column,
   47:                     repeated,
    3:                 ) in compile_state.columns_plus_names
                   ]
   47:             if c is not None
               ]
       
    3:         if populate_result_map and select_wraps_for is not None:
                   # if this select was generated from translate_select,
                   # rewrite the targeted columns in the result map
       
>>>>>>             translate = dict(
>>>>>>                 zip(
>>>>>>                     [
>>>>>>                         name
>>>>>>                         for (
>>>>>>                             key,
>>>>>>                             proxy_name,
>>>>>>                             fallback_label_name,
>>>>>>                             name,
>>>>>>                             repeated,
>>>>>>                         ) in compile_state.columns_plus_names
                           ],
>>>>>>                     [
>>>>>>                         name
>>>>>>                         for (
>>>>>>                             key,
>>>>>>                             proxy_name,
>>>>>>                             fallback_label_name,
>>>>>>                             name,
>>>>>>                             repeated,
>>>>>>                         ) in compile_state_wraps_for.columns_plus_names
                           ],
                       )
                   )
       
>>>>>>             self._result_columns = [
>>>>>>                 ResultColumnsEntry(
>>>>>>                     key, name, tuple(translate.get(o, o) for o in obj), type_
                       )
>>>>>>                 for key, name, obj, type_ in self._result_columns
                   ]
       
    6:         text = self._compose_select_body(
    3:             text,
    3:             select_stmt,
    3:             compile_state,
    3:             inner_columns,
    3:             froms,
    3:             byfrom,
    3:             toplevel,
    3:             kwargs,
               )
       
    3:         if select_stmt._statement_hints:
>>>>>>             per_dialect = [
>>>>>>                 ht
>>>>>>                 for (dialect_name, ht) in select_stmt._statement_hints
>>>>>>                 if dialect_name in ("*", self.dialect.name)
                   ]
>>>>>>             if per_dialect:
>>>>>>                 text += " " + self.get_statement_hint_text(per_dialect)
       
               # In compound query, CTEs are shared at the compound level
    3:         if self.ctes and (not is_embedded_select or toplevel):
>>>>>>             nesting_level = len(self.stack) if not toplevel else None
>>>>>>             text = self._render_cte_clause(nesting_level=nesting_level) + text
       
    3:         if select_stmt._suffixes:
>>>>>>             text += " " + self._generate_prefixes(
>>>>>>                 select_stmt, select_stmt._suffixes, **kwargs
                   )
       
    3:         self.stack.pop(-1)
       
    3:         return text
       
    1:     def _setup_select_hints(
               self, select: Select[Any]
           ) -> Tuple[str, _FromHintsType]:
>>>>>>         byfrom = {
>>>>>>             from_: hinttext
>>>>>>             % {"name": from_._compiler_dispatch(self, ashint=True)}
>>>>>>             for (from_, dialect), hinttext in select._hints.items()
>>>>>>             if dialect in ("*", self.dialect.name)
               }
>>>>>>         hint_text = self.get_select_hint_text(byfrom)
>>>>>>         return hint_text, byfrom
       
    1:     def _setup_select_stack(
               self, select, compile_state, entry, asfrom, lateral, compound_index
           ):
    3:         correlate_froms = entry["correlate_froms"]
    3:         asfrom_froms = entry["asfrom_froms"]
       
    3:         if compound_index == 0:
>>>>>>             entry["select_0"] = select
    3:         elif compound_index:
>>>>>>             select_0 = entry["select_0"]
>>>>>>             numcols = len(select_0._all_selected_columns)
       
>>>>>>             if len(compile_state.columns_plus_names) != numcols:
>>>>>>                 raise exc.CompileError(
>>>>>>                     "All selectables passed to "
                           "CompoundSelect must have identical numbers of "
                           "columns; select #%d has %d columns, select "
                           "#%d has %d"
>>>>>>                     % (
>>>>>>                         1,
>>>>>>                         numcols,
>>>>>>                         compound_index + 1,
>>>>>>                         len(select._all_selected_columns),
                           )
                       )
       
    3:         if asfrom and not lateral:
>>>>>>             froms = compile_state._get_display_froms(
>>>>>>                 explicit_correlate_froms=correlate_froms.difference(
>>>>>>                     asfrom_froms
                       ),
>>>>>>                 implicit_correlate_froms=(),
                   )
               else:
    6:             froms = compile_state._get_display_froms(
    3:                 explicit_correlate_froms=correlate_froms,
    3:                 implicit_correlate_froms=asfrom_froms,
                   )
       
    3:         new_correlate_froms = set(_from_objects(*froms))
    3:         all_correlate_froms = new_correlate_froms.union(correlate_froms)
       
    3:         new_entry: _CompilerStackEntry = {
    3:             "asfrom_froms": new_correlate_froms,
    3:             "correlate_froms": all_correlate_froms,
    3:             "selectable": select,
    3:             "compile_state": compile_state,
               }
    3:         self.stack.append(new_entry)
       
    3:         return froms
       
    1:     def _compose_select_body(
               self,
               text,
               select,
               compile_state,
               inner_columns,
               froms,
               byfrom,
               toplevel,
               kwargs,
           ):
    3:         text += ", ".join(inner_columns)
       
    3:         if self.linting & COLLECT_CARTESIAN_PRODUCTS:
    2:             from_linter = FromLinter({}, set())
    2:             warn_linting = self.linting & WARN_LINTING
    2:             if toplevel:
    2:                 self.from_linter = from_linter
               else:
    1:             from_linter = None
    1:             warn_linting = False
       
               # adjust the whitespace for no inner columns, part of #9440,
               # so that a no-col SELECT comes out as "SELECT WHERE..." or
               # "SELECT FROM ...".
               # while it would be better to have built the SELECT starting string
               # without trailing whitespace first, then add whitespace only if inner
               # cols were present, this breaks compatibility with various custom
               # compilation schemes that are currently being tested.
    3:         if not inner_columns:
>>>>>>             text = text.rstrip()
       
    3:         if froms:
    2:             text += " \nFROM "
       
    2:             if select._hints:
>>>>>>                 text += ", ".join(
>>>>>>                     [
>>>>>>                         f._compiler_dispatch(
>>>>>>                             self,
>>>>>>                             asfrom=True,
>>>>>>                             fromhints=byfrom,
>>>>>>                             from_linter=from_linter,
>>>>>>                             **kwargs,
                               )
>>>>>>                         for f in froms
                           ]
                       )
                   else:
    4:                 text += ", ".join(
    8:                     [
    8:                         f._compiler_dispatch(
    2:                             self,
    2:                             asfrom=True,
    2:                             from_linter=from_linter,
    2:                             **kwargs,
                               )
    4:                         for f in froms
                           ]
                       )
               else:
    1:             text += self.default_from()
       
    3:         if select._where_criteria:
    4:             t = self._generate_delimited_and_list(
    3:                 select._where_criteria, from_linter=from_linter, **kwargs
                   )
    1:             if t:
    1:                 text += " \nWHERE " + t
       
    3:         if warn_linting:
    2:             assert from_linter is not None
    2:             from_linter.warn()
       
    3:         if select._group_by_clauses:
>>>>>>             text += self.group_by_clause(select, **kwargs)
       
    3:         if select._having_criteria:
>>>>>>             t = self._generate_delimited_and_list(
>>>>>>                 select._having_criteria, **kwargs
                   )
>>>>>>             if t:
>>>>>>                 text += " \nHAVING " + t
       
    3:         if select._order_by_clauses:
>>>>>>             text += self.order_by_clause(select, **kwargs)
       
    3:         if select._has_row_limiting_clause:
    1:             text += self._row_limit_clause(select, **kwargs)
       
    3:         if select._for_update_arg is not None:
>>>>>>             text += self.for_update_clause(select, **kwargs)
       
    3:         return text
       
    1:     def _generate_prefixes(self, stmt, prefixes, **kw):
>>>>>>         clause = " ".join(
>>>>>>             prefix._compiler_dispatch(self, **kw)
>>>>>>             for prefix, dialect_name in prefixes
>>>>>>             if dialect_name in (None, "*") or dialect_name == self.dialect.name
               )
>>>>>>         if clause:
>>>>>>             clause += " "
>>>>>>         return clause
       
>>>>>>     def _render_cte_clause(
               self,
               nesting_level=None,
    1:         include_following_stack=False,
           ):
               """
               include_following_stack
                   Also render the nesting CTEs on the next stack. Useful for
                   SQL structures like UNION or INSERT that can wrap SELECT
                   statements containing nesting CTEs.
               """
>>>>>>         if not self.ctes:
>>>>>>             return ""
       
               ctes: MutableMapping[CTE, str]
       
>>>>>>         if nesting_level and nesting_level > 1:
>>>>>>             ctes = util.OrderedDict()
>>>>>>             for cte in list(self.ctes.keys()):
>>>>>>                 cte_level, cte_name, cte_opts = self.level_name_by_cte[
>>>>>>                     cte._get_reference_cte()
                       ]
>>>>>>                 nesting = cte.nesting or cte_opts.nesting
>>>>>>                 is_rendered_level = cte_level == nesting_level or (
>>>>>>                     include_following_stack and cte_level == nesting_level + 1
                       )
>>>>>>                 if not (nesting and is_rendered_level):
>>>>>>                     continue
       
>>>>>>                 ctes[cte] = self.ctes[cte]
       
               else:
>>>>>>             ctes = self.ctes
       
>>>>>>         if not ctes:
>>>>>>             return ""
>>>>>>         ctes_recursive = any([cte.recursive for cte in ctes])
       
>>>>>>         cte_text = self.get_cte_preamble(ctes_recursive) + " "
>>>>>>         cte_text += ", \n".join([txt for txt in ctes.values()])
>>>>>>         cte_text += "\n "
       
>>>>>>         if nesting_level and nesting_level > 1:
>>>>>>             for cte in list(ctes.keys()):
>>>>>>                 cte_level, cte_name, cte_opts = self.level_name_by_cte[
>>>>>>                     cte._get_reference_cte()
                       ]
>>>>>>                 del self.ctes[cte]
>>>>>>                 del self.ctes_by_level_name[(cte_level, cte_name)]
>>>>>>                 del self.level_name_by_cte[cte._get_reference_cte()]
       
>>>>>>         return cte_text
       
    1:     def get_cte_preamble(self, recursive):
>>>>>>         if recursive:
>>>>>>             return "WITH RECURSIVE"
               else:
>>>>>>             return "WITH"
       
    1:     def get_select_precolumns(self, select, **kw):
               """Called when building a ``SELECT`` statement, position is just
               before column list.
       
               """
>>>>>>         if select._distinct_on:
>>>>>>             util.warn_deprecated(
>>>>>>                 "DISTINCT ON is currently supported only by the PostgreSQL "
                       "dialect.  Use of DISTINCT ON for other backends is currently "
                       "silently ignored, however this usage is deprecated, and will "
                       "raise CompileError in a future release for all backends "
                       "that do not support this syntax.",
>>>>>>                 version="1.4",
                   )
>>>>>>         return "DISTINCT " if select._distinct else ""
       
    1:     def group_by_clause(self, select, **kw):
               """allow dialects to customize how GROUP BY is rendered."""
       
>>>>>>         group_by = self._generate_delimited_list(
>>>>>>             select._group_by_clauses, OPERATORS[operators.comma_op], **kw
               )
>>>>>>         if group_by:
>>>>>>             return " GROUP BY " + group_by
               else:
>>>>>>             return ""
       
    1:     def order_by_clause(self, select, **kw):
               """allow dialects to customize how ORDER BY is rendered."""
       
>>>>>>         order_by = self._generate_delimited_list(
>>>>>>             select._order_by_clauses, OPERATORS[operators.comma_op], **kw
               )
       
>>>>>>         if order_by:
>>>>>>             return " ORDER BY " + order_by
               else:
>>>>>>             return ""
       
    1:     def for_update_clause(self, select, **kw):
>>>>>>         return " FOR UPDATE"
       
    1:     def returning_clause(
               self,
               stmt: UpdateBase,
               returning_cols: Sequence[ColumnElement[Any]],
               *,
               populate_result_map: bool,
               **kw: Any,
           ) -> str:
>>>>>>         columns = [
>>>>>>             self._label_returning_column(
>>>>>>                 stmt,
>>>>>>                 column,
>>>>>>                 populate_result_map,
>>>>>>                 fallback_label_name=fallback_label_name,
>>>>>>                 column_is_repeated=repeated,
>>>>>>                 name=name,
>>>>>>                 proxy_name=proxy_name,
>>>>>>                 **kw,
                   )
>>>>>>             for (
>>>>>>                 name,
>>>>>>                 proxy_name,
>>>>>>                 fallback_label_name,
>>>>>>                 column,
>>>>>>                 repeated,
>>>>>>             ) in stmt._generate_columns_plus_names(
>>>>>>                 True, cols=base._select_iterables(returning_cols)
                   )
               ]
       
>>>>>>         return "RETURNING " + ", ".join(columns)
       
    1:     def limit_clause(self, select, **kw):
>>>>>>         text = ""
>>>>>>         if select._limit_clause is not None:
>>>>>>             text += "\n LIMIT " + self.process(select._limit_clause, **kw)
>>>>>>         if select._offset_clause is not None:
>>>>>>             if select._limit_clause is None:
>>>>>>                 text += "\n LIMIT -1"
>>>>>>             text += " OFFSET " + self.process(select._offset_clause, **kw)
>>>>>>         return text
       
>>>>>>     def fetch_clause(
               self,
               select,
               fetch_clause=None,
               require_offset=False,
    1:         use_literal_execute_for_simple_int=False,
               **kw,
           ):
>>>>>>         if fetch_clause is None:
>>>>>>             fetch_clause = select._fetch_clause
>>>>>>             fetch_clause_options = select._fetch_clause_options
               else:
>>>>>>             fetch_clause_options = {"percent": False, "with_ties": False}
       
>>>>>>         text = ""
       
>>>>>>         if select._offset_clause is not None:
>>>>>>             offset_clause = select._offset_clause
>>>>>>             if (
>>>>>>                 use_literal_execute_for_simple_int
>>>>>>                 and select._simple_int_clause(offset_clause)
                   ):
>>>>>>                 offset_clause = offset_clause.render_literal_execute()
>>>>>>             offset_str = self.process(offset_clause, **kw)
>>>>>>             text += "\n OFFSET %s ROWS" % offset_str
>>>>>>         elif require_offset:
>>>>>>             text += "\n OFFSET 0 ROWS"
       
>>>>>>         if fetch_clause is not None:
>>>>>>             if (
>>>>>>                 use_literal_execute_for_simple_int
>>>>>>                 and select._simple_int_clause(fetch_clause)
                   ):
>>>>>>                 fetch_clause = fetch_clause.render_literal_execute()
>>>>>>             text += "\n FETCH FIRST %s%s ROWS %s" % (
>>>>>>                 self.process(fetch_clause, **kw),
>>>>>>                 " PERCENT" if fetch_clause_options["percent"] else "",
>>>>>>                 "WITH TIES" if fetch_clause_options["with_ties"] else "ONLY",
                   )
>>>>>>         return text
       
>>>>>>     def visit_table(
               self,
               table,
               asfrom=False,
               iscrud=False,
               ashint=False,
               fromhints=None,
               use_schema=True,
               from_linter=None,
    1:         ambiguous_table_name_map=None,
               **kwargs,
           ):
    3:         if from_linter:
    3:             from_linter.froms[table] = table.fullname
       
    3:         if asfrom or ashint:
    3:             effective_schema = self.preparer.schema_for_object(table)
       
    3:             if use_schema and effective_schema:
    2:                 ret = (
    6:                     self.preparer.quote_schema(effective_schema)
    2:                     + "."
    2:                     + self.preparer.quote(table.name)
                       )
                   else:
    1:                 ret = self.preparer.quote(table.name)
       
    2:                 if (
    1:                     not effective_schema
    1:                     and ambiguous_table_name_map
>>>>>>                     and table.name in ambiguous_table_name_map
                       ):
>>>>>>                     anon_name = self._truncated_identifier(
>>>>>>                         "alias", ambiguous_table_name_map[table.name]
                           )
       
>>>>>>                     ret = ret + self.get_render_as_alias_suffix(
>>>>>>                         self.preparer.format_alias(None, anon_name)
                           )
       
    3:             if fromhints and table in fromhints:
>>>>>>                 ret = self.format_from_hint_text(
>>>>>>                     ret, table, fromhints[table], iscrud
                       )
    3:             return ret
               else:
>>>>>>             return ""
       
    1:     def visit_join(self, join, asfrom=False, from_linter=None, **kwargs):
    1:         if from_linter:
    2:             from_linter.edges.update(
    2:                 itertools.product(
    1:                     _de_clone(join.left._from_objects),
    1:                     _de_clone(join.right._from_objects),
                       )
                   )
       
    1:         if join.full:
>>>>>>             join_type = " FULL OUTER JOIN "
    1:         elif join.isouter:
>>>>>>             join_type = " LEFT OUTER JOIN "
               else:
    1:             join_type = " JOIN "
    1:         return (
    8:             join.left._compiler_dispatch(
    3:                 self, asfrom=True, from_linter=from_linter, **kwargs
                   )
    1:             + join_type
    4:             + join.right._compiler_dispatch(
    3:                 self, asfrom=True, from_linter=from_linter, **kwargs
                   )
    1:             + " ON "
                   # TODO: likely need asfrom=True here?
    4:             + join.onclause._compiler_dispatch(
    3:                 self, from_linter=from_linter, **kwargs
                   )
               )
       
    1:     def _setup_crud_hints(self, stmt, table_text):
>>>>>>         dialect_hints = {
>>>>>>             table: hint_text
>>>>>>             for (table, dialect), hint_text in stmt._hints.items()
>>>>>>             if dialect in ("*", self.dialect.name)
               }
>>>>>>         if stmt.table in dialect_hints:
>>>>>>             table_text = self.format_from_hint_text(
>>>>>>                 table_text, stmt.table, dialect_hints[stmt.table], True
                   )
>>>>>>         return dialect_hints, table_text
       
           # within the realm of "insertmanyvalues sentinel columns",
           # these lookups match different kinds of Column() configurations
           # to specific backend capabilities.  they are broken into two
           # lookups, one for autoincrement columns and the other for non
           # autoincrement columns
    2:     _sentinel_col_non_autoinc_lookup = util.immutabledict(
    1:         {
    1:             _SentinelDefaultCharacterization.CLIENTSIDE: (
    1:                 InsertmanyvaluesSentinelOpts._SUPPORTED_OR_NOT
                   ),
    1:             _SentinelDefaultCharacterization.SENTINEL_DEFAULT: (
    1:                 InsertmanyvaluesSentinelOpts._SUPPORTED_OR_NOT
                   ),
    1:             _SentinelDefaultCharacterization.NONE: (
    1:                 InsertmanyvaluesSentinelOpts._SUPPORTED_OR_NOT
                   ),
    1:             _SentinelDefaultCharacterization.IDENTITY: (
    1:                 InsertmanyvaluesSentinelOpts.IDENTITY
                   ),
    1:             _SentinelDefaultCharacterization.SEQUENCE: (
    1:                 InsertmanyvaluesSentinelOpts.SEQUENCE
                   ),
               }
           )
    2:     _sentinel_col_autoinc_lookup = _sentinel_col_non_autoinc_lookup.union(
    1:         {
    1:             _SentinelDefaultCharacterization.NONE: (
    1:                 InsertmanyvaluesSentinelOpts.AUTOINCREMENT
                   ),
               }
           )
       
    1:     def _get_sentinel_column_for_table(
               self, table: Table
           ) -> Optional[Sequence[Column[Any]]]:
               """given a :class:`.Table`, return a usable sentinel column or
               columns for this dialect if any.
       
               Return None if no sentinel columns could be identified, or raise an
               error if a column was marked as a sentinel explicitly but isn't
               compatible with this dialect.
       
               """
       
    1:         sentinel_opts = self.dialect.insertmanyvalues_implicit_sentinel
    1:         sentinel_characteristics = table._sentinel_column_characteristics
       
    1:         sent_cols = sentinel_characteristics.columns
       
    1:         if sent_cols is None:
>>>>>>             return None
       
    1:         if sentinel_characteristics.is_autoinc:
>>>>>>             bitmask = self._sentinel_col_autoinc_lookup.get(
>>>>>>                 sentinel_characteristics.default_characterization, 0
                   )
               else:
    2:             bitmask = self._sentinel_col_non_autoinc_lookup.get(
    1:                 sentinel_characteristics.default_characterization, 0
                   )
       
    1:         if sentinel_opts & bitmask:
    1:             return sent_cols
       
>>>>>>         if sentinel_characteristics.is_explicit:
                   # a column was explicitly marked as insert_sentinel=True,
                   # however it is not compatible with this dialect.   they should
                   # not indicate this column as a sentinel if they need to include
                   # this dialect.
       
                   # TODO: do we want non-primary key explicit sentinel cols
                   # that can gracefully degrade for some backends?
                   # insert_sentinel="degrade" perhaps.  not for the initial release.
                   # I am hoping people are generally not dealing with this sentinel
                   # business at all.
       
                   # if is_explicit is True, there will be only one sentinel column.
       
>>>>>>             raise exc.InvalidRequestError(
>>>>>>                 f"Column {sent_cols[0]} can't be explicitly "
                       "marked as a sentinel column when using the "
>>>>>>                 f"{self.dialect.name} dialect, as the "
                       "particular type of default generation on this column is "
                       "not currently compatible with this dialect's specific "
                       f"INSERT..RETURNING syntax which can receive the "
                       "server-generated value in "
                       "a deterministic way.  To remove this error, remove "
                       "insert_sentinel=True from primary key autoincrement "
                       "columns; these columns are automatically used as "
                       "sentinels for supported dialects in any case."
                   )
       
>>>>>>         return None
       
    1:     def _deliver_insertmanyvalues_batches(
               self,
               statement: str,
               parameters: _DBAPIMultiExecuteParams,
               generic_setinputsizes: Optional[_GenericSetInputSizesType],
               batch_size: int,
               sort_by_parameter_order: bool,
           ) -> Iterator[_InsertManyValuesBatch]:
    1:         imv = self._insertmanyvalues
    1:         assert imv is not None
       
    1:         lenparams = len(parameters)
    1:         if imv.is_default_expr and not self.dialect.supports_default_metavalue:
                   # backend doesn't support
                   # INSERT INTO table (pk_col) VALUES (DEFAULT), (DEFAULT), ...
                   # at the moment this is basically SQL Server due to
                   # not being able to use DEFAULT for identity column
                   # just yield out that many single statements!  still
                   # faster than a whole connection.execute() call ;)
                   #
                   # note we still are taking advantage of the fact that we know
                   # we are using RETURNING.   The generalized approach of fetching
                   # cursor.lastrowid etc. still goes through the more heavyweight
                   # "ExecutionContext per statement" system as it isn't usable
                   # as a generic "RETURNING" approach
>>>>>>             use_row_at_a_time = True
>>>>>>             downgraded = False
    2:         elif not self.dialect.supports_multivalues_insert or (
    1:             sort_by_parameter_order
>>>>>>             and self._result_columns
>>>>>>             and (imv.sentinel_columns is None or imv.includes_upsert_behaviors)
               ):
                   # deterministic order was requested and the compiler could
                   # not organize sentinel columns for this dialect/statement.
                   # use row at a time
>>>>>>             use_row_at_a_time = True
>>>>>>             downgraded = True
               else:
    1:             use_row_at_a_time = False
    1:             downgraded = False
       
    1:         if use_row_at_a_time:
>>>>>>             for batchnum, param in enumerate(
>>>>>>                 cast("Sequence[_DBAPISingleExecuteParams]", parameters), 1
                   ):
>>>>>>                 yield _InsertManyValuesBatch(
>>>>>>                     statement,
>>>>>>                     param,
>>>>>>                     generic_setinputsizes,
>>>>>>                     [param],
>>>>>>                     batch_size,
>>>>>>                     batchnum,
>>>>>>                     lenparams,
>>>>>>                     sort_by_parameter_order,
>>>>>>                     downgraded,
                       )
>>>>>>             return
       
    1:         executemany_values = f"({imv.single_values_expr})"
    1:         statement = statement.replace(executemany_values, "__EXECMANY_TOKEN__")
       
               # Use optional insertmanyvalues_max_parameters
               # to further shrink the batch size so that there are no more than
               # insertmanyvalues_max_parameters params.
               # Currently used by SQL Server, which limits statements to 2100 bound
               # parameters (actually 2099).
    1:         max_params = self.dialect.insertmanyvalues_max_parameters
    1:         if max_params:
    1:             total_num_of_params = len(self.bind_names)
    1:             num_params_per_batch = len(imv.insert_crud_params)
    1:             num_params_outside_of_batch = (
    1:                 total_num_of_params - num_params_per_batch
                   )
    2:             batch_size = min(
    1:                 batch_size,
                       (
    2:                     (max_params - num_params_outside_of_batch)
    1:                     // num_params_per_batch
                       ),
                   )
       
    1:         batches = list(parameters)
       
    1:         processed_setinputsizes: Optional[_GenericSetInputSizesType] = None
    1:         batchnum = 1
    2:         total_batches = lenparams // batch_size + (
    1:             1 if lenparams % batch_size else 0
               )
       
    1:         insert_crud_params = imv.insert_crud_params
    1:         assert insert_crud_params is not None
       
               escaped_bind_names: Mapping[str, str]
    1:         expand_pos_lower_index = expand_pos_upper_index = 0
       
    1:         if not self.positional:
    1:             if self.escaped_bind_names:
>>>>>>                 escaped_bind_names = self.escaped_bind_names
                   else:
    1:                 escaped_bind_names = {}
       
    1:             all_keys = set(parameters[0])
       
    1:             def apply_placeholders(keys, formatted):
   90:                 for key in keys:
   45:                     key = escaped_bind_names.get(key, key)
   90:                     formatted = formatted.replace(
   45:                         self.bindtemplate % {"name": key},
   90:                         self.bindtemplate
   45:                         % {"name": f"{key}__EXECMANY_INDEX__"},
                           )
   45:                 return formatted
       
    1:             if imv.embed_values_counter:
>>>>>>                 imv_values_counter = ", _IMV_VALUES_COUNTER"
                   else:
    1:                 imv_values_counter = ""
   49:             formatted_values_clause = f"""({', '.join(
   45:                 apply_placeholders(bind_keys, formatted)
   46:                 for _, _, formatted, bind_keys in insert_crud_params
    1:             )}{imv_values_counter})"""
       
   48:             keys_to_replace = all_keys.intersection(
   45:                 escaped_bind_names.get(key, key)
   46:                 for _, _, _, bind_keys in insert_crud_params
   90:                 for key in bind_keys
                   )
    3:             base_parameters = {
>>>>>>                 key: parameters[0][key]
    1:                 for key in all_keys.difference(keys_to_replace)
                   }
    1:             executemany_values_w_comma = ""
               else:
>>>>>>             formatted_values_clause = ""
>>>>>>             keys_to_replace = set()
>>>>>>             base_parameters = {}
       
>>>>>>             if imv.embed_values_counter:
>>>>>>                 executemany_values_w_comma = (
>>>>>>                     f"({imv.single_values_expr}, _IMV_VALUES_COUNTER), "
                       )
                   else:
>>>>>>                 executemany_values_w_comma = f"({imv.single_values_expr}), "
       
>>>>>>             all_names_we_will_expand: Set[str] = set()
>>>>>>             for elem in imv.insert_crud_params:
>>>>>>                 all_names_we_will_expand.update(elem[3])
       
                   # get the start and end position in a particular list
                   # of parameters where we will be doing the "expanding".
                   # statements can have params on either side or both sides,
                   # given RETURNING and CTEs
>>>>>>             if all_names_we_will_expand:
>>>>>>                 positiontup = self.positiontup
>>>>>>                 assert positiontup is not None
       
>>>>>>                 all_expand_positions = {
>>>>>>                     idx
>>>>>>                     for idx, name in enumerate(positiontup)
>>>>>>                     if name in all_names_we_will_expand
                       }
>>>>>>                 expand_pos_lower_index = min(all_expand_positions)
>>>>>>                 expand_pos_upper_index = max(all_expand_positions) + 1
>>>>>>                 assert (
>>>>>>                     len(all_expand_positions)
>>>>>>                     == expand_pos_upper_index - expand_pos_lower_index
                       )
       
>>>>>>             if self._numeric_binds:
>>>>>>                 escaped = re.escape(self._numeric_binds_identifier_char)
>>>>>>                 executemany_values_w_comma = re.sub(
>>>>>>                     rf"{escaped}\d+", "%s", executemany_values_w_comma
                       )
       
    2:         while batches:
    1:             batch = cast("Sequence[Any]", batches[0:batch_size])
    1:             batches[0:batch_size] = []
       
    1:             if generic_setinputsizes:
                       # if setinputsizes is present, expand this collection to
                       # suit the batch length as well
                       # currently this will be mssql+pyodbc for internal dialects
>>>>>>                 processed_setinputsizes = [
>>>>>>                     (new_key, len_, typ)
>>>>>>                     for new_key, len_, typ in (
>>>>>>                         (f"{key}_{index}", len_, typ)
>>>>>>                         for index in range(len(batch))
>>>>>>                         for key, len_, typ in generic_setinputsizes
                           )
                       ]
       
                   replaced_parameters: Any
    1:             if self.positional:
>>>>>>                 num_ins_params = imv.num_positional_params_counted
       
                       batch_iterator: Iterable[Sequence[Any]]
>>>>>>                 if num_ins_params == len(batch[0]):
>>>>>>                     extra_params_left = extra_params_right = ()
>>>>>>                     batch_iterator = batch
                       else:
>>>>>>                     extra_params_left = batch[0][:expand_pos_lower_index]
>>>>>>                     extra_params_right = batch[0][expand_pos_upper_index:]
>>>>>>                     batch_iterator = (
>>>>>>                         b[expand_pos_lower_index:expand_pos_upper_index]
>>>>>>                         for b in batch
                           )
       
>>>>>>                 if imv.embed_values_counter:
>>>>>>                     expanded_values_string = (
>>>>>>                         "".join(
>>>>>>                             executemany_values_w_comma.replace(
>>>>>>                                 "_IMV_VALUES_COUNTER", str(i)
                                   )
>>>>>>                             for i, _ in enumerate(batch)
                               )
>>>>>>                     )[:-2]
                       else:
>>>>>>                     expanded_values_string = (
>>>>>>                         (executemany_values_w_comma * len(batch))
>>>>>>                     )[:-2]
       
>>>>>>                 if self._numeric_binds and num_ins_params > 0:
                           # numeric will always number the parameters inside of
                           # VALUES (and thus order self.positiontup) to be higher
                           # than non-VALUES parameters, no matter where in the
                           # statement those non-VALUES parameters appear (this is
                           # ensured in _process_numeric by numbering first all
                           # params that are not in _values_bindparam)
                           # therefore all extra params are always
                           # on the left side and numbered lower than the VALUES
                           # parameters
>>>>>>                     assert not extra_params_right
       
>>>>>>                     start = expand_pos_lower_index + 1
>>>>>>                     end = num_ins_params * (len(batch)) + start
       
                           # need to format here, since statement may contain
                           # unescaped %, while values_string contains just (%s, %s)
>>>>>>                     positions = tuple(
>>>>>>                         f"{self._numeric_binds_identifier_char}{i}"
>>>>>>                         for i in range(start, end)
                           )
>>>>>>                     expanded_values_string = expanded_values_string % positions
       
>>>>>>                 replaced_statement = statement.replace(
>>>>>>                     "__EXECMANY_TOKEN__", expanded_values_string
                       )
       
>>>>>>                 replaced_parameters = tuple(
>>>>>>                     itertools.chain.from_iterable(batch_iterator)
                       )
       
>>>>>>                 replaced_parameters = (
>>>>>>                     extra_params_left
>>>>>>                     + replaced_parameters
>>>>>>                     + extra_params_right
                       )
       
                   else:
    1:                 replaced_values_clauses = []
    1:                 replaced_parameters = base_parameters.copy()
       
    3:                 for i, param in enumerate(batch):
    4:                     fmv = formatted_values_clause.replace(
    2:                         "EXECMANY_INDEX__", str(i)
                           )
    2:                     if imv.embed_values_counter:
>>>>>>                         fmv = fmv.replace("_IMV_VALUES_COUNTER", str(i))
       
    2:                     replaced_values_clauses.append(fmv)
    4:                     replaced_parameters.update(
   94:                         {f"{key}__{i}": param[key] for key in keys_to_replace}
                           )
       
    2:                 replaced_statement = statement.replace(
    1:                     "__EXECMANY_TOKEN__",
    1:                     ", ".join(replaced_values_clauses),
                       )
       
    2:             yield _InsertManyValuesBatch(
    1:                 replaced_statement,
    1:                 replaced_parameters,
    1:                 processed_setinputsizes,
    1:                 batch,
    1:                 batch_size,
    1:                 batchnum,
    1:                 total_batches,
    1:                 sort_by_parameter_order,
    1:                 False,
                   )
    1:             batchnum += 1
       
>>>>>>     def visit_insert(
    1:         self, insert_stmt, visited_bindparam=None, visiting_cte=None, **kw
           ):
    3:         compile_state = insert_stmt._compile_state_factory(
    2:             insert_stmt, self, **kw
               )
    1:         insert_stmt = compile_state.statement
       
    1:         if visiting_cte is not None:
>>>>>>             kw["visiting_cte"] = visiting_cte
>>>>>>             toplevel = False
               else:
    1:             toplevel = not self.stack
       
    1:         if toplevel:
    1:             self.isinsert = True
    1:             if not self.dml_compile_state:
    1:                 self.dml_compile_state = compile_state
    1:             if not self.compile_state:
    1:                 self.compile_state = compile_state
       
    2:         self.stack.append(
    1:             {
    1:                 "correlate_froms": set(),
    1:                 "asfrom_froms": set(),
    1:                 "selectable": insert_stmt,
                   }
               )
       
    1:         counted_bindparam = 0
       
               # reset any incoming "visited_bindparam" collection
    1:         visited_bindparam = None
       
               # for positional, insertmanyvalues needs to know how many
               # bound parameters are in the VALUES sequence; there's no simple
               # rule because default expressions etc. can have zero or more
               # params inside them.   After multiple attempts to figure this out,
               # this very simplistic "count after" works and is
               # likely the least amount of callcounts, though looks clumsy
    1:         if self.positional and visiting_cte is None:
                   # if we are inside a CTE, don't count parameters
                   # here since they wont be for insertmanyvalues. keep
                   # visited_bindparam at None so no counting happens.
                   # see #9173
>>>>>>             visited_bindparam = []
       
    4:         crud_params_struct = crud._get_crud_params(
    1:             self,
    1:             insert_stmt,
    1:             compile_state,
    1:             toplevel,
    1:             visited_bindparam=visited_bindparam,
    1:             **kw,
               )
       
    1:         if self.positional and visited_bindparam is not None:
>>>>>>             counted_bindparam = len(visited_bindparam)
>>>>>>             if self._numeric_binds:
>>>>>>                 if self._values_bindparam is not None:
>>>>>>                     self._values_bindparam += visited_bindparam
                       else:
>>>>>>                     self._values_bindparam = visited_bindparam
       
    1:         crud_params_single = crud_params_struct.single_params
       
    1:         if (
    1:             not crud_params_single
>>>>>>             and not self.dialect.supports_default_values
>>>>>>             and not self.dialect.supports_default_metavalue
>>>>>>             and not self.dialect.supports_empty_insert
               ):
>>>>>>             raise exc.CompileError(
>>>>>>                 "The '%s' dialect with current database "
                       "version settings does not support empty "
>>>>>>                 "inserts." % self.dialect.name
                   )
       
    1:         if compile_state._has_multi_parameters:
>>>>>>             if not self.dialect.supports_multivalues_insert:
>>>>>>                 raise exc.CompileError(
>>>>>>                     "The '%s' dialect with current database "
                           "version settings does not support "
>>>>>>                     "in-place multirow inserts." % self.dialect.name
                       )
>>>>>>             elif (
>>>>>>                 self.implicit_returning or insert_stmt._returning
>>>>>>             ) and insert_stmt._sort_by_parameter_order:
>>>>>>                 raise exc.CompileError(
>>>>>>                     "RETURNING cannot be determinstically sorted when "
                           "using an INSERT which includes multi-row values()."
                       )
>>>>>>             crud_params_single = crud_params_struct.single_params
               else:
    1:             crud_params_single = crud_params_struct.single_params
       
    1:         preparer = self.preparer
    1:         supports_default_values = self.dialect.supports_default_values
       
    1:         text = "INSERT "
       
    1:         if insert_stmt._prefixes:
>>>>>>             text += self._generate_prefixes(
>>>>>>                 insert_stmt, insert_stmt._prefixes, **kw
                   )
       
    1:         text += "INTO "
    1:         table_text = preparer.format_table(insert_stmt.table)
       
    1:         if insert_stmt._hints:
>>>>>>             _, table_text = self._setup_crud_hints(insert_stmt, table_text)
       
    1:         if insert_stmt._independent_ctes:
>>>>>>             self._dispatch_independent_ctes(insert_stmt, kw)
       
    1:         text += table_text
       
    1:         if crud_params_single or not supports_default_values:
    2:             text += " (%s)" % ", ".join(
   47:                 [expr for _, expr, _, _ in crud_params_single]
                   )
       
               # look for insertmanyvalues attributes that would have been configured
               # by crud.py as it scanned through the columns to be part of the
               # INSERT
    1:         use_insertmanyvalues = crud_params_struct.use_insertmanyvalues
    1:         named_sentinel_params: Optional[Sequence[str]] = None
    1:         add_sentinel_cols = None
    1:         implicit_sentinel = False
       
    1:         returning_cols = self.implicit_returning or insert_stmt._returning
    1:         if returning_cols:
>>>>>>             add_sentinel_cols = crud_params_struct.use_sentinel_columns
>>>>>>             if add_sentinel_cols is not None:
>>>>>>                 assert use_insertmanyvalues
       
                       # search for the sentinel column explicitly present
                       # in the INSERT columns list, and additionally check that
                       # this column has a bound parameter name set up that's in the
                       # parameter list.  If both of these cases are present, it means
                       # we will have a client side value for the sentinel in each
                       # parameter set.
       
>>>>>>                 _params_by_col = {
>>>>>>                     col: param_names
>>>>>>                     for col, _, _, param_names in crud_params_single
                       }
>>>>>>                 named_sentinel_params = []
>>>>>>                 for _add_sentinel_col in add_sentinel_cols:
>>>>>>                     if _add_sentinel_col not in _params_by_col:
>>>>>>                         named_sentinel_params = None
>>>>>>                         break
>>>>>>                     param_name = self._within_exec_param_key_getter(
>>>>>>                         _add_sentinel_col
                           )
>>>>>>                     if param_name not in _params_by_col[_add_sentinel_col]:
>>>>>>                         named_sentinel_params = None
>>>>>>                         break
>>>>>>                     named_sentinel_params.append(param_name)
       
>>>>>>                 if named_sentinel_params is None:
                           # if we are not going to have a client side value for
                           # the sentinel in the parameter set, that means it's
                           # an autoincrement, an IDENTITY, or a server-side SQL
                           # expression like nextval('seqname').  So this is
                           # an "implicit" sentinel; we will look for it in
                           # RETURNING
                           # only, and then sort on it.  For this case on PG,
                           # SQL Server we have to use a special INSERT form
                           # that guarantees the server side function lines up with
                           # the entries in the VALUES.
>>>>>>                     if (
>>>>>>                         self.dialect.insertmanyvalues_implicit_sentinel
>>>>>>                         & InsertmanyvaluesSentinelOpts.ANY_AUTOINCREMENT
                           ):
>>>>>>                         implicit_sentinel = True
                           else:
                               # here, we are not using a sentinel at all
                               # and we are likely the SQLite dialect.
                               # The first add_sentinel_col that we have should not
                               # be marked as "insert_sentinel=True".  if it was,
                               # an error should have been raised in
                               # _get_sentinel_column_for_table.
>>>>>>                         assert not add_sentinel_cols[0]._insert_sentinel, (
>>>>>>                             "sentinel selection rules should have prevented "
                                   "us from getting here for this dialect"
                               )
       
                       # always put the sentinel columns last.  even if they are
                       # in the returning list already, they will be there twice
                       # then.
>>>>>>                 returning_cols = list(returning_cols) + list(add_sentinel_cols)
       
>>>>>>             returning_clause = self.returning_clause(
>>>>>>                 insert_stmt,
>>>>>>                 returning_cols,
>>>>>>                 populate_result_map=toplevel,
                   )
       
>>>>>>             if self.returning_precedes_values:
>>>>>>                 text += " " + returning_clause
       
               else:
    1:             returning_clause = None
       
    1:         if insert_stmt.select is not None:
                   # placed here by crud.py
>>>>>>             select_text = self.process(
>>>>>>                 self.stack[-1]["insert_from_select"], insert_into=True, **kw
                   )
       
>>>>>>             if self.ctes and self.dialect.cte_follows_insert:
>>>>>>                 nesting_level = len(self.stack) if not toplevel else None
>>>>>>                 text += " %s%s" % (
>>>>>>                     self._render_cte_clause(
>>>>>>                         nesting_level=nesting_level,
>>>>>>                         include_following_stack=True,
                           ),
>>>>>>                     select_text,
                       )
                   else:
>>>>>>                 text += " %s" % select_text
    1:         elif not crud_params_single and supports_default_values:
>>>>>>             text += " DEFAULT VALUES"
>>>>>>             if use_insertmanyvalues:
>>>>>>                 self._insertmanyvalues = _InsertManyValues(
>>>>>>                     True,
>>>>>>                     self.dialect.default_metavalue_token,
>>>>>>                     cast(
>>>>>>                         "List[crud._CrudParamElementStr]", crud_params_single
                           ),
>>>>>>                     counted_bindparam,
                           sort_by_parameter_order=(
>>>>>>                         insert_stmt._sort_by_parameter_order
                           ),
                           includes_upsert_behaviors=(
>>>>>>                         insert_stmt._post_values_clause is not None
                           ),
>>>>>>                     sentinel_columns=add_sentinel_cols,
                           num_sentinel_columns=(
>>>>>>                         len(add_sentinel_cols) if add_sentinel_cols else 0
                           ),
>>>>>>                     implicit_sentinel=implicit_sentinel,
                       )
    1:         elif compile_state._has_multi_parameters:
>>>>>>             text += " VALUES %s" % (
>>>>>>                 ", ".join(
>>>>>>                     "(%s)"
>>>>>>                     % (", ".join(value for _, _, value, _ in crud_param_set))
>>>>>>                     for crud_param_set in crud_params_struct.all_multi_params
                       ),
                   )
               else:
    2:             insert_single_values_expr = ", ".join(
   48:                 [
   45:                     value
   47:                     for _, _, value, _ in cast(
    1:                         "List[crud._CrudParamElementStr]",
    1:                         crud_params_single,
                           )
                       ]
                   )
       
    1:             if use_insertmanyvalues:
    1:                 if (
    1:                     implicit_sentinel
                           and (
>>>>>>                         self.dialect.insertmanyvalues_implicit_sentinel
>>>>>>                         & InsertmanyvaluesSentinelOpts.USE_INSERT_FROM_SELECT
                           )
                           # this is checking if we have
                           # INSERT INTO table (id) VALUES (DEFAULT).
>>>>>>                     and not (crud_params_struct.is_default_metavalue_only)
                       ):
                           # if we have a sentinel column that is server generated,
                           # then for selected backends render the VALUES list as a
                           # subquery.  This is the orderable form supported by
                           # PostgreSQL and SQL Server.
>>>>>>                     embed_sentinel_value = True
       
>>>>>>                     render_bind_casts = (
>>>>>>                         self.dialect.insertmanyvalues_implicit_sentinel
>>>>>>                         & InsertmanyvaluesSentinelOpts.RENDER_SELECT_COL_CASTS
                           )
       
>>>>>>                     colnames = ", ".join(
>>>>>>                         f"p{i}" for i, _ in enumerate(crud_params_single)
                           )
       
>>>>>>                     if render_bind_casts:
                               # render casts for the SELECT list.  For PG, we are
                               # already rendering bind casts in the parameter list,
                               # selectively for the more "tricky" types like ARRAY.
                               # however, even for the "easy" types, if the parameter
                               # is NULL for every entry, PG gives up and says
                               # "it must be TEXT", which fails for other easy types
                               # like ints.  So we cast on this side too.
>>>>>>                         colnames_w_cast = ", ".join(
>>>>>>                             self.render_bind_cast(
>>>>>>                                 col.type,
>>>>>>                                 col.type._unwrapped_dialect_impl(self.dialect),
>>>>>>                                 f"p{i}",
                                   )
>>>>>>                             for i, (col, *_) in enumerate(crud_params_single)
                               )
                           else:
>>>>>>                         colnames_w_cast = colnames
       
>>>>>>                     text += (
>>>>>>                         f" SELECT {colnames_w_cast} FROM "
>>>>>>                         f"(VALUES ({insert_single_values_expr})) "
>>>>>>                         f"AS imp_sen({colnames}, sen_counter) "
                               "ORDER BY sen_counter"
                           )
                       else:
                           # otherwise, if no sentinel or backend doesn't support
                           # orderable subquery form, use a plain VALUES list
    1:                     embed_sentinel_value = False
    1:                     text += f" VALUES ({insert_single_values_expr})"
       
    2:                 self._insertmanyvalues = _InsertManyValues(
    1:                     is_default_expr=False,
    1:                     single_values_expr=insert_single_values_expr,
    2:                     insert_crud_params=cast(
    1:                         "List[crud._CrudParamElementStr]",
    1:                         crud_params_single,
                           ),
    1:                     num_positional_params_counted=counted_bindparam,
                           sort_by_parameter_order=(
    1:                         insert_stmt._sort_by_parameter_order
                           ),
                           includes_upsert_behaviors=(
    1:                         insert_stmt._post_values_clause is not None
                           ),
    1:                     sentinel_columns=add_sentinel_cols,
                           num_sentinel_columns=(
    1:                         len(add_sentinel_cols) if add_sentinel_cols else 0
                           ),
    1:                     sentinel_param_keys=named_sentinel_params,
    1:                     implicit_sentinel=implicit_sentinel,
    1:                     embed_values_counter=embed_sentinel_value,
                       )
       
                   else:
>>>>>>                 text += f" VALUES ({insert_single_values_expr})"
       
    1:         if insert_stmt._post_values_clause is not None:
>>>>>>             post_values_clause = self.process(
>>>>>>                 insert_stmt._post_values_clause, **kw
                   )
>>>>>>             if post_values_clause:
>>>>>>                 text += " " + post_values_clause
       
    1:         if returning_clause and not self.returning_precedes_values:
>>>>>>             text += " " + returning_clause
       
    1:         if self.ctes and not self.dialect.cte_follows_insert:
>>>>>>             nesting_level = len(self.stack) if not toplevel else None
>>>>>>             text = (
>>>>>>                 self._render_cte_clause(
>>>>>>                     nesting_level=nesting_level,
>>>>>>                     include_following_stack=True,
                       )
>>>>>>                 + text
                   )
       
    1:         self.stack.pop(-1)
       
    1:         return text
       
    1:     def update_limit_clause(self, update_stmt):
               """Provide a hook for MySQL to add LIMIT to the UPDATE"""
>>>>>>         return None
       
    1:     def update_tables_clause(self, update_stmt, from_table, extra_froms, **kw):
               """Provide a hook to override the initial table clause
               in an UPDATE statement.
       
               MySQL overrides this.
       
               """
>>>>>>         kw["asfrom"] = True
>>>>>>         return from_table._compiler_dispatch(self, iscrud=True, **kw)
       
    1:     def update_from_clause(
               self, update_stmt, from_table, extra_froms, from_hints, **kw
           ):
               """Provide a hook to override the generation of an
               UPDATE..FROM clause.
       
               MySQL and MSSQL override this.
       
               """
>>>>>>         raise NotImplementedError(
>>>>>>             "This backend does not support multiple-table "
                   "criteria within UPDATE"
               )
       
    1:     def visit_update(self, update_stmt, visiting_cte=None, **kw):
>>>>>>         compile_state = update_stmt._compile_state_factory(
>>>>>>             update_stmt, self, **kw
               )
>>>>>>         update_stmt = compile_state.statement
       
>>>>>>         if visiting_cte is not None:
>>>>>>             kw["visiting_cte"] = visiting_cte
>>>>>>             toplevel = False
               else:
>>>>>>             toplevel = not self.stack
       
>>>>>>         if toplevel:
>>>>>>             self.isupdate = True
>>>>>>             if not self.dml_compile_state:
>>>>>>                 self.dml_compile_state = compile_state
>>>>>>             if not self.compile_state:
>>>>>>                 self.compile_state = compile_state
       
>>>>>>         if self.linting & COLLECT_CARTESIAN_PRODUCTS:
>>>>>>             from_linter = FromLinter({}, set())
>>>>>>             warn_linting = self.linting & WARN_LINTING
>>>>>>             if toplevel:
>>>>>>                 self.from_linter = from_linter
               else:
>>>>>>             from_linter = None
>>>>>>             warn_linting = False
       
>>>>>>         extra_froms = compile_state._extra_froms
>>>>>>         is_multitable = bool(extra_froms)
       
>>>>>>         if is_multitable:
                   # main table might be a JOIN
>>>>>>             main_froms = set(_from_objects(update_stmt.table))
>>>>>>             render_extra_froms = [
>>>>>>                 f for f in extra_froms if f not in main_froms
                   ]
>>>>>>             correlate_froms = main_froms.union(extra_froms)
               else:
>>>>>>             render_extra_froms = []
>>>>>>             correlate_froms = {update_stmt.table}
       
>>>>>>         self.stack.append(
>>>>>>             {
>>>>>>                 "correlate_froms": correlate_froms,
>>>>>>                 "asfrom_froms": correlate_froms,
>>>>>>                 "selectable": update_stmt,
                   }
               )
       
>>>>>>         text = "UPDATE "
       
>>>>>>         if update_stmt._prefixes:
>>>>>>             text += self._generate_prefixes(
>>>>>>                 update_stmt, update_stmt._prefixes, **kw
                   )
       
>>>>>>         table_text = self.update_tables_clause(
>>>>>>             update_stmt,
>>>>>>             update_stmt.table,
>>>>>>             render_extra_froms,
>>>>>>             from_linter=from_linter,
>>>>>>             **kw,
               )
>>>>>>         crud_params_struct = crud._get_crud_params(
>>>>>>             self, update_stmt, compile_state, toplevel, **kw
               )
>>>>>>         crud_params = crud_params_struct.single_params
       
>>>>>>         if update_stmt._hints:
>>>>>>             dialect_hints, table_text = self._setup_crud_hints(
>>>>>>                 update_stmt, table_text
                   )
               else:
>>>>>>             dialect_hints = None
       
>>>>>>         if update_stmt._independent_ctes:
>>>>>>             self._dispatch_independent_ctes(update_stmt, kw)
       
>>>>>>         text += table_text
       
>>>>>>         text += " SET "
>>>>>>         text += ", ".join(
>>>>>>             expr + "=" + value
>>>>>>             for _, expr, value, _ in cast(
>>>>>>                 "List[Tuple[Any, str, str, Any]]", crud_params
                   )
               )
       
>>>>>>         if self.implicit_returning or update_stmt._returning:
>>>>>>             if self.returning_precedes_values:
>>>>>>                 text += " " + self.returning_clause(
>>>>>>                     update_stmt,
>>>>>>                     self.implicit_returning or update_stmt._returning,
>>>>>>                     populate_result_map=toplevel,
                       )
       
>>>>>>         if extra_froms:
>>>>>>             extra_from_text = self.update_from_clause(
>>>>>>                 update_stmt,
>>>>>>                 update_stmt.table,
>>>>>>                 render_extra_froms,
>>>>>>                 dialect_hints,
>>>>>>                 from_linter=from_linter,
>>>>>>                 **kw,
                   )
>>>>>>             if extra_from_text:
>>>>>>                 text += " " + extra_from_text
       
>>>>>>         if update_stmt._where_criteria:
>>>>>>             t = self._generate_delimited_and_list(
>>>>>>                 update_stmt._where_criteria, from_linter=from_linter, **kw
                   )
>>>>>>             if t:
>>>>>>                 text += " WHERE " + t
       
>>>>>>         limit_clause = self.update_limit_clause(update_stmt)
>>>>>>         if limit_clause:
>>>>>>             text += " " + limit_clause
       
>>>>>>         if (
>>>>>>             self.implicit_returning or update_stmt._returning
>>>>>>         ) and not self.returning_precedes_values:
>>>>>>             text += " " + self.returning_clause(
>>>>>>                 update_stmt,
>>>>>>                 self.implicit_returning or update_stmt._returning,
>>>>>>                 populate_result_map=toplevel,
                   )
       
>>>>>>         if self.ctes:
>>>>>>             nesting_level = len(self.stack) if not toplevel else None
>>>>>>             text = self._render_cte_clause(nesting_level=nesting_level) + text
       
>>>>>>         if warn_linting:
>>>>>>             assert from_linter is not None
>>>>>>             from_linter.warn(stmt_type="UPDATE")
       
>>>>>>         self.stack.pop(-1)
       
>>>>>>         return text
       
    1:     def delete_extra_from_clause(
               self, update_stmt, from_table, extra_froms, from_hints, **kw
           ):
               """Provide a hook to override the generation of an
               DELETE..FROM clause.
       
               This can be used to implement DELETE..USING for example.
       
               MySQL and MSSQL override this.
       
               """
>>>>>>         raise NotImplementedError(
>>>>>>             "This backend does not support multiple-table "
                   "criteria within DELETE"
               )
       
    1:     def delete_table_clause(self, delete_stmt, from_table, extra_froms, **kw):
>>>>>>         return from_table._compiler_dispatch(
>>>>>>             self, asfrom=True, iscrud=True, **kw
               )
       
    1:     def visit_delete(self, delete_stmt, visiting_cte=None, **kw):
>>>>>>         compile_state = delete_stmt._compile_state_factory(
>>>>>>             delete_stmt, self, **kw
               )
>>>>>>         delete_stmt = compile_state.statement
       
>>>>>>         if visiting_cte is not None:
>>>>>>             kw["visiting_cte"] = visiting_cte
>>>>>>             toplevel = False
               else:
>>>>>>             toplevel = not self.stack
       
>>>>>>         if toplevel:
>>>>>>             self.isdelete = True
>>>>>>             if not self.dml_compile_state:
>>>>>>                 self.dml_compile_state = compile_state
>>>>>>             if not self.compile_state:
>>>>>>                 self.compile_state = compile_state
       
>>>>>>         if self.linting & COLLECT_CARTESIAN_PRODUCTS:
>>>>>>             from_linter = FromLinter({}, set())
>>>>>>             warn_linting = self.linting & WARN_LINTING
>>>>>>             if toplevel:
>>>>>>                 self.from_linter = from_linter
               else:
>>>>>>             from_linter = None
>>>>>>             warn_linting = False
       
>>>>>>         extra_froms = compile_state._extra_froms
       
>>>>>>         correlate_froms = {delete_stmt.table}.union(extra_froms)
>>>>>>         self.stack.append(
>>>>>>             {
>>>>>>                 "correlate_froms": correlate_froms,
>>>>>>                 "asfrom_froms": correlate_froms,
>>>>>>                 "selectable": delete_stmt,
                   }
               )
       
>>>>>>         text = "DELETE "
       
>>>>>>         if delete_stmt._prefixes:
>>>>>>             text += self._generate_prefixes(
>>>>>>                 delete_stmt, delete_stmt._prefixes, **kw
                   )
       
>>>>>>         text += "FROM "
       
>>>>>>         try:
>>>>>>             table_text = self.delete_table_clause(
>>>>>>                 delete_stmt,
>>>>>>                 delete_stmt.table,
>>>>>>                 extra_froms,
>>>>>>                 from_linter=from_linter,
                   )
>>>>>>         except TypeError:
                   # anticipate 3rd party dialects that don't include **kw
                   # TODO: remove in 2.1
>>>>>>             table_text = self.delete_table_clause(
>>>>>>                 delete_stmt, delete_stmt.table, extra_froms
                   )
>>>>>>             if from_linter:
>>>>>>                 _ = self.process(delete_stmt.table, from_linter=from_linter)
       
>>>>>>         crud._get_crud_params(self, delete_stmt, compile_state, toplevel, **kw)
       
>>>>>>         if delete_stmt._hints:
>>>>>>             dialect_hints, table_text = self._setup_crud_hints(
>>>>>>                 delete_stmt, table_text
                   )
               else:
>>>>>>             dialect_hints = None
       
>>>>>>         if delete_stmt._independent_ctes:
>>>>>>             self._dispatch_independent_ctes(delete_stmt, kw)
       
>>>>>>         text += table_text
       
>>>>>>         if (
>>>>>>             self.implicit_returning or delete_stmt._returning
>>>>>>         ) and self.returning_precedes_values:
>>>>>>             text += " " + self.returning_clause(
>>>>>>                 delete_stmt,
>>>>>>                 self.implicit_returning or delete_stmt._returning,
>>>>>>                 populate_result_map=toplevel,
                   )
       
>>>>>>         if extra_froms:
>>>>>>             extra_from_text = self.delete_extra_from_clause(
>>>>>>                 delete_stmt,
>>>>>>                 delete_stmt.table,
>>>>>>                 extra_froms,
>>>>>>                 dialect_hints,
>>>>>>                 from_linter=from_linter,
>>>>>>                 **kw,
                   )
>>>>>>             if extra_from_text:
>>>>>>                 text += " " + extra_from_text
       
>>>>>>         if delete_stmt._where_criteria:
>>>>>>             t = self._generate_delimited_and_list(
>>>>>>                 delete_stmt._where_criteria, from_linter=from_linter, **kw
                   )
>>>>>>             if t:
>>>>>>                 text += " WHERE " + t
       
>>>>>>         if (
>>>>>>             self.implicit_returning or delete_stmt._returning
>>>>>>         ) and not self.returning_precedes_values:
>>>>>>             text += " " + self.returning_clause(
>>>>>>                 delete_stmt,
>>>>>>                 self.implicit_returning or delete_stmt._returning,
>>>>>>                 populate_result_map=toplevel,
                   )
       
>>>>>>         if self.ctes:
>>>>>>             nesting_level = len(self.stack) if not toplevel else None
>>>>>>             text = self._render_cte_clause(nesting_level=nesting_level) + text
       
>>>>>>         if warn_linting:
>>>>>>             assert from_linter is not None
>>>>>>             from_linter.warn(stmt_type="DELETE")
       
>>>>>>         self.stack.pop(-1)
       
>>>>>>         return text
       
    1:     def visit_savepoint(self, savepoint_stmt, **kw):
>>>>>>         return "SAVEPOINT %s" % self.preparer.format_savepoint(savepoint_stmt)
       
    1:     def visit_rollback_to_savepoint(self, savepoint_stmt, **kw):
>>>>>>         return "ROLLBACK TO SAVEPOINT %s" % self.preparer.format_savepoint(
>>>>>>             savepoint_stmt
               )
       
    1:     def visit_release_savepoint(self, savepoint_stmt, **kw):
>>>>>>         return "RELEASE SAVEPOINT %s" % self.preparer.format_savepoint(
>>>>>>             savepoint_stmt
               )
       
       
    2: class StrSQLCompiler(SQLCompiler):
    1:     """A :class:`.SQLCompiler` subclass which allows a small selection
           of non-standard SQL features to render into a string value.
       
           The :class:`.StrSQLCompiler` is invoked whenever a Core expression
           element is directly stringified without calling upon the
           :meth:`_expression.ClauseElement.compile` method.
           It can render a limited set
           of non-standard SQL constructs to assist in basic stringification,
           however for more substantial custom or dialect-specific SQL constructs,
           it will be necessary to make use of
           :meth:`_expression.ClauseElement.compile`
           directly.
       
           .. seealso::
       
               :ref:`faq_sql_expression_string`
       
           """
       
    1:     def _fallback_column_name(self, column):
>>>>>>         return "<name unknown>"
       
    1:     @util.preload_module("sqlalchemy.engine.url")
    1:     def visit_unsupported_compilation(self, element, err, **kw):
>>>>>>         if element.stringify_dialect != "default":
>>>>>>             url = util.preloaded.engine_url
>>>>>>             dialect = url.URL.create(element.stringify_dialect).get_dialect()()
       
>>>>>>             compiler = dialect.statement_compiler(
>>>>>>                 dialect, None, _supporting_against=self
                   )
>>>>>>             if not isinstance(compiler, StrSQLCompiler):
>>>>>>                 return compiler.process(element, **kw)
       
>>>>>>         return super().visit_unsupported_compilation(element, err)
       
    1:     def visit_getitem_binary(self, binary, operator, **kw):
>>>>>>         return "%s[%s]" % (
>>>>>>             self.process(binary.left, **kw),
>>>>>>             self.process(binary.right, **kw),
               )
       
    1:     def visit_json_getitem_op_binary(self, binary, operator, **kw):
>>>>>>         return self.visit_getitem_binary(binary, operator, **kw)
       
    1:     def visit_json_path_getitem_op_binary(self, binary, operator, **kw):
>>>>>>         return self.visit_getitem_binary(binary, operator, **kw)
       
    1:     def visit_sequence(self, seq, **kw):
>>>>>>         return "<next sequence value: %s>" % self.preparer.format_sequence(seq)
       
    1:     def returning_clause(
               self,
               stmt: UpdateBase,
               returning_cols: Sequence[ColumnElement[Any]],
               *,
               populate_result_map: bool,
               **kw: Any,
           ) -> str:
>>>>>>         columns = [
>>>>>>             self._label_select_column(None, c, True, False, {})
>>>>>>             for c in base._select_iterables(returning_cols)
               ]
>>>>>>         return "RETURNING " + ", ".join(columns)
       
    1:     def update_from_clause(
               self, update_stmt, from_table, extra_froms, from_hints, **kw
           ):
>>>>>>         kw["asfrom"] = True
>>>>>>         return "FROM " + ", ".join(
>>>>>>             t._compiler_dispatch(self, fromhints=from_hints, **kw)
>>>>>>             for t in extra_froms
               )
       
    1:     def delete_extra_from_clause(
               self, update_stmt, from_table, extra_froms, from_hints, **kw
           ):
>>>>>>         kw["asfrom"] = True
>>>>>>         return ", " + ", ".join(
>>>>>>             t._compiler_dispatch(self, fromhints=from_hints, **kw)
>>>>>>             for t in extra_froms
               )
       
    1:     def visit_empty_set_expr(self, type_, **kw):
>>>>>>         return "SELECT 1 WHERE 1!=1"
       
    1:     def get_from_hint_text(self, table, text):
>>>>>>         return "[%s]" % text
       
    1:     def visit_regexp_match_op_binary(self, binary, operator, **kw):
>>>>>>         return self._generate_generic_binary(binary, " <regexp> ", **kw)
       
    1:     def visit_not_regexp_match_op_binary(self, binary, operator, **kw):
>>>>>>         return self._generate_generic_binary(binary, " <not regexp> ", **kw)
       
    1:     def visit_regexp_replace_op_binary(self, binary, operator, **kw):
>>>>>>         return "<regexp replace>(%s, %s)" % (
>>>>>>             binary.left._compiler_dispatch(self, **kw),
>>>>>>             binary.right._compiler_dispatch(self, **kw),
               )
       
    1:     def visit_try_cast(self, cast, **kwargs):
>>>>>>         return "TRY_CAST(%s AS %s)" % (
>>>>>>             cast.clause._compiler_dispatch(self, **kwargs),
>>>>>>             cast.typeclause._compiler_dispatch(self, **kwargs),
               )
       
       
    2: class DDLCompiler(Compiled):
    1:     is_ddl = True
       
    1:     if TYPE_CHECKING:
       
>>>>>>         def __init__(
                   self,
                   dialect: Dialect,
                   statement: ExecutableDDLElement,
                   schema_translate_map: Optional[SchemaTranslateMapType] = ...,
                   render_schema_translate: bool = ...,
                   compile_kwargs: Mapping[str, Any] = ...,
>>>>>>         ): ...
       
    1:     @util.memoized_property
    1:     def sql_compiler(self):
  160:         return self.dialect.statement_compiler(
   80:             self.dialect, None, schema_translate_map=self.schema_translate_map
               )
       
    1:     @util.memoized_property
    1:     def type_compiler(self):
>>>>>>         return self.dialect.type_compiler_instance
       
    1:     def construct_params(
               self,
               params: Optional[_CoreSingleExecuteParams] = None,
               extracted_parameters: Optional[Sequence[BindParameter[Any]]] = None,
               escape_names: bool = True,
           ) -> Optional[_MutableCoreSingleExecuteParams]:
>>>>>>         return None
       
    1:     def visit_ddl(self, ddl, **kwargs):
               # table events can substitute table and schema name
>>>>>>         context = ddl.context
>>>>>>         if isinstance(ddl.target, schema.Table):
>>>>>>             context = context.copy()
       
>>>>>>             preparer = self.preparer
>>>>>>             path = preparer.format_table_seq(ddl.target)
>>>>>>             if len(path) == 1:
>>>>>>                 table, sch = path[0], ""
                   else:
>>>>>>                 table, sch = path[-1], path[0]
       
>>>>>>             context.setdefault("table", table)
>>>>>>             context.setdefault("schema", sch)
>>>>>>             context.setdefault("fullname", preparer.format_table(ddl.target))
       
>>>>>>         return self.sql_compiler.post_process_text(ddl.statement % context)
       
    1:     def visit_create_schema(self, create, **kw):
>>>>>>         text = "CREATE SCHEMA "
>>>>>>         if create.if_not_exists:
>>>>>>             text += "IF NOT EXISTS "
>>>>>>         return text + self.preparer.format_schema(create.element)
       
    1:     def visit_drop_schema(self, drop, **kw):
>>>>>>         text = "DROP SCHEMA "
>>>>>>         if drop.if_exists:
>>>>>>             text += "IF EXISTS "
>>>>>>         text += self.preparer.format_schema(drop.element)
>>>>>>         if drop.cascade:
>>>>>>             text += " CASCADE"
>>>>>>         return text
       
    1:     def visit_create_table(self, create, **kw):
   45:         table = create.element
   45:         preparer = self.preparer
       
   45:         text = "\nCREATE "
   45:         if table._prefixes:
>>>>>>             text += " ".join(table._prefixes) + " "
       
   45:         text += "TABLE "
   45:         if create.if_not_exists:
>>>>>>             text += "IF NOT EXISTS "
       
   45:         text += preparer.format_table(table) + " "
       
   45:         create_table_suffix = self.create_table_suffix(table)
   45:         if create_table_suffix:
>>>>>>             text += create_table_suffix + " "
       
   45:         text += "("
       
   45:         separator = "\n"
       
               # if only one primary key, specify it along with the column
   45:         first_pk = False
  467:         for create_column in create.columns:
  422:             column = create_column.element
  422:             try:
  844:                 processed = self.process(
  422:                     create_column, first_pk=column.primary_key and not first_pk
                       )
  422:                 if processed is not None:
  422:                     text += separator
  422:                     separator = ", \n"
  422:                     text += "\t" + processed
  422:                 if column.primary_key:
   50:                     first_pk = True
>>>>>>             except exc.CompileError as ce:
>>>>>>                 raise exc.CompileError(
>>>>>>                     "(in table '%s', column '%s'): %s"
>>>>>>                     % (table.description, column.name, ce.args[0])
>>>>>>                 ) from ce
       
   90:         const = self.create_table_constraints(
   45:             table,
   45:             _include_foreign_key_constraints=create.include_foreign_key_constraints,  # noqa
               )
   45:         if const:
   45:             text += separator + "\t" + const
       
   45:         text += "\n)%s\n\n" % self.post_create_table(table)
   45:         return text
       
    1:     def visit_create_column(self, create, first_pk=False, **kw):
  422:         column = create.element
       
  422:         if column.system:
>>>>>>             return None
       
  422:         text = self.get_column_specification(column, first_pk=first_pk)
 1266:         const = " ".join(
  422:             self.process(constraint) for constraint in column.constraints
               )
  422:         if const:
>>>>>>             text += " " + const
       
  422:         return text
       
    1:     def create_table_constraints(
               self, table, _include_foreign_key_constraints=None, **kw
           ):
               # On some DB order is significant: visit PK first, then the
               # other constraints (engine.ReflectionTest.testbasic failed on FB2)
   45:         constraints = []
   45:         if table.primary_key:
   45:             constraints.append(table.primary_key)
       
   45:         all_fkcs = table.foreign_key_constraints
   45:         if _include_foreign_key_constraints is not None:
   45:             omit_fkcs = all_fkcs.difference(_include_foreign_key_constraints)
               else:
>>>>>>             omit_fkcs = set()
       
   90:         constraints.extend(
  258:             [
   78:                 c
  168:                 for c in table._sorted_constraints
  123:                 if c is not table.primary_key and c not in omit_fkcs
                   ]
               )
       
  258:         return ", \n\t".join(
  123:             p
  381:             for p in (
  123:                 self.process(constraint)
  168:                 for constraint in constraints
  123:                 if (constraint._should_create_for_compiler(self))
                       and (
  123:                     not self.dialect.supports_alter
  123:                     or not getattr(constraint, "use_alter", False)
                       )
                   )
  123:             if p is not None
               )
       
    1:     def visit_drop_table(self, drop, **kw):
>>>>>>         text = "\nDROP TABLE "
>>>>>>         if drop.if_exists:
>>>>>>             text += "IF EXISTS "
>>>>>>         return text + self.preparer.format_table(drop.element)
       
    1:     def visit_drop_view(self, drop, **kw):
>>>>>>         return "\nDROP VIEW " + self.preparer.format_table(drop.element)
       
    1:     def _verify_index_table(self, index):
   80:         if index.table is None:
>>>>>>             raise exc.CompileError(
>>>>>>                 "Index '%s' is not associated with any table." % index.name
                   )
       
    1:     def visit_create_index(
               self, create, include_schema=False, include_table_schema=True, **kw
           ):
>>>>>>         index = create.element
>>>>>>         self._verify_index_table(index)
>>>>>>         preparer = self.preparer
>>>>>>         text = "CREATE "
>>>>>>         if index.unique:
>>>>>>             text += "UNIQUE "
>>>>>>         if index.name is None:
>>>>>>             raise exc.CompileError(
>>>>>>                 "CREATE INDEX requires that the index have a name"
                   )
       
>>>>>>         text += "INDEX "
>>>>>>         if create.if_not_exists:
>>>>>>             text += "IF NOT EXISTS "
       
>>>>>>         text += "%s ON %s (%s)" % (
>>>>>>             self._prepared_index_name(index, include_schema=include_schema),
>>>>>>             preparer.format_table(
>>>>>>                 index.table, use_schema=include_table_schema
                   ),
>>>>>>             ", ".join(
>>>>>>                 self.sql_compiler.process(
>>>>>>                     expr, include_table=False, literal_binds=True
                       )
>>>>>>                 for expr in index.expressions
                   ),
               )
>>>>>>         return text
       
    1:     def visit_drop_index(self, drop, **kw):
>>>>>>         index = drop.element
       
>>>>>>         if index.name is None:
>>>>>>             raise exc.CompileError(
>>>>>>                 "DROP INDEX requires that the index have a name"
                   )
>>>>>>         text = "\nDROP INDEX "
>>>>>>         if drop.if_exists:
>>>>>>             text += "IF EXISTS "
       
>>>>>>         return text + self._prepared_index_name(index, include_schema=True)
       
    1:     def _prepared_index_name(self, index, include_schema=False):
   80:         if index.table is not None:
   80:             effective_schema = self.preparer.schema_for_object(index.table)
               else:
>>>>>>             effective_schema = None
   80:         if include_schema and effective_schema:
>>>>>>             schema_name = self.preparer.quote_schema(effective_schema)
               else:
   80:             schema_name = None
       
   80:         index_name = self.preparer.format_index(index)
       
   80:         if schema_name:
>>>>>>             index_name = schema_name + "." + index_name
   80:         return index_name
       
    1:     def visit_add_constraint(self, create, **kw):
>>>>>>         return "ALTER TABLE %s ADD %s" % (
>>>>>>             self.preparer.format_table(create.element.table),
>>>>>>             self.process(create.element),
               )
       
    1:     def visit_set_table_comment(self, create, **kw):
>>>>>>         return "COMMENT ON TABLE %s IS %s" % (
>>>>>>             self.preparer.format_table(create.element),
>>>>>>             self.sql_compiler.render_literal_value(
>>>>>>                 create.element.comment, sqltypes.String()
                   ),
               )
       
    1:     def visit_drop_table_comment(self, drop, **kw):
>>>>>>         return "COMMENT ON TABLE %s IS NULL" % self.preparer.format_table(
>>>>>>             drop.element
               )
       
    1:     def visit_set_column_comment(self, create, **kw):
>>>>>>         return "COMMENT ON COLUMN %s IS %s" % (
>>>>>>             self.preparer.format_column(
>>>>>>                 create.element, use_table=True, use_schema=True
                   ),
>>>>>>             self.sql_compiler.render_literal_value(
>>>>>>                 create.element.comment, sqltypes.String()
                   ),
               )
       
    1:     def visit_drop_column_comment(self, drop, **kw):
>>>>>>         return "COMMENT ON COLUMN %s IS NULL" % self.preparer.format_column(
>>>>>>             drop.element, use_table=True
               )
       
    1:     def visit_set_constraint_comment(self, create, **kw):
>>>>>>         raise exc.UnsupportedCompilationError(self, type(create))
       
    1:     def visit_drop_constraint_comment(self, drop, **kw):
>>>>>>         raise exc.UnsupportedCompilationError(self, type(drop))
       
    1:     def get_identity_options(self, identity_options):
>>>>>>         text = []
>>>>>>         if identity_options.increment is not None:
>>>>>>             text.append("INCREMENT BY %d" % identity_options.increment)
>>>>>>         if identity_options.start is not None:
>>>>>>             text.append("START WITH %d" % identity_options.start)
>>>>>>         if identity_options.minvalue is not None:
>>>>>>             text.append("MINVALUE %d" % identity_options.minvalue)
>>>>>>         if identity_options.maxvalue is not None:
>>>>>>             text.append("MAXVALUE %d" % identity_options.maxvalue)
>>>>>>         if identity_options.nominvalue is not None:
>>>>>>             text.append("NO MINVALUE")
>>>>>>         if identity_options.nomaxvalue is not None:
>>>>>>             text.append("NO MAXVALUE")
>>>>>>         if identity_options.cache is not None:
>>>>>>             text.append("CACHE %d" % identity_options.cache)
>>>>>>         if identity_options.cycle is not None:
>>>>>>             text.append("CYCLE" if identity_options.cycle else "NO CYCLE")
>>>>>>         return " ".join(text)
       
    1:     def visit_create_sequence(self, create, prefix=None, **kw):
>>>>>>         text = "CREATE SEQUENCE "
>>>>>>         if create.if_not_exists:
>>>>>>             text += "IF NOT EXISTS "
>>>>>>         text += self.preparer.format_sequence(create.element)
       
>>>>>>         if prefix:
>>>>>>             text += prefix
>>>>>>         options = self.get_identity_options(create.element)
>>>>>>         if options:
>>>>>>             text += " " + options
>>>>>>         return text
       
    1:     def visit_drop_sequence(self, drop, **kw):
>>>>>>         text = "DROP SEQUENCE "
>>>>>>         if drop.if_exists:
>>>>>>             text += "IF EXISTS "
>>>>>>         return text + self.preparer.format_sequence(drop.element)
       
    1:     def visit_drop_constraint(self, drop, **kw):
>>>>>>         constraint = drop.element
>>>>>>         if constraint.name is not None:
>>>>>>             formatted_name = self.preparer.format_constraint(constraint)
               else:
>>>>>>             formatted_name = None
       
>>>>>>         if formatted_name is None:
>>>>>>             raise exc.CompileError(
>>>>>>                 "Can't emit DROP CONSTRAINT for constraint %r; "
>>>>>>                 "it has no name" % drop.element
                   )
>>>>>>         return "ALTER TABLE %s DROP CONSTRAINT %s%s%s" % (
>>>>>>             self.preparer.format_table(drop.element.table),
>>>>>>             "IF EXISTS " if drop.if_exists else "",
>>>>>>             formatted_name,
>>>>>>             " CASCADE" if drop.cascade else "",
               )
       
    1:     def get_column_specification(self, column, **kwargs):
>>>>>>         colspec = (
>>>>>>             self.preparer.format_column(column)
>>>>>>             + " "
>>>>>>             + self.dialect.type_compiler_instance.process(
>>>>>>                 column.type, type_expression=column
                   )
               )
>>>>>>         default = self.get_column_default_string(column)
>>>>>>         if default is not None:
>>>>>>             colspec += " DEFAULT " + default
       
>>>>>>         if column.computed is not None:
>>>>>>             colspec += " " + self.process(column.computed)
       
>>>>>>         if (
>>>>>>             column.identity is not None
>>>>>>             and self.dialect.supports_identity_columns
               ):
>>>>>>             colspec += " " + self.process(column.identity)
       
>>>>>>         if not column.nullable and (
>>>>>>             not column.identity or not self.dialect.supports_identity_columns
               ):
>>>>>>             colspec += " NOT NULL"
>>>>>>         return colspec
       
    1:     def create_table_suffix(self, table):
   45:         return ""
       
    1:     def post_create_table(self, table):
>>>>>>         return ""
       
    1:     def get_column_default_string(self, column):
  389:         if isinstance(column.server_default, schema.DefaultClause):
>>>>>>             return self.render_default_string(column.server_default.arg)
               else:
  389:             return None
       
    1:     def render_default_string(self, default):
>>>>>>         if isinstance(default, str):
>>>>>>             return self.sql_compiler.render_literal_value(
>>>>>>                 default, sqltypes.STRINGTYPE
                   )
               else:
>>>>>>             return self.sql_compiler.process(default, literal_binds=True)
       
    1:     def visit_table_or_column_check_constraint(self, constraint, **kw):
>>>>>>         if constraint.is_column_level:
>>>>>>             return self.visit_column_check_constraint(constraint)
               else:
>>>>>>             return self.visit_check_constraint(constraint)
       
    1:     def visit_check_constraint(self, constraint, **kw):
>>>>>>         text = ""
>>>>>>         if constraint.name is not None:
>>>>>>             formatted_name = self.preparer.format_constraint(constraint)
>>>>>>             if formatted_name is not None:
>>>>>>                 text += "CONSTRAINT %s " % formatted_name
>>>>>>         text += "CHECK (%s)" % self.sql_compiler.process(
>>>>>>             constraint.sqltext, include_table=False, literal_binds=True
               )
>>>>>>         text += self.define_constraint_deferrability(constraint)
>>>>>>         return text
       
    1:     def visit_column_check_constraint(self, constraint, **kw):
>>>>>>         text = ""
>>>>>>         if constraint.name is not None:
>>>>>>             formatted_name = self.preparer.format_constraint(constraint)
>>>>>>             if formatted_name is not None:
>>>>>>                 text += "CONSTRAINT %s " % formatted_name
>>>>>>         text += "CHECK (%s)" % self.sql_compiler.process(
>>>>>>             constraint.sqltext, include_table=False, literal_binds=True
               )
>>>>>>         text += self.define_constraint_deferrability(constraint)
>>>>>>         return text
       
    1:     def visit_primary_key_constraint(self, constraint, **kw):
   45:         if len(constraint) == 0:
>>>>>>             return ""
   45:         text = ""
   45:         if constraint.name is not None:
>>>>>>             formatted_name = self.preparer.format_constraint(constraint)
>>>>>>             if formatted_name is not None:
>>>>>>                 text += "CONSTRAINT %s " % formatted_name
   45:         text += "PRIMARY KEY "
  185:         text += "(%s)" % ", ".join(
   50:             self.preparer.quote(c.name)
   50:             for c in (
   45:                 constraint.columns_autoinc_first
   45:                 if constraint._implicit_generated
>>>>>>                 else constraint.columns
                   )
               )
   45:         text += self.define_constraint_deferrability(constraint)
   45:         return text
       
    1:     def visit_foreign_key_constraint(self, constraint, **kw):
   50:         preparer = self.preparer
   50:         text = ""
   50:         if constraint.name is not None:
>>>>>>             formatted_name = self.preparer.format_constraint(constraint)
>>>>>>             if formatted_name is not None:
>>>>>>                 text += "CONSTRAINT %s " % formatted_name
   50:         remote_table = list(constraint.elements)[0].column.table
  100:         text += "FOREIGN KEY(%s) REFERENCES %s (%s)" % (
  200:             ", ".join(
  100:                 preparer.quote(f.parent.name) for f in constraint.elements
                   ),
  100:             self.define_constraint_remote_table(
   50:                 constraint, remote_table, preparer
                   ),
  200:             ", ".join(
  100:                 preparer.quote(f.column.name) for f in constraint.elements
                   ),
               )
   50:         text += self.define_constraint_match(constraint)
   50:         text += self.define_constraint_cascades(constraint)
   50:         text += self.define_constraint_deferrability(constraint)
   50:         return text
       
    1:     def define_constraint_remote_table(self, constraint, table, preparer):
               """Format the remote table clause of a CREATE CONSTRAINT clause."""
       
   50:         return preparer.format_table(table)
       
    1:     def visit_unique_constraint(self, constraint, **kw):
   28:         if len(constraint) == 0:
>>>>>>             return ""
   28:         text = ""
   28:         if constraint.name is not None:
   20:             formatted_name = self.preparer.format_constraint(constraint)
   20:             if formatted_name is not None:
   20:                 text += "CONSTRAINT %s " % formatted_name
   56:         text += "UNIQUE %s(%s)" % (
   28:             self.define_unique_constraint_distinct(constraint, **kw),
  103:             ", ".join(self.preparer.quote(c.name) for c in constraint),
               )
   28:         text += self.define_constraint_deferrability(constraint)
   28:         return text
       
    1:     def define_unique_constraint_distinct(self, constraint, **kw):
>>>>>>         return ""
       
    1:     def define_constraint_cascades(self, constraint):
   50:         text = ""
   50:         if constraint.ondelete is not None:
>>>>>>             text += " ON DELETE %s" % self.preparer.validate_sql_phrase(
>>>>>>                 constraint.ondelete, FK_ON_DELETE
                   )
   50:         if constraint.onupdate is not None:
>>>>>>             text += " ON UPDATE %s" % self.preparer.validate_sql_phrase(
>>>>>>                 constraint.onupdate, FK_ON_UPDATE
                   )
   50:         return text
       
    1:     def define_constraint_deferrability(self, constraint):
  123:         text = ""
  123:         if constraint.deferrable is not None:
>>>>>>             if constraint.deferrable:
>>>>>>                 text += " DEFERRABLE"
                   else:
>>>>>>                 text += " NOT DEFERRABLE"
  123:         if constraint.initially is not None:
>>>>>>             text += " INITIALLY %s" % self.preparer.validate_sql_phrase(
>>>>>>                 constraint.initially, FK_INITIALLY
                   )
  123:         return text
       
    1:     def define_constraint_match(self, constraint):
   50:         text = ""
   50:         if constraint.match is not None:
>>>>>>             text += " MATCH %s" % constraint.match
   50:         return text
       
    1:     def visit_computed_column(self, generated, **kw):
>>>>>>         text = "GENERATED ALWAYS AS (%s)" % self.sql_compiler.process(
>>>>>>             generated.sqltext, include_table=False, literal_binds=True
               )
>>>>>>         if generated.persisted is True:
>>>>>>             text += " STORED"
>>>>>>         elif generated.persisted is False:
>>>>>>             text += " VIRTUAL"
>>>>>>         return text
       
    1:     def visit_identity_column(self, identity, **kw):
>>>>>>         text = "GENERATED %s AS IDENTITY" % (
>>>>>>             "ALWAYS" if identity.always else "BY DEFAULT",
               )
>>>>>>         options = self.get_identity_options(identity)
>>>>>>         if options:
>>>>>>             text += " (%s)" % options
>>>>>>         return text
       
       
    2: class GenericTypeCompiler(TypeCompiler):
    1:     def visit_FLOAT(self, type_, **kw):
>>>>>>         return "FLOAT"
       
    1:     def visit_DOUBLE(self, type_, **kw):
>>>>>>         return "DOUBLE"
       
    1:     def visit_DOUBLE_PRECISION(self, type_, **kw):
>>>>>>         return "DOUBLE PRECISION"
       
    1:     def visit_REAL(self, type_, **kw):
>>>>>>         return "REAL"
       
    1:     def visit_NUMERIC(self, type_, **kw):
>>>>>>         if type_.precision is None:
>>>>>>             return "NUMERIC"
>>>>>>         elif type_.scale is None:
>>>>>>             return "NUMERIC(%(precision)s)" % {"precision": type_.precision}
               else:
>>>>>>             return "NUMERIC(%(precision)s, %(scale)s)" % {
>>>>>>                 "precision": type_.precision,
>>>>>>                 "scale": type_.scale,
                   }
       
    1:     def visit_DECIMAL(self, type_, **kw):
>>>>>>         if type_.precision is None:
>>>>>>             return "DECIMAL"
>>>>>>         elif type_.scale is None:
>>>>>>             return "DECIMAL(%(precision)s)" % {"precision": type_.precision}
               else:
>>>>>>             return "DECIMAL(%(precision)s, %(scale)s)" % {
>>>>>>                 "precision": type_.precision,
>>>>>>                 "scale": type_.scale,
                   }
       
    1:     def visit_INTEGER(self, type_, **kw):
   40:         return "INTEGER"
       
    1:     def visit_SMALLINT(self, type_, **kw):
>>>>>>         return "SMALLINT"
       
    1:     def visit_BIGINT(self, type_, **kw):
>>>>>>         return "BIGINT"
       
    1:     def visit_TIMESTAMP(self, type_, **kw):
>>>>>>         return "TIMESTAMP"
       
    1:     def visit_DATETIME(self, type_, **kw):
>>>>>>         return "DATETIME"
       
    1:     def visit_DATE(self, type_, **kw):
   16:         return "DATE"
       
    1:     def visit_TIME(self, type_, **kw):
>>>>>>         return "TIME"
       
    1:     def visit_CLOB(self, type_, **kw):
>>>>>>         return "CLOB"
       
    1:     def visit_NCLOB(self, type_, **kw):
>>>>>>         return "NCLOB"
       
    1:     def _render_string_type(self, type_, name, length_override=None):
  157:         text = name
  157:         if length_override:
>>>>>>             text += "(%d)" % length_override
  157:         elif type_.length:
    7:             text += "(%d)" % type_.length
  157:         if type_.collation:
>>>>>>             text += ' COLLATE "%s"' % type_.collation
  157:         return text
       
    1:     def visit_CHAR(self, type_, **kw):
>>>>>>         return self._render_string_type(type_, "CHAR")
       
    1:     def visit_NCHAR(self, type_, **kw):
>>>>>>         return self._render_string_type(type_, "NCHAR")
       
    1:     def visit_VARCHAR(self, type_, **kw):
  150:         return self._render_string_type(type_, "VARCHAR")
       
    1:     def visit_NVARCHAR(self, type_, **kw):
>>>>>>         return self._render_string_type(type_, "NVARCHAR")
       
    1:     def visit_TEXT(self, type_, **kw):
    7:         return self._render_string_type(type_, "TEXT")
       
    1:     def visit_UUID(self, type_, **kw):
>>>>>>         return "UUID"
       
    1:     def visit_BLOB(self, type_, **kw):
>>>>>>         return "BLOB"
       
    1:     def visit_BINARY(self, type_, **kw):
>>>>>>         return "BINARY" + (type_.length and "(%d)" % type_.length or "")
       
    1:     def visit_VARBINARY(self, type_, **kw):
>>>>>>         return "VARBINARY" + (type_.length and "(%d)" % type_.length or "")
       
    1:     def visit_BOOLEAN(self, type_, **kw):
   37:         return "BOOLEAN"
       
    1:     def visit_uuid(self, type_, **kw):
>>>>>>         if not type_.native_uuid or not self.dialect.supports_native_uuid:
>>>>>>             return self._render_string_type(type_, "CHAR", length_override=32)
               else:
>>>>>>             return self.visit_UUID(type_, **kw)
       
    1:     def visit_large_binary(self, type_, **kw):
>>>>>>         return self.visit_BLOB(type_, **kw)
       
    1:     def visit_boolean(self, type_, **kw):
   37:         return self.visit_BOOLEAN(type_, **kw)
       
    1:     def visit_time(self, type_, **kw):
>>>>>>         return self.visit_TIME(type_, **kw)
       
    1:     def visit_datetime(self, type_, **kw):
>>>>>>         return self.visit_DATETIME(type_, **kw)
       
    1:     def visit_date(self, type_, **kw):
   16:         return self.visit_DATE(type_, **kw)
       
    1:     def visit_big_integer(self, type_, **kw):
   48:         return self.visit_BIGINT(type_, **kw)
       
    1:     def visit_small_integer(self, type_, **kw):
>>>>>>         return self.visit_SMALLINT(type_, **kw)
       
    1:     def visit_integer(self, type_, **kw):
   40:         return self.visit_INTEGER(type_, **kw)
       
    1:     def visit_real(self, type_, **kw):
>>>>>>         return self.visit_REAL(type_, **kw)
       
    1:     def visit_float(self, type_, **kw):
   11:         return self.visit_FLOAT(type_, **kw)
       
    1:     def visit_double(self, type_, **kw):
>>>>>>         return self.visit_DOUBLE(type_, **kw)
       
    1:     def visit_numeric(self, type_, **kw):
>>>>>>         return self.visit_NUMERIC(type_, **kw)
       
    1:     def visit_string(self, type_, **kw):
  150:         return self.visit_VARCHAR(type_, **kw)
       
    1:     def visit_unicode(self, type_, **kw):
>>>>>>         return self.visit_VARCHAR(type_, **kw)
       
    1:     def visit_text(self, type_, **kw):
    7:         return self.visit_TEXT(type_, **kw)
       
    1:     def visit_unicode_text(self, type_, **kw):
>>>>>>         return self.visit_TEXT(type_, **kw)
       
    1:     def visit_enum(self, type_, **kw):
>>>>>>         return self.visit_VARCHAR(type_, **kw)
       
    1:     def visit_null(self, type_, **kw):
>>>>>>         raise exc.CompileError(
>>>>>>             "Can't generate DDL for %r; "
                   "did you forget to specify a "
>>>>>>             "type on this Column?" % type_
               )
       
    1:     def visit_type_decorator(self, type_, **kw):
>>>>>>         return self.process(type_.type_engine(self.dialect), **kw)
       
    1:     def visit_user_defined(self, type_, **kw):
>>>>>>         return type_.get_col_spec(**kw)
       
       
    2: class StrSQLTypeCompiler(GenericTypeCompiler):
    1:     def process(self, type_, **kw):
>>>>>>         try:
>>>>>>             _compiler_dispatch = type_._compiler_dispatch
>>>>>>         except AttributeError:
>>>>>>             return self._visit_unknown(type_, **kw)
               else:
>>>>>>             return _compiler_dispatch(self, **kw)
       
    1:     def __getattr__(self, key):
>>>>>>         if key.startswith("visit_"):
>>>>>>             return self._visit_unknown
               else:
>>>>>>             raise AttributeError(key)
       
    1:     def _visit_unknown(self, type_, **kw):
>>>>>>         if type_.__class__.__name__ == type_.__class__.__name__.upper():
>>>>>>             return type_.__class__.__name__
               else:
>>>>>>             return repr(type_)
       
    1:     def visit_null(self, type_, **kw):
>>>>>>         return "NULL"
       
    1:     def visit_user_defined(self, type_, **kw):
>>>>>>         try:
>>>>>>             get_col_spec = type_.get_col_spec
>>>>>>         except AttributeError:
>>>>>>             return repr(type_)
               else:
>>>>>>             return get_col_spec(**kw)
       
       
    2: class _SchemaForObjectCallable(Protocol):
    1:     def __call__(self, obj: Any) -> str: ...
       
       
    2: class _BindNameForColProtocol(Protocol):
    1:     def __call__(self, col: ColumnClause[Any]) -> str: ...
       
       
    2: class IdentifierPreparer:
    1:     """Handle quoting and case-folding of identifiers based on options."""
       
    1:     reserved_words = RESERVED_WORDS
       
    1:     legal_characters = LEGAL_CHARACTERS
       
    1:     illegal_initial_characters = ILLEGAL_INITIAL_CHARACTERS
       
    1:     initial_quote: str
       
    1:     final_quote: str
       
    1:     _strings: MutableMapping[str, str]
       
    1:     schema_for_object: _SchemaForObjectCallable = operator.attrgetter("schema")
           """Return the .schema attribute for an object.
       
           For the default IdentifierPreparer, the schema for an object is always
           the value of the ".schema" attribute.   if the preparer is replaced
           with one that has a non-empty schema_translate_map, the value of the
           ".schema" attribute is rendered a symbol that will be converted to a
           real schema name from the mapping post-compile.
       
           """
       
    1:     _includes_none_schema_translate: bool = False
       
    1:     def __init__(
               self,
               dialect,
               initial_quote='"',
               final_quote=None,
               escape_quote='"',
               quote_case_sensitive_collations=True,
               omit_schema=False,
           ):
               """Construct a new ``IdentifierPreparer`` object.
       
               initial_quote
                 Character that begins a delimited identifier.
       
               final_quote
                 Character that ends a delimited identifier. Defaults to
                 `initial_quote`.
       
               omit_schema
                 Prevent prepending schema name. Useful for databases that do
                 not support schemae.
               """
       
    2:         self.dialect = dialect
    2:         self.initial_quote = initial_quote
    2:         self.final_quote = final_quote or self.initial_quote
    2:         self.escape_quote = escape_quote
    2:         self.escape_to_quote = self.escape_quote * 2
    2:         self.omit_schema = omit_schema
    2:         self.quote_case_sensitive_collations = quote_case_sensitive_collations
    2:         self._strings = {}
    2:         self._double_percents = self.dialect.paramstyle in (
                   "format",
                   "pyformat",
               )
       
    1:     def _with_schema_translate(self, schema_translate_map):
>>>>>>         prep = self.__class__.__new__(self.__class__)
>>>>>>         prep.__dict__.update(self.__dict__)
       
>>>>>>         includes_none = None in schema_translate_map
       
>>>>>>         def symbol_getter(obj):
>>>>>>             name = obj.schema
>>>>>>             if obj._use_schema_map and (name is not None or includes_none):
>>>>>>                 if name is not None and ("[" in name or "]" in name):
>>>>>>                     raise exc.CompileError(
>>>>>>                         "Square bracket characters ([]) not supported "
>>>>>>                         "in schema translate name '%s'" % name
                           )
>>>>>>                 return quoted_name(
>>>>>>                     "__[SCHEMA_%s]" % (name or "_none"), quote=False
                       )
                   else:
>>>>>>                 return obj.schema
       
>>>>>>         prep.schema_for_object = symbol_getter
>>>>>>         prep._includes_none_schema_translate = includes_none
>>>>>>         return prep
       
    1:     def _render_schema_translates(self, statement, schema_translate_map):
>>>>>>         d = schema_translate_map
>>>>>>         if None in d:
>>>>>>             if not self._includes_none_schema_translate:
>>>>>>                 raise exc.InvalidRequestError(
>>>>>>                     "schema translate map which previously did not have "
                           "`None` present as a key now has `None` present; compiled "
                           "statement may lack adequate placeholders.  Please use "
                           "consistent keys in successive "
                           "schema_translate_map dictionaries."
                       )
       
>>>>>>             d["_none"] = d[None]
       
>>>>>>         def replace(m):
>>>>>>             name = m.group(2)
>>>>>>             if name in d:
>>>>>>                 effective_schema = d[name]
                   else:
>>>>>>                 if name in (None, "_none"):
>>>>>>                     raise exc.InvalidRequestError(
>>>>>>                         "schema translate map which previously had `None` "
                               "present as a key now no longer has it present; don't "
                               "know how to apply schema for compiled statement. "
                               "Please use consistent keys in successive "
                               "schema_translate_map dictionaries."
                           )
>>>>>>                 effective_schema = name
       
>>>>>>             if not effective_schema:
>>>>>>                 effective_schema = self.dialect.default_schema_name
>>>>>>                 if not effective_schema:
                           # TODO: no coverage here
>>>>>>                     raise exc.CompileError(
>>>>>>                         "Dialect has no default schema name; can't "
                               "use None as dynamic schema target."
                           )
>>>>>>             return self.quote_schema(effective_schema)
       
>>>>>>         return re.sub(r"(__\[SCHEMA_([^\]]+)\])", replace, statement)
       
    1:     def _escape_identifier(self, value: str) -> str:
               """Escape an identifier.
       
               Subclasses should override this to provide database-dependent
               escaping behavior.
               """
       
>>>>>>         value = value.replace(self.escape_quote, self.escape_to_quote)
>>>>>>         if self._double_percents:
>>>>>>             value = value.replace("%", "%%")
>>>>>>         return value
       
    1:     def _unescape_identifier(self, value: str) -> str:
               """Canonicalize an escaped identifier.
       
               Subclasses should override this to provide database-dependent
               unescaping behavior that reverses _escape_identifier.
               """
       
>>>>>>         return value.replace(self.escape_to_quote, self.escape_quote)
       
    1:     def validate_sql_phrase(self, element, reg):
               """keyword sequence filter.
       
               a filter for elements that are intended to represent keyword sequences,
               such as "INITIALLY", "INITIALLY DEFERRED", etc.   no special characters
               should be present.
       
               .. versionadded:: 1.3
       
               """
       
>>>>>>         if element is not None and not reg.match(element):
>>>>>>             raise exc.CompileError(
>>>>>>                 "Unexpected SQL phrase: %r (matching against %r)"
>>>>>>                 % (element, reg.pattern)
                   )
>>>>>>         return element
       
    1:     def quote_identifier(self, value: str) -> str:
               """Quote an identifier.
       
               Subclasses should override this to provide database-dependent
               quoting behavior.
               """
       
>>>>>>         return (
>>>>>>             self.initial_quote
>>>>>>             + self._escape_identifier(value)
>>>>>>             + self.final_quote
               )
       
    1:     def _requires_quotes(self, value: str) -> bool:
               """Return True if the given identifier requires quoting."""
  401:         lc_value = value.lower()
  401:         return (
 1203:             lc_value in self.reserved_words
  401:             or value[0] in self.illegal_initial_characters
  401:             or not self.legal_characters.match(str(value))
  401:             or (lc_value != value)
               )
       
    1:     def _requires_quotes_illegal_chars(self, value):
               """Return True if the given identifier requires quoting, but
               not taking case convention into account."""
    2:         return not self.legal_characters.match(str(value))
       
    1:     def quote_schema(self, schema: str, force: Any = None) -> str:
               """Conditionally quote a schema name.
       
       
               The name is quoted if it is a reserved word, contains quote-necessary
               characters, or is an instance of :class:`.quoted_name` which includes
               ``quote`` set to ``True``.
       
               Subclasses can override this to provide database-dependent
               quoting behavior for schema names.
       
               :param schema: string schema name
               :param force: unused
       
                   .. deprecated:: 0.9
       
                       The :paramref:`.IdentifierPreparer.quote_schema.force`
                       parameter is deprecated and will be removed in a future
                       release.  This flag has no effect on the behavior of the
                       :meth:`.IdentifierPreparer.quote` method; please refer to
                       :class:`.quoted_name`.
       
               """
    9:         if force is not None:
                   # not using the util.deprecated_params() decorator in this
                   # case because of the additional function call overhead on this
                   # very performance-critical spot.
>>>>>>             util.warn_deprecated(
>>>>>>                 "The IdentifierPreparer.quote_schema.force parameter is "
                       "deprecated and will be removed in a future release.  This "
                       "flag has no effect on the behavior of the "
                       "IdentifierPreparer.quote method; please refer to "
                       "quoted_name().",
                       # deprecated 0.9. warning from 1.3
>>>>>>                 version="0.9",
                   )
       
    9:         return self.quote(schema)
       
    1:     def quote(self, ident: str, force: Any = None) -> str:
               """Conditionally quote an identifier.
       
               The identifier is quoted if it is a reserved word, contains
               quote-necessary characters, or is an instance of
               :class:`.quoted_name` which includes ``quote`` set to ``True``.
       
               Subclasses can override this to provide database-dependent
               quoting behavior for identifier names.
       
               :param ident: string identifier
               :param force: unused
       
                   .. deprecated:: 0.9
       
                       The :paramref:`.IdentifierPreparer.quote.force`
                       parameter is deprecated and will be removed in a future
                       release.  This flag has no effect on the behavior of the
                       :meth:`.IdentifierPreparer.quote` method; please refer to
                       :class:`.quoted_name`.
       
               """
 1189:         if force is not None:
                   # not using the util.deprecated_params() decorator in this
                   # case because of the additional function call overhead on this
                   # very performance-critical spot.
>>>>>>             util.warn_deprecated(
>>>>>>                 "The IdentifierPreparer.quote.force parameter is "
                       "deprecated and will be removed in a future release.  This "
                       "flag has no effect on the behavior of the "
                       "IdentifierPreparer.quote method; please refer to "
                       "quoted_name().",
                       # deprecated 0.9. warning from 1.3
>>>>>>                 version="0.9",
                   )
       
 1189:         force = getattr(ident, "quote", None)
       
 1189:         if force is None:
 1189:             if ident in self._strings:
  788:                 return self._strings[ident]
                   else:
  401:                 if self._requires_quotes(ident):
>>>>>>                     self._strings[ident] = self.quote_identifier(ident)
                       else:
  401:                     self._strings[ident] = ident
  401:                 return self._strings[ident]
>>>>>>         elif force:
>>>>>>             return self.quote_identifier(ident)
               else:
>>>>>>             return ident
       
    1:     def format_collation(self, collation_name):
>>>>>>         if self.quote_case_sensitive_collations:
>>>>>>             return self.quote(collation_name)
               else:
>>>>>>             return collation_name
       
    1:     def format_sequence(self, sequence, use_schema=True):
>>>>>>         name = self.quote(sequence.name)
       
>>>>>>         effective_schema = self.schema_for_object(sequence)
       
>>>>>>         if (
>>>>>>             not self.omit_schema
>>>>>>             and use_schema
>>>>>>             and effective_schema is not None
               ):
>>>>>>             name = self.quote_schema(effective_schema) + "." + name
>>>>>>         return name
       
    1:     def format_label(
               self, label: Label[Any], name: Optional[str] = None
           ) -> str:
   45:         return self.quote(name or label.name)
       
    1:     def format_alias(
               self, alias: Optional[AliasedReturnsRows], name: Optional[str] = None
           ) -> str:
>>>>>>         if name is None:
>>>>>>             assert alias is not None
>>>>>>             return self.quote(alias.name)
               else:
>>>>>>             return self.quote(name)
       
    1:     def format_savepoint(self, savepoint, name=None):
               # Running the savepoint name through quoting is unnecessary
               # for all known dialects.  This is here to support potential
               # third party use cases
>>>>>>         ident = name or savepoint.ident
>>>>>>         if self._requires_quotes(ident):
>>>>>>             ident = self.quote_identifier(ident)
>>>>>>         return ident
       
    1:     @util.preload_module("sqlalchemy.sql.naming")
    1:     def format_constraint(self, constraint, _alembic_quote=True):
  100:         naming = util.preloaded.sql_naming
       
  100:         if constraint.name is _NONE_NAME:
>>>>>>             name = naming._constraint_name_for_table(
>>>>>>                 constraint, constraint.table
                   )
       
>>>>>>             if name is None:
>>>>>>                 return None
               else:
  100:             name = constraint.name
       
  100:         if constraint.__visit_name__ == "index":
  160:             return self.truncate_and_render_index_name(
   80:                 name, _alembic_quote=_alembic_quote
                   )
               else:
   40:             return self.truncate_and_render_constraint_name(
   20:                 name, _alembic_quote=_alembic_quote
                   )
       
    1:     def truncate_and_render_index_name(self, name, _alembic_quote=True):
               # calculate these at format time so that ad-hoc changes
               # to dialect.max_identifier_length etc. can be reflected
               # as IdentifierPreparer is long lived
   80:         max_ = (
   80:             self.dialect.max_index_name_length
   80:             or self.dialect.max_identifier_length
               )
  160:         return self._truncate_and_render_maxlen_name(
   80:             name, max_, _alembic_quote
               )
       
    1:     def truncate_and_render_constraint_name(self, name, _alembic_quote=True):
               # calculate these at format time so that ad-hoc changes
               # to dialect.max_identifier_length etc. can be reflected
               # as IdentifierPreparer is long lived
   20:         max_ = (
   20:             self.dialect.max_constraint_name_length
   20:             or self.dialect.max_identifier_length
               )
   40:         return self._truncate_and_render_maxlen_name(
   20:             name, max_, _alembic_quote
               )
       
    1:     def _truncate_and_render_maxlen_name(self, name, max_, _alembic_quote):
  100:         if isinstance(name, elements._truncated_label):
   76:             if len(name) > max_:
>>>>>>                 name = name[0 : max_ - 8] + "_" + util.md5_hex(name)[-4:]
               else:
   24:             self.dialect.validate_identifier(name)
       
  100:         if not _alembic_quote:
>>>>>>             return name
               else:
  100:             return self.quote(name)
       
    1:     def format_index(self, index):
   80:         return self.format_constraint(index)
       
    1:     def format_table(self, table, use_schema=True, name=None):
               """Prepare a quoted table and schema name."""
       
  176:         if name is None:
  176:             name = table.name
       
  176:         result = self.quote(name)
       
  176:         effective_schema = self.schema_for_object(table)
       
  176:         if not self.omit_schema and use_schema and effective_schema:
>>>>>>             result = self.quote_schema(effective_schema) + "." + result
  176:         return result
       
    1:     def format_schema(self, name):
               """Prepare a quoted schema name."""
       
>>>>>>         return self.quote(name)
       
    1:     def format_label_name(
               self,
               name,
               anon_map=None,
           ):
               """Prepare a quoted column name."""
       
>>>>>>         if anon_map is not None and isinstance(
>>>>>>             name, elements._truncated_label
               ):
>>>>>>             name = name.apply_map(anon_map)
       
>>>>>>         return self.quote(name)
       
    1:     def format_column(
               self,
               column,
               use_table=False,
               name=None,
               table_name=None,
               use_schema=False,
               anon_map=None,
           ):
               """Prepare a quoted column name."""
       
  467:         if name is None:
  467:             name = column.name
       
  467:         if anon_map is not None and isinstance(
>>>>>>             name, elements._truncated_label
               ):
>>>>>>             name = name.apply_map(anon_map)
       
  467:         if not getattr(column, "is_literal", False):
  467:             if use_table:
>>>>>>                 return (
>>>>>>                     self.format_table(
>>>>>>                         column.table, use_schema=use_schema, name=table_name
                           )
>>>>>>                     + "."
>>>>>>                     + self.quote(name)
                       )
                   else:
  467:                 return self.quote(name)
               else:
                   # literal textual elements get stuck into ColumnClause a lot,
                   # which shouldn't get quoted
       
>>>>>>             if use_table:
>>>>>>                 return (
>>>>>>                     self.format_table(
>>>>>>                         column.table, use_schema=use_schema, name=table_name
                           )
>>>>>>                     + "."
>>>>>>                     + name
                       )
                   else:
>>>>>>                 return name
       
    1:     def format_table_seq(self, table, use_schema=True):
               """Format table name and schema as a tuple."""
       
               # Dialects with more levels in their fully qualified references
               # ('database', 'owner', etc.) could override this and return
               # a longer sequence.
       
>>>>>>         effective_schema = self.schema_for_object(table)
       
>>>>>>         if not self.omit_schema and use_schema and effective_schema:
>>>>>>             return (
>>>>>>                 self.quote_schema(effective_schema),
>>>>>>                 self.format_table(table, use_schema=False),
                   )
               else:
>>>>>>             return (self.format_table(table, use_schema=False),)
       
    1:     @util.memoized_property
    1:     def _r_identifiers(self):
>>>>>>         initial, final, escaped_final = (
>>>>>>             re.escape(s)
>>>>>>             for s in (
>>>>>>                 self.initial_quote,
>>>>>>                 self.final_quote,
>>>>>>                 self._escape_identifier(self.final_quote),
                   )
               )
>>>>>>         r = re.compile(
>>>>>>             r"(?:"
                   r"(?:%(initial)s((?:%(escaped)s|[^%(final)s])+)%(final)s"
                   r"|([^\.]+))(?=\.|$))+"
>>>>>>             % {"initial": initial, "final": final, "escaped": escaped_final}
               )
>>>>>>         return r
       
    1:     def unformat_identifiers(self, identifiers):
               """Unpack 'schema.table.column'-like strings into components."""
       
>>>>>>         r = self._r_identifiers
>>>>>>         return [
>>>>>>             self._unescape_identifier(i)
>>>>>>             for i in [a or b for a, b in r.findall(identifiers)]
               ]
