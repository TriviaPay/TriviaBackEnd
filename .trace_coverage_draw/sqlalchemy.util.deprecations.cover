       # util/deprecations.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       # mypy: allow-untyped-defs, allow-untyped-calls
       
    1: """Helpers related to deprecation of functions, methods, classes, other
       functionality."""
       
    1: from __future__ import annotations
       
    1: import re
    1: from typing import Any
    1: from typing import Callable
    1: from typing import Dict
    1: from typing import Match
    1: from typing import Optional
    1: from typing import Sequence
    1: from typing import Set
    1: from typing import Tuple
    1: from typing import Type
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from . import compat
    1: from .langhelpers import _hash_limit_string
    1: from .langhelpers import _warnings_warn
    1: from .langhelpers import decorator
    1: from .langhelpers import inject_docstring_text
    1: from .langhelpers import inject_param_text
    1: from .. import exc
       
    1: _T = TypeVar("_T", bound=Any)
       
       
       # https://mypy.readthedocs.io/en/stable/generics.html#declaring-decorators
    1: _F = TypeVar("_F", bound="Callable[..., Any]")
       
       
    1: def _warn_with_version(
           msg: str,
           version: str,
           type_: Type[exc.SADeprecationWarning],
           stacklevel: int,
           code: Optional[str] = None,
       ) -> None:
    1:     warn = type_(msg, code=code)
    1:     warn.deprecated_since = version
       
    1:     _warnings_warn(warn, stacklevel=stacklevel + 1)
       
       
    1: def warn_deprecated(
           msg: str, version: str, stacklevel: int = 3, code: Optional[str] = None
       ) -> None:
>>>>>>     _warn_with_version(
>>>>>>         msg, version, exc.SADeprecationWarning, stacklevel, code=code
           )
       
       
    1: def warn_deprecated_limited(
           msg: str,
           args: Sequence[Any],
           version: str,
           stacklevel: int = 3,
           code: Optional[str] = None,
       ) -> None:
           """Issue a deprecation warning with a parameterized string,
           limiting the number of registrations.
       
           """
>>>>>>     if args:
>>>>>>         msg = _hash_limit_string(msg, 10, args)
>>>>>>     _warn_with_version(
>>>>>>         msg, version, exc.SADeprecationWarning, stacklevel, code=code
           )
       
       
    1: def deprecated_cls(
           version: str, message: str, constructor: Optional[str] = "__init__"
       ) -> Callable[[Type[_T]], Type[_T]]:
    1:     header = ".. deprecated:: %s %s" % (version, (message or ""))
       
    1:     def decorate(cls: Type[_T]) -> Type[_T]:
    2:         return _decorate_cls_with_warning(
    1:             cls,
    1:             constructor,
    1:             exc.SADeprecationWarning,
    1:             message % dict(func=constructor),
    1:             version,
    1:             header,
               )
       
    1:     return decorate
       
       
    1: def deprecated(
           version: str,
           message: Optional[str] = None,
           add_deprecation_to_docstring: bool = True,
           warning: Optional[Type[exc.SADeprecationWarning]] = None,
           enable_warnings: bool = True,
       ) -> Callable[[_F], _F]:
           """Decorates a function and issues a deprecation warning on use.
       
           :param version:
             Issue version in the warning.
       
           :param message:
             If provided, issue message in the warning.  A sensible default
             is used if not provided.
       
           :param add_deprecation_to_docstring:
             Default True.  If False, the wrapped function's __doc__ is left
             as-is.  If True, the 'message' is prepended to the docs if
             provided, or sensible default if message is omitted.
       
           """
       
   48:     if add_deprecation_to_docstring:
   96:         header = ".. deprecated:: %s %s" % (
   48:             version,
   48:             (message or ""),
               )
           else:
>>>>>>         header = None
       
   48:     if message is None:
>>>>>>         message = "Call to deprecated function %(func)s"
       
   48:     if warning is None:
   39:         warning = exc.SADeprecationWarning
       
   48:     message += " (deprecated since: %s)" % version
       
   48:     def decorate(fn: _F) -> _F:
   48:         assert message is not None
   48:         assert warning is not None
   96:         return _decorate_with_warning(
   48:             fn,
   48:             warning,
   48:             message % dict(func=fn.__name__),
   48:             version,
   48:             header,
   48:             enable_warnings=enable_warnings,
               )
       
   48:     return decorate
       
       
    1: def moved_20(
           message: str, **kw: Any
       ) -> Callable[[Callable[..., _T]], Callable[..., _T]]:
   16:     return deprecated(
    8:         "2.0", message=message, warning=exc.MovedIn20Warning, **kw
           )
       
       
    1: def became_legacy_20(
           api_name: str, alternative: Optional[str] = None, **kw: Any
       ) -> Callable[[_F], _F]:
    5:     type_reg = re.match("^:(attr|func|meth):", api_name)
    5:     if type_reg:
   10:         type_ = {"attr": "attribute", "func": "function", "meth": "method"}[
    5:             type_reg.group(1)
               ]
           else:
>>>>>>         type_ = "construct"
    5:     message = (
   10:         "The %s %s is considered legacy as of the "
               "1.x series of SQLAlchemy and %s in 2.0."
    5:         % (
    5:             api_name,
    5:             type_,
    5:             "becomes a legacy construct",
               )
           )
       
    5:     if ":attr:" in api_name:
>>>>>>         attribute_ok = kw.pop("warn_on_attribute_access", False)
>>>>>>         if not attribute_ok:
>>>>>>             assert kw.get("enable_warnings") is False, (
>>>>>>                 "attribute %s will emit a warning on read access.  "
                       "If you *really* want this, "
                       "add warn_on_attribute_access=True.  Otherwise please add "
>>>>>>                 "enable_warnings=False." % api_name
                   )
       
    5:     if alternative:
    5:         message += " " + alternative
       
    5:     warning_cls = exc.LegacyAPIWarning
       
    5:     return deprecated("2.0", message=message, warning=warning_cls, **kw)
       
       
    1: def deprecated_params(**specs: Tuple[str, str]) -> Callable[[_F], _F]:
           """Decorates a function to warn on use of certain parameters.
       
           e.g. ::
       
               @deprecated_params(
                   weak_identity_map=(
                       "0.7",
                       "the :paramref:`.Session.weak_identity_map parameter "
                       "is deprecated."
                   )
       
               )
       
           """
       
    5:     messages: Dict[str, str] = {}
    5:     versions: Dict[str, str] = {}
    5:     version_warnings: Dict[str, Type[exc.SADeprecationWarning]] = {}
       
   16:     for param, (version, message) in specs.items():
   11:         versions[param] = version
   11:         messages[param] = _sanitize_restructured_text(message)
   11:         version_warnings[param] = exc.SADeprecationWarning
       
    5:     def decorate(fn: _F) -> _F:
    5:         spec = compat.inspect_getfullargspec(fn)
       
               check_defaults: Union[Set[str], Tuple[()]]
    5:         if spec.defaults is not None:
    4:             defaults = dict(
    4:                 zip(
    2:                     spec.args[(len(spec.args) - len(spec.defaults)) :],
    2:                     spec.defaults,
                       )
                   )
    2:             check_defaults = set(defaults).intersection(messages)
    2:             check_kw = set(messages).difference(defaults)
    3:         elif spec.kwonlydefaults is not None:
    1:             defaults = spec.kwonlydefaults
    1:             check_defaults = set(defaults).intersection(messages)
    1:             check_kw = set(messages).difference(defaults)
               else:
    2:             check_defaults = ()
    2:             check_kw = set(messages)
       
    5:         check_any_kw = spec.varkw
       
               # latest mypy has opinions here, not sure if they implemented
               # Concatenate or something
    5:         @decorator
    5:         def warned(fn: _F, *args: Any, **kwargs: Any) -> _F:
  152:             for m in check_defaults:
  141:                 if (defaults[m] is None and kwargs[m] is not None) or (
   94:                     defaults[m] is not None and kwargs[m] != defaults[m]
                       ):
>>>>>>                     _warn_with_version(
>>>>>>                         messages[m],
>>>>>>                         versions[m],
>>>>>>                         version_warnings[m],
>>>>>>                         stacklevel=3,
                           )
       
  105:             if check_any_kw in messages and set(kwargs).difference(
>>>>>>                 check_defaults
                   ):
>>>>>>                 assert check_any_kw is not None
>>>>>>                 _warn_with_version(
>>>>>>                     messages[check_any_kw],
>>>>>>                     versions[check_any_kw],
>>>>>>                     version_warnings[check_any_kw],
>>>>>>                     stacklevel=3,
                       )
       
  169:             for m in check_kw:
   64:                 if m in kwargs:
>>>>>>                     _warn_with_version(
>>>>>>                         messages[m],
>>>>>>                         versions[m],
>>>>>>                         version_warnings[m],
>>>>>>                         stacklevel=3,
                           )
  105:             return fn(*args, **kwargs)  # type: ignore[no-any-return]
       
    5:         doc = fn.__doc__ is not None and fn.__doc__ or ""
    5:         if doc:
    6:             doc = inject_param_text(
    3:                 doc,
   17:                 {
   16:                     param: ".. deprecated:: %s %s"
    8:                     % ("1.4" if version == "2.0" else version, (message or ""))
   11:                     for param, (version, message) in specs.items()
                       },
                   )
    5:         decorated = warned(fn)
    5:         decorated.__doc__ = doc
    5:         return decorated
       
    5:     return decorate
       
       
    1: def _sanitize_restructured_text(text: str) -> str:
   59:     def repl(m: Match[str]) -> str:
  108:         type_, name = m.group(1, 2)
  108:         if type_ in ("func", "meth"):
   69:             name += "()"
  108:         return name
       
   59:     text = re.sub(r":ref:`(.+) <.*>`", lambda m: '"%s"' % m.group(1), text)
   59:     return re.sub(r"\:(\w+)\:`~?(?:_\w+)?\.?(.+?)`", repl, text)
       
       
    1: def _decorate_cls_with_warning(
           cls: Type[_T],
           constructor: Optional[str],
           wtype: Type[exc.SADeprecationWarning],
           message: str,
           version: str,
           docstring_header: Optional[str] = None,
       ) -> Type[_T]:
    1:     doc = cls.__doc__ is not None and cls.__doc__ or ""
    1:     if docstring_header is not None:
    1:         if constructor is not None:
>>>>>>             docstring_header %= dict(func=constructor)
       
    1:         if issubclass(wtype, exc.Base20DeprecationWarning):
>>>>>>             docstring_header += (
>>>>>>                 " (Background on SQLAlchemy 2.0 at: "
                       ":ref:`migration_20_toplevel`)"
                   )
    1:         doc = inject_docstring_text(doc, docstring_header, 1)
       
    1:         constructor_fn = None
    1:         if type(cls) is type:
    1:             clsdict = dict(cls.__dict__)
    1:             clsdict["__doc__"] = doc
    1:             clsdict.pop("__dict__", None)
    1:             clsdict.pop("__weakref__", None)
    1:             cls = type(cls.__name__, cls.__bases__, clsdict)
    1:             if constructor is not None:
>>>>>>                 constructor_fn = clsdict[constructor]
       
               else:
>>>>>>             cls.__doc__ = doc
>>>>>>             if constructor is not None:
>>>>>>                 constructor_fn = getattr(cls, constructor)
       
    1:         if constructor is not None:
>>>>>>             assert constructor_fn is not None
>>>>>>             assert wtype is not None
>>>>>>             setattr(
>>>>>>                 cls,
>>>>>>                 constructor,
>>>>>>                 _decorate_with_warning(
>>>>>>                     constructor_fn, wtype, message, version, None
                       ),
                   )
    1:     return cls
       
       
    1: def _decorate_with_warning(
           func: _F,
           wtype: Type[exc.SADeprecationWarning],
           message: str,
           version: str,
           docstring_header: Optional[str] = None,
           enable_warnings: bool = True,
       ) -> _F:
           """Wrap a function with a warnings.warn and augmented docstring."""
       
   48:     message = _sanitize_restructured_text(message)
       
   48:     if issubclass(wtype, exc.Base20DeprecationWarning):
    9:         doc_only = (
    9:             " (Background on SQLAlchemy 2.0 at: "
                   ":ref:`migration_20_toplevel`)"
               )
           else:
   39:         doc_only = ""
       
   48:     @decorator
   48:     def warned(fn: _F, *args: Any, **kwargs: Any) -> _F:
    2:         skip_warning = not enable_warnings or kwargs.pop(
    1:             "_sa_skip_warning", False
               )
    1:         if not skip_warning:
    1:             _warn_with_version(message, version, wtype, stacklevel=3)
    1:         return fn(*args, **kwargs)  # type: ignore[no-any-return]
       
   48:     doc = func.__doc__ is not None and func.__doc__ or ""
   48:     if docstring_header is not None:
   48:         docstring_header %= dict(func=func.__name__)
       
   48:         docstring_header += doc_only
       
   48:         doc = inject_docstring_text(doc, docstring_header, 1)
       
   48:     decorated = warned(func)
   48:     decorated.__doc__ = doc
   48:     decorated._sa_warn = lambda: _warn_with_version(  # type: ignore
>>>>>>         message, version, wtype, stacklevel=3
           )
   48:     return decorated
