    1: __all__ = 'run',
       
    1: from . import coroutines
    1: from . import events
    1: from . import tasks
       
       
    1: def run(main, *, debug=None):
           """Execute the coroutine and return the result.
       
           This function runs the passed coroutine, taking care of
           managing the asyncio event loop and finalizing asynchronous
           generators.
       
           This function cannot be called when another asyncio event loop is
           running in the same thread.
       
           If debug is True, the event loop will be run in debug mode.
       
           This function always creates a new event loop and closes it at the end.
           It should be used as a main entry point for asyncio programs, and should
           ideally only be called once.
       
           Example:
       
               async def main():
                   await asyncio.sleep(1)
                   print('hello')
       
               asyncio.run(main())
           """
    1:     if events._get_running_loop() is not None:
>>>>>>         raise RuntimeError(
>>>>>>             "asyncio.run() cannot be called from a running event loop")
       
    1:     if not coroutines.iscoroutine(main):
>>>>>>         raise ValueError("a coroutine was expected, got {!r}".format(main))
       
    1:     loop = events.new_event_loop()
    1:     try:
    1:         events.set_event_loop(loop)
    1:         if debug is not None:
    1:             loop.set_debug(debug)
    1:         return loop.run_until_complete(main)
           finally:
    1:         try:
    1:             _cancel_all_tasks(loop)
    1:             loop.run_until_complete(loop.shutdown_asyncgens())
    1:             loop.run_until_complete(loop.shutdown_default_executor())
               finally:
    1:             events.set_event_loop(None)
    1:             loop.close()
       
       
    1: def _cancel_all_tasks(loop):
    1:     to_cancel = tasks.all_tasks(loop)
    1:     if not to_cancel:
    1:         return
       
>>>>>>     for task in to_cancel:
>>>>>>         task.cancel()
       
>>>>>>     loop.run_until_complete(
>>>>>>         tasks.gather(*to_cancel, loop=loop, return_exceptions=True))
       
>>>>>>     for task in to_cancel:
>>>>>>         if task.cancelled():
>>>>>>             continue
>>>>>>         if task.exception() is not None:
>>>>>>             loop.call_exception_handler({
>>>>>>                 'message': 'unhandled exception during asyncio.run() shutdown',
>>>>>>                 'exception': task.exception(),
>>>>>>                 'task': task,
                   })
