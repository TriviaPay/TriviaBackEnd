       # orm/attributes.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       # mypy: allow-untyped-defs, allow-untyped-calls
       
    1: """Defines instrumentation for class attributes and their interaction
       with instances.
       
       This module is usually not directly visible to user applications, but
       defines a large part of the ORM's interactivity.
       
       
       """
       
    1: from __future__ import annotations
       
    1: import dataclasses
    1: import operator
    1: from typing import Any
    1: from typing import Callable
    1: from typing import cast
    1: from typing import ClassVar
    1: from typing import Dict
    1: from typing import Iterable
    1: from typing import List
    1: from typing import NamedTuple
    1: from typing import Optional
    1: from typing import overload
    1: from typing import Sequence
    1: from typing import Tuple
    1: from typing import Type
    1: from typing import TYPE_CHECKING
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from . import collections
    1: from . import exc as orm_exc
    1: from . import interfaces
    1: from ._typing import insp_is_aliased_class
    1: from .base import _DeclarativeMapped
    1: from .base import ATTR_EMPTY
    1: from .base import ATTR_WAS_SET
    1: from .base import CALLABLES_OK
    1: from .base import DEFERRED_HISTORY_LOAD
    1: from .base import INCLUDE_PENDING_MUTATIONS  # noqa
    1: from .base import INIT_OK
    1: from .base import instance_dict as instance_dict
    1: from .base import instance_state as instance_state
    1: from .base import instance_str
    1: from .base import LOAD_AGAINST_COMMITTED
    1: from .base import LoaderCallableStatus
    1: from .base import manager_of_class as manager_of_class
    1: from .base import Mapped as Mapped  # noqa
    1: from .base import NEVER_SET  # noqa
    1: from .base import NO_AUTOFLUSH
    1: from .base import NO_CHANGE  # noqa
    1: from .base import NO_KEY
    1: from .base import NO_RAISE
    1: from .base import NO_VALUE
    1: from .base import NON_PERSISTENT_OK  # noqa
    1: from .base import opt_manager_of_class as opt_manager_of_class
    1: from .base import PASSIVE_CLASS_MISMATCH  # noqa
    1: from .base import PASSIVE_NO_FETCH
    1: from .base import PASSIVE_NO_FETCH_RELATED  # noqa
    1: from .base import PASSIVE_NO_INITIALIZE
    1: from .base import PASSIVE_NO_RESULT
    1: from .base import PASSIVE_OFF
    1: from .base import PASSIVE_ONLY_PERSISTENT
    1: from .base import PASSIVE_RETURN_NO_VALUE
    1: from .base import PassiveFlag
    1: from .base import RELATED_OBJECT_OK  # noqa
    1: from .base import SQL_OK  # noqa
    1: from .base import SQLORMExpression
    1: from .base import state_str
    1: from .. import event
    1: from .. import exc
    1: from .. import inspection
    1: from .. import util
    1: from ..event import dispatcher
    1: from ..event import EventTarget
    1: from ..sql import base as sql_base
    1: from ..sql import cache_key
    1: from ..sql import coercions
    1: from ..sql import roles
    1: from ..sql import visitors
    1: from ..sql.cache_key import HasCacheKey
    1: from ..sql.visitors import _TraverseInternalsType
    1: from ..sql.visitors import InternalTraversal
    1: from ..util.typing import Literal
    1: from ..util.typing import Self
    1: from ..util.typing import TypeGuard
       
    1: if TYPE_CHECKING:
>>>>>>     from ._typing import _EntityType
>>>>>>     from ._typing import _ExternalEntityType
>>>>>>     from ._typing import _InstanceDict
>>>>>>     from ._typing import _InternalEntityType
>>>>>>     from ._typing import _LoaderCallable
>>>>>>     from ._typing import _O
>>>>>>     from .collections import _AdaptedCollectionProtocol
>>>>>>     from .collections import CollectionAdapter
>>>>>>     from .interfaces import MapperProperty
>>>>>>     from .relationships import RelationshipProperty
>>>>>>     from .state import InstanceState
>>>>>>     from .util import AliasedInsp
>>>>>>     from .writeonly import WriteOnlyAttributeImpl
>>>>>>     from ..event.base import _Dispatch
>>>>>>     from ..sql._typing import _ColumnExpressionArgument
>>>>>>     from ..sql._typing import _DMLColumnArgument
>>>>>>     from ..sql._typing import _InfoType
>>>>>>     from ..sql._typing import _PropagateAttrsType
>>>>>>     from ..sql.annotation import _AnnotationDict
>>>>>>     from ..sql.elements import ColumnElement
>>>>>>     from ..sql.elements import Label
>>>>>>     from ..sql.operators import OperatorType
>>>>>>     from ..sql.selectable import FromClause
       
       
    1: _T = TypeVar("_T")
    1: _T_co = TypeVar("_T_co", bound=Any, covariant=True)
       
       
    2: _AllPendingType = Sequence[
    1:     Tuple[Optional["InstanceState[Any]"], Optional[object]]
       ]
       
       
    1: _UNKNOWN_ATTR_KEY = object()
       
       
    2: @inspection._self_inspects
    2: class QueryableAttribute(
    1:     _DeclarativeMapped[_T_co],
    1:     SQLORMExpression[_T_co],
    1:     interfaces.InspectionAttr,
    1:     interfaces.PropComparator[_T_co],
    1:     roles.JoinTargetRole,
    1:     roles.OnClauseRole,
    1:     sql_base.Immutable,
    1:     cache_key.SlotsMemoizedHasCacheKey,
    1:     util.MemoizedSlots,
    1:     EventTarget,
       ):
    1:     """Base class for :term:`descriptor` objects that intercept
           attribute events on behalf of a :class:`.MapperProperty`
           object.  The actual :class:`.MapperProperty` is accessible
           via the :attr:`.QueryableAttribute.property`
           attribute.
       
       
           .. seealso::
       
               :class:`.InstrumentedAttribute`
       
               :class:`.MapperProperty`
       
               :attr:`_orm.Mapper.all_orm_descriptors`
       
               :attr:`_orm.Mapper.attrs`
           """
       
    1:     __slots__ = (
               "class_",
               "key",
               "impl",
               "comparator",
               "property",
               "parent",
               "expression",
               "_of_type",
               "_extra_criteria",
               "_slots_dispatch",
               "_propagate_attrs",
               "_doc",
           )
       
    1:     is_attribute = True
       
    1:     dispatch: dispatcher[QueryableAttribute[_T_co]]
       
    1:     class_: _ExternalEntityType[Any]
    1:     key: str
    1:     parententity: _InternalEntityType[Any]
    1:     impl: AttributeImpl
    1:     comparator: interfaces.PropComparator[_T_co]
    1:     _of_type: Optional[_InternalEntityType[Any]]
    1:     _extra_criteria: Tuple[ColumnElement[bool], ...]
    1:     _doc: Optional[str]
       
           # PropComparator has a __visit_name__ to participate within
           # traversals.   Disambiguate the attribute vs. a comparator.
    1:     __visit_name__ = "orm_instrumented_attribute"
       
    1:     def __init__(
               self,
               class_: _ExternalEntityType[_O],
               key: str,
               parententity: _InternalEntityType[_O],
               comparator: interfaces.PropComparator[_T_co],
               impl: Optional[AttributeImpl] = None,
               of_type: Optional[_InternalEntityType[Any]] = None,
               extra_criteria: Tuple[ColumnElement[bool], ...] = (),
           ):
  519:         self.class_ = class_
  519:         self.key = key
       
  519:         self._parententity = self.parent = parententity
       
               # this attribute is non-None after mappers are set up, however in the
               # interim class manager setup, there's a check for None to see if it
               # needs to be populated, so we assign None here leaving the attribute
               # in a temporarily not-type-correct state
  519:         self.impl = impl  # type: ignore
       
  519:         assert comparator is not None
  519:         self.comparator = comparator
  519:         self._of_type = of_type
  519:         self._extra_criteria = extra_criteria
  519:         self._doc = None
       
  519:         manager = opt_manager_of_class(class_)
               # manager is None in the case of AliasedClass
  519:         if manager:
                   # propagate existing event listeners from
                   # immediate superclass
  519:             for base in manager._bases:
>>>>>>                 if key in base:
>>>>>>                     self.dispatch._update(base[key].dispatch)
>>>>>>                     if base[key].dispatch._active_history:
>>>>>>                         self.dispatch._active_history = True  # type: ignore
       
    1:     _cache_key_traversal = [
    1:         ("key", visitors.ExtendedInternalTraversal.dp_string),
    1:         ("_parententity", visitors.ExtendedInternalTraversal.dp_multi),
    1:         ("_of_type", visitors.ExtendedInternalTraversal.dp_multi),
    1:         ("_extra_criteria", visitors.InternalTraversal.dp_clauseelement_list),
           ]
       
    1:     def __reduce__(self) -> Any:
               # this method is only used in terms of the
               # sqlalchemy.ext.serializer extension
>>>>>>         return (
>>>>>>             _queryable_attribute_unreduce,
>>>>>>             (
>>>>>>                 self.key,
>>>>>>                 self._parententity.mapper.class_,
>>>>>>                 self._parententity,
>>>>>>                 self._parententity.entity,
                   ),
               )
       
    1:     @property
    1:     def _impl_uses_objects(self) -> bool:
>>>>>>         return self.impl.uses_objects
       
    1:     def get_history(
    1:         self, instance: Any, passive: PassiveFlag = PASSIVE_OFF
           ) -> History:
>>>>>>         return self.impl.get_history(
>>>>>>             instance_state(instance), instance_dict(instance), passive
               )
       
    1:     @property
    1:     def info(self) -> _InfoType:
               """Return the 'info' dictionary for the underlying SQL element.
       
               The behavior here is as follows:
       
               * If the attribute is a column-mapped property, i.e.
                 :class:`.ColumnProperty`, which is mapped directly
                 to a schema-level :class:`_schema.Column` object, this attribute
                 will return the :attr:`.SchemaItem.info` dictionary associated
                 with the core-level :class:`_schema.Column` object.
       
               * If the attribute is a :class:`.ColumnProperty` but is mapped to
                 any other kind of SQL expression other than a
                 :class:`_schema.Column`,
                 the attribute will refer to the :attr:`.MapperProperty.info`
                 dictionary associated directly with the :class:`.ColumnProperty`,
                 assuming the SQL expression itself does not have its own ``.info``
                 attribute (which should be the case, unless a user-defined SQL
                 construct has defined one).
       
               * If the attribute refers to any other kind of
                 :class:`.MapperProperty`, including :class:`.Relationship`,
                 the attribute will refer to the :attr:`.MapperProperty.info`
                 dictionary associated with that :class:`.MapperProperty`.
       
               * To access the :attr:`.MapperProperty.info` dictionary of the
                 :class:`.MapperProperty` unconditionally, including for a
                 :class:`.ColumnProperty` that's associated directly with a
                 :class:`_schema.Column`, the attribute can be referred to using
                 :attr:`.QueryableAttribute.property` attribute, as
                 ``MyClass.someattribute.property.info``.
       
               .. seealso::
       
                   :attr:`.SchemaItem.info`
       
                   :attr:`.MapperProperty.info`
       
               """
>>>>>>         return self.comparator.info
       
    1:     parent: _InternalEntityType[Any]
           """Return an inspection instance representing the parent.
       
           This will be either an instance of :class:`_orm.Mapper`
           or :class:`.AliasedInsp`, depending upon the nature
           of the parent entity which this attribute is associated
           with.
       
           """
       
    1:     expression: ColumnElement[_T_co]
           """The SQL expression object represented by this
           :class:`.QueryableAttribute`.
       
           This will typically be an instance of a :class:`_sql.ColumnElement`
           subclass representing a column expression.
       
           """
       
    1:     def _memoized_attr_expression(self) -> ColumnElement[_T]:
               annotations: _AnnotationDict
       
               # applies only to Proxy() as used by hybrid.
               # currently is an exception to typing rather than feeding through
               # non-string keys.
               # ideally Proxy() would have a separate set of methods to deal
               # with this case.
    1:         entity_namespace = self._entity_namespace
    1:         assert isinstance(entity_namespace, HasCacheKey)
       
    1:         if self.key is _UNKNOWN_ATTR_KEY:
>>>>>>             annotations = {"entity_namespace": entity_namespace}
               else:
    1:             annotations = {
    1:                 "proxy_key": self.key,
    1:                 "proxy_owner": self._parententity,
    1:                 "entity_namespace": entity_namespace,
                   }
       
    1:         ce = self.comparator.__clause_element__()
    1:         try:
    1:             if TYPE_CHECKING:
>>>>>>                 assert isinstance(ce, ColumnElement)
    1:             anno = ce._annotate
>>>>>>         except AttributeError as ae:
>>>>>>             raise exc.InvalidRequestError(
>>>>>>                 'When interpreting attribute "%s" as a SQL expression, '
                       "expected __clause_element__() to return "
>>>>>>                 "a ClauseElement object, got: %r" % (self, ce)
>>>>>>             ) from ae
               else:
    1:             return anno(annotations)
       
    1:     def _memoized_attr__propagate_attrs(self) -> _PropagateAttrsType:
               # this suits the case in coercions where we don't actually
               # call ``__clause_element__()`` but still need to get
               # resolved._propagate_attrs.  See #6558.
>>>>>>         return util.immutabledict(
>>>>>>             {
>>>>>>                 "compile_state_plugin": "orm",
>>>>>>                 "plugin_subject": self._parentmapper,
                   }
               )
       
    1:     @property
    1:     def _entity_namespace(self) -> _InternalEntityType[Any]:
    1:         return self._parententity
       
    1:     @property
    1:     def _annotations(self) -> _AnnotationDict:
>>>>>>         return self.__clause_element__()._annotations
       
    1:     def __clause_element__(self) -> ColumnElement[_T_co]:
    1:         return self.expression
       
    1:     @property
    1:     def _from_objects(self) -> List[FromClause]:
>>>>>>         return self.expression._from_objects
       
    1:     def _bulk_update_tuples(
               self, value: Any
           ) -> Sequence[Tuple[_DMLColumnArgument, Any]]:
               """Return setter tuples for a bulk UPDATE."""
       
>>>>>>         return self.comparator._bulk_update_tuples(value)
       
    1:     def adapt_to_entity(self, adapt_to_entity: AliasedInsp[Any]) -> Self:
>>>>>>         assert not self._of_type
>>>>>>         return self.__class__(
>>>>>>             adapt_to_entity.entity,
>>>>>>             self.key,
>>>>>>             impl=self.impl,
>>>>>>             comparator=self.comparator.adapt_to_entity(adapt_to_entity),
>>>>>>             parententity=adapt_to_entity,
               )
       
    1:     def of_type(self, entity: _EntityType[Any]) -> QueryableAttribute[_T]:
>>>>>>         return QueryableAttribute(
>>>>>>             self.class_,
>>>>>>             self.key,
>>>>>>             self._parententity,
>>>>>>             impl=self.impl,
>>>>>>             comparator=self.comparator.of_type(entity),
>>>>>>             of_type=inspection.inspect(entity),
>>>>>>             extra_criteria=self._extra_criteria,
               )
       
    1:     def and_(
               self, *clauses: _ColumnExpressionArgument[bool]
           ) -> QueryableAttribute[bool]:
>>>>>>         if TYPE_CHECKING:
>>>>>>             assert isinstance(self.comparator, RelationshipProperty.Comparator)
       
>>>>>>         exprs = tuple(
>>>>>>             coercions.expect(roles.WhereHavingRole, clause)
>>>>>>             for clause in util.coerce_generator_arg(clauses)
               )
       
>>>>>>         return QueryableAttribute(
>>>>>>             self.class_,
>>>>>>             self.key,
>>>>>>             self._parententity,
>>>>>>             impl=self.impl,
>>>>>>             comparator=self.comparator.and_(*exprs),
>>>>>>             of_type=self._of_type,
>>>>>>             extra_criteria=self._extra_criteria + exprs,
               )
       
    1:     def _clone(self, **kw: Any) -> QueryableAttribute[_T]:
>>>>>>         return QueryableAttribute(
>>>>>>             self.class_,
>>>>>>             self.key,
>>>>>>             self._parententity,
>>>>>>             impl=self.impl,
>>>>>>             comparator=self.comparator,
>>>>>>             of_type=self._of_type,
>>>>>>             extra_criteria=self._extra_criteria,
               )
       
    1:     def label(self, name: Optional[str]) -> Label[_T_co]:
>>>>>>         return self.__clause_element__().label(name)
       
    1:     def operate(
               self, op: OperatorType, *other: Any, **kwargs: Any
           ) -> ColumnElement[Any]:
>>>>>>         return op(self.comparator, *other, **kwargs)  # type: ignore[no-any-return]  # noqa: E501
       
    1:     def reverse_operate(
               self, op: OperatorType, other: Any, **kwargs: Any
           ) -> ColumnElement[Any]:
>>>>>>         return op(other, self.comparator, **kwargs)  # type: ignore[no-any-return]  # noqa: E501
       
    1:     def hasparent(
               self, state: InstanceState[Any], optimistic: bool = False
           ) -> bool:
>>>>>>         return self.impl.hasparent(state, optimistic=optimistic) is not False
       
    1:     def __getattr__(self, key: str) -> Any:
  521:         try:
  521:             return util.MemoizedSlots.__getattr__(self, key)
  519:         except AttributeError:
  519:             pass
       
  519:         try:
  519:             return getattr(self.comparator, key)
  519:         except AttributeError as err:
 1557:             raise AttributeError(
 1038:                 "Neither %r object nor %r object associated with %s "
                       "has an attribute %r"
  519:                 % (
  519:                     type(self).__name__,
  519:                     type(self.comparator).__name__,
  519:                     self,
  519:                     key,
                       )
  519:             ) from err
       
    1:     def __str__(self) -> str:
  519:         return f"{self.class_.__name__}.{self.key}"
       
    1:     def _memoized_attr_property(self) -> Optional[MapperProperty[Any]]:
    1:         return self.comparator.property
       
       
    1: def _queryable_attribute_unreduce(
           key: str,
           mapped_class: Type[_O],
           parententity: _InternalEntityType[_O],
           entity: _ExternalEntityType[Any],
       ) -> Any:
           # this method is only used in terms of the
           # sqlalchemy.ext.serializer extension
>>>>>>     if insp_is_aliased_class(parententity):
>>>>>>         return entity._get_from_serialized(key, mapped_class, parententity)
           else:
>>>>>>         return getattr(entity, key)
       
       
    2: class InstrumentedAttribute(QueryableAttribute[_T]):
    1:     """Class bound instrumented attribute which adds basic
           :term:`descriptor` methods.
       
           See :class:`.QueryableAttribute` for a description of most features.
       
       
           """
       
    1:     __slots__ = ()
       
    1:     inherit_cache = True
           """:meta private:"""
       
           # hack to make __doc__ writeable on instances of
           # InstrumentedAttribute, while still keeping classlevel
           # __doc__ correct
       
    1:     @util.rw_hybridproperty
    1:     def __doc__(self) -> Optional[str]:
>>>>>>         return self._doc
       
    1:     @__doc__.setter  # type: ignore
    1:     def __doc__(self, value: Optional[str]) -> None:
  519:         self._doc = value
       
    1:     @__doc__.classlevel  # type: ignore
    1:     def __doc__(cls) -> Optional[str]:
>>>>>>         return super().__doc__
       
    1:     def __set__(self, instance: object, value: Any) -> None:
   12:         self.impl.set(
    6:             instance_state(instance), instance_dict(instance), value, None
               )
       
    1:     def __delete__(self, instance: object) -> None:
>>>>>>         self.impl.delete(instance_state(instance), instance_dict(instance))
       
    1:     @overload
    1:     def __get__(
               self, instance: None, owner: Any
>>>>>>     ) -> InstrumentedAttribute[_T]: ...
       
    1:     @overload
    1:     def __get__(self, instance: object, owner: Any) -> _T: ...
       
    1:     def __get__(
               self, instance: Optional[object], owner: Any
           ) -> Union[InstrumentedAttribute[_T], _T]:
    8:         if instance is None:
    8:             return self
       
>>>>>>         dict_ = instance_dict(instance)
>>>>>>         if self.impl.supports_population and self.key in dict_:
>>>>>>             return dict_[self.key]  # type: ignore[no-any-return]
               else:
>>>>>>             try:
>>>>>>                 state = instance_state(instance)
>>>>>>             except AttributeError as err:
>>>>>>                 raise orm_exc.UnmappedInstanceError(instance) from err
>>>>>>             return self.impl.get(state, dict_)  # type: ignore[no-any-return]
       
       
    2: @dataclasses.dataclass(frozen=True)
    1: class AdHocHasEntityNamespace(HasCacheKey):
    1:     _traverse_internals: ClassVar[_TraverseInternalsType] = [
    1:         ("_entity_namespace", InternalTraversal.dp_has_cache_key),
           ]
       
           # py37 compat, no slots=True on dataclass
    1:     __slots__ = ("_entity_namespace",)
    1:     _entity_namespace: _InternalEntityType[Any]
    1:     is_mapper: ClassVar[bool] = False
    1:     is_aliased_class: ClassVar[bool] = False
       
    1:     @property
    1:     def entity_namespace(self):
>>>>>>         return self._entity_namespace.entity_namespace
       
       
    1: def create_proxied_attribute(
           descriptor: Any,
       ) -> Callable[..., QueryableAttribute[Any]]:
           """Create an QueryableAttribute / user descriptor hybrid.
       
           Returns a new QueryableAttribute type that delegates descriptor
           behavior and getattr() to the given descriptor.
           """
       
           # TODO: can move this to descriptor_props if the need for this
           # function is removed from ext/hybrid.py
       
>>>>>>     class Proxy(QueryableAttribute[Any]):
               """Presents the :class:`.QueryableAttribute` interface as a
               proxy on top of a Python descriptor / :class:`.PropComparator`
               combination.
       
               """
       
>>>>>>         _extra_criteria = ()
       
               # the attribute error catches inside of __getattr__ basically create a
               # singularity if you try putting slots on this too
               # __slots__ = ("descriptor", "original_property", "_comparator")
       
>>>>>>         def __init__(
                   self,
                   class_,
                   key,
                   descriptor,
                   comparator,
                   adapt_to_entity=None,
                   doc=None,
                   original_property=None,
               ):
>>>>>>             self.class_ = class_
>>>>>>             self.key = key
>>>>>>             self.descriptor = descriptor
>>>>>>             self.original_property = original_property
>>>>>>             self._comparator = comparator
>>>>>>             self._adapt_to_entity = adapt_to_entity
>>>>>>             self._doc = self.__doc__ = doc
       
>>>>>>         @property
>>>>>>         def _parententity(self):
>>>>>>             return inspection.inspect(self.class_, raiseerr=False)
       
>>>>>>         @property
>>>>>>         def parent(self):
>>>>>>             return inspection.inspect(self.class_, raiseerr=False)
       
>>>>>>         _is_internal_proxy = True
       
>>>>>>         _cache_key_traversal = [
>>>>>>             ("key", visitors.ExtendedInternalTraversal.dp_string),
>>>>>>             ("_parententity", visitors.ExtendedInternalTraversal.dp_multi),
               ]
       
>>>>>>         @property
>>>>>>         def _impl_uses_objects(self):
>>>>>>             return (
>>>>>>                 self.original_property is not None
>>>>>>                 and getattr(self.class_, self.key).impl.uses_objects
                   )
       
>>>>>>         @property
>>>>>>         def _entity_namespace(self):
>>>>>>             if hasattr(self._comparator, "_parententity"):
>>>>>>                 return self._comparator._parententity
                   else:
                       # used by hybrid attributes which try to remain
                       # agnostic of any ORM concepts like mappers
>>>>>>                 return AdHocHasEntityNamespace(self._parententity)
       
>>>>>>         @property
>>>>>>         def property(self):
>>>>>>             return self.comparator.property
       
>>>>>>         @util.memoized_property
>>>>>>         def comparator(self):
>>>>>>             if callable(self._comparator):
>>>>>>                 self._comparator = self._comparator()
>>>>>>             if self._adapt_to_entity:
>>>>>>                 self._comparator = self._comparator.adapt_to_entity(
>>>>>>                     self._adapt_to_entity
                       )
>>>>>>             return self._comparator
       
>>>>>>         def adapt_to_entity(self, adapt_to_entity):
>>>>>>             return self.__class__(
>>>>>>                 adapt_to_entity.entity,
>>>>>>                 self.key,
>>>>>>                 self.descriptor,
>>>>>>                 self._comparator,
>>>>>>                 adapt_to_entity,
                   )
       
>>>>>>         def _clone(self, **kw):
>>>>>>             return self.__class__(
>>>>>>                 self.class_,
>>>>>>                 self.key,
>>>>>>                 self.descriptor,
>>>>>>                 self._comparator,
>>>>>>                 adapt_to_entity=self._adapt_to_entity,
>>>>>>                 original_property=self.original_property,
                   )
       
>>>>>>         def __get__(self, instance, owner):
>>>>>>             retval = self.descriptor.__get__(instance, owner)
                   # detect if this is a plain Python @property, which just returns
                   # itself for class level access.  If so, then return us.
                   # Otherwise, return the object returned by the descriptor.
>>>>>>             if retval is self.descriptor and instance is None:
>>>>>>                 return self
                   else:
>>>>>>                 return retval
       
>>>>>>         def __str__(self) -> str:
>>>>>>             return f"{self.class_.__name__}.{self.key}"
       
>>>>>>         def __getattr__(self, attribute):
                   """Delegate __getattr__ to the original descriptor and/or
                   comparator."""
       
                   # this is unfortunately very complicated, and is easily prone
                   # to recursion overflows when implementations of related
                   # __getattr__ schemes are changed
       
>>>>>>             try:
>>>>>>                 return util.MemoizedSlots.__getattr__(self, attribute)
>>>>>>             except AttributeError:
>>>>>>                 pass
       
>>>>>>             try:
>>>>>>                 return getattr(descriptor, attribute)
>>>>>>             except AttributeError as err:
>>>>>>                 if attribute == "comparator":
>>>>>>                     raise AttributeError("comparator") from err
>>>>>>                 try:
                           # comparator itself might be unreachable
>>>>>>                     comparator = self.comparator
>>>>>>                 except AttributeError as err2:
>>>>>>                     raise AttributeError(
>>>>>>                         "Neither %r object nor unconfigured comparator "
                               "object associated with %s has an attribute %r"
>>>>>>                         % (type(descriptor).__name__, self, attribute)
>>>>>>                     ) from err2
                       else:
>>>>>>                     try:
>>>>>>                         return getattr(comparator, attribute)
>>>>>>                     except AttributeError as err3:
>>>>>>                         raise AttributeError(
>>>>>>                             "Neither %r object nor %r object "
                                   "associated with %s has an attribute %r"
>>>>>>                             % (
>>>>>>                                 type(descriptor).__name__,
>>>>>>                                 type(comparator).__name__,
>>>>>>                                 self,
>>>>>>                                 attribute,
                                   )
>>>>>>                         ) from err3
       
>>>>>>     Proxy.__name__ = type(descriptor).__name__ + "Proxy"
       
>>>>>>     util.monkeypatch_proxied_specials(
>>>>>>         Proxy, type(descriptor), name="descriptor", from_instance=descriptor
           )
>>>>>>     return Proxy
       
       
    1: OP_REMOVE = util.symbol("REMOVE")
    1: OP_APPEND = util.symbol("APPEND")
    1: OP_REPLACE = util.symbol("REPLACE")
    1: OP_BULK_REPLACE = util.symbol("BULK_REPLACE")
    1: OP_MODIFIED = util.symbol("MODIFIED")
       
       
    2: class AttributeEventToken:
    1:     """A token propagated throughout the course of a chain of attribute
           events.
       
           Serves as an indicator of the source of the event and also provides
           a means of controlling propagation across a chain of attribute
           operations.
       
           The :class:`.Event` object is sent as the ``initiator`` argument
           when dealing with events such as :meth:`.AttributeEvents.append`,
           :meth:`.AttributeEvents.set`,
           and :meth:`.AttributeEvents.remove`.
       
           The :class:`.Event` object is currently interpreted by the backref
           event handlers, and is used to control the propagation of operations
           across two mutually-dependent attributes.
       
           .. versionchanged:: 2.0  Changed the name from ``AttributeEvent``
              to ``AttributeEventToken``.
       
           :attribute impl: The :class:`.AttributeImpl` which is the current event
            initiator.
       
           :attribute op: The symbol :attr:`.OP_APPEND`, :attr:`.OP_REMOVE`,
            :attr:`.OP_REPLACE`, or :attr:`.OP_BULK_REPLACE`, indicating the
            source operation.
       
           """
       
    1:     __slots__ = "impl", "op", "parent_token"
       
    1:     def __init__(self, attribute_impl: AttributeImpl, op: util.symbol):
 1604:         self.impl = attribute_impl
 1604:         self.op = op
 1604:         self.parent_token = self.impl.parent_token
       
    1:     def __eq__(self, other):
>>>>>>         return (
>>>>>>             isinstance(other, AttributeEventToken)
>>>>>>             and other.impl is self.impl
>>>>>>             and other.op == self.op
               )
       
    1:     @property
    1:     def key(self):
>>>>>>         return self.impl.key
       
    1:     def hasparent(self, state):
>>>>>>         return self.impl.hasparent(state)
       
       
    1: AttributeEvent = AttributeEventToken  # legacy
    1: Event = AttributeEventToken  # legacy
       
       
    2: class AttributeImpl:
    1:     """internal implementation for instrumented attributes."""
       
    1:     collection: bool
    1:     default_accepts_scalar_loader: bool
    1:     uses_objects: bool
    1:     supports_population: bool
    1:     dynamic: bool
       
    1:     _is_has_collection_adapter = False
       
    1:     _replace_token: AttributeEventToken
    1:     _remove_token: AttributeEventToken
    1:     _append_token: AttributeEventToken
       
    1:     def __init__(
               self,
               class_: _ExternalEntityType[_O],
               key: str,
               callable_: Optional[_LoaderCallable],
               dispatch: _Dispatch[QueryableAttribute[Any]],
               trackparent: bool = False,
               compare_function: Optional[Callable[..., bool]] = None,
               active_history: bool = False,
               parent_token: Optional[AttributeEventToken] = None,
               load_on_unexpire: bool = True,
               send_modified_events: bool = True,
               accepts_scalar_loader: Optional[bool] = None,
               **kwargs: Any,
           ):
               r"""Construct an AttributeImpl.
       
               :param \class_: associated class
       
               :param key: string name of the attribute
       
               :param \callable_:
                 optional function which generates a callable based on a parent
                 instance, which produces the "default" values for a scalar or
                 collection attribute when it's first accessed, if not present
                 already.
       
               :param trackparent:
                 if True, attempt to track if an instance has a parent attached
                 to it via this attribute.
       
               :param compare_function:
                 a function that compares two values which are normally
                 assignable to this attribute.
       
               :param active_history:
                 indicates that get_history() should always return the "old" value,
                 even if it means executing a lazy callable upon attribute change.
       
               :param parent_token:
                 Usually references the MapperProperty, used as a key for
                 the hasparent() function to identify an "owning" attribute.
                 Allows multiple AttributeImpls to all match a single
                 owner attribute.
       
               :param load_on_unexpire:
                 if False, don't include this attribute in a load-on-expired
                 operation, i.e. the "expired_attribute_loader" process.
                 The attribute can still be in the "expired" list and be
                 considered to be "expired".   Previously, this flag was called
                 "expire_missing" and is only used by a deferred column
                 attribute.
       
               :param send_modified_events:
                 if False, the InstanceState._modified_event method will have no
                 effect; this means the attribute will never show up as changed in a
                 history entry.
       
               """
  519:         self.class_ = class_
  519:         self.key = key
  519:         self.callable_ = callable_
  519:         self.dispatch = dispatch
  519:         self.trackparent = trackparent
  519:         self.parent_token = parent_token or self
  519:         self.send_modified_events = send_modified_events
  519:         if compare_function is None:
   97:             self.is_equal = operator.eq
               else:
  422:             self.is_equal = compare_function
       
  519:         if accepts_scalar_loader is not None:
>>>>>>             self.accepts_scalar_loader = accepts_scalar_loader
               else:
  519:             self.accepts_scalar_loader = self.default_accepts_scalar_loader
       
  519:         _deferred_history = kwargs.pop("_deferred_history", False)
  519:         self._deferred_history = _deferred_history
       
  519:         if active_history:
   50:             self.dispatch._active_history = True
       
  519:         self.load_on_unexpire = load_on_unexpire
  519:         self._modified_token = AttributeEventToken(self, OP_MODIFIED)
       
    1:     __slots__ = (
               "class_",
               "key",
               "callable_",
               "dispatch",
               "trackparent",
               "parent_token",
               "send_modified_events",
               "is_equal",
               "load_on_unexpire",
               "_modified_token",
               "accepts_scalar_loader",
               "_deferred_history",
           )
       
    1:     def __str__(self) -> str:
>>>>>>         return f"{self.class_.__name__}.{self.key}"
       
    1:     def _get_active_history(self):
               """Backwards compat for impl.active_history"""
       
>>>>>>         return self.dispatch._active_history
       
    1:     def _set_active_history(self, value):
>>>>>>         self.dispatch._active_history = value
       
    1:     active_history = property(_get_active_history, _set_active_history)
       
    1:     def hasparent(
               self, state: InstanceState[Any], optimistic: bool = False
           ) -> bool:
               """Return the boolean value of a `hasparent` flag attached to
               the given state.
       
               The `optimistic` flag determines what the default return value
               should be if no `hasparent` flag can be located.
       
               As this function is used to determine if an instance is an
               *orphan*, instances that were loaded from storage should be
               assumed to not be orphans, until a True/False value for this
               flag is set.
       
               An instance attribute that is loaded by a callable function
               will also not have a `hasparent` flag.
       
               """
>>>>>>         msg = "This AttributeImpl is not configured to track parents."
>>>>>>         assert self.trackparent, msg
       
>>>>>>         return (
>>>>>>             state.parents.get(id(self.parent_token), optimistic) is not False
               )
       
    1:     def sethasparent(
               self,
               state: InstanceState[Any],
               parent_state: InstanceState[Any],
               value: bool,
           ) -> None:
               """Set a boolean flag on the given item corresponding to
               whether or not it is attached to a parent object via the
               attribute represented by this ``InstrumentedAttribute``.
       
               """
>>>>>>         msg = "This AttributeImpl is not configured to track parents."
>>>>>>         assert self.trackparent, msg
       
>>>>>>         id_ = id(self.parent_token)
>>>>>>         if value:
>>>>>>             state.parents[id_] = parent_state
               else:
>>>>>>             if id_ in state.parents:
>>>>>>                 last_parent = state.parents[id_]
       
>>>>>>                 if (
>>>>>>                     last_parent is not False
>>>>>>                     and last_parent.key != parent_state.key
                       ):
>>>>>>                     if last_parent.obj() is None:
>>>>>>                         raise orm_exc.StaleDataError(
>>>>>>                             "Removing state %s from parent "
                                   "state %s along attribute '%s', "
                                   "but the parent record "
                                   "has gone stale, can't be sure this "
                                   "is the most recent parent."
>>>>>>                             % (
>>>>>>                                 state_str(state),
>>>>>>                                 state_str(parent_state),
>>>>>>                                 self.key,
                                   )
                               )
       
>>>>>>                     return
       
>>>>>>             state.parents[id_] = False
       
    1:     def get_history(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> History:
>>>>>>         raise NotImplementedError()
       
    1:     def get_all_pending(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         passive: PassiveFlag = PASSIVE_NO_INITIALIZE,
           ) -> _AllPendingType:
               """Return a list of tuples of (state, obj)
               for all objects in this attribute's current state
               + history.
       
               Only applies to object-based attributes.
       
               This is an inlining of existing functionality
               which roughly corresponds to:
       
                   get_state_history(
                               state,
                               key,
                               passive=PASSIVE_NO_INITIALIZE).sum()
       
               """
>>>>>>         raise NotImplementedError()
       
    1:     def _default_value(
               self, state: InstanceState[Any], dict_: _InstanceDict
           ) -> Any:
               """Produce an empty value for an uninitialized scalar attribute."""
       
>>>>>>         assert self.key not in dict_, (
>>>>>>             "_default_value should only be invoked for an "
                   "uninitialized or expired attribute"
               )
       
>>>>>>         value = None
>>>>>>         for fn in self.dispatch.init_scalar:
>>>>>>             ret = fn(state, value, dict_)
>>>>>>             if ret is not ATTR_EMPTY:
>>>>>>                 value = ret
       
>>>>>>         return value
       
    1:     def get(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> Any:
               """Retrieve a value from the given object.
               If a callable is assembled on this object's attribute, and
               passive is False, the callable will be executed and the
               resulting value will be set as the new value for this attribute.
               """
   72:         if self.key in dict_:
    2:             return dict_[self.key]
               else:
                   # if history present, don't load
   70:             key = self.key
   70:             if (
   70:                 key not in state.committed_state
>>>>>>                 or state.committed_state[key] is NO_VALUE
                   ):
   70:                 if not passive & CALLABLES_OK:
   68:                     return PASSIVE_NO_RESULT
       
    2:                 value = self._fire_loader_callables(state, key, passive)
       
    2:                 if value is PASSIVE_NO_RESULT or value is NO_VALUE:
>>>>>>                     return value
    2:                 elif value is ATTR_WAS_SET:
>>>>>>                     try:
>>>>>>                         return dict_[key]
>>>>>>                     except KeyError as err:
                               # TODO: no test coverage here.
>>>>>>                         raise KeyError(
>>>>>>                             "Deferred loader for attribute "
                                   "%r failed to populate "
>>>>>>                             "correctly" % key
>>>>>>                         ) from err
    2:                 elif value is not ATTR_EMPTY:
>>>>>>                     return self.set_committed_value(state, dict_, value)
       
    2:             if not passive & INIT_OK:
    2:                 return NO_VALUE
                   else:
>>>>>>                 return self._default_value(state, dict_)
       
    1:     def _fire_loader_callables(
               self, state: InstanceState[Any], key: str, passive: PassiveFlag
           ) -> Any:
    6:         if (
    2:             self.accepts_scalar_loader
    2:             and self.load_on_unexpire
    2:             and key in state.expired_attributes
               ):
>>>>>>             return state._load_expired(state, passive)
    2:         elif key in state.callables:
>>>>>>             callable_ = state.callables[key]
>>>>>>             return callable_(state, passive)
    2:         elif self.callable_:
>>>>>>             return self.callable_(state, passive)
               else:
    2:             return ATTR_EMPTY
       
    1:     def append(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
               initiator: Optional[AttributeEventToken],
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> None:
>>>>>>         self.set(state, dict_, value, initiator, passive=passive)
       
    1:     def remove(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
               initiator: Optional[AttributeEventToken],
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> None:
>>>>>>         self.set(
>>>>>>             state, dict_, None, initiator, passive=passive, check_old=value
               )
       
    1:     def pop(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
               initiator: Optional[AttributeEventToken],
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> None:
>>>>>>         self.set(
>>>>>>             state,
>>>>>>             dict_,
>>>>>>             None,
>>>>>>             initiator,
>>>>>>             passive=passive,
>>>>>>             check_old=value,
>>>>>>             pop=True,
               )
       
    1:     def set(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
    1:         initiator: Optional[AttributeEventToken] = None,
    1:         passive: PassiveFlag = PASSIVE_OFF,
    1:         check_old: Any = None,
    1:         pop: bool = False,
           ) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def delete(self, state: InstanceState[Any], dict_: _InstanceDict) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def get_committed_value(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> Any:
               """return the unchanged value of this attribute"""
       
>>>>>>         if self.key in state.committed_state:
>>>>>>             value = state.committed_state[self.key]
>>>>>>             if value is NO_VALUE:
>>>>>>                 return None
                   else:
>>>>>>                 return value
               else:
>>>>>>             return self.get(state, dict_, passive=passive)
       
    1:     def set_committed_value(self, state, dict_, value):
               """set an attribute value on the given instance and 'commit' it."""
       
>>>>>>         dict_[self.key] = value
>>>>>>         state._commit(dict_, [self.key])
>>>>>>         return value
       
       
    2: class ScalarAttributeImpl(AttributeImpl):
    1:     """represents a scalar value-holding InstrumentedAttribute."""
       
    1:     default_accepts_scalar_loader = True
    1:     uses_objects = False
    1:     supports_population = True
    1:     collection = False
    1:     dynamic = False
       
    1:     __slots__ = "_replace_token", "_append_token", "_remove_token"
       
    1:     def __init__(self, *arg, **kw):
  472:         super().__init__(*arg, **kw)
  944:         self._replace_token = self._append_token = AttributeEventToken(
  472:             self, OP_REPLACE
               )
  472:         self._remove_token = AttributeEventToken(self, OP_REMOVE)
       
    1:     def delete(self, state: InstanceState[Any], dict_: _InstanceDict) -> None:
>>>>>>         if self.dispatch._active_history:
>>>>>>             old = self.get(state, dict_, PASSIVE_RETURN_NO_VALUE)
               else:
>>>>>>             old = dict_.get(self.key, NO_VALUE)
       
>>>>>>         if self.dispatch.remove:
>>>>>>             self.fire_remove_event(state, dict_, old, self._remove_token)
>>>>>>         state._modified_event(dict_, self, old)
       
>>>>>>         existing = dict_.pop(self.key, NO_VALUE)
>>>>>>         if (
>>>>>>             existing is NO_VALUE
>>>>>>             and old is NO_VALUE
>>>>>>             and not state.expired
>>>>>>             and self.key not in state.expired_attributes
               ):
>>>>>>             raise AttributeError("%s object does not have a value" % self)
       
    1:     def get_history(
               self,
               state: InstanceState[Any],
               dict_: Dict[str, Any],
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> History:
    2:         if self.key in dict_:
>>>>>>             return History.from_scalar_attribute(self, state, dict_[self.key])
    2:         elif self.key in state.committed_state:
>>>>>>             return History.from_scalar_attribute(self, state, NO_VALUE)
               else:
    2:             if passive & INIT_OK:
>>>>>>                 passive ^= INIT_OK
    2:             current = self.get(state, dict_, passive=passive)
    2:             if current is PASSIVE_NO_RESULT:
    2:                 return HISTORY_BLANK
                   else:
>>>>>>                 return History.from_scalar_attribute(self, state, current)
       
    1:     def set(
               self,
               state: InstanceState[Any],
               dict_: Dict[str, Any],
               value: Any,
    1:         initiator: Optional[AttributeEventToken] = None,
    1:         passive: PassiveFlag = PASSIVE_OFF,
    1:         check_old: Optional[object] = None,
    1:         pop: bool = False,
           ) -> None:
    6:         if self.dispatch._active_history:
>>>>>>             old = self.get(state, dict_, PASSIVE_RETURN_NO_VALUE)
               else:
    6:             old = dict_.get(self.key, NO_VALUE)
       
    6:         if self.dispatch.set:
>>>>>>             value = self.fire_replace_event(
>>>>>>                 state, dict_, value, old, initiator
                   )
    6:         state._modified_event(dict_, self, old)
    6:         dict_[self.key] = value
       
    1:     def fire_replace_event(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: _T,
               previous: Any,
               initiator: Optional[AttributeEventToken],
           ) -> _T:
>>>>>>         for fn in self.dispatch.set:
>>>>>>             value = fn(
>>>>>>                 state, value, previous, initiator or self._replace_token
                   )
>>>>>>         return value
       
    1:     def fire_remove_event(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
               initiator: Optional[AttributeEventToken],
           ) -> None:
>>>>>>         for fn in self.dispatch.remove:
>>>>>>             fn(state, value, initiator or self._remove_token)
       
       
    2: class ScalarObjectAttributeImpl(ScalarAttributeImpl):
    1:     """represents a scalar-holding InstrumentedAttribute,
           where the target object is also instrumented.
       
           Adds events to delete/set operations.
       
           """
       
    1:     default_accepts_scalar_loader = False
    1:     uses_objects = True
    1:     supports_population = True
    1:     collection = False
       
    1:     __slots__ = ()
       
    1:     def delete(self, state: InstanceState[Any], dict_: _InstanceDict) -> None:
>>>>>>         if self.dispatch._active_history:
>>>>>>             old = self.get(
>>>>>>                 state,
>>>>>>                 dict_,
>>>>>>                 passive=PASSIVE_ONLY_PERSISTENT
>>>>>>                 | NO_AUTOFLUSH
>>>>>>                 | LOAD_AGAINST_COMMITTED,
                   )
               else:
>>>>>>             old = self.get(
>>>>>>                 state,
>>>>>>                 dict_,
>>>>>>                 passive=PASSIVE_NO_FETCH ^ INIT_OK
>>>>>>                 | LOAD_AGAINST_COMMITTED
>>>>>>                 | NO_RAISE,
                   )
       
>>>>>>         self.fire_remove_event(state, dict_, old, self._remove_token)
       
>>>>>>         existing = dict_.pop(self.key, NO_VALUE)
       
               # if the attribute is expired, we currently have no way to tell
               # that an object-attribute was expired vs. not loaded.   So
               # for this test, we look to see if the object has a DB identity.
>>>>>>         if (
>>>>>>             existing is NO_VALUE
>>>>>>             and old is not PASSIVE_NO_RESULT
>>>>>>             and state.key is None
               ):
>>>>>>             raise AttributeError("%s object does not have a value" % self)
       
    1:     def get_history(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> History:
    2:         if self.key in dict_:
>>>>>>             current = dict_[self.key]
               else:
    2:             if passive & INIT_OK:
>>>>>>                 passive ^= INIT_OK
    2:             current = self.get(state, dict_, passive=passive)
    2:             if current is PASSIVE_NO_RESULT:
    2:                 return HISTORY_BLANK
       
>>>>>>         if not self._deferred_history:
>>>>>>             return History.from_object_attribute(self, state, current)
               else:
>>>>>>             original = state.committed_state.get(self.key, _NO_HISTORY)
>>>>>>             if original is PASSIVE_NO_RESULT:
>>>>>>                 loader_passive = passive | (
>>>>>>                     PASSIVE_ONLY_PERSISTENT
>>>>>>                     | NO_AUTOFLUSH
>>>>>>                     | LOAD_AGAINST_COMMITTED
>>>>>>                     | NO_RAISE
>>>>>>                     | DEFERRED_HISTORY_LOAD
                       )
>>>>>>                 original = self._fire_loader_callables(
>>>>>>                     state, self.key, loader_passive
                       )
>>>>>>             return History.from_object_attribute(
>>>>>>                 self, state, current, original=original
                   )
       
    1:     def get_all_pending(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         passive: PassiveFlag = PASSIVE_NO_INITIALIZE,
           ) -> _AllPendingType:
    2:         if self.key in dict_:
>>>>>>             current = dict_[self.key]
    2:         elif passive & CALLABLES_OK:
>>>>>>             current = self.get(state, dict_, passive=passive)
               else:
    2:             return []
       
               ret: _AllPendingType
       
               # can't use __hash__(), can't use __eq__() here
>>>>>>         if (
>>>>>>             current is not None
>>>>>>             and current is not PASSIVE_NO_RESULT
>>>>>>             and current is not NO_VALUE
               ):
>>>>>>             ret = [(instance_state(current), current)]
               else:
>>>>>>             ret = [(None, None)]
       
>>>>>>         if self.key in state.committed_state:
>>>>>>             original = state.committed_state[self.key]
>>>>>>             if (
>>>>>>                 original is not None
>>>>>>                 and original is not PASSIVE_NO_RESULT
>>>>>>                 and original is not NO_VALUE
>>>>>>                 and original is not current
                   ):
>>>>>>                 ret.append((instance_state(original), original))
>>>>>>         return ret
       
    1:     def set(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
    1:         initiator: Optional[AttributeEventToken] = None,
    1:         passive: PassiveFlag = PASSIVE_OFF,
    1:         check_old: Any = None,
    1:         pop: bool = False,
           ) -> None:
               """Set a value on the given InstanceState."""
       
>>>>>>         if self.dispatch._active_history:
>>>>>>             old = self.get(
>>>>>>                 state,
>>>>>>                 dict_,
>>>>>>                 passive=PASSIVE_ONLY_PERSISTENT
>>>>>>                 | NO_AUTOFLUSH
>>>>>>                 | LOAD_AGAINST_COMMITTED,
                   )
               else:
>>>>>>             old = self.get(
>>>>>>                 state,
>>>>>>                 dict_,
>>>>>>                 passive=PASSIVE_NO_FETCH ^ INIT_OK
>>>>>>                 | LOAD_AGAINST_COMMITTED
>>>>>>                 | NO_RAISE,
                   )
       
>>>>>>         if (
>>>>>>             check_old is not None
>>>>>>             and old is not PASSIVE_NO_RESULT
>>>>>>             and check_old is not old
               ):
>>>>>>             if pop:
>>>>>>                 return
                   else:
>>>>>>                 raise ValueError(
>>>>>>                     "Object %s not associated with %s on attribute '%s'"
>>>>>>                     % (instance_str(check_old), state_str(state), self.key)
                       )
       
>>>>>>         value = self.fire_replace_event(state, dict_, value, old, initiator)
>>>>>>         dict_[self.key] = value
       
    1:     def fire_remove_event(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
               initiator: Optional[AttributeEventToken],
           ) -> None:
>>>>>>         if self.trackparent and value not in (
>>>>>>             None,
>>>>>>             PASSIVE_NO_RESULT,
>>>>>>             NO_VALUE,
               ):
>>>>>>             self.sethasparent(instance_state(value), state, False)
       
>>>>>>         for fn in self.dispatch.remove:
>>>>>>             fn(state, value, initiator or self._remove_token)
       
>>>>>>         state._modified_event(dict_, self, value)
       
    1:     def fire_replace_event(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: _T,
               previous: Any,
               initiator: Optional[AttributeEventToken],
           ) -> _T:
>>>>>>         if self.trackparent:
>>>>>>             if previous is not value and previous not in (
>>>>>>                 None,
>>>>>>                 PASSIVE_NO_RESULT,
>>>>>>                 NO_VALUE,
                   ):
>>>>>>                 self.sethasparent(instance_state(previous), state, False)
       
>>>>>>         for fn in self.dispatch.set:
>>>>>>             value = fn(
>>>>>>                 state, value, previous, initiator or self._replace_token
                   )
       
>>>>>>         state._modified_event(dict_, self, previous)
       
>>>>>>         if self.trackparent:
>>>>>>             if value is not None:
>>>>>>                 self.sethasparent(instance_state(value), state, True)
       
>>>>>>         return value
       
       
    2: class HasCollectionAdapter:
    1:     __slots__ = ()
       
    1:     collection: bool
    1:     _is_has_collection_adapter = True
       
    1:     def _dispose_previous_collection(
               self,
               state: InstanceState[Any],
               collection: _AdaptedCollectionProtocol,
               adapter: CollectionAdapter,
               fire_event: bool,
           ) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     @overload
    1:     def get_collection(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               user_data: Literal[None] = ...,
               passive: Literal[PassiveFlag.PASSIVE_OFF] = ...,
>>>>>>     ) -> CollectionAdapter: ...
       
    1:     @overload
    1:     def get_collection(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               user_data: _AdaptedCollectionProtocol = ...,
               passive: PassiveFlag = ...,
>>>>>>     ) -> CollectionAdapter: ...
       
    1:     @overload
    1:     def get_collection(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               user_data: Optional[_AdaptedCollectionProtocol] = ...,
               passive: PassiveFlag = ...,
           ) -> Union[
               Literal[LoaderCallableStatus.PASSIVE_NO_RESULT], CollectionAdapter
>>>>>>     ]: ...
       
    1:     def get_collection(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         user_data: Optional[_AdaptedCollectionProtocol] = None,
    1:         passive: PassiveFlag = PassiveFlag.PASSIVE_OFF,
           ) -> Union[
               Literal[LoaderCallableStatus.PASSIVE_NO_RESULT], CollectionAdapter
           ]:
>>>>>>         raise NotImplementedError()
       
    1:     def set(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
    1:         initiator: Optional[AttributeEventToken] = None,
    1:         passive: PassiveFlag = PassiveFlag.PASSIVE_OFF,
    1:         check_old: Any = None,
    1:         pop: bool = False,
    1:         _adapt: bool = True,
           ) -> None:
>>>>>>         raise NotImplementedError()
       
       
    1: if TYPE_CHECKING:
       
>>>>>>     def _is_collection_attribute_impl(
               impl: AttributeImpl,
>>>>>>     ) -> TypeGuard[CollectionAttributeImpl]: ...
       
       else:
    1:     _is_collection_attribute_impl = operator.attrgetter("collection")
       
       
    2: class CollectionAttributeImpl(HasCollectionAdapter, AttributeImpl):
    1:     """A collection-holding attribute that instruments changes in membership.
       
           Only handles collections of instrumented objects.
       
           InstrumentedCollectionAttribute holds an arbitrary, user-specified
           container object (defaulting to a list) and brokers access to the
           CollectionAdapter, a "view" onto that object that presents consistent bag
           semantics to the orm layer independent of the user data implementation.
       
           """
       
    1:     uses_objects = True
    1:     collection = True
    1:     default_accepts_scalar_loader = False
    1:     supports_population = True
    1:     dynamic = False
       
    1:     _bulk_replace_token: AttributeEventToken
       
    1:     __slots__ = (
               "copy",
               "collection_factory",
               "_append_token",
               "_remove_token",
               "_bulk_replace_token",
               "_duck_typed_as",
           )
       
    1:     def __init__(
               self,
               class_,
               key,
               callable_,
               dispatch,
               typecallable=None,
               trackparent=False,
               copy_function=None,
               compare_function=None,
               **kwargs,
           ):
  188:         super().__init__(
   47:             class_,
   47:             key,
   47:             callable_,
   47:             dispatch,
   47:             trackparent=trackparent,
   47:             compare_function=compare_function,
   47:             **kwargs,
               )
       
   47:         if copy_function is None:
   47:             copy_function = self.__copy
   47:         self.copy = copy_function
   47:         self.collection_factory = typecallable
   47:         self._append_token = AttributeEventToken(self, OP_APPEND)
   47:         self._remove_token = AttributeEventToken(self, OP_REMOVE)
   47:         self._bulk_replace_token = AttributeEventToken(self, OP_BULK_REPLACE)
   94:         self._duck_typed_as = util.duck_type_collection(
   47:             self.collection_factory()
               )
       
   47:         if getattr(self.collection_factory, "_sa_linker", None):
       
>>>>>>             @event.listens_for(self, "init_collection")
>>>>>>             def link(target, collection, collection_adapter):
>>>>>>                 collection._sa_linker(collection_adapter)
       
>>>>>>             @event.listens_for(self, "dispose_collection")
>>>>>>             def unlink(target, collection, collection_adapter):
>>>>>>                 collection._sa_linker(None)
       
    1:     def __copy(self, item):
>>>>>>         return [y for y in collections.collection_adapter(item)]
       
    1:     def get_history(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> History:
   64:         current = self.get(state, dict_, passive=passive)
       
   64:         if current is PASSIVE_NO_RESULT:
  128:             if (
   64:                 passive & PassiveFlag.INCLUDE_PENDING_MUTATIONS
   64:                 and self.key in state._pending_mutations
                   ):
>>>>>>                 pending = state._pending_mutations[self.key]
>>>>>>                 return pending.merge_with_history(HISTORY_BLANK)
                   else:
   64:                 return HISTORY_BLANK
               else:
>>>>>>             if passive & PassiveFlag.INCLUDE_PENDING_MUTATIONS:
                       # this collection is loaded / present.  should not be any
                       # pending mutations
>>>>>>                 assert self.key not in state._pending_mutations
       
>>>>>>             return History.from_collection(self, state, current)
       
    1:     def get_all_pending(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         passive: PassiveFlag = PASSIVE_NO_INITIALIZE,
           ) -> _AllPendingType:
               # NOTE: passive is ignored here at the moment
       
   64:         if self.key not in dict_:
   64:             return []
       
>>>>>>         current = dict_[self.key]
>>>>>>         current = getattr(current, "_sa_adapter")
       
>>>>>>         if self.key in state.committed_state:
>>>>>>             original = state.committed_state[self.key]
>>>>>>             if original is not NO_VALUE:
>>>>>>                 current_states = [
>>>>>>                     ((c is not None) and instance_state(c) or None, c)
>>>>>>                     for c in current
                       ]
>>>>>>                 original_states = [
>>>>>>                     ((c is not None) and instance_state(c) or None, c)
>>>>>>                     for c in original
                       ]
       
>>>>>>                 current_set = dict(current_states)
>>>>>>                 original_set = dict(original_states)
       
>>>>>>                 return (
>>>>>>                     [
>>>>>>                         (s, o)
>>>>>>                         for s, o in current_states
>>>>>>                         if s not in original_set
                           ]
>>>>>>                     + [(s, o) for s, o in current_states if s in original_set]
>>>>>>                     + [
>>>>>>                         (s, o)
>>>>>>                         for s, o in original_states
>>>>>>                         if s not in current_set
                           ]
                       )
       
>>>>>>         return [(instance_state(o), o) for o in current]
       
    1:     def fire_append_event(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: _T,
               initiator: Optional[AttributeEventToken],
               key: Optional[Any],
           ) -> _T:
>>>>>>         for fn in self.dispatch.append:
>>>>>>             value = fn(state, value, initiator or self._append_token, key=key)
       
>>>>>>         state._modified_event(dict_, self, NO_VALUE, True)
       
>>>>>>         if self.trackparent and value is not None:
>>>>>>             self.sethasparent(instance_state(value), state, True)
       
>>>>>>         return value
       
    1:     def fire_append_wo_mutation_event(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: _T,
               initiator: Optional[AttributeEventToken],
               key: Optional[Any],
           ) -> _T:
>>>>>>         for fn in self.dispatch.append_wo_mutation:
>>>>>>             value = fn(state, value, initiator or self._append_token, key=key)
       
>>>>>>         return value
       
    1:     def fire_pre_remove_event(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               initiator: Optional[AttributeEventToken],
               key: Optional[Any],
           ) -> None:
               """A special event used for pop() operations.
       
               The "remove" event needs to have the item to be removed passed to
               it, which in the case of pop from a set, we don't have a way to access
               the item before the operation.   the event is used for all pop()
               operations (even though set.pop is the one where it is really needed).
       
               """
>>>>>>         state._modified_event(dict_, self, NO_VALUE, True)
       
    1:     def fire_remove_event(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
               initiator: Optional[AttributeEventToken],
               key: Optional[Any],
           ) -> None:
>>>>>>         if self.trackparent and value is not None:
>>>>>>             self.sethasparent(instance_state(value), state, False)
       
>>>>>>         for fn in self.dispatch.remove:
>>>>>>             fn(state, value, initiator or self._remove_token, key=key)
       
>>>>>>         state._modified_event(dict_, self, NO_VALUE, True)
       
    1:     def delete(self, state: InstanceState[Any], dict_: _InstanceDict) -> None:
>>>>>>         if self.key not in dict_:
>>>>>>             return
       
>>>>>>         state._modified_event(dict_, self, NO_VALUE, True)
       
>>>>>>         collection = self.get_collection(state, state.dict)
>>>>>>         collection.clear_with_event()
       
               # key is always present because we checked above.  e.g.
               # del is a no-op if collection not present.
>>>>>>         del dict_[self.key]
       
    1:     def _default_value(
               self, state: InstanceState[Any], dict_: _InstanceDict
           ) -> _AdaptedCollectionProtocol:
               """Produce an empty collection for an un-initialized attribute"""
       
>>>>>>         assert self.key not in dict_, (
>>>>>>             "_default_value should only be invoked for an "
                   "uninitialized or expired attribute"
               )
       
>>>>>>         if self.key in state._empty_collections:
>>>>>>             return state._empty_collections[self.key]
       
>>>>>>         adapter, user_data = self._initialize_collection(state)
>>>>>>         adapter._set_empty(user_data)
>>>>>>         return user_data
       
    1:     def _initialize_collection(
               self, state: InstanceState[Any]
           ) -> Tuple[CollectionAdapter, _AdaptedCollectionProtocol]:
>>>>>>         adapter, collection = state.manager.initialize_collection(
>>>>>>             self.key, state, self.collection_factory
               )
       
>>>>>>         self.dispatch.init_collection(state, collection, adapter)
       
>>>>>>         return adapter, collection
       
    1:     def append(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
               initiator: Optional[AttributeEventToken],
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> None:
>>>>>>         collection = self.get_collection(
>>>>>>             state, dict_, user_data=None, passive=passive
               )
>>>>>>         if collection is PASSIVE_NO_RESULT:
>>>>>>             value = self.fire_append_event(
>>>>>>                 state, dict_, value, initiator, key=NO_KEY
                   )
>>>>>>             assert (
>>>>>>                 self.key not in dict_
>>>>>>             ), "Collection was loaded during event handling."
>>>>>>             state._get_pending_mutation(self.key).append(value)
               else:
>>>>>>             if TYPE_CHECKING:
>>>>>>                 assert isinstance(collection, CollectionAdapter)
>>>>>>             collection.append_with_event(value, initiator)
       
    1:     def remove(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
               initiator: Optional[AttributeEventToken],
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> None:
>>>>>>         collection = self.get_collection(
>>>>>>             state, state.dict, user_data=None, passive=passive
               )
>>>>>>         if collection is PASSIVE_NO_RESULT:
>>>>>>             self.fire_remove_event(state, dict_, value, initiator, key=NO_KEY)
>>>>>>             assert (
>>>>>>                 self.key not in dict_
>>>>>>             ), "Collection was loaded during event handling."
>>>>>>             state._get_pending_mutation(self.key).remove(value)
               else:
>>>>>>             if TYPE_CHECKING:
>>>>>>                 assert isinstance(collection, CollectionAdapter)
>>>>>>             collection.remove_with_event(value, initiator)
       
    1:     def pop(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
               initiator: Optional[AttributeEventToken],
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> None:
>>>>>>         try:
                   # TODO: better solution here would be to add
                   # a "popper" role to collections.py to complement
                   # "remover".
>>>>>>             self.remove(state, dict_, value, initiator, passive=passive)
>>>>>>         except (ValueError, KeyError, IndexError):
>>>>>>             pass
       
    1:     def set(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               value: Any,
    1:         initiator: Optional[AttributeEventToken] = None,
    1:         passive: PassiveFlag = PassiveFlag.PASSIVE_OFF,
    1:         check_old: Any = None,
    1:         pop: bool = False,
    1:         _adapt: bool = True,
           ) -> None:
>>>>>>         iterable = orig_iterable = value
>>>>>>         new_keys = None
       
               # pulling a new collection first so that an adaptation exception does
               # not trigger a lazy load of the old collection.
>>>>>>         new_collection, user_data = self._initialize_collection(state)
>>>>>>         if _adapt:
>>>>>>             if new_collection._converter is not None:
>>>>>>                 iterable = new_collection._converter(iterable)
                   else:
>>>>>>                 setting_type = util.duck_type_collection(iterable)
>>>>>>                 receiving_type = self._duck_typed_as
       
>>>>>>                 if setting_type is not receiving_type:
>>>>>>                     given = (
>>>>>>                         iterable is None
>>>>>>                         and "None"
>>>>>>                         or iterable.__class__.__name__
                           )
>>>>>>                     wanted = self._duck_typed_as.__name__
>>>>>>                     raise TypeError(
>>>>>>                         "Incompatible collection type: %s is not %s-like"
>>>>>>                         % (given, wanted)
                           )
       
                       # If the object is an adapted collection, return the (iterable)
                       # adapter.
>>>>>>                 if hasattr(iterable, "_sa_iterator"):
>>>>>>                     iterable = iterable._sa_iterator()
>>>>>>                 elif setting_type is dict:
>>>>>>                     new_keys = list(iterable)
>>>>>>                     iterable = iterable.values()
                       else:
>>>>>>                     iterable = iter(iterable)
>>>>>>         elif util.duck_type_collection(iterable) is dict:
>>>>>>             new_keys = list(value)
       
>>>>>>         new_values = list(iterable)
       
>>>>>>         evt = self._bulk_replace_token
       
>>>>>>         self.dispatch.bulk_replace(state, new_values, evt, keys=new_keys)
       
               # propagate NO_RAISE in passive through to the get() for the
               # existing object (ticket #8862)
>>>>>>         old = self.get(
>>>>>>             state,
>>>>>>             dict_,
>>>>>>             passive=PASSIVE_ONLY_PERSISTENT ^ (passive & PassiveFlag.NO_RAISE),
               )
>>>>>>         if old is PASSIVE_NO_RESULT:
>>>>>>             old = self._default_value(state, dict_)
>>>>>>         elif old is orig_iterable:
                   # ignore re-assignment of the current collection, as happens
                   # implicitly with in-place operators (foo.collection |= other)
>>>>>>             return
       
               # place a copy of "old" in state.committed_state
>>>>>>         state._modified_event(dict_, self, old, True)
       
>>>>>>         old_collection = old._sa_adapter
       
>>>>>>         dict_[self.key] = user_data
       
>>>>>>         collections.bulk_replace(
>>>>>>             new_values, old_collection, new_collection, initiator=evt
               )
       
>>>>>>         self._dispose_previous_collection(state, old, old_collection, True)
       
    1:     def _dispose_previous_collection(
               self,
               state: InstanceState[Any],
               collection: _AdaptedCollectionProtocol,
               adapter: CollectionAdapter,
               fire_event: bool,
           ) -> None:
>>>>>>         del collection._sa_adapter
       
               # discarding old collection make sure it is not referenced in empty
               # collections.
>>>>>>         state._empty_collections.pop(self.key, None)
>>>>>>         if fire_event:
>>>>>>             self.dispatch.dispose_collection(state, collection, adapter)
       
    1:     def _invalidate_collection(
               self, collection: _AdaptedCollectionProtocol
           ) -> None:
>>>>>>         adapter = getattr(collection, "_sa_adapter")
>>>>>>         adapter.invalidated = True
       
    1:     def set_committed_value(
               self, state: InstanceState[Any], dict_: _InstanceDict, value: Any
           ) -> _AdaptedCollectionProtocol:
               """Set an attribute value on the given instance and 'commit' it."""
       
>>>>>>         collection, user_data = self._initialize_collection(state)
       
>>>>>>         if value:
>>>>>>             collection.append_multiple_without_event(value)
       
>>>>>>         state.dict[self.key] = user_data
       
>>>>>>         state._commit(dict_, [self.key])
       
>>>>>>         if self.key in state._pending_mutations:
                   # pending items exist.  issue a modified event,
                   # add/remove new items.
>>>>>>             state._modified_event(dict_, self, user_data, True)
       
>>>>>>             pending = state._pending_mutations.pop(self.key)
>>>>>>             added = pending.added_items
>>>>>>             removed = pending.deleted_items
>>>>>>             for item in added:
>>>>>>                 collection.append_without_event(item)
>>>>>>             for item in removed:
>>>>>>                 collection.remove_without_event(item)
       
>>>>>>         return user_data
       
    1:     @overload
    1:     def get_collection(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               user_data: Literal[None] = ...,
               passive: Literal[PassiveFlag.PASSIVE_OFF] = ...,
>>>>>>     ) -> CollectionAdapter: ...
       
    1:     @overload
    1:     def get_collection(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
               user_data: _AdaptedCollectionProtocol = ...,
               passive: PassiveFlag = ...,
>>>>>>     ) -> CollectionAdapter: ...
       
    1:     @overload
    1:     def get_collection(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         user_data: Optional[_AdaptedCollectionProtocol] = ...,
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> Union[
               Literal[LoaderCallableStatus.PASSIVE_NO_RESULT], CollectionAdapter
>>>>>>     ]: ...
       
    1:     def get_collection(
               self,
               state: InstanceState[Any],
               dict_: _InstanceDict,
    1:         user_data: Optional[_AdaptedCollectionProtocol] = None,
    1:         passive: PassiveFlag = PASSIVE_OFF,
           ) -> Union[
               Literal[LoaderCallableStatus.PASSIVE_NO_RESULT], CollectionAdapter
           ]:
               """Retrieve the CollectionAdapter associated with the given state.
       
               if user_data is None, retrieves it from the state using normal
               "get()" rules, which will fire lazy callables or return the "empty"
               collection value.
       
               """
>>>>>>         if user_data is None:
>>>>>>             fetch_user_data = self.get(state, dict_, passive=passive)
>>>>>>             if fetch_user_data is LoaderCallableStatus.PASSIVE_NO_RESULT:
>>>>>>                 return fetch_user_data
                   else:
>>>>>>                 user_data = cast("_AdaptedCollectionProtocol", fetch_user_data)
       
>>>>>>         return user_data._sa_adapter
       
       
    1: def backref_listeners(
           attribute: QueryableAttribute[Any], key: str, uselist: bool
       ) -> None:
           """Apply listeners to synchronize a two-way relationship."""
       
           # use easily recognizable names for stack traces.
       
           # in the sections marked "tokens to test for a recursive loop",
           # this is somewhat brittle and very performance-sensitive logic
           # that is specific to how we might arrive at each event.  a marker
           # that can target us directly to arguments being invoked against
           # the impl might be simpler, but could interfere with other systems.
       
   94:     parent_token = attribute.impl.parent_token
   94:     parent_impl = attribute.impl
       
   94:     def _acceptable_key_err(child_state, initiator, child_impl):
>>>>>>         raise ValueError(
>>>>>>             "Bidirectional attribute conflict detected: "
                   'Passing object %s to attribute "%s" '
                   'triggers a modify event on attribute "%s" '
                   'via the backref "%s".'
>>>>>>             % (
>>>>>>                 state_str(child_state),
>>>>>>                 initiator.parent_token,
>>>>>>                 child_impl.parent_token,
>>>>>>                 attribute.impl.parent_token,
                   )
               )
       
   94:     def emit_backref_from_scalar_set_event(
               state, child, oldchild, initiator, **kw
           ):
>>>>>>         if oldchild is child:
>>>>>>             return child
>>>>>>         if (
>>>>>>             oldchild is not None
>>>>>>             and oldchild is not PASSIVE_NO_RESULT
>>>>>>             and oldchild is not NO_VALUE
               ):
                   # With lazy=None, there's no guarantee that the full collection is
                   # present when updating via a backref.
>>>>>>             old_state, old_dict = (
>>>>>>                 instance_state(oldchild),
>>>>>>                 instance_dict(oldchild),
                   )
>>>>>>             impl = old_state.manager[key].impl
       
                   # tokens to test for a recursive loop.
>>>>>>             if not impl.collection and not impl.dynamic:
>>>>>>                 check_recursive_token = impl._replace_token
                   else:
>>>>>>                 check_recursive_token = impl._remove_token
       
>>>>>>             if initiator is not check_recursive_token:
>>>>>>                 impl.pop(
>>>>>>                     old_state,
>>>>>>                     old_dict,
>>>>>>                     state.obj(),
>>>>>>                     parent_impl._append_token,
>>>>>>                     passive=PASSIVE_NO_FETCH,
                       )
       
>>>>>>         if child is not None:
>>>>>>             child_state, child_dict = (
>>>>>>                 instance_state(child),
>>>>>>                 instance_dict(child),
                   )
>>>>>>             child_impl = child_state.manager[key].impl
       
>>>>>>             if (
>>>>>>                 initiator.parent_token is not parent_token
>>>>>>                 and initiator.parent_token is not child_impl.parent_token
                   ):
>>>>>>                 _acceptable_key_err(state, initiator, child_impl)
       
                   # tokens to test for a recursive loop.
>>>>>>             check_append_token = child_impl._append_token
>>>>>>             check_bulk_replace_token = (
>>>>>>                 child_impl._bulk_replace_token
>>>>>>                 if _is_collection_attribute_impl(child_impl)
>>>>>>                 else None
                   )
       
>>>>>>             if (
>>>>>>                 initiator is not check_append_token
>>>>>>                 and initiator is not check_bulk_replace_token
                   ):
>>>>>>                 child_impl.append(
>>>>>>                     child_state,
>>>>>>                     child_dict,
>>>>>>                     state.obj(),
>>>>>>                     initiator,
>>>>>>                     passive=PASSIVE_NO_FETCH,
                       )
>>>>>>         return child
       
   94:     def emit_backref_from_collection_append_event(
               state, child, initiator, **kw
           ):
>>>>>>         if child is None:
>>>>>>             return
       
>>>>>>         child_state, child_dict = instance_state(child), instance_dict(child)
>>>>>>         child_impl = child_state.manager[key].impl
       
>>>>>>         if (
>>>>>>             initiator.parent_token is not parent_token
>>>>>>             and initiator.parent_token is not child_impl.parent_token
               ):
>>>>>>             _acceptable_key_err(state, initiator, child_impl)
       
               # tokens to test for a recursive loop.
>>>>>>         check_append_token = child_impl._append_token
>>>>>>         check_bulk_replace_token = (
>>>>>>             child_impl._bulk_replace_token
>>>>>>             if _is_collection_attribute_impl(child_impl)
>>>>>>             else None
               )
       
>>>>>>         if (
>>>>>>             initiator is not check_append_token
>>>>>>             and initiator is not check_bulk_replace_token
               ):
>>>>>>             child_impl.append(
>>>>>>                 child_state,
>>>>>>                 child_dict,
>>>>>>                 state.obj(),
>>>>>>                 initiator,
>>>>>>                 passive=PASSIVE_NO_FETCH,
                   )
>>>>>>         return child
       
   94:     def emit_backref_from_collection_remove_event(
               state, child, initiator, **kw
           ):
>>>>>>         if (
>>>>>>             child is not None
>>>>>>             and child is not PASSIVE_NO_RESULT
>>>>>>             and child is not NO_VALUE
               ):
>>>>>>             child_state, child_dict = (
>>>>>>                 instance_state(child),
>>>>>>                 instance_dict(child),
                   )
>>>>>>             child_impl = child_state.manager[key].impl
       
                   check_replace_token: Optional[AttributeEventToken]
       
                   # tokens to test for a recursive loop.
>>>>>>             if not child_impl.collection and not child_impl.dynamic:
>>>>>>                 check_remove_token = child_impl._remove_token
>>>>>>                 check_replace_token = child_impl._replace_token
>>>>>>                 check_for_dupes_on_remove = uselist and not parent_impl.dynamic
                   else:
>>>>>>                 check_remove_token = child_impl._remove_token
>>>>>>                 check_replace_token = (
>>>>>>                     child_impl._bulk_replace_token
>>>>>>                     if _is_collection_attribute_impl(child_impl)
>>>>>>                     else None
                       )
>>>>>>                 check_for_dupes_on_remove = False
       
>>>>>>             if (
>>>>>>                 initiator is not check_remove_token
>>>>>>                 and initiator is not check_replace_token
                   ):
>>>>>>                 if not check_for_dupes_on_remove or not util.has_dupes(
                           # when this event is called, the item is usually
                           # present in the list, except for a pop() operation.
>>>>>>                     state.dict[parent_impl.key],
>>>>>>                     child,
                       ):
>>>>>>                     child_impl.pop(
>>>>>>                         child_state,
>>>>>>                         child_dict,
>>>>>>                         state.obj(),
>>>>>>                         initiator,
>>>>>>                         passive=PASSIVE_NO_FETCH,
                           )
       
   94:     if uselist:
   94:         event.listen(
   47:             attribute,
   47:             "append",
   47:             emit_backref_from_collection_append_event,
   47:             retval=True,
   47:             raw=True,
   47:             include_key=True,
               )
           else:
   94:         event.listen(
   47:             attribute,
   47:             "set",
   47:             emit_backref_from_scalar_set_event,
   47:             retval=True,
   47:             raw=True,
   47:             include_key=True,
               )
           # TODO: need coverage in test/orm/ of remove event
  188:     event.listen(
   94:         attribute,
   94:         "remove",
   94:         emit_backref_from_collection_remove_event,
   94:         retval=True,
   94:         raw=True,
   94:         include_key=True,
           )
       
       
    1: _NO_HISTORY = util.symbol("NO_HISTORY")
    1: _NO_STATE_SYMBOLS = frozenset([id(PASSIVE_NO_RESULT), id(NO_VALUE)])
       
       
    2: class History(NamedTuple):
    1:     """A 3-tuple of added, unchanged and deleted values,
           representing the changes which have occurred on an instrumented
           attribute.
       
           The easiest way to get a :class:`.History` object for a particular
           attribute on an object is to use the :func:`_sa.inspect` function::
       
               from sqlalchemy import inspect
       
               hist = inspect(myobject).attrs.myattribute.history
       
           Each tuple member is an iterable sequence:
       
           * ``added`` - the collection of items added to the attribute (the first
             tuple element).
       
           * ``unchanged`` - the collection of items that have not changed on the
             attribute (the second tuple element).
       
           * ``deleted`` - the collection of items that have been removed from the
             attribute (the third tuple element).
       
           """
       
    1:     added: Union[Tuple[()], List[Any]]
    1:     unchanged: Union[Tuple[()], List[Any]]
    1:     deleted: Union[Tuple[()], List[Any]]
       
    1:     def __bool__(self) -> bool:
  198:         return self != HISTORY_BLANK
       
    1:     def empty(self) -> bool:
               """Return True if this :class:`.History` has no changes
               and no existing, unchanged state.
       
               """
       
>>>>>>         return not bool((self.added or self.deleted) or self.unchanged)
       
    1:     def sum(self) -> Sequence[Any]:
               """Return a collection of added + unchanged + deleted."""
       
>>>>>>         return (
>>>>>>             (self.added or []) + (self.unchanged or []) + (self.deleted or [])
               )
       
    1:     def non_deleted(self) -> Sequence[Any]:
               """Return a collection of added + unchanged."""
       
>>>>>>         return (self.added or []) + (self.unchanged or [])
       
    1:     def non_added(self) -> Sequence[Any]:
               """Return a collection of unchanged + deleted."""
       
>>>>>>         return (self.unchanged or []) + (self.deleted or [])
       
    1:     def has_changes(self) -> bool:
               """Return True if this :class:`.History` has changes."""
       
>>>>>>         return bool(self.added or self.deleted)
       
    1:     def _merge(self, added: Iterable[Any], deleted: Iterable[Any]) -> History:
>>>>>>         return History(
>>>>>>             list(self.added) + list(added),
>>>>>>             self.unchanged,
>>>>>>             list(self.deleted) + list(deleted),
               )
       
    1:     def as_state(self) -> History:
>>>>>>         return History(
>>>>>>             [
>>>>>>                 (c is not None) and instance_state(c) or None
>>>>>>                 for c in self.added
                   ],
>>>>>>             [
>>>>>>                 (c is not None) and instance_state(c) or None
>>>>>>                 for c in self.unchanged
                   ],
>>>>>>             [
>>>>>>                 (c is not None) and instance_state(c) or None
>>>>>>                 for c in self.deleted
                   ],
               )
       
    1:     @classmethod
    1:     def from_scalar_attribute(
               cls,
               attribute: ScalarAttributeImpl,
               state: InstanceState[Any],
               current: Any,
           ) -> History:
>>>>>>         original = state.committed_state.get(attribute.key, _NO_HISTORY)
       
               deleted: Union[Tuple[()], List[Any]]
       
>>>>>>         if original is _NO_HISTORY:
>>>>>>             if current is NO_VALUE:
>>>>>>                 return cls((), (), ())
                   else:
>>>>>>                 return cls((), [current], ())
               # don't let ClauseElement expressions here trip things up
>>>>>>         elif (
>>>>>>             current is not NO_VALUE
>>>>>>             and attribute.is_equal(current, original) is True
               ):
>>>>>>             return cls((), [current], ())
               else:
                   # current convention on native scalars is to not
                   # include information
                   # about missing previous value in "deleted", but
                   # we do include None, which helps in some primary
                   # key situations
>>>>>>             if id(original) in _NO_STATE_SYMBOLS:
>>>>>>                 deleted = ()
                       # indicate a "del" operation occurred when we don't have
                       # the previous value as: ([None], (), ())
>>>>>>                 if id(current) in _NO_STATE_SYMBOLS:
>>>>>>                     current = None
                   else:
>>>>>>                 deleted = [original]
>>>>>>             if current is NO_VALUE:
>>>>>>                 return cls((), (), deleted)
                   else:
>>>>>>                 return cls([current], (), deleted)
       
    1:     @classmethod
    1:     def from_object_attribute(
               cls,
               attribute: ScalarObjectAttributeImpl,
               state: InstanceState[Any],
               current: Any,
    1:         original: Any = _NO_HISTORY,
           ) -> History:
               deleted: Union[Tuple[()], List[Any]]
       
>>>>>>         if original is _NO_HISTORY:
>>>>>>             original = state.committed_state.get(attribute.key, _NO_HISTORY)
       
>>>>>>         if original is _NO_HISTORY:
>>>>>>             if current is NO_VALUE:
>>>>>>                 return cls((), (), ())
                   else:
>>>>>>                 return cls((), [current], ())
>>>>>>         elif current is original and current is not NO_VALUE:
>>>>>>             return cls((), [current], ())
               else:
                   # current convention on related objects is to not
                   # include information
                   # about missing previous value in "deleted", and
                   # to also not include None - the dependency.py rules
                   # ignore the None in any case.
>>>>>>             if id(original) in _NO_STATE_SYMBOLS or original is None:
>>>>>>                 deleted = ()
                       # indicate a "del" operation occurred when we don't have
                       # the previous value as: ([None], (), ())
>>>>>>                 if id(current) in _NO_STATE_SYMBOLS:
>>>>>>                     current = None
                   else:
>>>>>>                 deleted = [original]
>>>>>>             if current is NO_VALUE:
>>>>>>                 return cls((), (), deleted)
                   else:
>>>>>>                 return cls([current], (), deleted)
       
    1:     @classmethod
    1:     def from_collection(
               cls,
               attribute: CollectionAttributeImpl,
               state: InstanceState[Any],
               current: Any,
           ) -> History:
>>>>>>         original = state.committed_state.get(attribute.key, _NO_HISTORY)
>>>>>>         if current is NO_VALUE:
>>>>>>             return cls((), (), ())
       
>>>>>>         current = getattr(current, "_sa_adapter")
>>>>>>         if original is NO_VALUE:
>>>>>>             return cls(list(current), (), ())
>>>>>>         elif original is _NO_HISTORY:
>>>>>>             return cls((), list(current), ())
               else:
>>>>>>             current_states = [
>>>>>>                 ((c is not None) and instance_state(c) or None, c)
>>>>>>                 for c in current
                   ]
>>>>>>             original_states = [
>>>>>>                 ((c is not None) and instance_state(c) or None, c)
>>>>>>                 for c in original
                   ]
       
>>>>>>             current_set = dict(current_states)
>>>>>>             original_set = dict(original_states)
       
>>>>>>             return cls(
>>>>>>                 [o for s, o in current_states if s not in original_set],
>>>>>>                 [o for s, o in current_states if s in original_set],
>>>>>>                 [o for s, o in original_states if s not in current_set],
                   )
       
       
    1: HISTORY_BLANK = History((), (), ())
       
       
    1: def get_history(
    1:     obj: object, key: str, passive: PassiveFlag = PASSIVE_OFF
       ) -> History:
           """Return a :class:`.History` record for the given object
           and attribute key.
       
           This is the **pre-flush** history for a given attribute, which is
           reset each time the :class:`.Session` flushes changes to the
           current database transaction.
       
           .. note::
       
               Prefer to use the :attr:`.AttributeState.history` and
               :meth:`.AttributeState.load_history` accessors to retrieve the
               :class:`.History` for instance attributes.
       
       
           :param obj: an object whose class is instrumented by the
             attributes package.
       
           :param key: string attribute name.
       
           :param passive: indicates loading behavior for the attribute
              if the value is not already present.   This is a
              bitflag attribute, which defaults to the symbol
              :attr:`.PASSIVE_OFF` indicating all necessary SQL
              should be emitted.
       
           .. seealso::
       
               :attr:`.AttributeState.history`
       
               :meth:`.AttributeState.load_history` - retrieve history
               using loader callables if the value is not locally present.
       
           """
       
>>>>>>     return get_state_history(instance_state(obj), key, passive)
       
       
    1: def get_state_history(
    1:     state: InstanceState[Any], key: str, passive: PassiveFlag = PASSIVE_OFF
       ) -> History:
>>>>>>     return state.get_history(key, passive)
       
       
    1: def has_parent(
           cls: Type[_O], obj: _O, key: str, optimistic: bool = False
       ) -> bool:
           """TODO"""
>>>>>>     manager = manager_of_class(cls)
>>>>>>     state = instance_state(obj)
>>>>>>     return manager.has_parent(state, key, optimistic)
       
       
    1: def register_attribute(
           class_: Type[_O],
           key: str,
           *,
           comparator: interfaces.PropComparator[_T],
           parententity: _InternalEntityType[_O],
    1:     doc: Optional[str] = None,
           **kw: Any,
       ) -> InstrumentedAttribute[_T]:
>>>>>>     desc = register_descriptor(
>>>>>>         class_, key, comparator=comparator, parententity=parententity, doc=doc
           )
>>>>>>     register_attribute_impl(class_, key, **kw)
>>>>>>     return desc
       
       
    1: def register_attribute_impl(
           class_: Type[_O],
           key: str,
           uselist: bool = False,
           callable_: Optional[_LoaderCallable] = None,
           useobject: bool = False,
           impl_class: Optional[Type[AttributeImpl]] = None,
           backref: Optional[str] = None,
           **kw: Any,
       ) -> QueryableAttribute[Any]:
  519:     manager = manager_of_class(class_)
  519:     if uselist:
   47:         factory = kw.pop("typecallable", None)
   94:         typecallable = manager.instrument_collection_class(
   47:             key, factory or list
               )
           else:
  472:         typecallable = kw.pop("typecallable", None)
       
 1038:     dispatch = cast(
  519:         "_Dispatch[QueryableAttribute[Any]]", manager[key].dispatch
           )  # noqa: E501
       
           impl: AttributeImpl
       
  519:     if impl_class:
               # TODO: this appears to be the WriteOnlyAttributeImpl /
               # DynamicAttributeImpl constructor which is hardcoded
>>>>>>         impl = cast("Type[WriteOnlyAttributeImpl]", impl_class)(
>>>>>>             class_, key, dispatch, **kw
               )
  519:     elif uselist:
  188:         impl = CollectionAttributeImpl(
  141:             class_, key, callable_, dispatch, typecallable=typecallable, **kw
               )
  472:     elif useobject:
  150:         impl = ScalarObjectAttributeImpl(
  100:             class_, key, callable_, dispatch, **kw
               )
           else:
  422:         impl = ScalarAttributeImpl(class_, key, callable_, dispatch, **kw)
       
  519:     manager[key].impl = impl
       
  519:     if backref:
>>>>>>         backref_listeners(manager[key], backref, uselist)
       
  519:     manager.post_configure_attribute(key)
  519:     return manager[key]
       
       
    1: def register_descriptor(
           class_: Type[Any],
           key: str,
           *,
           comparator: interfaces.PropComparator[_T],
           parententity: _InternalEntityType[Any],
    1:     doc: Optional[str] = None,
       ) -> InstrumentedAttribute[_T]:
  519:     manager = manager_of_class(class_)
       
 1038:     descriptor = InstrumentedAttribute(
  519:         class_, key, comparator=comparator, parententity=parententity
           )
       
  519:     descriptor.__doc__ = doc  # type: ignore
       
  519:     manager.instrument_attribute(key, descriptor)
  519:     return descriptor
       
       
    1: def unregister_attribute(class_: Type[Any], key: str) -> None:
>>>>>>     manager_of_class(class_).uninstrument_attribute(key)
       
       
    1: def init_collection(obj: object, key: str) -> CollectionAdapter:
           """Initialize a collection attribute and return the collection adapter.
       
           This function is used to provide direct access to collection internals
           for a previously unloaded attribute.  e.g.::
       
               collection_adapter = init_collection(someobject, 'elements')
               for elem in values:
                   collection_adapter.append_without_event(elem)
       
           For an easier way to do the above, see
           :func:`~sqlalchemy.orm.attributes.set_committed_value`.
       
           :param obj: a mapped object
       
           :param key: string attribute name where the collection is located.
       
           """
>>>>>>     state = instance_state(obj)
>>>>>>     dict_ = state.dict
>>>>>>     return init_state_collection(state, dict_, key)
       
       
    1: def init_state_collection(
           state: InstanceState[Any], dict_: _InstanceDict, key: str
       ) -> CollectionAdapter:
           """Initialize a collection attribute and return the collection adapter.
       
           Discards any existing collection which may be there.
       
           """
>>>>>>     attr = state.manager[key].impl
       
>>>>>>     if TYPE_CHECKING:
>>>>>>         assert isinstance(attr, HasCollectionAdapter)
       
>>>>>>     old = dict_.pop(key, None)  # discard old collection
>>>>>>     if old is not None:
>>>>>>         old_collection = old._sa_adapter
>>>>>>         attr._dispose_previous_collection(state, old, old_collection, False)
       
>>>>>>     user_data = attr._default_value(state, dict_)
>>>>>>     adapter: CollectionAdapter = attr.get_collection(
>>>>>>         state, dict_, user_data, passive=PassiveFlag.PASSIVE_NO_FETCH
           )
>>>>>>     adapter._reset_empty()
       
>>>>>>     return adapter
       
       
    1: def set_committed_value(instance, key, value):
           """Set the value of an attribute with no history events.
       
           Cancels any previous history present.  The value should be
           a scalar value for scalar-holding attributes, or
           an iterable for any collection-holding attribute.
       
           This is the same underlying method used when a lazy loader
           fires off and loads additional data from the database.
           In particular, this method can be used by application code
           which has loaded additional attributes or collections through
           separate queries, which can then be attached to an instance
           as though it were part of its original loaded state.
       
           """
>>>>>>     state, dict_ = instance_state(instance), instance_dict(instance)
>>>>>>     state.manager[key].impl.set_committed_value(state, dict_, value)
       
       
    1: def set_attribute(
           instance: object,
           key: str,
           value: Any,
           initiator: Optional[AttributeEventToken] = None,
       ) -> None:
           """Set the value of an attribute, firing history events.
       
           This function may be used regardless of instrumentation
           applied directly to the class, i.e. no descriptors are required.
           Custom attribute management schemes will need to make usage
           of this method to establish attribute state as understood
           by SQLAlchemy.
       
           :param instance: the object that will be modified
       
           :param key: string name of the attribute
       
           :param value: value to assign
       
           :param initiator: an instance of :class:`.Event` that would have
            been propagated from a previous event listener.  This argument
            is used when the :func:`.set_attribute` function is being used within
            an existing event listening function where an :class:`.Event` object
            is being supplied; the object may be used to track the origin of the
            chain of events.
       
            .. versionadded:: 1.2.3
       
           """
>>>>>>     state, dict_ = instance_state(instance), instance_dict(instance)
>>>>>>     state.manager[key].impl.set(state, dict_, value, initiator)
       
       
    1: def get_attribute(instance: object, key: str) -> Any:
           """Get the value of an attribute, firing any callables required.
       
           This function may be used regardless of instrumentation
           applied directly to the class, i.e. no descriptors are required.
           Custom attribute management schemes will need to make usage
           of this method to make usage of attribute state as understood
           by SQLAlchemy.
       
           """
>>>>>>     state, dict_ = instance_state(instance), instance_dict(instance)
>>>>>>     return state.manager[key].impl.get(state, dict_)
       
       
    1: def del_attribute(instance: object, key: str) -> None:
           """Delete the value of an attribute, firing history events.
       
           This function may be used regardless of instrumentation
           applied directly to the class, i.e. no descriptors are required.
           Custom attribute management schemes will need to make usage
           of this method to establish attribute state as understood
           by SQLAlchemy.
       
           """
>>>>>>     state, dict_ = instance_state(instance), instance_dict(instance)
>>>>>>     state.manager[key].impl.delete(state, dict_)
       
       
    1: def flag_modified(instance: object, key: str) -> None:
           """Mark an attribute on an instance as 'modified'.
       
           This sets the 'modified' flag on the instance and
           establishes an unconditional change event for the given attribute.
           The attribute must have a value present, else an
           :class:`.InvalidRequestError` is raised.
       
           To mark an object "dirty" without referring to any specific attribute
           so that it is considered within a flush, use the
           :func:`.attributes.flag_dirty` call.
       
           .. seealso::
       
               :func:`.attributes.flag_dirty`
       
           """
>>>>>>     state, dict_ = instance_state(instance), instance_dict(instance)
>>>>>>     impl = state.manager[key].impl
>>>>>>     impl.dispatch.modified(state, impl._modified_token)
>>>>>>     state._modified_event(dict_, impl, NO_VALUE, is_userland=True)
       
       
    1: def flag_dirty(instance: object) -> None:
           """Mark an instance as 'dirty' without any specific attribute mentioned.
       
           This is a special operation that will allow the object to travel through
           the flush process for interception by events such as
           :meth:`.SessionEvents.before_flush`.   Note that no SQL will be emitted in
           the flush process for an object that has no changes, even if marked dirty
           via this method.  However, a :meth:`.SessionEvents.before_flush` handler
           will be able to see the object in the :attr:`.Session.dirty` collection and
           may establish changes on it, which will then be included in the SQL
           emitted.
       
           .. versionadded:: 1.2
       
           .. seealso::
       
               :func:`.attributes.flag_modified`
       
           """
       
>>>>>>     state, dict_ = instance_state(instance), instance_dict(instance)
>>>>>>     state._modified_event(dict_, None, NO_VALUE, is_userland=True)
