    1: from typing import (
           Any,
           BinaryIO,
           Callable,
           Dict,
           Iterable,
           Optional,
           Type,
           TypeVar,
           cast,
       )
       
    1: from fastapi._compat import (
           PYDANTIC_V2,
           CoreSchema,
           GetJsonSchemaHandler,
           JsonSchemaValue,
           with_info_plain_validator_function,
       )
    1: from starlette.datastructures import URL as URL  # noqa: F401
    1: from starlette.datastructures import Address as Address  # noqa: F401
    1: from starlette.datastructures import FormData as FormData  # noqa: F401
    1: from starlette.datastructures import Headers as Headers  # noqa: F401
    1: from starlette.datastructures import QueryParams as QueryParams  # noqa: F401
    1: from starlette.datastructures import State as State  # noqa: F401
    1: from starlette.datastructures import UploadFile as StarletteUploadFile
    1: from typing_extensions import Annotated, Doc  # type: ignore [attr-defined]
       
       
    2: class UploadFile(StarletteUploadFile):
    1:     """
           A file uploaded in a request.
       
           Define it as a *path operation function* (or dependency) parameter.
       
           If you are using a regular `def` function, you can use the `upload_file.file`
           attribute to access the raw standard Python file (blocking, not async), useful and
           needed for non-async code.
       
           Read more about it in the
           [FastAPI docs for Request Files](https://fastapi.tiangolo.com/tutorial/request-files/).
       
           ## Example
       
           ```python
           from typing import Annotated
       
           from fastapi import FastAPI, File, UploadFile
       
           app = FastAPI()
       
       
           @app.post("/files/")
           async def create_file(file: Annotated[bytes, File()]):
               return {"file_size": len(file)}
       
       
           @app.post("/uploadfile/")
           async def create_upload_file(file: UploadFile):
               return {"filename": file.filename}
           ```
           """
       
    2:     file: Annotated[
    2:         BinaryIO,
    1:         Doc("The standard Python file object (non-async)."),
           ]
    1:     filename: Annotated[Optional[str], Doc("The original file name.")]
    1:     size: Annotated[Optional[int], Doc("The size of the file in bytes.")]
    1:     headers: Annotated[Headers, Doc("The headers of the request.")]
    2:     content_type: Annotated[
    1:         Optional[str], Doc("The content type of the request, from the headers.")
           ]
       
    1:     async def write(
               self,
    2:         data: Annotated[
    2:             bytes,
    2:             Doc(
    1:                 """
                       The bytes to write to the file.
                       """
                   ),
               ],
    1:     ) -> None:
               """
               Write some bytes to the file.
       
               You normally wouldn't use this from a file you read in a request.
       
               To be awaitable, compatible with async, this is run in threadpool.
               """
>>>>>>         return await super().write(data)
       
    2:     async def read(
               self,
    2:         size: Annotated[
    2:             int,
    2:             Doc(
    1:                 """
                       The number of bytes to read from the file.
                       """
                   ),
               ] = -1,
    1:     ) -> bytes:
               """
               Read some bytes from the file.
       
               To be awaitable, compatible with async, this is run in threadpool.
               """
>>>>>>         return await super().read(size)
       
    1:     async def seek(
               self,
    2:         offset: Annotated[
    2:             int,
    2:             Doc(
    1:                 """
                       The position in bytes to seek to in the file.
                       """
                   ),
               ],
    1:     ) -> None:
               """
               Move to a position in the file.
       
               Any next read or write will be done from that position.
       
               To be awaitable, compatible with async, this is run in threadpool.
               """
>>>>>>         return await super().seek(offset)
       
    1:     async def close(self) -> None:
               """
               Close the file.
       
               To be awaitable, compatible with async, this is run in threadpool.
               """
>>>>>>         return await super().close()
       
    1:     @classmethod
    1:     def __get_validators__(cls: Type["UploadFile"]) -> Iterable[Callable[..., Any]]:
>>>>>>         yield cls.validate
       
    1:     @classmethod
    1:     def validate(cls: Type["UploadFile"], v: Any) -> Any:
>>>>>>         if not isinstance(v, StarletteUploadFile):
>>>>>>             raise ValueError(f"Expected UploadFile, received: {type(v)}")
>>>>>>         return v
       
    1:     @classmethod
    1:     def _validate(cls, __input_value: Any, _: Any) -> "UploadFile":
>>>>>>         if not isinstance(__input_value, StarletteUploadFile):
>>>>>>             raise ValueError(f"Expected UploadFile, received: {type(__input_value)}")
>>>>>>         return cast(UploadFile, __input_value)
       
    1:     if not PYDANTIC_V2:
       
>>>>>>         @classmethod
>>>>>>         def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:
>>>>>>             field_schema.update({"type": "string", "format": "binary"})
       
    1:     @classmethod
    1:     def __get_pydantic_json_schema__(
    1:         cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler
    1:     ) -> JsonSchemaValue:
>>>>>>         return {"type": "string", "format": "binary"}
       
    1:     @classmethod
    1:     def __get_pydantic_core_schema__(
    1:         cls, source: Type[Any], handler: Callable[[Any], CoreSchema]
    1:     ) -> CoreSchema:
>>>>>>         return with_info_plain_validator_function(cls._validate)
       
       
    2: class DefaultPlaceholder:
    1:     """
           You shouldn't use this class directly.
       
           It's used internally to recognize when a default value has been overwritten, even
           if the overridden default value was truthy.
           """
       
    1:     def __init__(self, value: Any):
   72:         self.value = value
       
    1:     def __bool__(self) -> bool:
>>>>>>         return bool(self.value)
       
    1:     def __eq__(self, o: object) -> bool:
>>>>>>         return isinstance(o, DefaultPlaceholder) and o.value == self.value
       
       
    1: DefaultType = TypeVar("DefaultType")
       
       
    1: def Default(value: DefaultType) -> DefaultType:
           """
           You shouldn't use this function directly.
       
           It's used internally to recognize when a default value has been overwritten, even
           if the overridden default value was truthy.
           """
   72:     return DefaultPlaceholder(value)  # type: ignore
