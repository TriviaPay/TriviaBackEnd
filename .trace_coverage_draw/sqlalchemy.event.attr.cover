       # event/attr.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: """Attribute implementation for _Dispatch classes.
       
       The various listener targets for a particular event class are represented
       as attributes, which refer to collections of listeners to be fired off.
       These collections can exist at the class level as well as at the instance
       level.  An event is fired off using code like this::
       
           some_object.dispatch.first_connect(arg1, arg2)
       
       Above, ``some_object.dispatch`` would be an instance of ``_Dispatch`` and
       ``first_connect`` is typically an instance of ``_ListenerCollection``
       if event listeners are present, or ``_EmptyListener`` if none are present.
       
       The attribute mechanics here spend effort trying to ensure listener functions
       are available with a minimum of function call overhead, that unnecessary
       objects aren't created (i.e. many empty per-instance listener collections),
       as well as that everything is garbage collectable when owning references are
       lost.  Other features such as "propagation" of listener functions across
       many ``_Dispatch`` instances, "joining" of multiple ``_Dispatch`` instances,
       as well as support for subclass propagation (e.g. events assigned to
       ``Pool`` vs. ``QueuePool``) are all implemented here.
       
       """
    1: from __future__ import annotations
       
    1: import collections
    1: from itertools import chain
    1: import threading
    1: from types import TracebackType
    1: import typing
    1: from typing import Any
    1: from typing import cast
    1: from typing import Collection
    1: from typing import Deque
    1: from typing import FrozenSet
    1: from typing import Generic
    1: from typing import Iterator
    1: from typing import MutableMapping
    1: from typing import MutableSequence
    1: from typing import NoReturn
    1: from typing import Optional
    1: from typing import Sequence
    1: from typing import Set
    1: from typing import Tuple
    1: from typing import Type
    1: from typing import TypeVar
    1: from typing import Union
    1: import weakref
       
    1: from . import legacy
    1: from . import registry
    1: from .registry import _ET
    1: from .registry import _EventKey
    1: from .registry import _ListenerFnType
    1: from .. import exc
    1: from .. import util
    1: from ..util.concurrency import AsyncAdaptedLock
    1: from ..util.typing import Protocol
       
    1: _T = TypeVar("_T", bound=Any)
       
    1: if typing.TYPE_CHECKING:
>>>>>>     from .base import _Dispatch
>>>>>>     from .base import _DispatchCommon
>>>>>>     from .base import _HasEventsDispatch
       
       
    2: class RefCollection(util.MemoizedSlots, Generic[_ET]):
    1:     __slots__ = ("ref",)
       
    1:     ref: weakref.ref[RefCollection[_ET]]
       
    1:     def _memoized_attr_ref(self) -> weakref.ref[RefCollection[_ET]]:
  576:         return weakref.ref(self, registry._collection_gced)
       
       
    2: class _empty_collection(Collection[_T]):
    1:     def append(self, element: _T) -> None:
>>>>>>         pass
       
    1:     def appendleft(self, element: _T) -> None:
>>>>>>         pass
       
    1:     def extend(self, other: Sequence[_T]) -> None:
>>>>>>         pass
       
    1:     def remove(self, element: _T) -> None:
>>>>>>         pass
       
    1:     def __contains__(self, element: Any) -> bool:
>>>>>>         return False
       
    1:     def __iter__(self) -> Iterator[_T]:
>>>>>>         return iter([])
       
    1:     def clear(self) -> None:
>>>>>>         pass
       
    1:     def __len__(self) -> int:
>>>>>>         return 0
       
       
    1: _ListenerFnSequenceType = Union[Deque[_T], _empty_collection[_T]]
       
       
    2: class _ClsLevelDispatch(RefCollection[_ET]):
    1:     """Class-level events on :class:`._Dispatch` classes."""
       
    1:     __slots__ = (
               "clsname",
               "name",
               "arg_names",
               "has_kw",
               "legacy_signatures",
               "_clslevel",
               "__weakref__",
           )
       
    1:     clsname: str
    1:     name: str
    1:     arg_names: Sequence[str]
    1:     has_kw: bool
    1:     legacy_signatures: MutableSequence[legacy._LegacySignatureType]
    1:     _clslevel: MutableMapping[
               Type[_ET], _ListenerFnSequenceType[_ListenerFnType]
           ]
       
    1:     def __init__(
               self,
               parent_dispatch_cls: Type[_HasEventsDispatch[_ET]],
               fn: _ListenerFnType,
           ):
  104:         self.name = fn.__name__
  104:         self.clsname = parent_dispatch_cls.__name__
  104:         argspec = util.inspect_getfullargspec(fn)
  104:         self.arg_names = argspec.args[1:]
  104:         self.has_kw = bool(argspec.varkw)
  208:         self.legacy_signatures = list(
  208:             reversed(
  208:                 sorted(
  110:                     getattr(fn, "_legacy_signatures", []), key=lambda s: s[0]
                       )
                   )
               )
  104:         fn.__doc__ = legacy._augment_fn_docs(self, parent_dispatch_cls, fn)
       
  104:         self._clslevel = weakref.WeakKeyDictionary()
       
    1:     def _adjust_fn_spec(
               self, fn: _ListenerFnType, named: bool
           ) -> _ListenerFnType:
  772:         if named:
>>>>>>             fn = self._wrap_fn_for_kw(fn)
  772:         if self.legacy_signatures:
>>>>>>             try:
>>>>>>                 argspec = util.get_callable_argspec(fn, no_self=True)
>>>>>>             except TypeError:
>>>>>>                 pass
                   else:
>>>>>>                 fn = legacy._wrap_fn_for_legacy(self, fn, argspec)
  772:         return fn
       
    1:     def _wrap_fn_for_kw(self, fn: _ListenerFnType) -> _ListenerFnType:
>>>>>>         def wrap_kw(*args: Any, **kw: Any) -> Any:
>>>>>>             argdict = dict(zip(self.arg_names, args))
>>>>>>             argdict.update(kw)
>>>>>>             return fn(**argdict)
       
>>>>>>         return wrap_kw
       
    1:     def _do_insert_or_append(
               self, event_key: _EventKey[_ET], is_append: bool
           ) -> None:
    5:         target = event_key.dispatch_target
   10:         assert isinstance(
    5:             target, type
>>>>>>         ), "Class-level Event targets must be classes."
    5:         if not getattr(target, "_sa_propagate_class_events", True):
>>>>>>             raise exc.InvalidRequestError(
>>>>>>                 f"Can't assign an event directly to the {target} class"
                   )
       
               cls: Type[_ET]
       
   15:         for cls in util.walk_subclasses(target):
   10:             if cls is not target and cls not in self._clslevel:
    5:                 self.update_subclass(cls)
                   else:
    5:                 if cls not in self._clslevel:
    4:                     self.update_subclass(cls)
    5:                 if is_append:
    5:                     self._clslevel[cls].append(event_key._listen_fn)
                       else:
>>>>>>                     self._clslevel[cls].appendleft(event_key._listen_fn)
    5:         registry._stored_in_collection(event_key, self)
       
    1:     def insert(self, event_key: _EventKey[_ET], propagate: bool) -> None:
>>>>>>         self._do_insert_or_append(event_key, is_append=False)
       
    1:     def append(self, event_key: _EventKey[_ET], propagate: bool) -> None:
    5:         self._do_insert_or_append(event_key, is_append=True)
       
    1:     def update_subclass(self, target: Type[_ET]) -> None:
  247:         if target not in self._clslevel:
  247:             if getattr(target, "_sa_propagate_class_events", True):
  247:                 self._clslevel[target] = collections.deque()
                   else:
>>>>>>                 self._clslevel[target] = _empty_collection()
       
  247:         clslevel = self._clslevel[target]
               cls: Type[_ET]
 3107:         for cls in target.__mro__[1:]:
 2860:             if cls in self._clslevel:
   18:                 clslevel.extend(
   27:                     [fn for fn in self._clslevel[cls] if fn not in clslevel]
                       )
       
    1:     def remove(self, event_key: _EventKey[_ET]) -> None:
>>>>>>         target = event_key.dispatch_target
               cls: Type[_ET]
>>>>>>         for cls in util.walk_subclasses(target):
>>>>>>             if cls in self._clslevel:
>>>>>>                 self._clslevel[cls].remove(event_key._listen_fn)
>>>>>>         registry._removed_from_collection(event_key, self)
       
    1:     def clear(self) -> None:
               """Clear all class level listeners"""
       
>>>>>>         to_clear: Set[_ListenerFnType] = set()
>>>>>>         for dispatcher in self._clslevel.values():
>>>>>>             to_clear.update(dispatcher)
>>>>>>             dispatcher.clear()
>>>>>>         registry._clear(self, to_clear)
       
    1:     def for_modify(self, obj: _Dispatch[_ET]) -> _ClsLevelDispatch[_ET]:
               """Return an event collection which can be modified.
       
               For _ClsLevelDispatch at the class level of
               a dispatcher, this returns self.
       
               """
    5:         return self
       
       
    2: class _InstanceLevelDispatch(RefCollection[_ET], Collection[_ListenerFnType]):
    1:     __slots__ = ()
       
    1:     parent: _ClsLevelDispatch[_ET]
       
    1:     def _adjust_fn_spec(
               self, fn: _ListenerFnType, named: bool
           ) -> _ListenerFnType:
  767:         return self.parent._adjust_fn_spec(fn, named)
       
    1:     def __contains__(self, item: Any) -> bool:
>>>>>>         raise NotImplementedError()
       
    1:     def __len__(self) -> int:
>>>>>>         raise NotImplementedError()
       
    1:     def __iter__(self) -> Iterator[_ListenerFnType]:
>>>>>>         raise NotImplementedError()
       
    1:     def __bool__(self) -> bool:
>>>>>>         raise NotImplementedError()
       
    1:     def exec_once(self, *args: Any, **kw: Any) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def exec_once_unless_exception(self, *args: Any, **kw: Any) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def _exec_w_sync_on_first_run(self, *args: Any, **kw: Any) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def __call__(self, *args: Any, **kw: Any) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def insert(self, event_key: _EventKey[_ET], propagate: bool) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def append(self, event_key: _EventKey[_ET], propagate: bool) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def remove(self, event_key: _EventKey[_ET]) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def for_modify(
               self, obj: _DispatchCommon[_ET]
           ) -> _InstanceLevelDispatch[_ET]:
               """Return an event collection which can be modified.
       
               For _ClsLevelDispatch at the class level of
               a dispatcher, this returns self.
       
               """
>>>>>>         return self
       
       
    2: class _EmptyListener(_InstanceLevelDispatch[_ET]):
    1:     """Serves as a proxy interface to the events
           served by a _ClsLevelDispatch, when there are no
           instance-level events present.
       
           Is replaced by _ListenerCollection when instance-level
           events are added.
       
           """
       
    1:     __slots__ = "parent", "parent_listeners", "name"
       
    1:     propagate: FrozenSet[_ListenerFnType] = frozenset()
    1:     listeners: Tuple[()] = ()
    1:     parent: _ClsLevelDispatch[_ET]
    1:     parent_listeners: _ListenerFnSequenceType[_ListenerFnType]
    1:     name: str
       
    1:     def __init__(self, parent: _ClsLevelDispatch[_ET], target_cls: Type[_ET]):
  244:         if target_cls not in parent._clslevel:
  238:             parent.update_subclass(target_cls)
  244:         self.parent = parent
  244:         self.parent_listeners = parent._clslevel[target_cls]
  244:         self.name = parent.name
       
    1:     def for_modify(
               self, obj: _DispatchCommon[_ET]
           ) -> _ListenerCollection[_ET]:
               """Return an event collection which can be modified.
       
               For _EmptyListener at the instance level of
               a dispatcher, this generates a new
               _ListenerCollection, applies it to the instance,
               and returns it.
       
               """
  573:         obj = cast("_Dispatch[_ET]", obj)
       
  573:         assert obj._instance_cls is not None
  573:         result = _ListenerCollection(self.parent, obj._instance_cls)
  573:         if getattr(obj, self.name) is self:
  573:             setattr(obj, self.name, result)
               else:
>>>>>>             assert isinstance(getattr(obj, self.name), _JoinedListener)
  573:         return result
       
    1:     def _needs_modify(self, *args: Any, **kw: Any) -> NoReturn:
>>>>>>         raise NotImplementedError("need to call for_modify()")
       
    1:     def exec_once(self, *args: Any, **kw: Any) -> NoReturn:
>>>>>>         self._needs_modify(*args, **kw)
       
    1:     def exec_once_unless_exception(self, *args: Any, **kw: Any) -> NoReturn:
>>>>>>         self._needs_modify(*args, **kw)
       
    1:     def insert(self, *args: Any, **kw: Any) -> NoReturn:
>>>>>>         self._needs_modify(*args, **kw)
       
    1:     def append(self, *args: Any, **kw: Any) -> NoReturn:
>>>>>>         self._needs_modify(*args, **kw)
       
    1:     def remove(self, *args: Any, **kw: Any) -> NoReturn:
>>>>>>         self._needs_modify(*args, **kw)
       
    1:     def clear(self, *args: Any, **kw: Any) -> NoReturn:
>>>>>>         self._needs_modify(*args, **kw)
       
    1:     def __call__(self, *args: Any, **kw: Any) -> None:
               """Execute this event."""
       
 3449:         for fn in self.parent_listeners:
  354:             fn(*args, **kw)
       
    1:     def __contains__(self, item: Any) -> bool:
>>>>>>         return item in self.parent_listeners
       
    1:     def __len__(self) -> int:
>>>>>>         return len(self.parent_listeners)
       
    1:     def __iter__(self) -> Iterator[_ListenerFnType]:
   45:         return iter(self.parent_listeners)
       
    1:     def __bool__(self) -> bool:
   39:         return bool(self.parent_listeners)
       
       
    2: class _MutexProtocol(Protocol):
    1:     def __enter__(self) -> bool: ...
       
    1:     def __exit__(
               self,
               exc_type: Optional[Type[BaseException]],
               exc_val: Optional[BaseException],
               exc_tb: Optional[TracebackType],
>>>>>>     ) -> Optional[bool]: ...
       
       
    2: class _CompoundListener(_InstanceLevelDispatch[_ET]):
    1:     __slots__ = (
               "_exec_once_mutex",
               "_exec_once",
               "_exec_w_sync_once",
               "_is_asyncio",
           )
       
    1:     _exec_once_mutex: _MutexProtocol
    1:     parent_listeners: Collection[_ListenerFnType]
    1:     listeners: Collection[_ListenerFnType]
    1:     _exec_once: bool
    1:     _exec_w_sync_once: bool
       
    1:     def __init__(self, *arg: Any, **kw: Any):
  573:         super().__init__(*arg, **kw)
  573:         self._is_asyncio = False
       
    1:     def _set_asyncio(self) -> None:
>>>>>>         self._is_asyncio = True
       
    1:     def _memoized_attr__exec_once_mutex(self) -> _MutexProtocol:
    1:         if self._is_asyncio:
>>>>>>             return AsyncAdaptedLock()
               else:
    1:             return threading.Lock()
       
    1:     def _exec_once_impl(
               self, retry_on_exception: bool, *args: Any, **kw: Any
           ) -> None:
>>>>>>         with self._exec_once_mutex:
>>>>>>             if not self._exec_once:
>>>>>>                 try:
>>>>>>                     self(*args, **kw)
>>>>>>                     exception = False
>>>>>>                 except:
>>>>>>                     exception = True
>>>>>>                     raise
                       finally:
>>>>>>                     if not exception or not retry_on_exception:
>>>>>>                         self._exec_once = True
       
    1:     def exec_once(self, *args: Any, **kw: Any) -> None:
               """Execute this event, but only if it has not been
               executed already for this collection."""
       
>>>>>>         if not self._exec_once:
>>>>>>             self._exec_once_impl(False, *args, **kw)
       
    1:     def exec_once_unless_exception(self, *args: Any, **kw: Any) -> None:
               """Execute this event, but only if it has not been
               executed already for this collection, or was called
               by a previous exec_once_unless_exception call and
               raised an exception.
       
               If exec_once was already called, then this method will never run
               the callable regardless of whether it raised or not.
       
               .. versionadded:: 1.3.8
       
               """
>>>>>>         if not self._exec_once:
>>>>>>             self._exec_once_impl(True, *args, **kw)
       
    1:     def _exec_w_sync_on_first_run(self, *args: Any, **kw: Any) -> None:
               """Execute this event, and use a mutex if it has not been
               executed already for this collection, or was called
               by a previous _exec_w_sync_on_first_run call and
               raised an exception.
       
               If _exec_w_sync_on_first_run was already called and didn't raise an
               exception, then a mutex is not used.
       
               .. versionadded:: 1.4.11
       
               """
    1:         if not self._exec_w_sync_once:
    1:             with self._exec_once_mutex:
    1:                 try:
    1:                     self(*args, **kw)
>>>>>>                 except:
>>>>>>                     raise
                       else:
    1:                     self._exec_w_sync_once = True
               else:
>>>>>>             self(*args, **kw)
       
    1:     def __call__(self, *args: Any, **kw: Any) -> None:
               """Execute this event."""
       
  131:         for fn in self.parent_listeners:
>>>>>>             fn(*args, **kw)
  264:         for fn in self.listeners:
  133:             fn(*args, **kw)
       
    1:     def __contains__(self, item: Any) -> bool:
>>>>>>         return item in self.parent_listeners or item in self.listeners
       
    1:     def __len__(self) -> int:
>>>>>>         return len(self.parent_listeners) + len(self.listeners)
       
    1:     def __iter__(self) -> Iterator[_ListenerFnType]:
>>>>>>         return chain(self.parent_listeners, self.listeners)
       
    1:     def __bool__(self) -> bool:
>>>>>>         return bool(self.listeners or self.parent_listeners)
       
       
    2: class _ListenerCollection(_CompoundListener[_ET]):
    1:     """Instance-level attributes on instances of :class:`._Dispatch`.
       
           Represents a collection of listeners.
       
           As of 0.7.9, _ListenerCollection is only first
           created via the _EmptyListener.for_modify() method.
       
           """
       
    1:     __slots__ = (
               "parent_listeners",
               "parent",
               "name",
               "listeners",
               "propagate",
               "__weakref__",
           )
       
    1:     parent_listeners: Collection[_ListenerFnType]
    1:     parent: _ClsLevelDispatch[_ET]
    1:     name: str
    1:     listeners: Deque[_ListenerFnType]
    1:     propagate: Set[_ListenerFnType]
       
    1:     def __init__(self, parent: _ClsLevelDispatch[_ET], target_cls: Type[_ET]):
  573:         super().__init__()
  573:         if target_cls not in parent._clslevel:
>>>>>>             parent.update_subclass(target_cls)
  573:         self._exec_once = False
  573:         self._exec_w_sync_once = False
  573:         self.parent_listeners = parent._clslevel[target_cls]
  573:         self.parent = parent
  573:         self.name = parent.name
  573:         self.listeners = collections.deque()
  573:         self.propagate = set()
       
    1:     def for_modify(
               self, obj: _DispatchCommon[_ET]
           ) -> _ListenerCollection[_ET]:
               """Return an event collection which can be modified.
       
               For _ListenerCollection at the instance level of
               a dispatcher, this returns self.
       
               """
  193:         return self
       
    1:     def _update(
               self, other: _ListenerCollection[_ET], only_propagate: bool = True
           ) -> None:
               """Populate from the listeners in another :class:`_Dispatch`
               object."""
>>>>>>         existing_listeners = self.listeners
>>>>>>         existing_listener_set = set(existing_listeners)
>>>>>>         self.propagate.update(other.propagate)
>>>>>>         other_listeners = [
>>>>>>             l
>>>>>>             for l in other.listeners
>>>>>>             if l not in existing_listener_set
>>>>>>             and not only_propagate
>>>>>>             or l in self.propagate
               ]
       
>>>>>>         existing_listeners.extend(other_listeners)
       
>>>>>>         if other._is_asyncio:
>>>>>>             self._set_asyncio()
       
>>>>>>         to_associate = other.propagate.union(other_listeners)
>>>>>>         registry._stored_in_collection_multi(self, other, to_associate)
       
    1:     def insert(self, event_key: _EventKey[_ET], propagate: bool) -> None:
>>>>>>         if event_key.prepend_to_list(self, self.listeners):
>>>>>>             if propagate:
>>>>>>                 self.propagate.add(event_key._listen_fn)
       
    1:     def append(self, event_key: _EventKey[_ET], propagate: bool) -> None:
  765:         if event_key.append_to_list(self, self.listeners):
  765:             if propagate:
    7:                 self.propagate.add(event_key._listen_fn)
       
    1:     def remove(self, event_key: _EventKey[_ET]) -> None:
>>>>>>         self.listeners.remove(event_key._listen_fn)
>>>>>>         self.propagate.discard(event_key._listen_fn)
>>>>>>         registry._removed_from_collection(event_key, self)
       
    1:     def clear(self) -> None:
>>>>>>         registry._clear(self, self.listeners)
>>>>>>         self.propagate.clear()
>>>>>>         self.listeners.clear()
       
       
    2: class _JoinedListener(_CompoundListener[_ET]):
    1:     __slots__ = "parent_dispatch", "name", "local", "parent_listeners"
       
    1:     parent_dispatch: _DispatchCommon[_ET]
    1:     name: str
    1:     local: _InstanceLevelDispatch[_ET]
    1:     parent_listeners: Collection[_ListenerFnType]
       
    1:     def __init__(
               self,
               parent_dispatch: _DispatchCommon[_ET],
               name: str,
               local: _EmptyListener[_ET],
           ):
>>>>>>         self._exec_once = False
>>>>>>         self.parent_dispatch = parent_dispatch
>>>>>>         self.name = name
>>>>>>         self.local = local
>>>>>>         self.parent_listeners = self.local
       
    1:     if not typing.TYPE_CHECKING:
               # first error, I don't really understand:
               # Signature of "listeners" incompatible with
               # supertype "_CompoundListener"  [override]
               # the name / return type are exactly the same
               # second error is getattr_isn't typed, the cast() here
               # adds too much method overhead
    1:         @property
    1:         def listeners(self) -> Collection[_ListenerFnType]:
>>>>>>             return getattr(self.parent_dispatch, self.name)
       
    1:     def _adjust_fn_spec(
               self, fn: _ListenerFnType, named: bool
           ) -> _ListenerFnType:
>>>>>>         return self.local._adjust_fn_spec(fn, named)
       
    1:     def for_modify(self, obj: _DispatchCommon[_ET]) -> _JoinedListener[_ET]:
>>>>>>         self.local = self.parent_listeners = self.local.for_modify(obj)
>>>>>>         return self
       
    1:     def insert(self, event_key: _EventKey[_ET], propagate: bool) -> None:
>>>>>>         self.local.insert(event_key, propagate)
       
    1:     def append(self, event_key: _EventKey[_ET], propagate: bool) -> None:
>>>>>>         self.local.append(event_key, propagate)
       
    1:     def remove(self, event_key: _EventKey[_ET]) -> None:
>>>>>>         self.local.remove(event_key)
       
    1:     def clear(self) -> None:
>>>>>>         raise NotImplementedError()
