       # This file is dual licensed under the terms of the Apache License, Version
       # 2.0, and the BSD License. See the LICENSE file in the root of this repository
       # for complete details.
       
    1: from __future__ import annotations
       
    1: import abc
    1: import typing
       
    1: from cryptography.hazmat.bindings._rust import openssl as rust_openssl
    1: from cryptography.hazmat.primitives._cipheralgorithm import CipherAlgorithm
    1: from cryptography.hazmat.primitives.ciphers import modes
    1: from cryptography.utils import Buffer
       
       
    2: class CipherContext(metaclass=abc.ABCMeta):
    1:     @abc.abstractmethod
    1:     def update(self, data: Buffer) -> bytes:
               """
               Processes the provided bytes through the cipher and returns the results
               as bytes.
               """
       
    1:     @abc.abstractmethod
    1:     def update_into(self, data: Buffer, buf: Buffer) -> int:
               """
               Processes the provided bytes and writes the resulting data into the
               provided buffer. Returns the number of bytes written.
               """
       
    1:     @abc.abstractmethod
    1:     def finalize(self) -> bytes:
               """
               Returns the results of processing the final block as bytes.
               """
       
    1:     @abc.abstractmethod
    1:     def reset_nonce(self, nonce: bytes) -> None:
               """
               Resets the nonce for the cipher context to the provided value.
               Raises an exception if it does not support reset or if the
               provided nonce does not have a valid length.
               """
       
       
    2: class AEADCipherContext(CipherContext, metaclass=abc.ABCMeta):
    1:     @abc.abstractmethod
    1:     def authenticate_additional_data(self, data: Buffer) -> None:
               """
               Authenticates the provided bytes.
               """
       
       
    2: class AEADDecryptionContext(AEADCipherContext, metaclass=abc.ABCMeta):
    1:     @abc.abstractmethod
    1:     def finalize_with_tag(self, tag: bytes) -> bytes:
               """
               Returns the results of processing the final block as bytes and allows
               delayed passing of the authentication tag.
               """
       
       
    2: class AEADEncryptionContext(AEADCipherContext, metaclass=abc.ABCMeta):
    1:     @property
    1:     @abc.abstractmethod
    1:     def tag(self) -> bytes:
               """
               Returns tag bytes. This is only available after encryption is
               finalized.
               """
       
       
    2: Mode = typing.TypeVar(
    1:     "Mode", bound=typing.Optional[modes.Mode], covariant=True
       )
       
       
    2: class Cipher(typing.Generic[Mode]):
    1:     def __init__(
               self,
               algorithm: CipherAlgorithm,
               mode: Mode,
               backend: typing.Any = None,
           ) -> None:
>>>>>>         if not isinstance(algorithm, CipherAlgorithm):
>>>>>>             raise TypeError("Expected interface of CipherAlgorithm.")
       
>>>>>>         if mode is not None:
                   # mypy needs this assert to narrow the type from our generic
                   # type. Maybe it won't some time in the future.
>>>>>>             assert isinstance(mode, modes.Mode)
>>>>>>             mode.validate_for_algorithm(algorithm)
       
>>>>>>         self.algorithm = algorithm
>>>>>>         self.mode = mode
       
    1:     @typing.overload
    1:     def encryptor(
               self: Cipher[modes.ModeWithAuthenticationTag],
>>>>>>     ) -> AEADEncryptionContext: ...
       
    1:     @typing.overload
    1:     def encryptor(
               self: _CIPHER_TYPE,
>>>>>>     ) -> CipherContext: ...
       
    1:     def encryptor(self):
>>>>>>         if isinstance(self.mode, modes.ModeWithAuthenticationTag):
>>>>>>             if self.mode.tag is not None:
>>>>>>                 raise ValueError(
>>>>>>                     "Authentication tag must be None when encrypting."
                       )
       
>>>>>>         return rust_openssl.ciphers.create_encryption_ctx(
>>>>>>             self.algorithm, self.mode
               )
       
    1:     @typing.overload
    1:     def decryptor(
               self: Cipher[modes.ModeWithAuthenticationTag],
>>>>>>     ) -> AEADDecryptionContext: ...
       
    1:     @typing.overload
    1:     def decryptor(
               self: _CIPHER_TYPE,
>>>>>>     ) -> CipherContext: ...
       
    1:     def decryptor(self):
>>>>>>         return rust_openssl.ciphers.create_decryption_ctx(
>>>>>>             self.algorithm, self.mode
               )
       
       
    2: _CIPHER_TYPE = Cipher[
    2:     typing.Union[
    2:         modes.ModeWithNonce,
    1:         modes.ModeWithTweak,
    1:         modes.ECB,
    1:         modes.ModeWithInitializationVector,
    1:         None,
           ]
       ]
       
    1: CipherContext.register(rust_openssl.ciphers.CipherContext)
    1: AEADEncryptionContext.register(rust_openssl.ciphers.AEADEncryptionContext)
    1: AEADDecryptionContext.register(rust_openssl.ciphers.AEADDecryptionContext)
