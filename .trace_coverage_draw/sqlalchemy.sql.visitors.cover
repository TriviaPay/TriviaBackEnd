       # sql/visitors.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: """Visitor/traversal interface and library functions.
       
       
       """
       
    1: from __future__ import annotations
       
    1: from collections import deque
    1: from enum import Enum
    1: import itertools
    1: import operator
    1: import typing
    1: from typing import Any
    1: from typing import Callable
    1: from typing import cast
    1: from typing import ClassVar
    1: from typing import Dict
    1: from typing import Iterable
    1: from typing import Iterator
    1: from typing import List
    1: from typing import Mapping
    1: from typing import Optional
    1: from typing import overload
    1: from typing import Tuple
    1: from typing import Type
    1: from typing import TYPE_CHECKING
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from .. import exc
    1: from .. import util
    1: from ..util import langhelpers
    1: from ..util._has_cy import HAS_CYEXTENSION
    1: from ..util.typing import Literal
    1: from ..util.typing import Protocol
    1: from ..util.typing import Self
       
    1: if TYPE_CHECKING:
>>>>>>     from .annotation import _AnnotationDict
>>>>>>     from .elements import ColumnElement
       
    1: if typing.TYPE_CHECKING or not HAS_CYEXTENSION:
>>>>>>     from ._py_util import prefix_anon_map as prefix_anon_map
>>>>>>     from ._py_util import cache_anon_map as anon_map
       else:
    1:     from sqlalchemy.cyextension.util import (  # noqa: F401,E501
               prefix_anon_map as prefix_anon_map,
           )
    1:     from sqlalchemy.cyextension.util import (  # noqa: F401,E501
               cache_anon_map as anon_map,
           )
       
       
    1: __all__ = [
           "iterate",
           "traverse_using",
           "traverse",
           "cloned_traverse",
           "replacement_traverse",
           "Visitable",
           "ExternalTraversal",
           "InternalTraversal",
           "anon_map",
       ]
       
       
    2: class _CompilerDispatchType(Protocol):
    1:     def __call__(_self, self: Visitable, visitor: Any, **kw: Any) -> Any: ...
       
       
    2: class Visitable:
    1:     """Base class for visitable objects.
       
           :class:`.Visitable` is used to implement the SQL compiler dispatch
           functions.    Other forms of traversal such as for cache key generation
           are implemented separately using the :class:`.HasTraverseInternals`
           interface.
       
           .. versionchanged:: 2.0  The :class:`.Visitable` class was named
              :class:`.Traversible` in the 1.4 series; the name is changed back
              to :class:`.Visitable` in 2.0 which is what it was prior to 1.4.
       
              Both names remain importable in both 1.4 and 2.0 versions.
       
           """
       
    1:     __slots__ = ()
       
    1:     __visit_name__: str
       
    1:     _original_compiler_dispatch: _CompilerDispatchType
       
    1:     if typing.TYPE_CHECKING:
       
>>>>>>         def _compiler_dispatch(self, visitor: Any, **kw: Any) -> str: ...
       
    1:     def __init_subclass__(cls) -> None:
  509:         if "__visit_name__" in cls.__dict__:
  200:             cls._generate_compiler_dispatch()
  509:         super().__init_subclass__()
       
    1:     @classmethod
    1:     def _generate_compiler_dispatch(cls) -> None:
  200:         visit_name = cls.__visit_name__
       
  200:         if "_compiler_dispatch" in cls.__dict__:
                   # class has a fixed _compiler_dispatch() method.
                   # copy it to "original" so that we can get it back if
                   # sqlalchemy.ext.compiles overrides it.
    1:             cls._original_compiler_dispatch = cls._compiler_dispatch
    1:             return
       
  199:         if not isinstance(visit_name, str):
>>>>>>             raise exc.InvalidRequestError(
>>>>>>                 f"__visit_name__ on class {cls.__name__} must be a string "
                       "at the class level"
                   )
       
  199:         name = "visit_%s" % visit_name
  199:         getter = operator.attrgetter(name)
       
  199:         def _compiler_dispatch(
                   self: Visitable, visitor: Any, **kw: Any
               ) -> str:
                   """Look for an attribute named "visit_<visit_name>" on the
                   visitor, and call it with the same kw params.
       
                   """
 1361:             try:
 1361:                 meth = getter(visitor)
>>>>>>             except AttributeError as err:
>>>>>>                 return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
                   else:
 1361:                 return meth(self, **kw)  # type: ignore  # noqa: E501
       
  398:         cls._compiler_dispatch = (  # type: ignore
  199:             cls._original_compiler_dispatch
  199:         ) = _compiler_dispatch
       
    1:     def __class_getitem__(cls, key: Any) -> Any:
               # allow generic classes in py3.9+
  494:         return cls
       
       
    2: class InternalTraversal(Enum):
    1:     r"""Defines visitor symbols used for internal traversal.
       
           The :class:`.InternalTraversal` class is used in two ways.  One is that
           it can serve as the superclass for an object that implements the
           various visit methods of the class.   The other is that the symbols
           themselves of :class:`.InternalTraversal` are used within
           the ``_traverse_internals`` collection.   Such as, the :class:`.Case`
           object defines ``_traverse_internals`` as ::
       
               class Case(ColumnElement[_T]):
                   _traverse_internals = [
                       ("value", InternalTraversal.dp_clauseelement),
                       ("whens", InternalTraversal.dp_clauseelement_tuples),
                       ("else_", InternalTraversal.dp_clauseelement),
                   ]
       
           Above, the :class:`.Case` class indicates its internal state as the
           attributes named ``value``, ``whens``, and ``else_``.    They each
           link to an :class:`.InternalTraversal` method which indicates the type
           of datastructure to which each attribute refers.
       
           Using the ``_traverse_internals`` structure, objects of type
           :class:`.InternalTraversible` will have the following methods automatically
           implemented:
       
           * :meth:`.HasTraverseInternals.get_children`
       
           * :meth:`.HasTraverseInternals._copy_internals`
       
           * :meth:`.HasCacheKey._gen_cache_key`
       
           Subclasses can also implement these methods directly, particularly for the
           :meth:`.HasTraverseInternals._copy_internals` method, when special steps
           are needed.
       
           .. versionadded:: 1.4
       
           """
       
    1:     dp_has_cache_key = "HC"
           """Visit a :class:`.HasCacheKey` object."""
       
    1:     dp_has_cache_key_list = "HL"
           """Visit a list of :class:`.HasCacheKey` objects."""
       
    1:     dp_clauseelement = "CE"
           """Visit a :class:`_expression.ClauseElement` object."""
       
    1:     dp_fromclause_canonical_column_collection = "FC"
           """Visit a :class:`_expression.FromClause` object in the context of the
           ``columns`` attribute.
       
           The column collection is "canonical", meaning it is the originally
           defined location of the :class:`.ColumnClause` objects.   Right now
           this means that the object being visited is a
           :class:`_expression.TableClause`
           or :class:`_schema.Table` object only.
       
           """
       
    1:     dp_clauseelement_tuples = "CTS"
           """Visit a list of tuples which contain :class:`_expression.ClauseElement`
           objects.
       
           """
       
    1:     dp_clauseelement_list = "CL"
           """Visit a list of :class:`_expression.ClauseElement` objects.
       
           """
       
    1:     dp_clauseelement_tuple = "CT"
           """Visit a tuple of :class:`_expression.ClauseElement` objects.
       
           """
       
    1:     dp_executable_options = "EO"
       
    1:     dp_with_context_options = "WC"
       
    1:     dp_fromclause_ordered_set = "CO"
           """Visit an ordered set of :class:`_expression.FromClause` objects. """
       
    1:     dp_string = "S"
           """Visit a plain string value.
       
           Examples include table and column names, bound parameter keys, special
           keywords such as "UNION", "UNION ALL".
       
           The string value is considered to be significant for cache key
           generation.
       
           """
       
    1:     dp_string_list = "SL"
           """Visit a list of strings."""
       
    1:     dp_anon_name = "AN"
           """Visit a potentially "anonymized" string value.
       
           The string value is considered to be significant for cache key
           generation.
       
           """
       
    1:     dp_boolean = "B"
           """Visit a boolean value.
       
           The boolean value is considered to be significant for cache key
           generation.
       
           """
       
    1:     dp_operator = "O"
           """Visit an operator.
       
           The operator is a function from the :mod:`sqlalchemy.sql.operators`
           module.
       
           The operator value is considered to be significant for cache key
           generation.
       
           """
       
    1:     dp_type = "T"
           """Visit a :class:`.TypeEngine` object
       
           The type object is considered to be significant for cache key
           generation.
       
           """
       
    1:     dp_plain_dict = "PD"
           """Visit a dictionary with string keys.
       
           The keys of the dictionary should be strings, the values should
           be immutable and hashable.   The dictionary is considered to be
           significant for cache key generation.
       
           """
       
    1:     dp_dialect_options = "DO"
           """Visit a dialect options structure."""
       
    1:     dp_string_clauseelement_dict = "CD"
           """Visit a dictionary of string keys to :class:`_expression.ClauseElement`
           objects.
       
           """
       
    1:     dp_string_multi_dict = "MD"
           """Visit a dictionary of string keys to values which may either be
           plain immutable/hashable or :class:`.HasCacheKey` objects.
       
           """
       
    1:     dp_annotations_key = "AK"
           """Visit the _annotations_cache_key element.
       
           This is a dictionary of additional information about a ClauseElement
           that modifies its role.  It should be included when comparing or caching
           objects, however generating this key is relatively expensive.   Visitors
           should check the "_annotations" dict for non-None first before creating
           this key.
       
           """
       
    1:     dp_plain_obj = "PO"
           """Visit a plain python object.
       
           The value should be immutable and hashable, such as an integer.
           The value is considered to be significant for cache key generation.
       
           """
       
    1:     dp_named_ddl_element = "DD"
           """Visit a simple named DDL element.
       
           The current object used by this method is the :class:`.Sequence`.
       
           The object is only considered to be important for cache key generation
           as far as its name, but not any other aspects of it.
       
           """
       
    1:     dp_prefix_sequence = "PS"
           """Visit the sequence represented by :class:`_expression.HasPrefixes`
           or :class:`_expression.HasSuffixes`.
       
           """
       
    1:     dp_table_hint_list = "TH"
           """Visit the ``_hints`` collection of a :class:`_expression.Select`
           object.
       
           """
       
    1:     dp_setup_join_tuple = "SJ"
       
    1:     dp_memoized_select_entities = "ME"
       
    1:     dp_statement_hint_list = "SH"
           """Visit the ``_statement_hints`` collection of a
           :class:`_expression.Select`
           object.
       
           """
       
    1:     dp_unknown_structure = "UK"
           """Visit an unknown structure.
       
           """
       
    1:     dp_dml_ordered_values = "DML_OV"
           """Visit the values() ordered tuple list of an
           :class:`_expression.Update` object."""
       
    1:     dp_dml_values = "DML_V"
           """Visit the values() dictionary of a :class:`.ValuesBase`
           (e.g. Insert or Update) object.
       
           """
       
    1:     dp_dml_multi_values = "DML_MV"
           """Visit the values() multi-valued list of dictionaries of an
           :class:`_expression.Insert` object.
       
           """
       
    1:     dp_propagate_attrs = "PA"
           """Visit the propagate attrs dict.  This hardcodes to the particular
           elements we care about right now."""
       
           """Symbols that follow are additional symbols that are useful in
           caching applications.
       
           Traversals for :class:`_expression.ClauseElement` objects only need to use
           those symbols present in :class:`.InternalTraversal`.  However, for
           additional caching use cases within the ORM, symbols dealing with the
           :class:`.HasCacheKey` class are added here.
       
           """
       
    1:     dp_ignore = "IG"
           """Specify an object that should be ignored entirely.
       
           This currently applies function call argument caching where some
           arguments should not be considered to be part of a cache key.
       
           """
       
    1:     dp_inspectable = "IS"
           """Visit an inspectable object where the return value is a
           :class:`.HasCacheKey` object."""
       
    1:     dp_multi = "M"
           """Visit an object that may be a :class:`.HasCacheKey` or may be a
           plain hashable object."""
       
    1:     dp_multi_list = "MT"
           """Visit a tuple containing elements that may be :class:`.HasCacheKey` or
           may be a plain hashable object."""
       
    1:     dp_has_cache_key_tuples = "HT"
           """Visit a list of tuples which contain :class:`.HasCacheKey`
           objects.
       
           """
       
    1:     dp_inspectable_list = "IL"
    1:     """Visit a list of inspectable objects which upon inspection are
           HasCacheKey objects."""
       
       
    1: _TraverseInternalsType = List[Tuple[str, InternalTraversal]]
       """a structure that defines how a HasTraverseInternals should be
       traversed.
       
       This structure consists of a list of (attributename, internaltraversal)
       tuples, where the "attributename" refers to the name of an attribute on an
       instance of the HasTraverseInternals object, and "internaltraversal" refers
       to an :class:`.InternalTraversal` enumeration symbol defining what kind
       of data this attribute stores, which indicates to the traverser how it should
       be handled.
       
       """
       
       
    2: class HasTraverseInternals:
    1:     """base for classes that have a "traverse internals" element,
           which defines all kinds of ways of traversing the elements of an object.
       
           Compared to :class:`.Visitable`, which relies upon an external visitor to
           define how the object is travered (i.e. the :class:`.SQLCompiler`), the
           :class:`.HasTraverseInternals` interface allows classes to define their own
           traversal, that is, what attributes are accessed and in what order.
       
           """
       
    1:     __slots__ = ()
       
    1:     _traverse_internals: _TraverseInternalsType
       
    1:     _is_immutable: bool = False
       
    1:     @util.preload_module("sqlalchemy.sql.traversals")
    1:     def get_children(
    1:         self, *, omit_attrs: Tuple[str, ...] = (), **kw: Any
           ) -> Iterable[HasTraverseInternals]:
               r"""Return immediate child :class:`.visitors.HasTraverseInternals`
               elements of this :class:`.visitors.HasTraverseInternals`.
       
               This is used for visit traversal.
       
               \**kw may contain flags that change the collection that is
               returned, for example to return a subset of items in order to
               cut down on larger traversals, or to return child items from a
               different context (such as schema-level collections instead of
               clause-level).
       
               """
       
  931:         traversals = util.preloaded.sql_traversals
       
  931:         try:
  931:             traverse_internals = self._traverse_internals
>>>>>>         except AttributeError:
                   # user-defined classes may not have a _traverse_internals
>>>>>>             return []
       
  931:         dispatch = traversals._get_children.run_generated_dispatch
 4610:         return itertools.chain.from_iterable(
 1817:             meth(obj, **kw)
 3679:             for attrname, obj, meth in dispatch(
  931:                 self, traverse_internals, "_generated_get_children_traversal"
                   )
 1817:             if attrname not in omit_attrs and obj is not None
               )
       
       
    2: class _InternalTraversalDispatchType(Protocol):
    1:     def __call__(s, self: object, visitor: HasTraversalDispatch) -> Any: ...
       
       
    2: class HasTraversalDispatch:
    1:     r"""Define infrastructure for classes that perform internal traversals
       
           .. versionadded:: 2.0
       
           """
       
    1:     __slots__ = ()
       
    1:     _dispatch_lookup: ClassVar[Dict[Union[InternalTraversal, str], str]] = {}
       
    1:     def dispatch(self, visit_symbol: InternalTraversal) -> Callable[..., Any]:
               """Given a method from :class:`.HasTraversalDispatch`, return the
               corresponding method on a subclass.
       
               """
  601:         name = _dispatch_lookup[visit_symbol]
  601:         return getattr(self, name, None)  # type: ignore
       
    1:     def run_generated_dispatch(
               self,
               target: object,
               internal_dispatch: _TraverseInternalsType,
               generate_dispatcher_name: str,
           ) -> Any:
               dispatcher: _InternalTraversalDispatchType
 1692:         try:
 1692:             dispatcher = target.__class__.__dict__[generate_dispatcher_name]
    3:         except KeyError:
                   # traversals.py -> _preconfigure_traversals()
                   # may be used to run these ahead of time, but
                   # is not enabled right now.
                   # this block will generate any remaining dispatchers.
    6:             dispatcher = self.generate_dispatch(
    3:                 target.__class__, internal_dispatch, generate_dispatcher_name
                   )
 1692:         return dispatcher(target, self)
       
    1:     def generate_dispatch(
               self,
               target_cls: Type[object],
               internal_dispatch: _TraverseInternalsType,
               generate_dispatcher_name: str,
           ) -> _InternalTraversalDispatchType:
   30:         dispatcher = self._generate_dispatcher(
   15:             internal_dispatch, generate_dispatcher_name
               )
               # assert isinstance(target_cls, type)
   15:         setattr(target_cls, generate_dispatcher_name, dispatcher)
   15:         return dispatcher
       
    1:     def _generate_dispatcher(
               self, internal_dispatch: _TraverseInternalsType, method_name: str
           ) -> _InternalTraversalDispatchType:
   15:         names = []
  116:         for attrname, visit_sym in internal_dispatch:
  101:             meth = self.dispatch(visit_sym)
  101:             if meth is not None:
   90:                 visit_name = _dispatch_lookup[visit_sym]
   90:                 names.append((attrname, visit_name))
       
   15:         code = (
   45:             ("    return [\n")
                   + (
  135:                 ", \n".join(
  180:                     "        (%r, self.%s, visitor.%s)"
   90:                     % (attrname, attrname, visit_name)
  105:                     for attrname, visit_name in names
                       )
                   )
   15:             + ("\n    ]\n")
               )
   15:         meth_text = ("def %s(self, visitor):\n" % method_name) + code + "\n"
   30:         return cast(
   15:             _InternalTraversalDispatchType,
   15:             langhelpers._exec_code_in_env(meth_text, {}, method_name),
               )
       
       
    1: ExtendedInternalTraversal = InternalTraversal
       
       
    1: def _generate_traversal_dispatch() -> None:
    1:     lookup = _dispatch_lookup
       
   40:     for sym in InternalTraversal:
   39:         key = sym.name
   39:         if key.startswith("dp_"):
   39:             visit_key = key.replace("dp_", "visit_")
   39:             sym_name = sym.value
   39:             assert sym_name not in lookup, sym_name
   39:             lookup[sym] = lookup[sym_name] = visit_key
       
       
    1: _dispatch_lookup = HasTraversalDispatch._dispatch_lookup
    1: _generate_traversal_dispatch()
       
       
    2: class ExternallyTraversible(HasTraverseInternals, Visitable):
    1:     __slots__ = ()
       
    1:     _annotations: Mapping[Any, Any] = util.EMPTY_DICT
       
    1:     if typing.TYPE_CHECKING:
       
>>>>>>         def _annotate(self, values: _AnnotationDict) -> Self: ...
       
>>>>>>         def get_children(
>>>>>>             self, *, omit_attrs: Tuple[str, ...] = (), **kw: Any
>>>>>>         ) -> Iterable[ExternallyTraversible]: ...
       
    1:     def _clone(self, **kw: Any) -> Self:
               """clone this element"""
>>>>>>         raise NotImplementedError()
       
    1:     def _copy_internals(
    1:         self, *, omit_attrs: Tuple[str, ...] = (), **kw: Any
           ) -> None:
               """Reassign internal elements to be clones of themselves.
       
               Called during a copy-and-traverse operation on newly
               shallow-copied elements to create a deep copy.
       
               The given clone function should be used, which may be applying
               additional transformations to the element (i.e. replacement
               traversal, cloned traversal, annotations).
       
               """
>>>>>>         raise NotImplementedError()
       
       
    1: _ET = TypeVar("_ET", bound=ExternallyTraversible)
       
    1: _CE = TypeVar("_CE", bound="ColumnElement[Any]")
       
    1: _TraverseCallableType = Callable[[_ET], None]
       
       
    2: class _CloneCallableType(Protocol):
    1:     def __call__(self, element: _ET, **kw: Any) -> _ET: ...
       
       
    2: class _TraverseTransformCallableType(Protocol[_ET]):
    1:     def __call__(self, element: _ET, **kw: Any) -> Optional[_ET]: ...
       
       
    1: _ExtT = TypeVar("_ExtT", bound="ExternalTraversal")
       
       
    2: class ExternalTraversal(util.MemoizedSlots):
    1:     """Base class for visitor objects which can traverse externally using
           the :func:`.visitors.traverse` function.
       
           Direct usage of the :func:`.visitors.traverse` function is usually
           preferred.
       
           """
       
    1:     __slots__ = ("_visitor_dict", "_next")
       
    1:     __traverse_options__: Dict[str, Any] = {}
    1:     _next: Optional[ExternalTraversal]
       
    1:     def traverse_single(self, obj: Visitable, **kw: Any) -> Any:
  324:         for v in self.visitor_iterator:
  225:             meth = getattr(v, "visit_%s" % obj.__visit_name__, None)
  225:             if meth:
  126:                 return meth(obj, **kw)
       
    1:     def iterate(
               self, obj: Optional[ExternallyTraversible]
           ) -> Iterator[ExternallyTraversible]:
               """Traverse the given expression structure, returning an iterator
               of all elements.
       
               """
>>>>>>         return iterate(obj, self.__traverse_options__)
       
    1:     @overload
    1:     def traverse(self, obj: Literal[None]) -> None: ...
       
    1:     @overload
    1:     def traverse(
               self, obj: ExternallyTraversible
>>>>>>     ) -> ExternallyTraversible: ...
       
    1:     def traverse(
               self, obj: Optional[ExternallyTraversible]
           ) -> Optional[ExternallyTraversible]:
               """Traverse and visit the given expression structure."""
       
>>>>>>         return traverse(obj, self.__traverse_options__, self._visitor_dict)
       
    1:     def _memoized_attr__visitor_dict(
               self,
           ) -> Dict[str, _TraverseCallableType[Any]]:
>>>>>>         visitors = {}
       
>>>>>>         for name in dir(self):
>>>>>>             if name.startswith("visit_"):
>>>>>>                 visitors[name[6:]] = getattr(self, name)
>>>>>>         return visitors
       
    1:     @property
    1:     def visitor_iterator(self) -> Iterator[ExternalTraversal]:
               """Iterate through this visitor and each 'chained' visitor."""
       
  225:         v: Optional[ExternalTraversal] = self
  324:         while v:
  225:             yield v
   99:             v = getattr(v, "_next", None)
       
    1:     def chain(self: _ExtT, visitor: ExternalTraversal) -> _ExtT:
               """'Chain' an additional ExternalTraversal onto this ExternalTraversal
       
               The chained visitor will receive all visit events after this one.
       
               """
>>>>>>         tail = list(self.visitor_iterator)[-1]
>>>>>>         tail._next = visitor
>>>>>>         return self
       
       
    2: class CloningExternalTraversal(ExternalTraversal):
    1:     """Base class for visitor objects which can traverse using
           the :func:`.visitors.cloned_traverse` function.
       
           Direct usage of the :func:`.visitors.cloned_traverse` function is usually
           preferred.
       
       
           """
       
    1:     __slots__ = ()
       
    1:     def copy_and_process(
               self, list_: List[ExternallyTraversible]
           ) -> List[ExternallyTraversible]:
               """Apply cloned traversal to the given list of elements, and return
               the new list.
       
               """
>>>>>>         return [self.traverse(x) for x in list_]
       
    1:     @overload
    1:     def traverse(self, obj: Literal[None]) -> None: ...
       
    1:     @overload
    1:     def traverse(
               self, obj: ExternallyTraversible
>>>>>>     ) -> ExternallyTraversible: ...
       
    1:     def traverse(
               self, obj: Optional[ExternallyTraversible]
           ) -> Optional[ExternallyTraversible]:
               """Traverse and visit the given expression structure."""
       
>>>>>>         return cloned_traverse(
>>>>>>             obj, self.__traverse_options__, self._visitor_dict
               )
       
       
    2: class ReplacingExternalTraversal(CloningExternalTraversal):
    1:     """Base class for visitor objects which can traverse using
           the :func:`.visitors.replacement_traverse` function.
       
           Direct usage of the :func:`.visitors.replacement_traverse` function is
           usually preferred.
       
           """
       
    1:     __slots__ = ()
       
    1:     def replace(
               self, elem: ExternallyTraversible
           ) -> Optional[ExternallyTraversible]:
               """Receive pre-copied elements during a cloning traversal.
       
               If the method returns a new element, the element is used
               instead of creating a simple copy of the element.  Traversal
               will halt on the newly returned element if it is re-encountered.
               """
>>>>>>         return None
       
    1:     @overload
    1:     def traverse(self, obj: Literal[None]) -> None: ...
       
    1:     @overload
    1:     def traverse(
               self, obj: ExternallyTraversible
>>>>>>     ) -> ExternallyTraversible: ...
       
    1:     def traverse(
               self, obj: Optional[ExternallyTraversible]
           ) -> Optional[ExternallyTraversible]:
               """Traverse and visit the given expression structure."""
       
>>>>>>         def replace(
                   element: ExternallyTraversible,
                   **kw: Any,
               ) -> Optional[ExternallyTraversible]:
>>>>>>             for v in self.visitor_iterator:
>>>>>>                 e = cast(ReplacingExternalTraversal, v).replace(element)
>>>>>>                 if e is not None:
>>>>>>                     return e
       
>>>>>>             return None
       
>>>>>>         return replacement_traverse(obj, self.__traverse_options__, replace)
       
       
       # backwards compatibility
    1: Traversible = Visitable
       
    1: ClauseVisitor = ExternalTraversal
    1: CloningVisitor = CloningExternalTraversal
    1: ReplacingCloningVisitor = ReplacingExternalTraversal
       
       
    1: def iterate(
           obj: Optional[ExternallyTraversible],
    1:     opts: Mapping[str, Any] = util.EMPTY_DICT,
       ) -> Iterator[ExternallyTraversible]:
           r"""Traverse the given expression structure, returning an iterator.
       
           Traversal is configured to be breadth-first.
       
           The central API feature used by the :func:`.visitors.iterate`
           function is the
           :meth:`_expression.ClauseElement.get_children` method of
           :class:`_expression.ClauseElement` objects.  This method should return all
           the :class:`_expression.ClauseElement` objects which are associated with a
           particular :class:`_expression.ClauseElement` object. For example, a
           :class:`.Case` structure will refer to a series of
           :class:`_expression.ColumnElement` objects within its "whens" and "else\_"
           member variables.
       
           :param obj: :class:`_expression.ClauseElement` structure to be traversed
       
           :param opts: dictionary of iteration options.   This dictionary is usually
            empty in modern usage.
       
           """
  834:     if obj is None:
>>>>>>         return
       
  834:     yield obj
  834:     children = obj.get_children(**opts)
       
  834:     if not children:
>>>>>>         return
       
  834:     stack = deque([children])
 3246:     while stack:
 2412:         t_iterator = stack.popleft()
 3990:         for t in t_iterator:
 1578:             yield t
 1578:             stack.append(t.get_children(**opts))
       
       
    1: @overload
    1: def traverse_using(
           iterator: Iterable[ExternallyTraversible],
           obj: Literal[None],
           visitors: Mapping[str, _TraverseCallableType[Any]],
>>>>>> ) -> None: ...
       
       
    1: @overload
    1: def traverse_using(
           iterator: Iterable[ExternallyTraversible],
           obj: ExternallyTraversible,
           visitors: Mapping[str, _TraverseCallableType[Any]],
>>>>>> ) -> ExternallyTraversible: ...
       
       
    1: def traverse_using(
           iterator: Iterable[ExternallyTraversible],
           obj: Optional[ExternallyTraversible],
           visitors: Mapping[str, _TraverseCallableType[Any]],
       ) -> Optional[ExternallyTraversible]:
           """Visit the given expression structure using the given iterator of
           objects.
       
           :func:`.visitors.traverse_using` is usually called internally as the result
           of the :func:`.visitors.traverse` function.
       
           :param iterator: an iterable or sequence which will yield
            :class:`_expression.ClauseElement`
            structures; the iterator is assumed to be the
            product of the :func:`.visitors.iterate` function.
       
           :param obj: the :class:`_expression.ClauseElement`
            that was used as the target of the
            :func:`.iterate` function.
       
           :param visitors: dictionary of visit functions.  See :func:`.traverse`
            for details on this dictionary.
       
           .. seealso::
       
               :func:`.traverse`
       
       
           """
  482:     for target in iterator:
  339:         meth = visitors.get(target.__visit_name__, None)
  339:         if meth:
  144:             meth(target)
  143:     return obj
       
       
    1: @overload
    1: def traverse(
           obj: Literal[None],
           opts: Mapping[str, Any],
           visitors: Mapping[str, _TraverseCallableType[Any]],
>>>>>> ) -> None: ...
       
       
    1: @overload
    1: def traverse(
           obj: ExternallyTraversible,
           opts: Mapping[str, Any],
           visitors: Mapping[str, _TraverseCallableType[Any]],
>>>>>> ) -> ExternallyTraversible: ...
       
       
    1: def traverse(
           obj: Optional[ExternallyTraversible],
           opts: Mapping[str, Any],
           visitors: Mapping[str, _TraverseCallableType[Any]],
       ) -> Optional[ExternallyTraversible]:
           """Traverse and visit the given expression structure using the default
           iterator.
       
            e.g.::
       
               from sqlalchemy.sql import visitors
       
               stmt = select(some_table).where(some_table.c.foo == 'bar')
       
               def visit_bindparam(bind_param):
                   print("found bound value: %s" % bind_param.value)
       
               visitors.traverse(stmt, {}, {"bindparam": visit_bindparam})
       
           The iteration of objects uses the :func:`.visitors.iterate` function,
           which does a breadth-first traversal using a stack.
       
           :param obj: :class:`_expression.ClauseElement` structure to be traversed
       
           :param opts: dictionary of iteration options.   This dictionary is usually
            empty in modern usage.
       
           :param visitors: dictionary of visit functions.   The dictionary should
            have strings as keys, each of which would correspond to the
            ``__visit_name__`` of a particular kind of SQL expression object, and
            callable functions  as values, each of which represents a visitor function
            for that kind of object.
       
           """
  143:     return traverse_using(iterate(obj, opts), obj, visitors)
       
       
    1: @overload
    1: def cloned_traverse(
           obj: Literal[None],
           opts: Mapping[str, Any],
           visitors: Mapping[str, _TraverseCallableType[Any]],
>>>>>> ) -> None: ...
       
       
       # a bit of controversy here, as the clone of the lead element
       # *could* in theory replace with an entirely different kind of element.
       # however this is really not how cloned_traverse is ever used internally
       # at least.
    1: @overload
    1: def cloned_traverse(
           obj: _ET,
           opts: Mapping[str, Any],
           visitors: Mapping[str, _TraverseCallableType[Any]],
>>>>>> ) -> _ET: ...
       
       
    1: def cloned_traverse(
           obj: Optional[ExternallyTraversible],
           opts: Mapping[str, Any],
           visitors: Mapping[str, _TraverseCallableType[Any]],
       ) -> Optional[ExternallyTraversible]:
           """Clone the given expression structure, allowing modifications by
           visitors for mutable objects.
       
           Traversal usage is the same as that of :func:`.visitors.traverse`.
           The visitor functions present in the ``visitors`` dictionary may also
           modify the internals of the given structure as the traversal proceeds.
       
           The :func:`.cloned_traverse` function does **not** provide objects that are
           part of the :class:`.Immutable` interface to the visit methods (this
           primarily includes :class:`.ColumnClause`, :class:`.Column`,
           :class:`.TableClause` and :class:`.Table` objects). As this traversal is
           only intended to allow in-place mutation of objects, :class:`.Immutable`
           objects are skipped. The :meth:`.Immutable._clone` method is still called
           on each object to allow for objects to replace themselves with a different
           object based on a clone of their sub-internals (e.g. a
           :class:`.ColumnClause` that clones its subquery to return a new
           :class:`.ColumnClause`).
       
           .. versionchanged:: 2.0  The :func:`.cloned_traverse` function omits
              objects that are part of the :class:`.Immutable` interface.
       
           The central API feature used by the :func:`.visitors.cloned_traverse`
           and :func:`.visitors.replacement_traverse` functions, in addition to the
           :meth:`_expression.ClauseElement.get_children`
           function that is used to achieve
           the iteration, is the :meth:`_expression.ClauseElement._copy_internals`
           method.
           For a :class:`_expression.ClauseElement`
           structure to support cloning and replacement
           traversals correctly, it needs to be able to pass a cloning function into
           its internal members in order to make copies of them.
       
           .. seealso::
       
               :func:`.visitors.traverse`
       
               :func:`.visitors.replacement_traverse`
       
           """
       
   90:     cloned: Dict[int, ExternallyTraversible] = {}
   90:     stop_on = set(opts.get("stop_on", []))
       
   90:     def deferred_copy_internals(
               obj: ExternallyTraversible,
           ) -> ExternallyTraversible:
>>>>>>         return cloned_traverse(obj, opts, visitors)
       
   90:     def clone(elem: ExternallyTraversible, **kw: Any) -> ExternallyTraversible:
  270:         if elem in stop_on:
>>>>>>             return elem
               else:
  270:             if id(elem) not in cloned:
  270:                 if "replace" in kw:
>>>>>>                     newelem = cast(
>>>>>>                         Optional[ExternallyTraversible], kw["replace"](elem)
                           )
>>>>>>                     if newelem is not None:
>>>>>>                         cloned[id(elem)] = newelem
>>>>>>                         return newelem
       
                       # the _clone method for immutable normally returns "self".
                       # however, the method is still allowed to return a
                       # different object altogether; ColumnClause._clone() will
                       # based on options clone the subquery to which it is associated
                       # and return the new corresponding column.
  270:                 cloned[id(elem)] = newelem = elem._clone(clone=clone, **kw)
  270:                 newelem._copy_internals(clone=clone, **kw)
       
                       # however, visit methods which are tasked with in-place
                       # mutation of the object should not get access to the immutable
                       # object.
  270:                 if not elem._is_immutable:
   90:                     meth = visitors.get(newelem.__visit_name__, None)
   90:                     if meth:
   90:                         meth(newelem)
  270:             return cloned[id(elem)]
       
   90:     if obj is not None:
  360:         obj = clone(
  270:             obj, deferred_copy_internals=deferred_copy_internals, **opts
               )
   90:     clone = None  # type: ignore[assignment]  # remove gc cycles
   90:     return obj
       
       
    1: @overload
    1: def replacement_traverse(
           obj: Literal[None],
           opts: Mapping[str, Any],
           replace: _TraverseTransformCallableType[Any],
>>>>>> ) -> None: ...
       
       
    1: @overload
    1: def replacement_traverse(
           obj: _CE,
           opts: Mapping[str, Any],
           replace: _TraverseTransformCallableType[Any],
>>>>>> ) -> _CE: ...
       
       
    1: @overload
    1: def replacement_traverse(
           obj: ExternallyTraversible,
           opts: Mapping[str, Any],
           replace: _TraverseTransformCallableType[Any],
>>>>>> ) -> ExternallyTraversible: ...
       
       
    1: def replacement_traverse(
           obj: Optional[ExternallyTraversible],
           opts: Mapping[str, Any],
           replace: _TraverseTransformCallableType[Any],
       ) -> Optional[ExternallyTraversible]:
           """Clone the given expression structure, allowing element
           replacement by a given replacement function.
       
           This function is very similar to the :func:`.visitors.cloned_traverse`
           function, except instead of being passed a dictionary of visitors, all
           elements are unconditionally passed into the given replace function.
           The replace function then has the option to return an entirely new object
           which will replace the one given.  If it returns ``None``, then the object
           is kept in place.
       
           The difference in usage between :func:`.visitors.cloned_traverse` and
           :func:`.visitors.replacement_traverse` is that in the former case, an
           already-cloned object is passed to the visitor function, and the visitor
           function can then manipulate the internal state of the object.
           In the case of the latter, the visitor function should only return an
           entirely different object, or do nothing.
       
           The use case for :func:`.visitors.replacement_traverse` is that of
           replacing a FROM clause inside of a SQL structure with a different one,
           as is a common use case within the ORM.
       
           """
       
  492:     cloned = {}
  984:     stop_on = {id(x) for x in opts.get("stop_on", [])}
       
  492:     def deferred_copy_internals(
               obj: ExternallyTraversible,
           ) -> ExternallyTraversible:
>>>>>>         return replacement_traverse(obj, opts, replace)
       
  492:     def clone(elem: ExternallyTraversible, **kw: Any) -> ExternallyTraversible:
 2952:         if (
 1476:             id(elem) in stop_on
 1476:             or "no_replacement_traverse" in elem._annotations
               ):
>>>>>>             return elem
               else:
 1476:             newelem = replace(elem)
 1476:             if newelem is not None:
  589:                 stop_on.add(id(newelem))
  589:                 return newelem  # type: ignore
                   else:
                       # base "already seen" on id(), not hash, so that we don't
                       # replace an Annotated element with its non-annotated one, and
                       # vice versa
  887:                 id_elem = id(elem)
  887:                 if id_elem not in cloned:
  887:                     if "replace" in kw:
>>>>>>                         newelem = kw["replace"](elem)
>>>>>>                         if newelem is not None:
>>>>>>                             cloned[id_elem] = newelem
>>>>>>                             return newelem  # type: ignore
       
  887:                     cloned[id_elem] = newelem = elem._clone(**kw)
  887:                     newelem._copy_internals(clone=clone, **kw)
  887:                 return cloned[id_elem]  # type: ignore
       
  492:     if obj is not None:
 1968:         obj = clone(
 1476:             obj, deferred_copy_internals=deferred_copy_internals, **opts
               )
  492:     clone = None  # type: ignore[assignment]  # remove gc cycles
  492:     return obj
