       # orm/path_registry.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
    1: """Path tracking utilities, representing mapper graph traversals.
       
       """
       
    1: from __future__ import annotations
       
    1: from functools import reduce
    1: from itertools import chain
    1: import logging
    1: import operator
    1: from typing import Any
    1: from typing import cast
    1: from typing import Dict
    1: from typing import Iterator
    1: from typing import List
    1: from typing import Optional
    1: from typing import overload
    1: from typing import Sequence
    1: from typing import Tuple
    1: from typing import TYPE_CHECKING
    1: from typing import Union
       
    1: from . import base as orm_base
    1: from ._typing import insp_is_mapper_property
    1: from .. import exc
    1: from .. import util
    1: from ..sql import visitors
    1: from ..sql.cache_key import HasCacheKey
       
    1: if TYPE_CHECKING:
>>>>>>     from ._typing import _InternalEntityType
>>>>>>     from .interfaces import MapperProperty
>>>>>>     from .mapper import Mapper
>>>>>>     from .relationships import RelationshipProperty
>>>>>>     from .util import AliasedInsp
>>>>>>     from ..sql.cache_key import _CacheKeyTraversalType
>>>>>>     from ..sql.elements import BindParameter
>>>>>>     from ..sql.visitors import anon_map
>>>>>>     from ..util.typing import _LiteralStar
>>>>>>     from ..util.typing import TypeGuard
       
>>>>>>     def is_root(path: PathRegistry) -> TypeGuard[RootRegistry]: ...
       
>>>>>>     def is_entity(path: PathRegistry) -> TypeGuard[AbstractEntityRegistry]: ...
       
       else:
    1:     is_root = operator.attrgetter("is_root")
    1:     is_entity = operator.attrgetter("is_entity")
       
       
    1: _SerializedPath = List[Any]
    1: _StrPathToken = str
    2: _PathElementType = Union[
    1:     _StrPathToken, "_InternalEntityType[Any]", "MapperProperty[Any]"
       ]
       
       # the representation is in fact
       # a tuple with alternating:
       # [_InternalEntityType[Any], Union[str, MapperProperty[Any]],
       # _InternalEntityType[Any], Union[str, MapperProperty[Any]], ...]
       # this might someday be a tuple of 2-tuples instead, but paths can be
       # chopped at odd intervals as well so this is less flexible
    1: _PathRepresentation = Tuple[_PathElementType, ...]
       
       # NOTE: these names are weird since the array is 0-indexed,
       # the "_Odd" entries are at 0, 2, 4, etc
    1: _OddPathRepresentation = Sequence["_InternalEntityType[Any]"]
    1: _EvenPathRepresentation = Sequence[Union["MapperProperty[Any]", str]]
       
       
    1: log = logging.getLogger(__name__)
       
       
    1: def _unreduce_path(path: _SerializedPath) -> PathRegistry:
>>>>>>     return PathRegistry.deserialize(path)
       
       
    1: _WILDCARD_TOKEN: _LiteralStar = "*"
    1: _DEFAULT_TOKEN = "_sa_default"
       
       
    2: class PathRegistry(HasCacheKey):
    1:     """Represent query load paths and registry functions.
       
           Basically represents structures like:
       
           (<User mapper>, "orders", <Order mapper>, "items", <Item mapper>)
       
           These structures are generated by things like
           query options (joinedload(), subqueryload(), etc.) and are
           used to compose keys stored in the query._attributes dictionary
           for various options.
       
           They are then re-composed at query compile/result row time as
           the query is formed and as rows are fetched, where they again
           serve to compose keys to look up options in the context.attributes
           dictionary, which is copied from query._attributes.
       
           The path structure has a limited amount of caching, where each
           "root" ultimately pulls from a fixed registry associated with
           the first mapper, that also contains elements for each of its
           property keys.  However paths longer than two elements, which
           are the exception rather than the rule, are generated on an
           as-needed basis.
       
           """
       
    1:     __slots__ = ()
       
    1:     is_token = False
    1:     is_root = False
    1:     has_entity = False
    1:     is_property = False
    1:     is_entity = False
       
    1:     is_unnatural: bool
       
    1:     path: _PathRepresentation
    1:     natural_path: _PathRepresentation
    1:     parent: Optional[PathRegistry]
    1:     root: RootRegistry
       
    1:     _cache_key_traversal: _CacheKeyTraversalType = [
    1:         ("path", visitors.ExtendedInternalTraversal.dp_has_cache_key_list)
           ]
       
    1:     def __eq__(self, other: Any) -> bool:
>>>>>>         try:
>>>>>>             return other is not None and self.path == other._path_for_compare
>>>>>>         except AttributeError:
>>>>>>             util.warn(
>>>>>>                 "Comparison of PathRegistry to %r is not supported"
>>>>>>                 % (type(other))
                   )
>>>>>>             return False
       
    1:     def __ne__(self, other: Any) -> bool:
>>>>>>         try:
>>>>>>             return other is None or self.path != other._path_for_compare
>>>>>>         except AttributeError:
>>>>>>             util.warn(
>>>>>>                 "Comparison of PathRegistry to %r is not supported"
>>>>>>                 % (type(other))
                   )
>>>>>>             return True
       
    1:     @property
    1:     def _path_for_compare(self) -> Optional[_PathRepresentation]:
>>>>>>         return self.path
       
    1:     def odd_element(self, index: int) -> _InternalEntityType[Any]:
>>>>>>         return self.path[index]  # type: ignore
       
    1:     def set(self, attributes: Dict[Any, Any], key: Any, value: Any) -> None:
    2:         log.debug("set '%s' on path '%s' to '%s'", key, self, value)
    2:         attributes[(key, self.natural_path)] = value
       
    1:     def setdefault(
               self, attributes: Dict[Any, Any], key: Any, value: Any
           ) -> None:
>>>>>>         log.debug("setdefault '%s' on path '%s' to '%s'", key, self, value)
>>>>>>         attributes.setdefault((key, self.natural_path), value)
       
    1:     def get(
               self, attributes: Dict[Any, Any], key: Any, value: Optional[Any] = None
           ) -> Any:
    2:         key = (key, self.natural_path)
    2:         if key in attributes:
    1:             return attributes[key]
               else:
    1:             return value
       
    1:     def __len__(self) -> int:
    1:         return len(self.path)
       
    1:     def __hash__(self) -> int:
>>>>>>         return id(self)
       
    1:     @overload
    1:     def __getitem__(self, entity: _StrPathToken) -> TokenRegistry: ...
       
    1:     @overload
    1:     def __getitem__(self, entity: int) -> _PathElementType: ...
       
    1:     @overload
    1:     def __getitem__(self, entity: slice) -> _PathRepresentation: ...
       
    1:     @overload
    1:     def __getitem__(
               self, entity: _InternalEntityType[Any]
>>>>>>     ) -> AbstractEntityRegistry: ...
       
    1:     @overload
    1:     def __getitem__(self, entity: MapperProperty[Any]) -> PropRegistry: ...
       
    1:     def __getitem__(
               self,
               entity: Union[
                   _StrPathToken,
                   int,
                   slice,
                   _InternalEntityType[Any],
                   MapperProperty[Any],
               ],
           ) -> Union[
               TokenRegistry,
               _PathElementType,
               _PathRepresentation,
               PropRegistry,
               AbstractEntityRegistry,
           ]:
>>>>>>         raise NotImplementedError()
       
           # TODO: what are we using this for?
    1:     @property
    1:     def length(self) -> int:
>>>>>>         return len(self.path)
       
    1:     def pairs(
               self,
           ) -> Iterator[
               Tuple[_InternalEntityType[Any], Union[str, MapperProperty[Any]]]
           ]:
>>>>>>         odd_path = cast(_OddPathRepresentation, self.path)
>>>>>>         even_path = cast(_EvenPathRepresentation, odd_path)
>>>>>>         for i in range(0, len(odd_path), 2):
>>>>>>             yield odd_path[i], even_path[i + 1]
       
    1:     def contains_mapper(self, mapper: Mapper[Any]) -> bool:
>>>>>>         _m_path = cast(_OddPathRepresentation, self.path)
>>>>>>         for path_mapper in [_m_path[i] for i in range(0, len(_m_path), 2)]:
>>>>>>             if path_mapper.mapper.isa(mapper):
>>>>>>                 return True
               else:
>>>>>>             return False
       
    1:     def contains(self, attributes: Dict[Any, Any], key: Any) -> bool:
>>>>>>         return (key, self.path) in attributes
       
    1:     def __reduce__(self) -> Any:
>>>>>>         return _unreduce_path, (self.serialize(),)
       
    1:     @classmethod
    1:     def _serialize_path(cls, path: _PathRepresentation) -> _SerializedPath:
>>>>>>         _m_path = cast(_OddPathRepresentation, path)
>>>>>>         _p_path = cast(_EvenPathRepresentation, path)
       
>>>>>>         return list(
>>>>>>             zip(
>>>>>>                 tuple(
>>>>>>                     m.class_ if (m.is_mapper or m.is_aliased_class) else str(m)
>>>>>>                     for m in [_m_path[i] for i in range(0, len(_m_path), 2)]
                       ),
>>>>>>                 tuple(
>>>>>>                     p.key if insp_is_mapper_property(p) else str(p)
>>>>>>                     for p in [_p_path[i] for i in range(1, len(_p_path), 2)]
                       )
>>>>>>                 + (None,),
                   )
               )
       
    1:     @classmethod
    1:     def _deserialize_path(cls, path: _SerializedPath) -> _PathRepresentation:
>>>>>>         def _deserialize_mapper_token(mcls: Any) -> Any:
>>>>>>             return (
                       # note: we likely dont want configure=True here however
                       # this is maintained at the moment for backwards compatibility
>>>>>>                 orm_base._inspect_mapped_class(mcls, configure=True)
>>>>>>                 if mcls not in PathToken._intern
>>>>>>                 else PathToken._intern[mcls]
                   )
       
>>>>>>         def _deserialize_key_token(mcls: Any, key: Any) -> Any:
>>>>>>             if key is None:
>>>>>>                 return None
>>>>>>             elif key in PathToken._intern:
>>>>>>                 return PathToken._intern[key]
                   else:
>>>>>>                 mp = orm_base._inspect_mapped_class(mcls, configure=True)
>>>>>>                 assert mp is not None
>>>>>>                 return mp.attrs[key]
       
>>>>>>         p = tuple(
>>>>>>             chain(
>>>>>>                 *[
>>>>>>                     (
>>>>>>                         _deserialize_mapper_token(mcls),
>>>>>>                         _deserialize_key_token(mcls, key),
                           )
>>>>>>                     for mcls, key in path
                       ]
                   )
               )
>>>>>>         if p and p[-1] is None:
>>>>>>             p = p[0:-1]
>>>>>>         return p
       
    1:     def serialize(self) -> _SerializedPath:
>>>>>>         path = self.path
>>>>>>         return self._serialize_path(path)
       
    1:     @classmethod
    1:     def deserialize(cls, path: _SerializedPath) -> PathRegistry:
>>>>>>         assert path is not None
>>>>>>         p = cls._deserialize_path(path)
>>>>>>         return cls.coerce(p)
       
    1:     @overload
    1:     @classmethod
    1:     def per_mapper(cls, mapper: Mapper[Any]) -> CachingEntityRegistry: ...
       
    1:     @overload
    1:     @classmethod
    1:     def per_mapper(cls, mapper: AliasedInsp[Any]) -> SlotsEntityRegistry: ...
       
    1:     @classmethod
    1:     def per_mapper(
               cls, mapper: _InternalEntityType[Any]
           ) -> AbstractEntityRegistry:
    1:         if mapper.is_mapper:
    1:             return CachingEntityRegistry(cls.root, mapper)
               else:
>>>>>>             return SlotsEntityRegistry(cls.root, mapper)
       
    1:     @classmethod
    1:     def coerce(cls, raw: _PathRepresentation) -> PathRegistry:
>>>>>>         def _red(prev: PathRegistry, next_: _PathElementType) -> PathRegistry:
>>>>>>             return prev[next_]
       
               # can't quite get mypy to appreciate this one :)
>>>>>>         return reduce(_red, raw, cls.root)  # type: ignore
       
    1:     def __add__(self, other: PathRegistry) -> PathRegistry:
>>>>>>         def _red(prev: PathRegistry, next_: _PathElementType) -> PathRegistry:
>>>>>>             return prev[next_]
       
>>>>>>         return reduce(_red, other.path, self)
       
    1:     def __str__(self) -> str:
>>>>>>         return f"ORM Path[{' -> '.join(str(elem) for elem in self.path)}]"
       
    1:     def __repr__(self) -> str:
>>>>>>         return f"{self.__class__.__name__}({self.path!r})"
       
       
    2: class CreatesToken(PathRegistry):
    1:     __slots__ = ()
       
    1:     is_aliased_class: bool
    1:     is_root: bool
       
    1:     def token(self, token: _StrPathToken) -> TokenRegistry:
>>>>>>         if token.endswith(f":{_WILDCARD_TOKEN}"):
>>>>>>             return TokenRegistry(self, token)
>>>>>>         elif token.endswith(f":{_DEFAULT_TOKEN}"):
>>>>>>             return TokenRegistry(self.root, token)
               else:
>>>>>>             raise exc.ArgumentError(f"invalid token: {token}")
       
       
    2: class RootRegistry(CreatesToken):
    1:     """Root registry, defers to mappers so that
           paths are maintained per-root-mapper.
       
           """
       
    1:     __slots__ = ()
       
    1:     inherit_cache = True
       
    1:     path = natural_path = ()
    1:     has_entity = False
    1:     is_aliased_class = False
    1:     is_root = True
    1:     is_unnatural = False
       
    1:     def _getitem(
               self, entity: Any
           ) -> Union[TokenRegistry, AbstractEntityRegistry]:
   78:         if entity in PathToken._intern:
>>>>>>             if TYPE_CHECKING:
>>>>>>                 assert isinstance(entity, _StrPathToken)
>>>>>>             return TokenRegistry(self, PathToken._intern[entity])
               else:
   78:             try:
   78:                 return entity._path_registry  # type: ignore
>>>>>>             except AttributeError:
>>>>>>                 raise IndexError(
>>>>>>                     f"invalid argument for RootRegistry.__getitem__: {entity}"
                       )
       
    1:     def _truncate_recursive(self) -> RootRegistry:
>>>>>>         return self
       
    1:     if not TYPE_CHECKING:
    1:         __getitem__ = _getitem
       
       
    1: PathRegistry.root = RootRegistry()
       
       
    2: class PathToken(orm_base.InspectionAttr, HasCacheKey, str):
    1:     """cacheable string token"""
       
    1:     _intern: Dict[str, PathToken] = {}
       
    1:     def _gen_cache_key(
               self, anon_map: anon_map, bindparams: List[BindParameter[Any]]
           ) -> Tuple[Any, ...]:
>>>>>>         return (str(self),)
       
    1:     @property
    1:     def _path_for_compare(self) -> Optional[_PathRepresentation]:
>>>>>>         return None
       
    1:     @classmethod
    1:     def intern(cls, strvalue: str) -> PathToken:
>>>>>>         if strvalue in cls._intern:
>>>>>>             return cls._intern[strvalue]
               else:
>>>>>>             cls._intern[strvalue] = result = PathToken(strvalue)
>>>>>>             return result
       
       
    2: class TokenRegistry(PathRegistry):
    1:     __slots__ = ("token", "parent", "path", "natural_path")
       
    1:     inherit_cache = True
       
    1:     token: _StrPathToken
    1:     parent: CreatesToken
       
    1:     def __init__(self, parent: CreatesToken, token: _StrPathToken):
>>>>>>         token = PathToken.intern(token)
       
>>>>>>         self.token = token
>>>>>>         self.parent = parent
>>>>>>         self.path = parent.path + (token,)
>>>>>>         self.natural_path = parent.natural_path + (token,)
       
    1:     has_entity = False
       
    1:     is_token = True
       
    1:     def generate_for_superclasses(self) -> Iterator[PathRegistry]:
               # NOTE: this method is no longer used.  consider removal
>>>>>>         parent = self.parent
>>>>>>         if is_root(parent):
>>>>>>             yield self
>>>>>>             return
       
>>>>>>         if TYPE_CHECKING:
>>>>>>             assert isinstance(parent, AbstractEntityRegistry)
>>>>>>         if not parent.is_aliased_class:
>>>>>>             for mp_ent in parent.mapper.iterate_to_root():
>>>>>>                 yield TokenRegistry(parent.parent[mp_ent], self.token)
>>>>>>         elif (
>>>>>>             parent.is_aliased_class
>>>>>>             and cast(
>>>>>>                 "AliasedInsp[Any]",
>>>>>>                 parent.entity,
                   )._is_with_polymorphic
               ):
>>>>>>             yield self
>>>>>>             for ent in cast(
>>>>>>                 "AliasedInsp[Any]", parent.entity
                   )._with_polymorphic_entities:
>>>>>>                 yield TokenRegistry(parent.parent[ent], self.token)
               else:
>>>>>>             yield self
       
    1:     def _generate_natural_for_superclasses(
               self,
           ) -> Iterator[_PathRepresentation]:
>>>>>>         parent = self.parent
>>>>>>         if is_root(parent):
>>>>>>             yield self.natural_path
>>>>>>             return
       
>>>>>>         if TYPE_CHECKING:
>>>>>>             assert isinstance(parent, AbstractEntityRegistry)
>>>>>>         for mp_ent in parent.mapper.iterate_to_root():
>>>>>>             yield TokenRegistry(parent.parent[mp_ent], self.token).natural_path
>>>>>>         if (
>>>>>>             parent.is_aliased_class
>>>>>>             and cast(
>>>>>>                 "AliasedInsp[Any]",
>>>>>>                 parent.entity,
                   )._is_with_polymorphic
               ):
>>>>>>             yield self.natural_path
>>>>>>             for ent in cast(
>>>>>>                 "AliasedInsp[Any]", parent.entity
                   )._with_polymorphic_entities:
>>>>>>                 yield (
>>>>>>                     TokenRegistry(parent.parent[ent], self.token).natural_path
                       )
               else:
>>>>>>             yield self.natural_path
       
    1:     def _getitem(self, entity: Any) -> Any:
>>>>>>         try:
>>>>>>             return self.path[entity]
>>>>>>         except TypeError as err:
>>>>>>             raise IndexError(f"{entity}") from err
       
    1:     if not TYPE_CHECKING:
    1:         __getitem__ = _getitem
       
       
    2: class PropRegistry(PathRegistry):
    1:     __slots__ = (
               "prop",
               "parent",
               "path",
               "natural_path",
               "has_entity",
               "entity",
               "mapper",
               "_wildcard_path_loader_key",
               "_default_path_loader_key",
               "_loader_key",
               "is_unnatural",
           )
    1:     inherit_cache = True
    1:     is_property = True
       
    1:     prop: MapperProperty[Any]
    1:     mapper: Optional[Mapper[Any]]
    1:     entity: Optional[_InternalEntityType[Any]]
       
    1:     def __init__(
               self, parent: AbstractEntityRegistry, prop: MapperProperty[Any]
           ):
               # restate this path in terms of the
               # given MapperProperty's parent.
   78:         insp = cast("_InternalEntityType[Any]", parent[-1])
   78:         natural_parent: AbstractEntityRegistry = parent
       
               # inherit "is_unnatural" from the parent
  156:         self.is_unnatural = parent.parent.is_unnatural or bool(
   78:             parent.mapper.inherits
               )
       
   78:         if not insp.is_aliased_class or insp._use_mapper_path:  # type: ignore
   78:             parent = natural_parent = parent.parent[prop.parent]
>>>>>>         elif (
>>>>>>             insp.is_aliased_class
>>>>>>             and insp.with_polymorphic_mappers
>>>>>>             and prop.parent in insp.with_polymorphic_mappers
               ):
>>>>>>             subclass_entity: _InternalEntityType[Any] = parent[-1]._entity_for_mapper(prop.parent)  # type: ignore  # noqa: E501
>>>>>>             parent = parent.parent[subclass_entity]
       
                   # when building a path where with_polymorphic() is in use,
                   # special logic to determine the "natural path" when subclass
                   # entities are used.
                   #
                   # here we are trying to distinguish between a path that starts
                   # on a the with_polymorhpic entity vs. one that starts on a
                   # normal entity that introduces a with_polymorphic() in the
                   # middle using of_type():
                   #
                   #  # as in test_polymorphic_rel->
                   #  #    test_subqueryload_on_subclass_uses_path_correctly
                   #  wp = with_polymorphic(RegularEntity, "*")
                   #  sess.query(wp).options(someload(wp.SomeSubEntity.foos))
                   #
                   # vs
                   #
                   #  # as in test_relationship->JoinedloadWPolyOfTypeContinued
                   #  wp = with_polymorphic(SomeFoo, "*")
                   #  sess.query(RegularEntity).options(
                   #       someload(RegularEntity.foos.of_type(wp))
                   #       .someload(wp.SubFoo.bar)
                   #   )
                   #
                   # in the former case, the Query as it generates a path that we
                   # want to match will be in terms of the with_polymorphic at the
                   # beginning.  in the latter case, Query will generate simple
                   # paths that don't know about this with_polymorphic, so we must
                   # use a separate natural path.
                   #
                   #
>>>>>>             if parent.parent:
>>>>>>                 natural_parent = parent.parent[subclass_entity.mapper]
>>>>>>                 self.is_unnatural = True
                   else:
>>>>>>                 natural_parent = parent
>>>>>>         elif (
>>>>>>             natural_parent.parent
>>>>>>             and insp.is_aliased_class
>>>>>>             and prop.parent  # this should always be the case here
>>>>>>             is not insp.mapper
>>>>>>             and insp.mapper.isa(prop.parent)
               ):
>>>>>>             natural_parent = parent.parent[prop.parent]
       
   78:         self.prop = prop
   78:         self.parent = parent
   78:         self.path = parent.path + (prop,)
   78:         self.natural_path = natural_parent.natural_path + (prop,)
       
   78:         self.has_entity = prop._links_to_entity
   78:         if prop._is_relationship:
   33:             if TYPE_CHECKING:
>>>>>>                 assert isinstance(prop, RelationshipProperty)
   33:             self.entity = prop.entity
   33:             self.mapper = prop.mapper
               else:
   45:             self.entity = None
   45:             self.mapper = None
       
   78:         self._wildcard_path_loader_key = (
   78:             "loader",
   78:             parent.natural_path + self.prop._wildcard_token,
               )
   78:         self._default_path_loader_key = self.prop._default_path_loader_key
   78:         self._loader_key = ("loader", self.natural_path)
       
    1:     def _truncate_recursive(self) -> PropRegistry:
>>>>>>         earliest = None
>>>>>>         for i, token in enumerate(reversed(self.path[:-1])):
>>>>>>             if token is self.prop:
>>>>>>                 earliest = i
       
>>>>>>         if earliest is None:
>>>>>>             return self
               else:
>>>>>>             return self.coerce(self.path[0 : -(earliest + 1)])  # type: ignore
       
    1:     @property
    1:     def entity_path(self) -> AbstractEntityRegistry:
>>>>>>         assert self.entity is not None
>>>>>>         return self[self.entity]
       
    1:     def _getitem(
               self, entity: Union[int, slice, _InternalEntityType[Any]]
           ) -> Union[AbstractEntityRegistry, _PathElementType, _PathRepresentation]:
>>>>>>         if isinstance(entity, (int, slice)):
>>>>>>             return self.path[entity]
               else:
>>>>>>             return SlotsEntityRegistry(self, entity)
       
    1:     if not TYPE_CHECKING:
    1:         __getitem__ = _getitem
       
       
    2: class AbstractEntityRegistry(CreatesToken):
    1:     __slots__ = (
               "key",
               "parent",
               "is_aliased_class",
               "path",
               "entity",
               "natural_path",
           )
       
    1:     has_entity = True
    1:     is_entity = True
       
    1:     parent: Union[RootRegistry, PropRegistry]
    1:     key: _InternalEntityType[Any]
    1:     entity: _InternalEntityType[Any]
    1:     is_aliased_class: bool
       
    1:     def __init__(
               self,
               parent: Union[RootRegistry, PropRegistry],
               entity: _InternalEntityType[Any],
           ):
    1:         self.key = entity
    1:         self.parent = parent
    1:         self.is_aliased_class = entity.is_aliased_class
    1:         self.entity = entity
    1:         self.path = parent.path + (entity,)
       
               # the "natural path" is the path that we get when Query is traversing
               # from the lead entities into the various relationships; it corresponds
               # to the structure of mappers and relationships. when we are given a
               # path that comes from loader options, as of 1.3 it can have ac-hoc
               # with_polymorphic() and other AliasedInsp objects inside of it, which
               # are usually not present in mappings.  So here we track both the
               # "enhanced" path in self.path and the "natural" path that doesn't
               # include those objects so these two traversals can be matched up.
       
               # the test here for "(self.is_aliased_class or parent.is_unnatural)"
               # are to avoid the more expensive conditional logic that follows if we
               # know we don't have to do it.   This conditional can just as well be
               # "if parent.path:", it just is more function calls.
               #
               # This is basically the only place that the "is_unnatural" flag
               # actually changes behavior.
    1:         if parent.path and (self.is_aliased_class or parent.is_unnatural):
                   # this is an infrequent code path used only for loader strategies
                   # that also make use of of_type().
>>>>>>             if entity.mapper.isa(parent.natural_path[-1].mapper):  # type: ignore # noqa: E501
>>>>>>                 self.natural_path = parent.natural_path + (entity.mapper,)
                   else:
>>>>>>                 self.natural_path = parent.natural_path + (
>>>>>>                     parent.natural_path[-1].entity,  # type: ignore
                       )
               # it seems to make sense that since these paths get mixed up
               # with statements that are cached or not, we should make
               # sure the natural path is cacheable across different occurrences
               # of equivalent AliasedClass objects.  however, so far this
               # does not seem to be needed for whatever reason.
               # elif not parent.path and self.is_aliased_class:
               #     self.natural_path = (self.entity._generate_cache_key()[0], )
               else:
    1:             self.natural_path = self.path
       
    1:     def _truncate_recursive(self) -> AbstractEntityRegistry:
>>>>>>         return self.parent._truncate_recursive()[self.entity]
       
    1:     @property
    1:     def root_entity(self) -> _InternalEntityType[Any]:
>>>>>>         return self.odd_element(0)
       
    1:     @property
    1:     def entity_path(self) -> PathRegistry:
>>>>>>         return self
       
    1:     @property
    1:     def mapper(self) -> Mapper[Any]:
   78:         return self.entity.mapper
       
    1:     def __bool__(self) -> bool:
>>>>>>         return True
       
    1:     def _getitem(
               self, entity: Any
           ) -> Union[_PathElementType, _PathRepresentation, PathRegistry]:
>>>>>>         if isinstance(entity, (int, slice)):
>>>>>>             return self.path[entity]
>>>>>>         elif entity in PathToken._intern:
>>>>>>             return TokenRegistry(self, PathToken._intern[entity])
               else:
>>>>>>             return PropRegistry(self, entity)
       
    1:     if not TYPE_CHECKING:
    1:         __getitem__ = _getitem
       
       
    2: class SlotsEntityRegistry(AbstractEntityRegistry):
           # for aliased class, return lightweight, no-cycles created
           # version
    1:     inherit_cache = True
       
       
    2: class _ERDict(Dict[Any, Any]):
    1:     def __init__(self, registry: CachingEntityRegistry):
    1:         self.registry = registry
       
    1:     def __missing__(self, key: Any) -> PropRegistry:
   78:         self[key] = item = PropRegistry(self.registry, key)
       
   78:         return item
       
       
    2: class CachingEntityRegistry(AbstractEntityRegistry):
           # for long lived mapper, return dict based caching
           # version that creates reference cycles
       
    1:     __slots__ = ("_cache",)
       
    1:     inherit_cache = True
       
    1:     def __init__(
               self,
               parent: Union[RootRegistry, PropRegistry],
               entity: _InternalEntityType[Any],
           ):
    1:         super().__init__(parent, entity)
    1:         self._cache = _ERDict(self)
       
    1:     def pop(self, key: Any, default: Any) -> Any:
>>>>>>         return self._cache.pop(key, default)
       
    1:     def _getitem(self, entity: Any) -> Any:
  189:         if isinstance(entity, (int, slice)):
   78:             return self.path[entity]
  111:         elif isinstance(entity, PathToken):
>>>>>>             return TokenRegistry(self, entity)
               else:
  111:             return self._cache[entity]
       
    1:     if not TYPE_CHECKING:
    1:         __getitem__ = _getitem
       
       
    1: if TYPE_CHECKING:
       
>>>>>>     def path_is_entity(
               path: PathRegistry,
>>>>>>     ) -> TypeGuard[AbstractEntityRegistry]: ...
       
>>>>>>     def path_is_property(path: PathRegistry) -> TypeGuard[PropRegistry]: ...
       
       else:
    1:     path_is_entity = operator.attrgetter("is_entity")
    1:     path_is_property = operator.attrgetter("is_property")
