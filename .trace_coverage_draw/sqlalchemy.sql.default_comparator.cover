       # sql/default_comparator.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: """Default implementation of SQL comparison operations.
       """
       
    1: from __future__ import annotations
       
    1: import typing
    1: from typing import Any
    1: from typing import Callable
    1: from typing import Dict
    1: from typing import NoReturn
    1: from typing import Optional
    1: from typing import Tuple
    1: from typing import Type
    1: from typing import Union
       
    1: from . import coercions
    1: from . import operators
    1: from . import roles
    1: from . import type_api
    1: from .elements import and_
    1: from .elements import BinaryExpression
    1: from .elements import ClauseElement
    1: from .elements import CollationClause
    1: from .elements import CollectionAggregate
    1: from .elements import ExpressionClauseList
    1: from .elements import False_
    1: from .elements import Null
    1: from .elements import OperatorExpression
    1: from .elements import or_
    1: from .elements import True_
    1: from .elements import UnaryExpression
    1: from .operators import OperatorType
    1: from .. import exc
    1: from .. import util
       
    1: _T = typing.TypeVar("_T", bound=Any)
       
    1: if typing.TYPE_CHECKING:
>>>>>>     from .elements import ColumnElement
>>>>>>     from .operators import custom_op
>>>>>>     from .type_api import TypeEngine
       
       
    1: def _boolean_compare(
           expr: ColumnElement[Any],
           op: OperatorType,
           obj: Any,
           *,
    1:     negate_op: Optional[OperatorType] = None,
    1:     reverse: bool = False,
    1:     _python_is_types: Tuple[Type[Any], ...] = (type(None), bool),
    1:     result_type: Optional[TypeEngine[bool]] = None,
           **kwargs: Any,
       ) -> OperatorExpression[bool]:
  634:     if result_type is None:
  634:         result_type = type_api.BOOLEANTYPE
       
  634:     if isinstance(obj, _python_is_types + (Null, True_, False_)):
               # allow x ==/!= True/False to be treated as a literal.
               # this comes out to "== / != true/false" or "1/0" if those
               # constants aren't supported and works on all platforms
>>>>>>         if op in (operators.eq, operators.ne) and isinstance(
>>>>>>             obj, (bool, True_, False_)
               ):
>>>>>>             return OperatorExpression._construct_for_op(
>>>>>>                 expr,
>>>>>>                 coercions.expect(roles.ConstExprRole, obj),
>>>>>>                 op,
>>>>>>                 type_=result_type,
>>>>>>                 negate=negate_op,
>>>>>>                 modifiers=kwargs,
                   )
>>>>>>         elif op in (
>>>>>>             operators.is_distinct_from,
>>>>>>             operators.is_not_distinct_from,
               ):
>>>>>>             return OperatorExpression._construct_for_op(
>>>>>>                 expr,
>>>>>>                 coercions.expect(roles.ConstExprRole, obj),
>>>>>>                 op,
>>>>>>                 type_=result_type,
>>>>>>                 negate=negate_op,
>>>>>>                 modifiers=kwargs,
                   )
>>>>>>         elif expr._is_collection_aggregate:
>>>>>>             obj = coercions.expect(
>>>>>>                 roles.ConstExprRole, element=obj, operator=op, expr=expr
                   )
               else:
                   # all other None uses IS, IS NOT
>>>>>>             if op in (operators.eq, operators.is_):
>>>>>>                 return OperatorExpression._construct_for_op(
>>>>>>                     expr,
>>>>>>                     coercions.expect(roles.ConstExprRole, obj),
>>>>>>                     operators.is_,
>>>>>>                     negate=operators.is_not,
>>>>>>                     type_=result_type,
                       )
>>>>>>             elif op in (operators.ne, operators.is_not):
>>>>>>                 return OperatorExpression._construct_for_op(
>>>>>>                     expr,
>>>>>>                     coercions.expect(roles.ConstExprRole, obj),
>>>>>>                     operators.is_not,
>>>>>>                     negate=operators.is_,
>>>>>>                     type_=result_type,
                       )
                   else:
>>>>>>                 raise exc.ArgumentError(
>>>>>>                     "Only '=', '!=', 'is_()', 'is_not()', "
                           "'is_distinct_from()', 'is_not_distinct_from()' "
                           "operators can be used with None/True/False"
                       )
           else:
 1268:         obj = coercions.expect(
  634:             roles.BinaryElementRole, element=obj, operator=op, expr=expr
               )
       
  634:     if reverse:
>>>>>>         return OperatorExpression._construct_for_op(
>>>>>>             obj,
>>>>>>             expr,
>>>>>>             op,
>>>>>>             type_=result_type,
>>>>>>             negate=negate_op,
>>>>>>             modifiers=kwargs,
               )
           else:
 1268:         return OperatorExpression._construct_for_op(
  634:             expr,
  634:             obj,
  634:             op,
  634:             type_=result_type,
  634:             negate=negate_op,
  634:             modifiers=kwargs,
               )
       
       
    1: def _custom_op_operate(
           expr: ColumnElement[Any],
           op: custom_op[Any],
           obj: Any,
           reverse: bool = False,
           result_type: Optional[TypeEngine[Any]] = None,
           **kw: Any,
       ) -> ColumnElement[Any]:
>>>>>>     if result_type is None:
>>>>>>         if op.return_type:
>>>>>>             result_type = op.return_type
>>>>>>         elif op.is_comparison:
>>>>>>             result_type = type_api.BOOLEANTYPE
       
>>>>>>     return _binary_operate(
>>>>>>         expr, op, obj, reverse=reverse, result_type=result_type, **kw
           )
       
       
    1: def _binary_operate(
           expr: ColumnElement[Any],
           op: OperatorType,
           obj: roles.BinaryElementRole[Any],
           *,
    1:     reverse: bool = False,
    1:     result_type: Optional[TypeEngine[_T]] = None,
           **kw: Any,
       ) -> OperatorExpression[_T]:
>>>>>>     coerced_obj = coercions.expect(
>>>>>>         roles.BinaryElementRole, obj, expr=expr, operator=op
           )
       
>>>>>>     if reverse:
>>>>>>         left, right = coerced_obj, expr
           else:
>>>>>>         left, right = expr, coerced_obj
       
>>>>>>     if result_type is None:
>>>>>>         op, result_type = left.comparator._adapt_expression(
>>>>>>             op, right.comparator
               )
       
>>>>>>     return OperatorExpression._construct_for_op(
>>>>>>         left, right, op, type_=result_type, modifiers=kw
           )
       
       
    1: def _conjunction_operate(
           expr: ColumnElement[Any], op: OperatorType, other: Any, **kw: Any
       ) -> ColumnElement[Any]:
>>>>>>     if op is operators.and_:
>>>>>>         return and_(expr, other)
>>>>>>     elif op is operators.or_:
>>>>>>         return or_(expr, other)
           else:
>>>>>>         raise NotImplementedError()
       
       
    1: def _scalar(
           expr: ColumnElement[Any],
           op: OperatorType,
           fn: Callable[[ColumnElement[Any]], ColumnElement[Any]],
           **kw: Any,
       ) -> ColumnElement[Any]:
>>>>>>     return fn(expr)
       
       
    1: def _in_impl(
           expr: ColumnElement[Any],
           op: OperatorType,
           seq_or_selectable: ClauseElement,
           negate_op: OperatorType,
           **kw: Any,
       ) -> ColumnElement[Any]:
>>>>>>     seq_or_selectable = coercions.expect(
>>>>>>         roles.InElementRole, seq_or_selectable, expr=expr, operator=op
           )
>>>>>>     if "in_ops" in seq_or_selectable._annotations:
>>>>>>         op, negate_op = seq_or_selectable._annotations["in_ops"]
       
>>>>>>     return _boolean_compare(
>>>>>>         expr, op, seq_or_selectable, negate_op=negate_op, **kw
           )
       
       
    1: def _getitem_impl(
           expr: ColumnElement[Any], op: OperatorType, other: Any, **kw: Any
       ) -> ColumnElement[Any]:
>>>>>>     if (
>>>>>>         isinstance(expr.type, type_api.INDEXABLE)
>>>>>>         or isinstance(expr.type, type_api.TypeDecorator)
>>>>>>         and isinstance(expr.type.impl_instance, type_api.INDEXABLE)
           ):
>>>>>>         other = coercions.expect(
>>>>>>             roles.BinaryElementRole, other, expr=expr, operator=op
               )
>>>>>>         return _binary_operate(expr, op, other, **kw)
           else:
>>>>>>         _unsupported_impl(expr, op, other, **kw)
       
       
    1: def _unsupported_impl(
           expr: ColumnElement[Any], op: OperatorType, *arg: Any, **kw: Any
       ) -> NoReturn:
>>>>>>     raise NotImplementedError(
>>>>>>         "Operator '%s' is not supported on this expression" % op.__name__
           )
       
       
    1: def _inv_impl(
           expr: ColumnElement[Any], op: OperatorType, **kw: Any
       ) -> ColumnElement[Any]:
           """See :meth:`.ColumnOperators.__inv__`."""
       
           # undocumented element currently used by the ORM for
           # relationship.contains()
>>>>>>     if hasattr(expr, "negation_clause"):
>>>>>>         return expr.negation_clause
           else:
>>>>>>         return expr._negate()
       
       
    1: def _neg_impl(
           expr: ColumnElement[Any], op: OperatorType, **kw: Any
       ) -> ColumnElement[Any]:
           """See :meth:`.ColumnOperators.__neg__`."""
>>>>>>     return UnaryExpression(expr, operator=operators.neg, type_=expr.type)
       
       
    1: def _bitwise_not_impl(
           expr: ColumnElement[Any], op: OperatorType, **kw: Any
       ) -> ColumnElement[Any]:
           """See :meth:`.ColumnOperators.bitwise_not`."""
       
>>>>>>     return UnaryExpression(
>>>>>>         expr, operator=operators.bitwise_not_op, type_=expr.type
           )
       
       
    1: def _match_impl(
           expr: ColumnElement[Any], op: OperatorType, other: Any, **kw: Any
       ) -> ColumnElement[Any]:
           """See :meth:`.ColumnOperators.match`."""
       
>>>>>>     return _boolean_compare(
>>>>>>         expr,
>>>>>>         operators.match_op,
>>>>>>         coercions.expect(
>>>>>>             roles.BinaryElementRole,
>>>>>>             other,
>>>>>>             expr=expr,
>>>>>>             operator=operators.match_op,
               ),
>>>>>>         result_type=type_api.MATCHTYPE,
               negate_op=(
>>>>>>             operators.not_match_op
>>>>>>             if op is operators.match_op
>>>>>>             else operators.match_op
               ),
>>>>>>         **kw,
           )
       
       
    1: def _distinct_impl(
           expr: ColumnElement[Any], op: OperatorType, **kw: Any
       ) -> ColumnElement[Any]:
           """See :meth:`.ColumnOperators.distinct`."""
>>>>>>     return UnaryExpression(
>>>>>>         expr, operator=operators.distinct_op, type_=expr.type
           )
       
       
    1: def _between_impl(
           expr: ColumnElement[Any],
           op: OperatorType,
           cleft: Any,
           cright: Any,
           **kw: Any,
       ) -> ColumnElement[Any]:
           """See :meth:`.ColumnOperators.between`."""
>>>>>>     return BinaryExpression(
>>>>>>         expr,
>>>>>>         ExpressionClauseList._construct_for_list(
>>>>>>             operators.and_,
>>>>>>             type_api.NULLTYPE,
>>>>>>             coercions.expect(
>>>>>>                 roles.BinaryElementRole,
>>>>>>                 cleft,
>>>>>>                 expr=expr,
>>>>>>                 operator=operators.and_,
                   ),
>>>>>>             coercions.expect(
>>>>>>                 roles.BinaryElementRole,
>>>>>>                 cright,
>>>>>>                 expr=expr,
>>>>>>                 operator=operators.and_,
                   ),
>>>>>>             group=False,
               ),
>>>>>>         op,
               negate=(
>>>>>>             operators.not_between_op
>>>>>>             if op is operators.between_op
>>>>>>             else operators.between_op
               ),
>>>>>>         modifiers=kw,
           )
       
       
    1: def _collate_impl(
           expr: ColumnElement[str], op: OperatorType, collation: str, **kw: Any
       ) -> ColumnElement[str]:
>>>>>>     return CollationClause._create_collation_expression(expr, collation)
       
       
    1: def _regexp_match_impl(
           expr: ColumnElement[str],
           op: OperatorType,
           pattern: Any,
           flags: Optional[str],
           **kw: Any,
       ) -> ColumnElement[Any]:
>>>>>>     return BinaryExpression(
>>>>>>         expr,
>>>>>>         coercions.expect(
>>>>>>             roles.BinaryElementRole,
>>>>>>             pattern,
>>>>>>             expr=expr,
>>>>>>             operator=operators.comma_op,
               ),
>>>>>>         op,
>>>>>>         negate=operators.not_regexp_match_op,
>>>>>>         modifiers={"flags": flags},
           )
       
       
    1: def _regexp_replace_impl(
           expr: ColumnElement[Any],
           op: OperatorType,
           pattern: Any,
           replacement: Any,
           flags: Optional[str],
           **kw: Any,
       ) -> ColumnElement[Any]:
>>>>>>     return BinaryExpression(
>>>>>>         expr,
>>>>>>         ExpressionClauseList._construct_for_list(
>>>>>>             operators.comma_op,
>>>>>>             type_api.NULLTYPE,
>>>>>>             coercions.expect(
>>>>>>                 roles.BinaryElementRole,
>>>>>>                 pattern,
>>>>>>                 expr=expr,
>>>>>>                 operator=operators.comma_op,
                   ),
>>>>>>             coercions.expect(
>>>>>>                 roles.BinaryElementRole,
>>>>>>                 replacement,
>>>>>>                 expr=expr,
>>>>>>                 operator=operators.comma_op,
                   ),
>>>>>>             group=False,
               ),
>>>>>>         op,
>>>>>>         modifiers={"flags": flags},
           )
       
       
       # a mapping of operators with the method they use, along with
       # additional keyword arguments to be passed
    1: operator_lookup: Dict[
           str,
           Tuple[
               Callable[..., ColumnElement[Any]],
               util.immutabledict[
                   str, Union[OperatorType, Callable[..., ColumnElement[Any]]]
               ],
           ],
    1: ] = {
    1:     "and_": (_conjunction_operate, util.EMPTY_DICT),
    1:     "or_": (_conjunction_operate, util.EMPTY_DICT),
    1:     "inv": (_inv_impl, util.EMPTY_DICT),
    1:     "add": (_binary_operate, util.EMPTY_DICT),
    1:     "mul": (_binary_operate, util.EMPTY_DICT),
    1:     "sub": (_binary_operate, util.EMPTY_DICT),
    1:     "div": (_binary_operate, util.EMPTY_DICT),
    1:     "mod": (_binary_operate, util.EMPTY_DICT),
    1:     "bitwise_xor_op": (_binary_operate, util.EMPTY_DICT),
    1:     "bitwise_or_op": (_binary_operate, util.EMPTY_DICT),
    1:     "bitwise_and_op": (_binary_operate, util.EMPTY_DICT),
    1:     "bitwise_not_op": (_bitwise_not_impl, util.EMPTY_DICT),
    1:     "bitwise_lshift_op": (_binary_operate, util.EMPTY_DICT),
    1:     "bitwise_rshift_op": (_binary_operate, util.EMPTY_DICT),
    1:     "truediv": (_binary_operate, util.EMPTY_DICT),
    1:     "floordiv": (_binary_operate, util.EMPTY_DICT),
    1:     "custom_op": (_custom_op_operate, util.EMPTY_DICT),
    1:     "json_path_getitem_op": (_binary_operate, util.EMPTY_DICT),
    1:     "json_getitem_op": (_binary_operate, util.EMPTY_DICT),
    1:     "concat_op": (_binary_operate, util.EMPTY_DICT),
    1:     "any_op": (
    1:         _scalar,
    1:         util.immutabledict({"fn": CollectionAggregate._create_any}),
           ),
    1:     "all_op": (
    1:         _scalar,
    1:         util.immutabledict({"fn": CollectionAggregate._create_all}),
           ),
    1:     "lt": (_boolean_compare, util.immutabledict({"negate_op": operators.ge})),
    1:     "le": (_boolean_compare, util.immutabledict({"negate_op": operators.gt})),
    1:     "ne": (_boolean_compare, util.immutabledict({"negate_op": operators.eq})),
    1:     "gt": (_boolean_compare, util.immutabledict({"negate_op": operators.le})),
    1:     "ge": (_boolean_compare, util.immutabledict({"negate_op": operators.lt})),
    1:     "eq": (_boolean_compare, util.immutabledict({"negate_op": operators.ne})),
    1:     "is_distinct_from": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.is_not_distinct_from}),
           ),
    1:     "is_not_distinct_from": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.is_distinct_from}),
           ),
    1:     "like_op": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.not_like_op}),
           ),
    1:     "ilike_op": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.not_ilike_op}),
           ),
    1:     "not_like_op": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.like_op}),
           ),
    1:     "not_ilike_op": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.ilike_op}),
           ),
    1:     "contains_op": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.not_contains_op}),
           ),
    1:     "icontains_op": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.not_icontains_op}),
           ),
    1:     "startswith_op": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.not_startswith_op}),
           ),
    1:     "istartswith_op": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.not_istartswith_op}),
           ),
    1:     "endswith_op": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.not_endswith_op}),
           ),
    1:     "iendswith_op": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.not_iendswith_op}),
           ),
    1:     "desc_op": (
    1:         _scalar,
    1:         util.immutabledict({"fn": UnaryExpression._create_desc}),
           ),
    1:     "asc_op": (
    1:         _scalar,
    1:         util.immutabledict({"fn": UnaryExpression._create_asc}),
           ),
    1:     "nulls_first_op": (
    1:         _scalar,
    1:         util.immutabledict({"fn": UnaryExpression._create_nulls_first}),
           ),
    1:     "nulls_last_op": (
    1:         _scalar,
    1:         util.immutabledict({"fn": UnaryExpression._create_nulls_last}),
           ),
    1:     "in_op": (
    1:         _in_impl,
    1:         util.immutabledict({"negate_op": operators.not_in_op}),
           ),
    1:     "not_in_op": (
    1:         _in_impl,
    1:         util.immutabledict({"negate_op": operators.in_op}),
           ),
    1:     "is_": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.is_}),
           ),
    1:     "is_not": (
    1:         _boolean_compare,
    1:         util.immutabledict({"negate_op": operators.is_not}),
           ),
    1:     "collate": (_collate_impl, util.EMPTY_DICT),
    1:     "match_op": (_match_impl, util.EMPTY_DICT),
    1:     "not_match_op": (_match_impl, util.EMPTY_DICT),
    1:     "distinct_op": (_distinct_impl, util.EMPTY_DICT),
    1:     "between_op": (_between_impl, util.EMPTY_DICT),
    1:     "not_between_op": (_between_impl, util.EMPTY_DICT),
    1:     "neg": (_neg_impl, util.EMPTY_DICT),
    1:     "getitem": (_getitem_impl, util.EMPTY_DICT),
    1:     "lshift": (_unsupported_impl, util.EMPTY_DICT),
    1:     "rshift": (_unsupported_impl, util.EMPTY_DICT),
    1:     "contains": (_unsupported_impl, util.EMPTY_DICT),
    1:     "regexp_match_op": (_regexp_match_impl, util.EMPTY_DICT),
    1:     "not_regexp_match_op": (_regexp_match_impl, util.EMPTY_DICT),
    1:     "regexp_replace_op": (_regexp_replace_impl, util.EMPTY_DICT),
       }
