    1: import inspect
    1: from contextlib import AsyncExitStack, contextmanager
    1: from copy import deepcopy
    1: from typing import (
           Any,
           Callable,
           Coroutine,
           Dict,
           ForwardRef,
           List,
           Mapping,
           Optional,
           Sequence,
           Tuple,
           Type,
           Union,
           cast,
       )
       
    1: import anyio
    1: from fastapi import params
    1: from fastapi._compat import (
           PYDANTIC_V2,
           ErrorWrapper,
           ModelField,
           Required,
           Undefined,
           _regenerate_error_with_loc,
           copy_field_info,
           create_body_model,
           evaluate_forwardref,
           field_annotation_is_scalar,
           get_annotation_from_field_info,
           get_missing_field_error,
           is_bytes_field,
           is_bytes_sequence_field,
           is_scalar_field,
           is_scalar_sequence_field,
           is_sequence_field,
           is_uploadfile_or_nonable_uploadfile_annotation,
           is_uploadfile_sequence_annotation,
           lenient_issubclass,
           sequence_types,
           serialize_sequence_value,
           value_is_sequence,
       )
    1: from fastapi.background import BackgroundTasks
    1: from fastapi.concurrency import (
           asynccontextmanager,
           contextmanager_in_threadpool,
       )
    1: from fastapi.dependencies.models import Dependant, SecurityRequirement
    1: from fastapi.logger import logger
    1: from fastapi.security.base import SecurityBase
    1: from fastapi.security.oauth2 import OAuth2, SecurityScopes
    1: from fastapi.security.open_id_connect_url import OpenIdConnect
    1: from fastapi.utils import create_response_field, get_path_param_names
    1: from pydantic.fields import FieldInfo
    1: from starlette.background import BackgroundTasks as StarletteBackgroundTasks
    1: from starlette.concurrency import run_in_threadpool
    1: from starlette.datastructures import FormData, Headers, QueryParams, UploadFile
    1: from starlette.requests import HTTPConnection, Request
    1: from starlette.responses import Response
    1: from starlette.websockets import WebSocket
    1: from typing_extensions import Annotated, get_args, get_origin
       
    1: multipart_not_installed_error = (
    1:     'Form data requires "python-multipart" to be installed. \n'
           'You can install "python-multipart" with: \n\n'
           "pip install python-multipart\n"
       )
    1: multipart_incorrect_install_error = (
    1:     'Form data requires "python-multipart" to be installed. '
           'It seems you installed "multipart" instead. \n'
           'You can remove "multipart" with: \n\n'
           "pip uninstall multipart\n\n"
           'And then install "python-multipart" with: \n\n'
           "pip install python-multipart\n"
       )
       
       
    1: def check_file_field(field: ModelField) -> None:
   33:     field_info = field.field_info
   33:     if isinstance(field_info, params.Form):
>>>>>>         try:
                   # __version__ is available in both multiparts, and can be mocked
>>>>>>             from multipart import __version__  # type: ignore
       
>>>>>>             assert __version__
>>>>>>             try:
                       # parse_options_header is only available in the right multipart
>>>>>>                 from multipart.multipart import parse_options_header  # type: ignore
       
>>>>>>                 assert parse_options_header
>>>>>>             except ImportError:
>>>>>>                 logger.error(multipart_incorrect_install_error)
>>>>>>                 raise RuntimeError(multipart_incorrect_install_error) from None
>>>>>>         except ImportError:
>>>>>>             logger.error(multipart_not_installed_error)
>>>>>>             raise RuntimeError(multipart_not_installed_error) from None
       
       
    2: def get_param_sub_dependant(
           *,
    1:     param_name: str,
    1:     depends: params.Depends,
    1:     path: str,
    2:     security_scopes: Optional[List[str]] = None,
    1: ) -> Dependant:
  195:     assert depends.dependency
  390:     return get_sub_dependant(
  195:         depends=depends,
  195:         dependency=depends.dependency,
  195:         path=path,
  195:         name=param_name,
  195:         security_scopes=security_scopes,
           )
       
       
    1: def get_parameterless_sub_dependant(*, depends: params.Depends, path: str) -> Dependant:
>>>>>>     assert callable(
>>>>>>         depends.dependency
>>>>>>     ), "A parameter-less dependency must have a callable dependency"
>>>>>>     return get_sub_dependant(depends=depends, dependency=depends.dependency, path=path)
       
       
    2: def get_sub_dependant(
           *,
    1:     depends: params.Depends,
    1:     dependency: Callable[..., Any],
    1:     path: str,
    2:     name: Optional[str] = None,
    2:     security_scopes: Optional[List[str]] = None,
    1: ) -> Dependant:
  195:     security_requirement = None
  195:     security_scopes = security_scopes or []
  195:     if isinstance(depends, params.Security):
>>>>>>         dependency_scopes = depends.scopes
>>>>>>         security_scopes.extend(dependency_scopes)
  195:     if isinstance(dependency, SecurityBase):
>>>>>>         use_scopes: List[str] = []
>>>>>>         if isinstance(dependency, (OAuth2, OpenIdConnect)):
>>>>>>             use_scopes = security_scopes
>>>>>>         security_requirement = SecurityRequirement(
>>>>>>             security_scheme=dependency, scopes=use_scopes
               )
  390:     sub_dependant = get_dependant(
  195:         path=path,
  195:         call=dependency,
  195:         name=name,
  195:         security_scopes=security_scopes,
  195:         use_cache=depends.use_cache,
           )
  195:     if security_requirement:
>>>>>>         sub_dependant.security_requirements.append(security_requirement)
  195:     return sub_dependant
       
       
    1: CacheKey = Tuple[Optional[Callable[..., Any]], Tuple[str, ...]]
       
       
    2: def get_flat_dependant(
    1:     dependant: Dependant,
           *,
    2:     skip_repeats: bool = False,
    2:     visited: Optional[List[CacheKey]] = None,
    1: ) -> Dependant:
  260:     if visited is None:
   65:         visited = []
  260:     visited.append(dependant.cache_key)
       
  520:     flat_dependant = Dependant(
  260:         path_params=dependant.path_params.copy(),
  260:         query_params=dependant.query_params.copy(),
  260:         header_params=dependant.header_params.copy(),
  260:         cookie_params=dependant.cookie_params.copy(),
  260:         body_params=dependant.body_params.copy(),
  260:         security_schemes=dependant.security_requirements.copy(),
  260:         use_cache=dependant.use_cache,
  260:         path=dependant.path,
           )
  455:     for sub_dependant in dependant.dependencies:
  195:         if skip_repeats and sub_dependant.cache_key in visited:
>>>>>>             continue
  390:         flat_sub = get_flat_dependant(
  195:             sub_dependant, skip_repeats=skip_repeats, visited=visited
               )
  195:         flat_dependant.path_params.extend(flat_sub.path_params)
  195:         flat_dependant.query_params.extend(flat_sub.query_params)
  195:         flat_dependant.header_params.extend(flat_sub.header_params)
  195:         flat_dependant.cookie_params.extend(flat_sub.cookie_params)
  195:         flat_dependant.body_params.extend(flat_sub.body_params)
  195:         flat_dependant.security_requirements.extend(flat_sub.security_requirements)
  260:     return flat_dependant
       
       
    1: def get_flat_params(dependant: Dependant) -> List[ModelField]:
>>>>>>     flat_dependant = get_flat_dependant(dependant, skip_repeats=True)
>>>>>>     return (
>>>>>>         flat_dependant.path_params
>>>>>>         + flat_dependant.query_params
>>>>>>         + flat_dependant.header_params
>>>>>>         + flat_dependant.cookie_params
           )
       
       
    1: def get_typed_signature(call: Callable[..., Any]) -> inspect.Signature:
  284:     signature = inspect.signature(call)
  284:     globalns = getattr(call, "__globals__", {})
 1212:     typed_params = [
  720:         inspect.Parameter(
  360:             name=param.name,
  360:             kind=param.kind,
  360:             default=param.default,
  360:             annotation=get_typed_annotation(param.annotation, globalns),
               )
  644:         for param in signature.parameters.values()
           ]
  284:     typed_signature = inspect.Signature(typed_params)
  284:     return typed_signature
       
       
    1: def get_typed_annotation(annotation: Any, globalns: Dict[str, Any]) -> Any:
  360:     if isinstance(annotation, str):
>>>>>>         annotation = ForwardRef(annotation)
>>>>>>         annotation = evaluate_forwardref(annotation, globalns, globalns)
  360:     return annotation
       
       
    1: def get_typed_return_annotation(call: Callable[..., Any]) -> Any:
   17:     signature = inspect.signature(call)
   17:     annotation = signature.return_annotation
       
   17:     if annotation is inspect.Signature.empty:
   17:         return None
       
>>>>>>     globalns = getattr(call, "__globals__", {})
>>>>>>     return get_typed_annotation(annotation, globalns)
       
       
    2: def get_dependant(
           *,
    1:     path: str,
    1:     call: Callable[..., Any],
    2:     name: Optional[str] = None,
    2:     security_scopes: Optional[List[str]] = None,
    2:     use_cache: bool = True,
    1: ) -> Dependant:
  284:     path_param_names = get_path_param_names(path)
  284:     endpoint_signature = get_typed_signature(call)
  284:     signature_params = endpoint_signature.parameters
  568:     dependant = Dependant(
  284:         call=call,
  284:         name=name,
  284:         path=path,
  284:         security_scopes=security_scopes,
  284:         use_cache=use_cache,
           )
  644:     for param_name, param in signature_params.items():
  360:         is_path_param = param_name in path_param_names
  720:         type_annotation, depends, param_field = analyze_param(
  360:             param_name=param_name,
  360:             annotation=param.annotation,
  360:             value=param.default,
  360:             is_path_param=is_path_param,
               )
  360:         if depends is not None:
  390:             sub_dependant = get_param_sub_dependant(
  195:                 param_name=param_name,
  195:                 depends=depends,
  195:                 path=path,
  195:                 security_scopes=security_scopes,
                   )
  195:             dependant.dependencies.append(sub_dependant)
  195:             continue
  330:         if add_non_field_param_to_dependency(
  165:             param_name=param_name,
  165:             type_annotation=type_annotation,
  165:             dependant=dependant,
               ):
   65:             assert (
   65:                 param_field is None
>>>>>>             ), f"Cannot specify multiple FastAPI annotations for {param_name!r}"
>>>>>>             continue
  100:         assert param_field is not None
  100:         if is_body_param(param_field=param_field, is_path_param=is_path_param):
   33:             dependant.body_params.append(param_field)
               else:
   67:             add_param_to_fields(field=param_field, dependant=dependant)
  284:     return dependant
       
       
    1: def add_non_field_param_to_dependency(
    1:     *, param_name: str, type_annotation: Any, dependant: Dependant
    1: ) -> Optional[bool]:
  165:     if lenient_issubclass(type_annotation, Request):
   65:         dependant.request_param_name = param_name
   65:         return True
  100:     elif lenient_issubclass(type_annotation, WebSocket):
>>>>>>         dependant.websocket_param_name = param_name
>>>>>>         return True
  100:     elif lenient_issubclass(type_annotation, HTTPConnection):
>>>>>>         dependant.http_connection_param_name = param_name
>>>>>>         return True
  100:     elif lenient_issubclass(type_annotation, Response):
>>>>>>         dependant.response_param_name = param_name
>>>>>>         return True
  100:     elif lenient_issubclass(type_annotation, StarletteBackgroundTasks):
>>>>>>         dependant.background_tasks_param_name = param_name
>>>>>>         return True
  100:     elif lenient_issubclass(type_annotation, SecurityScopes):
>>>>>>         dependant.security_scopes_param_name = param_name
>>>>>>         return True
  100:     return None
       
       
    1: def analyze_param(
           *,
    1:     param_name: str,
    1:     annotation: Any,
    1:     value: Any,
    1:     is_path_param: bool,
    1: ) -> Tuple[Any, Optional[params.Depends], Optional[ModelField]]:
  360:     field_info = None
  360:     depends = None
  360:     type_annotation: Any = Any
  360:     use_annotation: Any = Any
  360:     if annotation is not inspect.Signature.empty:
  295:         use_annotation = annotation
  295:         type_annotation = annotation
  360:     if get_origin(use_annotation) is Annotated:
>>>>>>         annotated_args = get_args(annotation)
>>>>>>         type_annotation = annotated_args[0]
>>>>>>         fastapi_annotations = [
>>>>>>             arg
>>>>>>             for arg in annotated_args[1:]
>>>>>>             if isinstance(arg, (FieldInfo, params.Depends))
               ]
>>>>>>         fastapi_specific_annotations = [
>>>>>>             arg
>>>>>>             for arg in fastapi_annotations
>>>>>>             if isinstance(arg, (params.Param, params.Body, params.Depends))
               ]
>>>>>>         if fastapi_specific_annotations:
>>>>>>             fastapi_annotation: Union[
                       FieldInfo, params.Depends, None
>>>>>>             ] = fastapi_specific_annotations[-1]
               else:
>>>>>>             fastapi_annotation = None
>>>>>>         if isinstance(fastapi_annotation, FieldInfo):
                   # Copy `field_info` because we mutate `field_info.default` below.
>>>>>>             field_info = copy_field_info(
>>>>>>                 field_info=fastapi_annotation, annotation=use_annotation
                   )
>>>>>>             assert field_info.default is Undefined or field_info.default is Required, (
>>>>>>                 f"`{field_info.__class__.__name__}` default value cannot be set in"
>>>>>>                 f" `Annotated` for {param_name!r}. Set the default value with `=` instead."
                   )
>>>>>>             if value is not inspect.Signature.empty:
>>>>>>                 assert not is_path_param, "Path parameters cannot have default values"
>>>>>>                 field_info.default = value
                   else:
>>>>>>                 field_info.default = Required
>>>>>>         elif isinstance(fastapi_annotation, params.Depends):
>>>>>>             depends = fastapi_annotation
       
  360:     if isinstance(value, params.Depends):
  195:         assert depends is None, (
>>>>>>             "Cannot specify `Depends` in `Annotated` and default value"
>>>>>>             f" together for {param_name!r}"
               )
  195:         assert field_info is None, (
>>>>>>             "Cannot specify a FastAPI annotation in `Annotated` and `Depends` as a"
>>>>>>             f" default value together for {param_name!r}"
               )
  195:         depends = value
  165:     elif isinstance(value, FieldInfo):
>>>>>>         assert field_info is None, (
>>>>>>             "Cannot specify FastAPI annotations in `Annotated` and default value"
>>>>>>             f" together for {param_name!r}"
               )
>>>>>>         field_info = value
>>>>>>         if PYDANTIC_V2:
>>>>>>             field_info.annotation = type_annotation
       
  360:     if depends is not None and depends.dependency is None:
>>>>>>         depends.dependency = type_annotation
       
  720:     if lenient_issubclass(
  360:         type_annotation,
  360:         (
  360:             Request,
  360:             WebSocket,
  360:             HTTPConnection,
  360:             Response,
  360:             StarletteBackgroundTasks,
  360:             SecurityScopes,
               ),
           ):
   65:         assert depends is None, f"Cannot specify `Depends` for type {type_annotation!r}"
   65:         assert (
   65:             field_info is None
>>>>>>         ), f"Cannot specify FastAPI annotation for type {type_annotation!r}"
  295:     elif field_info is None and depends is None:
  100:         default_value = value if value is not inspect.Signature.empty else Required
  100:         if is_path_param:
                   # We might check here that `default_value is Required`, but the fact is that the same
                   # parameter might sometimes be a path parameter and sometimes not. See
                   # `tests/test_infer_param_optionality.py` for an example.
   67:             field_info = params.Path(annotation=use_annotation)
   99:         elif is_uploadfile_or_nonable_uploadfile_annotation(
   33:             type_annotation
   33:         ) or is_uploadfile_sequence_annotation(type_annotation):
>>>>>>             field_info = params.File(annotation=use_annotation, default=default_value)
   33:         elif not field_annotation_is_scalar(annotation=type_annotation):
   33:             field_info = params.Body(annotation=use_annotation, default=default_value)
               else:
>>>>>>             field_info = params.Query(annotation=use_annotation, default=default_value)
       
  360:     field = None
  360:     if field_info is not None:
  100:         if is_path_param:
   67:             assert isinstance(field_info, params.Path), (
>>>>>>                 f"Cannot use `{field_info.__class__.__name__}` for path param"
>>>>>>                 f" {param_name!r}"
                   )
   33:         elif (
   33:             isinstance(field_info, params.Param)
>>>>>>             and getattr(field_info, "in_", None) is None
               ):
>>>>>>             field_info.in_ = params.ParamTypes.query
  200:         use_annotation_from_field_info = get_annotation_from_field_info(
  100:             use_annotation,
  100:             field_info,
  100:             param_name,
               )
  100:         if not field_info.alias and getattr(field_info, "convert_underscores", None):
>>>>>>             alias = param_name.replace("_", "-")
               else:
  100:             alias = field_info.alias or param_name
  100:         field_info.alias = alias
  200:         field = create_response_field(
  100:             name=param_name,
  100:             type_=use_annotation_from_field_info,
  100:             default=field_info.default,
  100:             alias=alias,
  100:             required=field_info.default in (Required, Undefined),
  100:             field_info=field_info,
               )
       
  360:     return type_annotation, depends, field
       
       
    1: def is_body_param(*, param_field: ModelField, is_path_param: bool) -> bool:
  100:     if is_path_param:
  134:         assert is_scalar_field(
   67:             field=param_field
>>>>>>         ), "Path params must be of one of the supported types"
   67:         return False
   33:     elif is_scalar_field(field=param_field):
>>>>>>         return False
   66:     elif isinstance(
   33:         param_field.field_info, (params.Query, params.Header)
>>>>>>     ) and is_scalar_sequence_field(param_field):
>>>>>>         return False
           else:
   66:         assert isinstance(
   33:             param_field.field_info, params.Body
>>>>>>         ), f"Param: {param_field.name} can only be a request body, using Body()"
   33:         return True
       
       
    1: def add_param_to_fields(*, field: ModelField, dependant: Dependant) -> None:
   67:     field_info = field.field_info
   67:     field_info_in = getattr(field_info, "in_", None)
   67:     if field_info_in == params.ParamTypes.path:
   67:         dependant.path_params.append(field)
>>>>>>     elif field_info_in == params.ParamTypes.query:
>>>>>>         dependant.query_params.append(field)
>>>>>>     elif field_info_in == params.ParamTypes.header:
>>>>>>         dependant.header_params.append(field)
           else:
>>>>>>         assert (
>>>>>>             field_info_in == params.ParamTypes.cookie
>>>>>>         ), f"non-body parameters must be in path, query, header or cookie: {field.name}"
>>>>>>         dependant.cookie_params.append(field)
       
       
    1: def is_coroutine_callable(call: Callable[..., Any]) -> bool:
   12:     if inspect.isroutine(call):
   12:         return inspect.iscoroutinefunction(call)
>>>>>>     if inspect.isclass(call):
>>>>>>         return False
>>>>>>     dunder_call = getattr(call, "__call__", None)  # noqa: B004
>>>>>>     return inspect.iscoroutinefunction(dunder_call)
       
       
    1: def is_async_gen_callable(call: Callable[..., Any]) -> bool:
   12:     if inspect.isasyncgenfunction(call):
>>>>>>         return True
   12:     dunder_call = getattr(call, "__call__", None)  # noqa: B004
   12:     return inspect.isasyncgenfunction(dunder_call)
       
       
    1: def is_gen_callable(call: Callable[..., Any]) -> bool:
   36:     if inspect.isgeneratorfunction(call):
   24:         return True
   12:     dunder_call = getattr(call, "__call__", None)  # noqa: B004
   12:     return inspect.isgeneratorfunction(dunder_call)
       
       
    1: async def solve_generator(
    1:     *, call: Callable[..., Any], stack: AsyncExitStack, sub_values: Dict[str, Any]
    1: ) -> Any:
   12:     if is_gen_callable(call):
   12:         cm = contextmanager_in_threadpool(contextmanager(call)(**sub_values))
>>>>>>     elif is_async_gen_callable(call):
>>>>>>         cm = asynccontextmanager(call)(**sub_values)
   12:     return await stack.enter_async_context(cm)
       
       
    2: async def solve_dependencies(
           *,
    1:     request: Union[Request, WebSocket],
    1:     dependant: Dependant,
    2:     body: Optional[Union[Dict[str, Any], FormData]] = None,
    2:     background_tasks: Optional[StarletteBackgroundTasks] = None,
    2:     response: Optional[Response] = None,
    2:     dependency_overrides_provider: Optional[Any] = None,
    2:     dependency_cache: Optional[Dict[Tuple[Callable[..., Any], Tuple[str]], Any]] = None,
    1:     async_exit_stack: AsyncExitStack,
    2: ) -> Tuple[
    2:     Dict[str, Any],
    1:     List[Any],
    1:     Optional[StarletteBackgroundTasks],
    1:     Response,
    1:     Dict[Tuple[Callable[..., Any], Tuple[str]], Any],
       ]:
   36:     values: Dict[str, Any] = {}
   36:     errors: List[Any] = []
   36:     if response is None:
   12:         response = Response()
   12:         del response.headers["content-length"]
   12:         response.status_code = None  # type: ignore
   36:     dependency_cache = dependency_cache or {}
           sub_dependant: Dependant
   60:     for sub_dependant in dependant.dependencies:
   24:         sub_dependant.call = cast(Callable[..., Any], sub_dependant.call)
   48:         sub_dependant.cache_key = cast(
   24:             Tuple[Callable[..., Any], Tuple[str]], sub_dependant.cache_key
               )
   24:         call = sub_dependant.call
   24:         use_sub_dependant = sub_dependant
   48:         if (
   24:             dependency_overrides_provider
   24:             and dependency_overrides_provider.dependency_overrides
               ):
   24:             original_call = sub_dependant.call
   72:             call = getattr(
   24:                 dependency_overrides_provider, "dependency_overrides", {}
   24:             ).get(original_call, original_call)
   24:             use_path: str = sub_dependant.path  # type: ignore
   48:             use_sub_dependant = get_dependant(
   24:                 path=use_path,
   24:                 call=call,
   24:                 name=sub_dependant.name,
   24:                 security_scopes=sub_dependant.security_scopes,
                   )
       
   48:         solved_result = await solve_dependencies(
   24:             request=request,
   24:             dependant=use_sub_dependant,
   24:             body=body,
   24:             background_tasks=background_tasks,
   24:             response=response,
   24:             dependency_overrides_provider=dependency_overrides_provider,
   24:             dependency_cache=dependency_cache,
   24:             async_exit_stack=async_exit_stack,
               )
   24:         (
   24:             sub_values,
   24:             sub_errors,
   24:             background_tasks,
   24:             _,  # the subdependency returns the same response we have
   24:             sub_dependency_cache,
   24:         ) = solved_result
   24:         dependency_cache.update(sub_dependency_cache)
   24:         if sub_errors:
>>>>>>             errors.extend(sub_errors)
>>>>>>             continue
   24:         if sub_dependant.use_cache and sub_dependant.cache_key in dependency_cache:
>>>>>>             solved = dependency_cache[sub_dependant.cache_key]
   24:         elif is_gen_callable(call) or is_async_gen_callable(call):
   24:             solved = await solve_generator(
   12:                 call=call, stack=async_exit_stack, sub_values=sub_values
                   )
   12:         elif is_coroutine_callable(call):
>>>>>>             solved = await call(**sub_values)
               else:
   12:             solved = await run_in_threadpool(call, **sub_values)
   24:         if sub_dependant.name is not None:
   24:             values[sub_dependant.name] = solved
   24:         if sub_dependant.cache_key not in dependency_cache:
   24:             dependency_cache[sub_dependant.cache_key] = solved
   72:     path_values, path_errors = request_params_to_args(
   36:         dependant.path_params, request.path_params
           )
   72:     query_values, query_errors = request_params_to_args(
   36:         dependant.query_params, request.query_params
           )
   72:     header_values, header_errors = request_params_to_args(
   36:         dependant.header_params, request.headers
           )
   72:     cookie_values, cookie_errors = request_params_to_args(
   36:         dependant.cookie_params, request.cookies
           )
   36:     values.update(path_values)
   36:     values.update(query_values)
   36:     values.update(header_values)
   36:     values.update(cookie_values)
   36:     errors += path_errors + query_errors + header_errors + cookie_errors
   36:     if dependant.body_params:
   11:         (
   11:             body_values,
   11:             body_errors,
   22:         ) = await request_body_to_args(  # body_params checked above
   11:             required_params=dependant.body_params, received_body=body
               )
   11:         values.update(body_values)
   11:         errors.extend(body_errors)
   36:     if dependant.http_connection_param_name:
>>>>>>         values[dependant.http_connection_param_name] = request
   36:     if dependant.request_param_name and isinstance(request, Request):
>>>>>>         values[dependant.request_param_name] = request
   36:     elif dependant.websocket_param_name and isinstance(request, WebSocket):
>>>>>>         values[dependant.websocket_param_name] = request
   36:     if dependant.background_tasks_param_name:
>>>>>>         if background_tasks is None:
>>>>>>             background_tasks = BackgroundTasks()
>>>>>>         values[dependant.background_tasks_param_name] = background_tasks
   36:     if dependant.response_param_name:
>>>>>>         values[dependant.response_param_name] = response
   36:     if dependant.security_scopes_param_name:
>>>>>>         values[dependant.security_scopes_param_name] = SecurityScopes(
>>>>>>             scopes=dependant.security_scopes
               )
   36:     return values, errors, background_tasks, response, dependency_cache
       
       
    1: def request_params_to_args(
    1:     required_params: Sequence[ModelField],
    1:     received_params: Union[Mapping[str, Any], QueryParams, Headers],
    1: ) -> Tuple[Dict[str, Any], List[Any]]:
  144:     values = {}
  144:     errors = []
  148:     for field in required_params:
    4:         if is_scalar_sequence_field(field) and isinstance(
>>>>>>             received_params, (QueryParams, Headers)
               ):
>>>>>>             value = received_params.getlist(field.alias) or field.default
               else:
    4:             value = received_params.get(field.alias)
    4:         field_info = field.field_info
    8:         assert isinstance(
    4:             field_info, params.Param
>>>>>>         ), "Params must be subclasses of Param"
    4:         loc = (field_info.in_.value, field.alias)
    4:         if value is None:
>>>>>>             if field.required:
>>>>>>                 errors.append(get_missing_field_error(loc=loc))
                   else:
>>>>>>                 values[field.name] = deepcopy(field.default)
>>>>>>             continue
    4:         v_, errors_ = field.validate(value, values, loc=loc)
    4:         if isinstance(errors_, ErrorWrapper):
>>>>>>             errors.append(errors_)
    4:         elif isinstance(errors_, list):
>>>>>>             new_errors = _regenerate_error_with_loc(errors=errors_, loc_prefix=())
>>>>>>             errors.extend(new_errors)
               else:
    4:             values[field.name] = v_
  144:     return values, errors
       
       
    1: async def request_body_to_args(
    1:     required_params: List[ModelField],
    1:     received_body: Optional[Union[Dict[str, Any], FormData]],
    1: ) -> Tuple[Dict[str, Any], List[Dict[str, Any]]]:
   11:     values = {}
   11:     errors: List[Dict[str, Any]] = []
   11:     if required_params:
   11:         field = required_params[0]
   11:         field_info = field.field_info
   11:         embed = getattr(field_info, "embed", None)
   11:         field_alias_omitted = len(required_params) == 1 and not embed
   11:         if field_alias_omitted:
   11:             received_body = {field.alias: received_body}
       
   22:         for field in required_params:
                   loc: Tuple[str, ...]
   11:             if field_alias_omitted:
   11:                 loc = ("body",)
                   else:
>>>>>>                 loc = ("body", field.alias)
       
   11:             value: Optional[Any] = None
   11:             if received_body is not None:
   11:                 if (is_sequence_field(field)) and isinstance(received_body, FormData):
>>>>>>                     value = received_body.getlist(field.alias)
                       else:
   11:                     try:
   11:                         value = received_body.get(field.alias)
>>>>>>                     except AttributeError:
>>>>>>                         errors.append(get_missing_field_error(loc))
>>>>>>                         continue
   33:             if (
   11:                 value is None
   11:                 or (isinstance(field_info, params.Form) and value == "")
                       or (
   11:                     isinstance(field_info, params.Form)
>>>>>>                     and is_sequence_field(field)
>>>>>>                     and len(value) == 0
                       )
                   ):
>>>>>>                 if field.required:
>>>>>>                     errors.append(get_missing_field_error(loc))
                       else:
>>>>>>                     values[field.name] = deepcopy(field.default)
>>>>>>                 continue
   11:             if (
   11:                 isinstance(field_info, params.File)
>>>>>>                 and is_bytes_field(field)
>>>>>>                 and isinstance(value, UploadFile)
                   ):
>>>>>>                 value = await value.read()
   11:             elif (
   11:                 is_bytes_sequence_field(field)
>>>>>>                 and isinstance(field_info, params.File)
>>>>>>                 and value_is_sequence(value)
                   ):
                       # For types
>>>>>>                 assert isinstance(value, sequence_types)  # type: ignore[arg-type]
>>>>>>                 results: List[Union[bytes, str]] = []
       
>>>>>>                 async def process_fn(
>>>>>>                     fn: Callable[[], Coroutine[Any, Any, Any]]
>>>>>>                 ) -> None:
>>>>>>                     result = await fn()
>>>>>>                     results.append(result)  # noqa: B023
       
>>>>>>                 async with anyio.create_task_group() as tg:
>>>>>>                     for sub_value in value:
>>>>>>                         tg.start_soon(process_fn, sub_value.read)
>>>>>>                 value = serialize_sequence_value(field=field, value=results)
       
   11:             v_, errors_ = field.validate(value, values, loc=loc)
       
   11:             if isinstance(errors_, list):
>>>>>>                 errors.extend(errors_)
   11:             elif errors_:
>>>>>>                 errors.append(errors_)
                   else:
   11:                 values[field.name] = v_
   11:     return values, errors
       
       
    1: def get_body_field(*, dependant: Dependant, name: str) -> Optional[ModelField]:
   65:     flat_dependant = get_flat_dependant(dependant)
   65:     if not flat_dependant.body_params:
   32:         return None
   33:     first_param = flat_dependant.body_params[0]
   33:     field_info = first_param.field_info
   33:     embed = getattr(field_info, "embed", None)
   99:     body_param_names_set = {param.name for param in flat_dependant.body_params}
   33:     if len(body_param_names_set) == 1 and not embed:
   33:         check_file_field(first_param)
   33:         return first_param
           # If one field requires to embed, all have to be embedded
           # in case a sub-dependency is evaluated with a single unique body field
           # That is combined (embedded) with other body fields
>>>>>>     for param in flat_dependant.body_params:
>>>>>>         setattr(param.field_info, "embed", True)  # noqa: B010
>>>>>>     model_name = "Body_" + name
>>>>>>     BodyModel = create_body_model(
>>>>>>         fields=flat_dependant.body_params, model_name=model_name
           )
>>>>>>     required = any(True for f in flat_dependant.body_params if f.required)
>>>>>>     BodyFieldInfo_kwargs: Dict[str, Any] = {
>>>>>>         "annotation": BodyModel,
>>>>>>         "alias": "body",
           }
>>>>>>     if not required:
>>>>>>         BodyFieldInfo_kwargs["default"] = None
>>>>>>     if any(isinstance(f.field_info, params.File) for f in flat_dependant.body_params):
>>>>>>         BodyFieldInfo: Type[params.Body] = params.File
>>>>>>     elif any(isinstance(f.field_info, params.Form) for f in flat_dependant.body_params):
>>>>>>         BodyFieldInfo = params.Form
           else:
>>>>>>         BodyFieldInfo = params.Body
       
>>>>>>         body_param_media_types = [
>>>>>>             f.field_info.media_type
>>>>>>             for f in flat_dependant.body_params
>>>>>>             if isinstance(f.field_info, params.Body)
               ]
>>>>>>         if len(set(body_param_media_types)) == 1:
>>>>>>             BodyFieldInfo_kwargs["media_type"] = body_param_media_types[0]
>>>>>>     final_field = create_response_field(
>>>>>>         name="body",
>>>>>>         type_=BodyModel,
>>>>>>         required=required,
>>>>>>         alias="body",
>>>>>>         field_info=BodyFieldInfo(**BodyFieldInfo_kwargs),
           )
>>>>>>     check_file_field(final_field)
>>>>>>     return final_field
