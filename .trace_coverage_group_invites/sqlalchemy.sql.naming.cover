       # sql/naming.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       # mypy: allow-untyped-defs, allow-untyped-calls
       
    1: """Establish constraint and index naming conventions.
       
       
       """
       
    1: from __future__ import annotations
       
    1: import re
       
    1: from . import events  # noqa
    1: from .base import _NONE_NAME
    1: from .elements import conv as conv
    1: from .schema import CheckConstraint
    1: from .schema import Column
    1: from .schema import Constraint
    1: from .schema import ForeignKeyConstraint
    1: from .schema import Index
    1: from .schema import PrimaryKeyConstraint
    1: from .schema import Table
    1: from .schema import UniqueConstraint
    1: from .. import event
    1: from .. import exc
       
       
    2: class ConventionDict:
    1:     def __init__(self, const, table, convention):
   78:         self.const = const
   78:         self._is_fk = isinstance(const, ForeignKeyConstraint)
   78:         self.table = table
   78:         self.convention = convention
   78:         self._const_name = const.name
       
    1:     def _key_table_name(self):
>>>>>>         return self.table.name
       
    1:     def _column_X(self, idx, attrname):
   78:         if self._is_fk:
>>>>>>             try:
>>>>>>                 fk = self.const.elements[idx]
>>>>>>             except IndexError:
>>>>>>                 return ""
                   else:
>>>>>>                 return getattr(fk.parent, attrname)
               else:
   78:             cols = list(self.const.columns)
   78:             try:
   78:                 col = cols[idx]
>>>>>>             except IndexError:
>>>>>>                 return ""
                   else:
   78:                 return getattr(col, attrname)
       
    1:     def _key_constraint_name(self):
>>>>>>         if self._const_name in (None, _NONE_NAME):
>>>>>>             raise exc.InvalidRequestError(
>>>>>>                 "Naming convention including "
                       "%(constraint_name)s token requires that "
                       "constraint is explicitly named."
                   )
>>>>>>         if not isinstance(self._const_name, conv):
>>>>>>             self.const.name = None
>>>>>>         return self._const_name
       
    1:     def _key_column_X_key(self, idx):
               # note this method was missing before
               # [ticket:3989], meaning tokens like ``%(column_0_key)s`` weren't
               # working even though documented.
>>>>>>         return self._column_X(idx, "key")
       
    1:     def _key_column_X_name(self, idx):
>>>>>>         return self._column_X(idx, "name")
       
    1:     def _key_column_X_label(self, idx):
   78:         return self._column_X(idx, "_ddl_label")
       
    1:     def _key_referred_table_name(self):
>>>>>>         fk = self.const.elements[0]
>>>>>>         refs = fk.target_fullname.split(".")
>>>>>>         if len(refs) == 3:
>>>>>>             refschema, reftable, refcol = refs
               else:
>>>>>>             reftable, refcol = refs
>>>>>>         return reftable
       
    1:     def _key_referred_column_X_name(self, idx):
>>>>>>         fk = self.const.elements[idx]
               # note that before [ticket:3989], this method was returning
               # the specification for the :class:`.ForeignKey` itself, which normally
               # would be using the ``.key`` of the column, not the name.
>>>>>>         return fk.column.name
       
    1:     def __getitem__(self, key):
   78:         if key in self.convention:
>>>>>>             return self.convention[key](self.const, self.table)
   78:         elif hasattr(self, "_key_%s" % key):
>>>>>>             return getattr(self, "_key_%s" % key)()
               else:
   78:             col_template = re.match(r".*_?column_(\d+)(_?N)?_.+", key)
   78:             if col_template:
   78:                 idx = col_template.group(1)
   78:                 multiples = col_template.group(2)
       
   78:                 if multiples:
>>>>>>                     if self._is_fk:
>>>>>>                         elems = self.const.elements
                           else:
>>>>>>                         elems = list(self.const.columns)
>>>>>>                     tokens = []
>>>>>>                     for idx, elem in enumerate(elems):
>>>>>>                         attr = "_key_" + key.replace("0" + multiples, "X")
>>>>>>                         try:
>>>>>>                             tokens.append(getattr(self, attr)(idx))
>>>>>>                         except AttributeError:
>>>>>>                             raise KeyError(key)
>>>>>>                     sep = "_" if multiples.startswith("_") else ""
>>>>>>                     return sep.join(tokens)
                       else:
   78:                     attr = "_key_" + key.replace(idx, "X")
   78:                     idx = int(idx)
   78:                     if hasattr(self, attr):
   78:                         return getattr(self, attr)(idx)
>>>>>>         raise KeyError(key)
       
       
    1: _prefix_dict = {
    1:     Index: "ix",
    1:     PrimaryKeyConstraint: "pk",
    1:     CheckConstraint: "ck",
    1:     UniqueConstraint: "uq",
    1:     ForeignKeyConstraint: "fk",
       }
       
       
    1: def _get_convention(dict_, key):
 2494:     for super_ in key.__mro__:
 2293:         if super_ in _prefix_dict and _prefix_dict[super_] in dict_:
   82:             return dict_[_prefix_dict[super_]]
 2211:         elif super_ in dict_:
>>>>>>             return dict_[super_]
           else:
  201:         return None
       
       
    1: def _constraint_name_for_table(const, table):
  283:     metadata = table.metadata
  283:     convention = _get_convention(metadata.naming_convention, type(const))
       
  283:     if isinstance(const.name, conv):
>>>>>>         return const.name
  455:     elif (
  283:         convention is not None
   82:         and not isinstance(const.name, conv)
               and (
   82:             const.name is None
    4:             or "constraint_name" in convention
    4:             or const.name is _NONE_NAME
               )
           ):
  156:         return conv(
  156:             convention
   78:             % ConventionDict(const, table, metadata.naming_convention)
               )
  205:     elif convention is _NONE_NAME:
>>>>>>         return None
       
       
    2: @event.listens_for(
    1:     PrimaryKeyConstraint, "_sa_event_column_added_to_pk_constraint"
       )
    1: def _column_added_to_pk_constraint(pk_constraint, col):
   56:     if pk_constraint._implicit_generated:
               # only operate upon the "implicit" pk constraint for now,
               # as we have to force the name to None to reset it.  the
               # "implicit" constraint will only have a naming convention name
               # if at all.
   56:         table = pk_constraint.table
   56:         pk_constraint.name = None
   56:         newname = _constraint_name_for_table(pk_constraint, table)
   56:         if newname:
>>>>>>             pk_constraint.name = newname
       
       
    1: @event.listens_for(Constraint, "after_parent_attach")
    1: @event.listens_for(Index, "after_parent_attach")
    1: def _constraint_name(const, table):
  227:     if isinstance(table, Column):
               # this path occurs for a CheckConstraint linked to a Column
       
               # for column-attached constraint, set another event
               # to link the column attached to the table as this constraint
               # associated with the table.
>>>>>>         event.listen(
>>>>>>             table,
>>>>>>             "after_parent_attach",
>>>>>>             lambda col, table: _constraint_name(const, table),
               )
       
  227:     elif isinstance(table, Table):
  227:         if isinstance(const.name, conv) or const.name is _NONE_NAME:
>>>>>>             return
       
  227:         newname = _constraint_name_for_table(const, table)
  227:         if newname:
   78:             const.name = newname
