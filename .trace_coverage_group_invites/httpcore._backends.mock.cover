    1: import ssl
    1: import typing
    1: from typing import Optional
       
    1: from .._exceptions import ReadError
    1: from .base import (
           SOCKET_OPTION,
           AsyncNetworkBackend,
           AsyncNetworkStream,
           NetworkBackend,
           NetworkStream,
       )
       
       
    2: class MockSSLObject:
    1:     def __init__(self, http2: bool):
>>>>>>         self._http2 = http2
       
    1:     def selected_alpn_protocol(self) -> str:
>>>>>>         return "h2" if self._http2 else "http/1.1"
       
       
    2: class MockStream(NetworkStream):
    1:     def __init__(self, buffer: typing.List[bytes], http2: bool = False) -> None:
>>>>>>         self._buffer = buffer
>>>>>>         self._http2 = http2
>>>>>>         self._closed = False
       
    1:     def read(self, max_bytes: int, timeout: Optional[float] = None) -> bytes:
>>>>>>         if self._closed:
>>>>>>             raise ReadError("Connection closed")
>>>>>>         if not self._buffer:
>>>>>>             return b""
>>>>>>         return self._buffer.pop(0)
       
    1:     def write(self, buffer: bytes, timeout: Optional[float] = None) -> None:
>>>>>>         pass
       
    1:     def close(self) -> None:
>>>>>>         self._closed = True
       
    2:     def start_tls(
               self,
    1:         ssl_context: ssl.SSLContext,
    1:         server_hostname: Optional[str] = None,
    1:         timeout: Optional[float] = None,
    1:     ) -> NetworkStream:
>>>>>>         return self
       
    1:     def get_extra_info(self, info: str) -> typing.Any:
>>>>>>         return MockSSLObject(http2=self._http2) if info == "ssl_object" else None
       
    1:     def __repr__(self) -> str:
>>>>>>         return "<httpcore.MockStream>"
       
       
    2: class MockBackend(NetworkBackend):
    1:     def __init__(self, buffer: typing.List[bytes], http2: bool = False) -> None:
>>>>>>         self._buffer = buffer
>>>>>>         self._http2 = http2
       
    2:     def connect_tcp(
               self,
    1:         host: str,
    1:         port: int,
    1:         timeout: Optional[float] = None,
    1:         local_address: Optional[str] = None,
    1:         socket_options: typing.Optional[typing.Iterable[SOCKET_OPTION]] = None,
    1:     ) -> NetworkStream:
>>>>>>         return MockStream(list(self._buffer), http2=self._http2)
       
    2:     def connect_unix_socket(
               self,
    1:         path: str,
    1:         timeout: Optional[float] = None,
    1:         socket_options: typing.Optional[typing.Iterable[SOCKET_OPTION]] = None,
    1:     ) -> NetworkStream:
>>>>>>         return MockStream(list(self._buffer), http2=self._http2)
       
    1:     def sleep(self, seconds: float) -> None:
>>>>>>         pass
       
       
    2: class AsyncMockStream(AsyncNetworkStream):
    1:     def __init__(self, buffer: typing.List[bytes], http2: bool = False) -> None:
>>>>>>         self._buffer = buffer
>>>>>>         self._http2 = http2
>>>>>>         self._closed = False
       
    1:     async def read(self, max_bytes: int, timeout: Optional[float] = None) -> bytes:
>>>>>>         if self._closed:
>>>>>>             raise ReadError("Connection closed")
>>>>>>         if not self._buffer:
>>>>>>             return b""
>>>>>>         return self._buffer.pop(0)
       
    1:     async def write(self, buffer: bytes, timeout: Optional[float] = None) -> None:
>>>>>>         pass
       
    1:     async def aclose(self) -> None:
>>>>>>         self._closed = True
       
    2:     async def start_tls(
               self,
    1:         ssl_context: ssl.SSLContext,
    1:         server_hostname: Optional[str] = None,
    1:         timeout: Optional[float] = None,
    1:     ) -> AsyncNetworkStream:
>>>>>>         return self
       
    1:     def get_extra_info(self, info: str) -> typing.Any:
>>>>>>         return MockSSLObject(http2=self._http2) if info == "ssl_object" else None
       
    1:     def __repr__(self) -> str:
>>>>>>         return "<httpcore.AsyncMockStream>"
       
       
    2: class AsyncMockBackend(AsyncNetworkBackend):
    1:     def __init__(self, buffer: typing.List[bytes], http2: bool = False) -> None:
>>>>>>         self._buffer = buffer
>>>>>>         self._http2 = http2
       
    2:     async def connect_tcp(
               self,
    1:         host: str,
    1:         port: int,
    1:         timeout: Optional[float] = None,
    1:         local_address: Optional[str] = None,
    1:         socket_options: typing.Optional[typing.Iterable[SOCKET_OPTION]] = None,
    1:     ) -> AsyncNetworkStream:
>>>>>>         return AsyncMockStream(list(self._buffer), http2=self._http2)
       
    2:     async def connect_unix_socket(
               self,
    1:         path: str,
    1:         timeout: Optional[float] = None,
    1:         socket_options: typing.Optional[typing.Iterable[SOCKET_OPTION]] = None,
    1:     ) -> AsyncNetworkStream:
>>>>>>         return AsyncMockStream(list(self._buffer), http2=self._http2)
       
    1:     async def sleep(self, seconds: float) -> None:
>>>>>>         pass
