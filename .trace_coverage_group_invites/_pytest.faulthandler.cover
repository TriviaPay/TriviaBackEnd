    1: from __future__ import annotations
       
    1: import os
    1: import sys
    1: from typing import Generator
       
    1: from _pytest.config import Config
    1: from _pytest.config.argparsing import Parser
    1: from _pytest.nodes import Item
    1: from _pytest.stash import StashKey
    1: import pytest
       
       
    1: fault_handler_original_stderr_fd_key = StashKey[int]()
    1: fault_handler_stderr_fd_key = StashKey[int]()
       
       
    1: def pytest_addoption(parser: Parser) -> None:
    1:     help = (
    1:         "Dump the traceback of all threads if a test takes "
               "more than TIMEOUT seconds to finish"
           )
    1:     parser.addini("faulthandler_timeout", help, default=0.0)
       
       
    1: def pytest_configure(config: Config) -> None:
    1:     import faulthandler
       
           # at teardown we want to restore the original faulthandler fileno
           # but faulthandler has no api to return the original fileno
           # so here we stash the stderr fileno to be used at teardown
           # sys.stderr and sys.__stderr__ may be closed or patched during the session
           # so we can't rely on their values being good at that point (#11572).
    1:     stderr_fileno = get_stderr_fileno()
    1:     if faulthandler.is_enabled():
>>>>>>         config.stash[fault_handler_original_stderr_fd_key] = stderr_fileno
    1:     config.stash[fault_handler_stderr_fd_key] = os.dup(stderr_fileno)
    1:     faulthandler.enable(file=config.stash[fault_handler_stderr_fd_key])
       
       
    1: def pytest_unconfigure(config: Config) -> None:
    1:     import faulthandler
       
    1:     faulthandler.disable()
           # Close the dup file installed during pytest_configure.
    1:     if fault_handler_stderr_fd_key in config.stash:
    1:         os.close(config.stash[fault_handler_stderr_fd_key])
    1:         del config.stash[fault_handler_stderr_fd_key]
           # Re-enable the faulthandler if it was originally enabled.
    1:     if fault_handler_original_stderr_fd_key in config.stash:
>>>>>>         faulthandler.enable(config.stash[fault_handler_original_stderr_fd_key])
>>>>>>         del config.stash[fault_handler_original_stderr_fd_key]
       
       
    1: def get_stderr_fileno() -> int:
    1:     try:
    1:         fileno = sys.stderr.fileno()
               # The Twisted Logger will return an invalid file descriptor since it is not backed
               # by an FD. So, let's also forward this to the same code path as with pytest-xdist.
    1:         if fileno == -1:
>>>>>>             raise AttributeError()
    1:         return fileno
>>>>>>     except (AttributeError, ValueError):
               # pytest-xdist monkeypatches sys.stderr with an object that is not an actual file.
               # https://docs.python.org/3/library/faulthandler.html#issue-with-file-descriptors
               # This is potentially dangerous, but the best we can do.
>>>>>>         assert sys.__stderr__ is not None
>>>>>>         return sys.__stderr__.fileno()
       
       
    1: def get_timeout_config_value(config: Config) -> float:
   11:     return float(config.getini("faulthandler_timeout") or 0.0)
       
       
    1: @pytest.hookimpl(wrapper=True, trylast=True)
    1: def pytest_runtest_protocol(item: Item) -> Generator[None, object, object]:
   11:     timeout = get_timeout_config_value(item.config)
   11:     if timeout > 0:
>>>>>>         import faulthandler
       
>>>>>>         stderr = item.config.stash[fault_handler_stderr_fd_key]
>>>>>>         faulthandler.dump_traceback_later(timeout, file=stderr)
>>>>>>         try:
>>>>>>             return (yield)
               finally:
>>>>>>             faulthandler.cancel_dump_traceback_later()
           else:
   11:         return (yield)
       
       
    1: @pytest.hookimpl(tryfirst=True)
    1: def pytest_enter_pdb() -> None:
           """Cancel any traceback dumping due to timeout before entering pdb."""
>>>>>>     import faulthandler
       
>>>>>>     faulthandler.cancel_dump_traceback_later()
       
       
    1: @pytest.hookimpl(tryfirst=True)
    1: def pytest_exception_interact() -> None:
           """Cancel any traceback dumping due to an interactive exception being
           raised."""
>>>>>>     import faulthandler
       
>>>>>>     faulthandler.cancel_dump_traceback_later()
