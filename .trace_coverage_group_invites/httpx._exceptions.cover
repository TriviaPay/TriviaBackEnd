    1: """
       Our exception hierarchy:
       
       * HTTPError
         x RequestError
           + TransportError
             - TimeoutException
               · ConnectTimeout
               · ReadTimeout
               · WriteTimeout
               · PoolTimeout
             - NetworkError
               · ConnectError
               · ReadError
               · WriteError
               · CloseError
             - ProtocolError
               · LocalProtocolError
               · RemoteProtocolError
             - ProxyError
             - UnsupportedProtocol
           + DecodingError
           + TooManyRedirects
         x HTTPStatusError
       * InvalidURL
       * CookieConflict
       * StreamError
         x StreamConsumed
         x StreamClosed
         x ResponseNotRead
         x RequestNotRead
       """
    1: import contextlib
    1: import typing
       
    1: if typing.TYPE_CHECKING:
>>>>>>     from ._models import Request, Response  # pragma: no cover
       
       
    2: class HTTPError(Exception):
    1:     """
           Base class for `RequestError` and `HTTPStatusError`.
       
           Useful for `try...except` blocks when issuing a request,
           and then calling `.raise_for_status()`.
       
           For example:
       
           ```
           try:
               response = httpx.get("https://www.example.com")
               response.raise_for_status()
           except httpx.HTTPError as exc:
               print(f"HTTP Exception for {exc.request.url} - {exc}")
           ```
           """
       
    1:     def __init__(self, message: str) -> None:
>>>>>>         super().__init__(message)
>>>>>>         self._request: typing.Optional["Request"] = None
       
    1:     @property
    1:     def request(self) -> "Request":
>>>>>>         if self._request is None:
>>>>>>             raise RuntimeError("The .request property has not been set.")
>>>>>>         return self._request
       
    1:     @request.setter
    1:     def request(self, request: "Request") -> None:
>>>>>>         self._request = request
       
       
    2: class RequestError(HTTPError):
    1:     """
           Base class for all exceptions that may occur when issuing a `.request()`.
           """
       
    2:     def __init__(
    2:         self, message: str, *, request: typing.Optional["Request"] = None
    1:     ) -> None:
>>>>>>         super().__init__(message)
               # At the point an exception is raised we won't typically have a request
               # instance to associate it with.
               #
               # The 'request_context' context manager is used within the Client and
               # Response methods in order to ensure that any raised exceptions
               # have a `.request` property set on them.
>>>>>>         self._request = request
       
       
    2: class TransportError(RequestError):
    1:     """
           Base class for all exceptions that occur at the level of the Transport API.
           """
       
       
       # Timeout exceptions...
       
       
    2: class TimeoutException(TransportError):
    1:     """
           The base class for timeout errors.
       
           An operation has timed out.
           """
       
       
    2: class ConnectTimeout(TimeoutException):
    1:     """
           Timed out while connecting to the host.
           """
       
       
    2: class ReadTimeout(TimeoutException):
    1:     """
           Timed out while receiving data from the host.
           """
       
       
    2: class WriteTimeout(TimeoutException):
    1:     """
           Timed out while sending data to the host.
           """
       
       
    2: class PoolTimeout(TimeoutException):
    1:     """
           Timed out waiting to acquire a connection from the pool.
           """
       
       
       # Core networking exceptions...
       
       
    2: class NetworkError(TransportError):
    1:     """
           The base class for network-related errors.
       
           An error occurred while interacting with the network.
           """
       
       
    2: class ReadError(NetworkError):
    1:     """
           Failed to receive data from the network.
           """
       
       
    2: class WriteError(NetworkError):
    1:     """
           Failed to send data through the network.
           """
       
       
    2: class ConnectError(NetworkError):
    1:     """
           Failed to establish a connection.
           """
       
       
    2: class CloseError(NetworkError):
    1:     """
           Failed to close a connection.
           """
       
       
       # Other transport exceptions...
       
       
    2: class ProxyError(TransportError):
    1:     """
           An error occurred while establishing a proxy connection.
           """
       
       
    2: class UnsupportedProtocol(TransportError):
    1:     """
           Attempted to make a request to an unsupported protocol.
       
           For example issuing a request to `ftp://www.example.com`.
           """
       
       
    2: class ProtocolError(TransportError):
    1:     """
           The protocol was violated.
           """
       
       
    2: class LocalProtocolError(ProtocolError):
    1:     """
           A protocol was violated by the client.
       
           For example if the user instantiated a `Request` instance explicitly,
           failed to include the mandatory `Host:` header, and then issued it directly
           using `client.send()`.
           """
       
       
    2: class RemoteProtocolError(ProtocolError):
    1:     """
           The protocol was violated by the server.
       
           For example, returning malformed HTTP.
           """
       
       
       # Other request exceptions...
       
       
    2: class DecodingError(RequestError):
    1:     """
           Decoding of the response failed, due to a malformed encoding.
           """
       
       
    2: class TooManyRedirects(RequestError):
    1:     """
           Too many redirects.
           """
       
       
       # Client errors
       
       
    2: class HTTPStatusError(HTTPError):
    1:     """
           The response had an error HTTP status of 4xx or 5xx.
       
           May be raised when calling `response.raise_for_status()`
           """
       
    1:     def __init__(
    1:         self, message: str, *, request: "Request", response: "Response"
    1:     ) -> None:
>>>>>>         super().__init__(message)
>>>>>>         self.request = request
>>>>>>         self.response = response
       
       
    2: class InvalidURL(Exception):
    1:     """
           URL is improperly formed or cannot be parsed.
           """
       
    1:     def __init__(self, message: str) -> None:
>>>>>>         super().__init__(message)
       
       
    2: class CookieConflict(Exception):
    1:     """
           Attempted to lookup a cookie by name, but multiple cookies existed.
       
           Can occur when calling `response.cookies.get(...)`.
           """
       
    1:     def __init__(self, message: str) -> None:
>>>>>>         super().__init__(message)
       
       
       # Stream exceptions...
       
       # These may occur as the result of a programming error, by accessing
       # the request/response stream in an invalid manner.
       
       
    2: class StreamError(RuntimeError):
    1:     """
           The base class for stream exceptions.
       
           The developer made an error in accessing the request stream in
           an invalid way.
           """
       
    1:     def __init__(self, message: str) -> None:
>>>>>>         super().__init__(message)
       
       
    2: class StreamConsumed(StreamError):
    1:     """
           Attempted to read or stream content, but the content has already
           been streamed.
           """
       
    1:     def __init__(self) -> None:
>>>>>>         message = (
>>>>>>             "Attempted to read or stream some content, but the content has "
                   "already been streamed. For requests, this could be due to passing "
                   "a generator as request content, and then receiving a redirect "
                   "response or a secondary request as part of an authentication flow."
                   "For responses, this could be due to attempting to stream the response "
                   "content more than once."
               )
>>>>>>         super().__init__(message)
       
       
    2: class StreamClosed(StreamError):
    1:     """
           Attempted to read or stream response content, but the request has been
           closed.
           """
       
    1:     def __init__(self) -> None:
>>>>>>         message = (
>>>>>>             "Attempted to read or stream content, but the stream has " "been closed."
               )
>>>>>>         super().__init__(message)
       
       
    2: class ResponseNotRead(StreamError):
    1:     """
           Attempted to access streaming response content, without having called `read()`.
           """
       
    1:     def __init__(self) -> None:
>>>>>>         message = "Attempted to access streaming response content, without having called `read()`."
>>>>>>         super().__init__(message)
       
       
    2: class RequestNotRead(StreamError):
    1:     """
           Attempted to access streaming request content, without having called `read()`.
           """
       
    1:     def __init__(self) -> None:
>>>>>>         message = "Attempted to access streaming request content, without having called `read()`."
>>>>>>         super().__init__(message)
       
       
    1: @contextlib.contextmanager
    2: def request_context(
    1:     request: typing.Optional["Request"] = None,
    1: ) -> typing.Iterator[None]:
           """
           A context manager that can be used to attach the given request context
           to any `RequestError` exceptions that are raised within the block.
           """
   48:     try:
   48:         yield
>>>>>>     except RequestError as exc:
>>>>>>         if request is not None:
>>>>>>             exc.request = request
>>>>>>         raise exc
