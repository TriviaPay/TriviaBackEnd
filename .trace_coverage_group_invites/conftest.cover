    1: import pytest
    1: from sqlalchemy import create_engine, text
    1: from sqlalchemy.orm import sessionmaker
    1: from models import Base, User
    1: from db import get_db
    1: import os
    1: import urllib.parse
    1: import ssl
       
    1: def create_test_engine(database_url):
           """Create test database engine with proper SSL handling for different drivers"""
           # Parse the URL to extract any query parameters
    1:     parsed = urllib.parse.urlparse(database_url)
    1:     query_params = urllib.parse.parse_qs(parsed.query)
           
           # Get SSL mode from URL parameters
    1:     ssl_mode = query_params.get('sslmode', [None])[0]
           
           # Determine if we're using pg8000 or psycopg2
    1:     is_pg8000 = 'pg8000' in database_url
           
           # For pg8000, we need to remove sslmode from URL and handle it in connect_args
    1:     if is_pg8000:
               # Remove sslmode from query parameters since pg8000 doesn't support it in URL
>>>>>>         if 'sslmode' in query_params:
>>>>>>             del query_params['sslmode']
               
               # Reconstruct URL without sslmode parameter
>>>>>>         new_query = urllib.parse.urlencode(query_params, doseq=True)
>>>>>>         clean_url = urllib.parse.urlunparse((
>>>>>>             parsed.scheme, parsed.netloc, parsed.path,
>>>>>>             parsed.params, new_query, parsed.fragment
               ))
               
               # Set up connect_args based on SSL mode for pg8000
>>>>>>         connect_args = {}
>>>>>>         if ssl_mode == 'require' or (ssl_mode is None and not os.getenv("TESTING", "false").lower() == "true"):
                   # Use SSL for production (default) or when explicitly required
>>>>>>             ssl_context = ssl.create_default_context()
>>>>>>             ssl_context.check_hostname = False
>>>>>>             ssl_context.verify_mode = ssl.CERT_NONE
>>>>>>             connect_args["ssl_context"] = ssl_context
               
>>>>>>         return create_engine(
>>>>>>             clean_url,
>>>>>>             pool_size=5,
>>>>>>             max_overflow=10,
>>>>>>             pool_pre_ping=True,
>>>>>>             echo=False,
>>>>>>             connect_args=connect_args
               )
           else:
               # For psycopg2, we can keep sslmode in the URL as it supports it natively
               # But we need to ensure we're using postgresql+psycopg2 explicitly
    1:         if database_url.startswith('postgresql://') and '+' not in database_url:
    1:             database_url = database_url.replace('postgresql://', 'postgresql+psycopg2://', 1)
               
    2:         return create_engine(
    1:             database_url,
    1:             pool_size=5,
    1:             max_overflow=10,
    1:             pool_pre_ping=True,
    1:             echo=False
               )
       
       # Test database URL
    2: TEST_DATABASE_URL = os.getenv(
    1:     "DATABASE_URL",
    1:     "postgresql+pg8000://postgres:postgres@localhost:5432/test_db?sslmode=disable"
       )
       
    1: @pytest.fixture(scope="session")
    1: def test_engine():
           """Create test database engine"""
    1:     return create_test_engine(TEST_DATABASE_URL)
       
    1: @pytest.fixture(scope="function")
    1: def test_db(test_engine):
           """Create all tables before each test and drop them after"""
           # Drop all tables with CASCADE
   11:     with test_engine.connect() as connection:
               # Get all table names
   11:         tables = connection.execute(text("""
                   SELECT tablename FROM pg_tables 
                   WHERE schemaname = 'public'
               """)).fetchall()
               
               # Drop each table with CASCADE
   11:         for table in tables:
>>>>>>             connection.execute(text(f'DROP TABLE IF EXISTS "{table[0]}" CASCADE'))
   11:         connection.commit()
           
           # Create all tables
   11:     Base.metadata.create_all(bind=test_engine)
           
           # Create test session
   11:     TestingSessionLocal = sessionmaker(bind=test_engine)
   11:     db = TestingSessionLocal()
           
   11:     try:
               # Letters table removed - no longer seeding letter data
               
               # Add some test users
   11:         test_users = [
   22:             User(
   11:                 descope_user_id="test_user_1",
   11:                 email="test1@example.com",
   11:                 username="testuser1"
                   ),
   22:             User(
   11:                 descope_user_id="test_user_2",
   11:                 email="test2@example.com",
   11:                 username="testuser2"
                   )
               ]
   11:         db.add_all(test_users)
               
               # Commit the test data
   11:         db.commit()
               
   11:         yield db
           finally:
   11:         db.close()
               # Drop all tables with CASCADE after test
   11:         with test_engine.connect() as connection:
   11:             tables = connection.execute(text("""
                       SELECT tablename FROM pg_tables 
                       WHERE schemaname = 'public'
                   """)).fetchall()
  561:             for table in tables:
  550:                 connection.execute(text(f'DROP TABLE IF EXISTS "{table[0]}" CASCADE'))
   11:             connection.commit()
       
    1: @pytest.fixture
    1: def db():
           """Override the regular get_db dependency with our test database"""
>>>>>>     return next(get_db()) 
