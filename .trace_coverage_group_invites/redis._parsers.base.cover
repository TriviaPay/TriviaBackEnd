    1: import logging
    1: import sys
    1: from abc import ABC
    1: from asyncio import IncompleteReadError, StreamReader, TimeoutError
    1: from typing import Awaitable, Callable, List, Optional, Protocol, Union
       
    1: from redis.maint_notifications import (
           MaintenanceNotification,
           NodeFailedOverNotification,
           NodeFailingOverNotification,
           NodeMigratedNotification,
           NodeMigratingNotification,
           NodeMovingNotification,
       )
       
    1: if sys.version_info.major >= 3 and sys.version_info.minor >= 11:
>>>>>>     from asyncio import timeout as async_timeout
       else:
    1:     from async_timeout import timeout as async_timeout
       
    1: from ..exceptions import (
           AskError,
           AuthenticationError,
           AuthenticationWrongNumberOfArgsError,
           BusyLoadingError,
           ClusterCrossSlotError,
           ClusterDownError,
           ConnectionError,
           ExecAbortError,
           ExternalAuthProviderError,
           MasterDownError,
           ModuleError,
           MovedError,
           NoPermissionError,
           NoScriptError,
           OutOfMemoryError,
           ReadOnlyError,
           RedisError,
           ResponseError,
           TryAgainError,
       )
    1: from ..typing import EncodableT
    1: from .encoders import Encoder
    1: from .socket import SERVER_CLOSED_CONNECTION_ERROR, SocketBuffer
       
    1: MODULE_LOAD_ERROR = "Error loading the extension. Please check the server logs."
    1: NO_SUCH_MODULE_ERROR = "Error unloading module: no such module with that name"
    1: MODULE_UNLOAD_NOT_POSSIBLE_ERROR = "Error unloading module: operation not possible."
    1: MODULE_EXPORTS_DATA_TYPES_ERROR = (
    1:     "Error unloading module: the module "
           "exports one or more module-side data "
           "types, can't unload"
       )
       # user send an AUTH cmd to a server without authorization configured
    1: NO_AUTH_SET_ERROR = {
           # Redis >= 6.0
           "AUTH <password> called without any password "
           "configured for the default user. Are you sure "
    1:     "your configuration is correct?": AuthenticationError,
           # Redis < 6.0
    1:     "Client sent AUTH, but no password is set": AuthenticationError,
       }
       
    1: EXTERNAL_AUTH_PROVIDER_ERROR = {
    1:     "problem with LDAP service": ExternalAuthProviderError,
       }
       
    1: logger = logging.getLogger(__name__)
       
       
    2: class BaseParser(ABC):
    1:     EXCEPTION_CLASSES = {
    3:         "ERR": {
    1:             "max number of clients reached": ConnectionError,
    1:             "invalid password": AuthenticationError,
                   # some Redis server versions report invalid command syntax
                   # in lowercase
    1:             "wrong number of arguments "
    1:             "for 'auth' command": AuthenticationWrongNumberOfArgsError,
                   # some Redis server versions report invalid command syntax
                   # in uppercase
    1:             "wrong number of arguments "
    1:             "for 'AUTH' command": AuthenticationWrongNumberOfArgsError,
    1:             MODULE_LOAD_ERROR: ModuleError,
    1:             MODULE_EXPORTS_DATA_TYPES_ERROR: ModuleError,
    1:             NO_SUCH_MODULE_ERROR: ModuleError,
    1:             MODULE_UNLOAD_NOT_POSSIBLE_ERROR: ModuleError,
    1:             **NO_AUTH_SET_ERROR,
    1:             **EXTERNAL_AUTH_PROVIDER_ERROR,
               },
    1:         "OOM": OutOfMemoryError,
    1:         "WRONGPASS": AuthenticationError,
    1:         "EXECABORT": ExecAbortError,
    1:         "LOADING": BusyLoadingError,
    1:         "NOSCRIPT": NoScriptError,
    1:         "READONLY": ReadOnlyError,
    1:         "NOAUTH": AuthenticationError,
    1:         "NOPERM": NoPermissionError,
    1:         "ASK": AskError,
    1:         "TRYAGAIN": TryAgainError,
    1:         "MOVED": MovedError,
    1:         "CLUSTERDOWN": ClusterDownError,
    1:         "CROSSSLOT": ClusterCrossSlotError,
    1:         "MASTERDOWN": MasterDownError,
           }
       
    1:     @classmethod
    1:     def parse_error(cls, response):
               "Parse an error response"
>>>>>>         error_code = response.split(" ")[0]
>>>>>>         if error_code in cls.EXCEPTION_CLASSES:
>>>>>>             response = response[len(error_code) + 1 :]
>>>>>>             exception_class = cls.EXCEPTION_CLASSES[error_code]
>>>>>>             if isinstance(exception_class, dict):
>>>>>>                 exception_class = exception_class.get(response, ResponseError)
>>>>>>             return exception_class(response)
>>>>>>         return ResponseError(response)
       
    1:     def on_disconnect(self):
>>>>>>         raise NotImplementedError()
       
    1:     def on_connect(self, connection):
>>>>>>         raise NotImplementedError()
       
       
    2: class _RESPBase(BaseParser):
    1:     """Base class for sync-based resp parsing"""
       
    1:     def __init__(self, socket_read_size):
>>>>>>         self.socket_read_size = socket_read_size
>>>>>>         self.encoder = None
>>>>>>         self._sock = None
>>>>>>         self._buffer = None
       
    1:     def __del__(self):
>>>>>>         try:
>>>>>>             self.on_disconnect()
>>>>>>         except Exception:
>>>>>>             pass
       
    1:     def on_connect(self, connection):
               "Called when the socket connects"
>>>>>>         self._sock = connection._sock
>>>>>>         self._buffer = SocketBuffer(
>>>>>>             self._sock, self.socket_read_size, connection.socket_timeout
               )
>>>>>>         self.encoder = connection.encoder
       
    1:     def on_disconnect(self):
               "Called when the socket disconnects"
>>>>>>         self._sock = None
>>>>>>         if self._buffer is not None:
>>>>>>             self._buffer.close()
>>>>>>             self._buffer = None
>>>>>>         self.encoder = None
       
    1:     def can_read(self, timeout):
>>>>>>         return self._buffer and self._buffer.can_read(timeout)
       
       
    2: class AsyncBaseParser(BaseParser):
    1:     """Base parsing class for the python-backed async parser"""
       
    1:     __slots__ = "_stream", "_read_size"
       
    1:     def __init__(self, socket_read_size: int):
>>>>>>         self._stream: Optional[StreamReader] = None
>>>>>>         self._read_size = socket_read_size
       
    1:     async def can_read_destructive(self) -> bool:
>>>>>>         raise NotImplementedError()
       
    2:     async def read_response(
    1:         self, disable_decoding: bool = False
    1:     ) -> Union[EncodableT, ResponseError, None, List[EncodableT]]:
>>>>>>         raise NotImplementedError()
       
       
    2: class MaintenanceNotificationsParser:
    1:     """Protocol defining maintenance push notification parsing functionality"""
       
    1:     @staticmethod
    1:     def parse_maintenance_start_msg(response, notification_type):
               # Expected message format is: <notification_type> <seq_number> <time>
>>>>>>         id = response[1]
>>>>>>         ttl = response[2]
>>>>>>         return notification_type(id, ttl)
       
    1:     @staticmethod
    1:     def parse_maintenance_completed_msg(response, notification_type):
               # Expected message format is: <notification_type> <seq_number>
>>>>>>         id = response[1]
>>>>>>         return notification_type(id)
       
    1:     @staticmethod
    1:     def parse_moving_msg(response):
               # Expected message format is: MOVING <seq_number> <time> <endpoint>
>>>>>>         id = response[1]
>>>>>>         ttl = response[2]
>>>>>>         if response[3] is None:
>>>>>>             host, port = None, None
               else:
>>>>>>             value = response[3]
>>>>>>             if isinstance(value, bytes):
>>>>>>                 value = value.decode()
>>>>>>             host, port = value.split(":")
>>>>>>             port = int(port) if port is not None else None
       
>>>>>>         return NodeMovingNotification(id, host, port, ttl)
       
       
    1: _INVALIDATION_MESSAGE = "invalidate"
    1: _MOVING_MESSAGE = "MOVING"
    1: _MIGRATING_MESSAGE = "MIGRATING"
    1: _MIGRATED_MESSAGE = "MIGRATED"
    1: _FAILING_OVER_MESSAGE = "FAILING_OVER"
    1: _FAILED_OVER_MESSAGE = "FAILED_OVER"
       
    1: _MAINTENANCE_MESSAGES = (
    1:     _MIGRATING_MESSAGE,
    1:     _MIGRATED_MESSAGE,
    1:     _FAILING_OVER_MESSAGE,
    1:     _FAILED_OVER_MESSAGE,
       )
       
    2: MSG_TYPE_TO_MAINT_NOTIFICATION_PARSER_MAPPING: dict[
    1:     str, tuple[type[MaintenanceNotification], Callable]
    1: ] = {
    2:     _MIGRATING_MESSAGE: (
    1:         NodeMigratingNotification,
    1:         MaintenanceNotificationsParser.parse_maintenance_start_msg,
           ),
    2:     _MIGRATED_MESSAGE: (
    1:         NodeMigratedNotification,
    1:         MaintenanceNotificationsParser.parse_maintenance_completed_msg,
           ),
    2:     _FAILING_OVER_MESSAGE: (
    1:         NodeFailingOverNotification,
    1:         MaintenanceNotificationsParser.parse_maintenance_start_msg,
           ),
    2:     _FAILED_OVER_MESSAGE: (
    1:         NodeFailedOverNotification,
    1:         MaintenanceNotificationsParser.parse_maintenance_completed_msg,
           ),
    2:     _MOVING_MESSAGE: (
    1:         NodeMovingNotification,
    1:         MaintenanceNotificationsParser.parse_moving_msg,
           ),
       }
       
       
    2: class PushNotificationsParser(Protocol):
    1:     """Protocol defining RESP3-specific parsing functionality"""
       
    1:     pubsub_push_handler_func: Callable
    1:     invalidation_push_handler_func: Optional[Callable] = None
    1:     node_moving_push_handler_func: Optional[Callable] = None
    1:     maintenance_push_handler_func: Optional[Callable] = None
       
    1:     def handle_pubsub_push_response(self, response):
               """Handle pubsub push responses"""
>>>>>>         raise NotImplementedError()
       
    1:     def handle_push_response(self, response, **kwargs):
>>>>>>         msg_type = response[0]
>>>>>>         if isinstance(msg_type, bytes):
>>>>>>             msg_type = msg_type.decode()
       
>>>>>>         if msg_type not in (
>>>>>>             _INVALIDATION_MESSAGE,
>>>>>>             *_MAINTENANCE_MESSAGES,
>>>>>>             _MOVING_MESSAGE,
               ):
>>>>>>             return self.pubsub_push_handler_func(response)
       
>>>>>>         try:
>>>>>>             if (
>>>>>>                 msg_type == _INVALIDATION_MESSAGE
>>>>>>                 and self.invalidation_push_handler_func
                   ):
>>>>>>                 return self.invalidation_push_handler_func(response)
       
>>>>>>             if msg_type == _MOVING_MESSAGE and self.node_moving_push_handler_func:
>>>>>>                 parser_function = MSG_TYPE_TO_MAINT_NOTIFICATION_PARSER_MAPPING[
>>>>>>                     msg_type
>>>>>>                 ][1]
       
>>>>>>                 notification = parser_function(response)
>>>>>>                 return self.node_moving_push_handler_func(notification)
       
>>>>>>             if msg_type in _MAINTENANCE_MESSAGES and self.maintenance_push_handler_func:
>>>>>>                 parser_function = MSG_TYPE_TO_MAINT_NOTIFICATION_PARSER_MAPPING[
>>>>>>                     msg_type
>>>>>>                 ][1]
>>>>>>                 notification_type = MSG_TYPE_TO_MAINT_NOTIFICATION_PARSER_MAPPING[
>>>>>>                     msg_type
>>>>>>                 ][0]
>>>>>>                 notification = parser_function(response, notification_type)
       
>>>>>>                 if notification is not None:
>>>>>>                     return self.maintenance_push_handler_func(notification)
>>>>>>         except Exception as e:
>>>>>>             logger.error(
>>>>>>                 "Error handling {} message ({}): {}".format(msg_type, response, e)
                   )
       
>>>>>>         return None
       
    1:     def set_pubsub_push_handler(self, pubsub_push_handler_func):
>>>>>>         self.pubsub_push_handler_func = pubsub_push_handler_func
       
    1:     def set_invalidation_push_handler(self, invalidation_push_handler_func):
>>>>>>         self.invalidation_push_handler_func = invalidation_push_handler_func
       
    1:     def set_node_moving_push_handler(self, node_moving_push_handler_func):
>>>>>>         self.node_moving_push_handler_func = node_moving_push_handler_func
       
    1:     def set_maintenance_push_handler(self, maintenance_push_handler_func):
>>>>>>         self.maintenance_push_handler_func = maintenance_push_handler_func
       
       
    2: class AsyncPushNotificationsParser(Protocol):
    1:     """Protocol defining async RESP3-specific parsing functionality"""
       
    1:     pubsub_push_handler_func: Callable
    1:     invalidation_push_handler_func: Optional[Callable] = None
    1:     node_moving_push_handler_func: Optional[Callable[..., Awaitable[None]]] = None
    1:     maintenance_push_handler_func: Optional[Callable[..., Awaitable[None]]] = None
       
    1:     async def handle_pubsub_push_response(self, response):
               """Handle pubsub push responses asynchronously"""
>>>>>>         raise NotImplementedError()
       
    1:     async def handle_push_response(self, response, **kwargs):
               """Handle push responses asynchronously"""
       
>>>>>>         msg_type = response[0]
>>>>>>         if isinstance(msg_type, bytes):
>>>>>>             msg_type = msg_type.decode()
       
>>>>>>         if msg_type not in (
>>>>>>             _INVALIDATION_MESSAGE,
>>>>>>             *_MAINTENANCE_MESSAGES,
>>>>>>             _MOVING_MESSAGE,
               ):
>>>>>>             return await self.pubsub_push_handler_func(response)
       
>>>>>>         try:
>>>>>>             if (
>>>>>>                 msg_type == _INVALIDATION_MESSAGE
>>>>>>                 and self.invalidation_push_handler_func
                   ):
>>>>>>                 return await self.invalidation_push_handler_func(response)
       
>>>>>>             if isinstance(msg_type, bytes):
>>>>>>                 msg_type = msg_type.decode()
       
>>>>>>             if msg_type == _MOVING_MESSAGE and self.node_moving_push_handler_func:
>>>>>>                 parser_function = MSG_TYPE_TO_MAINT_NOTIFICATION_PARSER_MAPPING[
>>>>>>                     msg_type
>>>>>>                 ][1]
>>>>>>                 notification = parser_function(response)
>>>>>>                 return await self.node_moving_push_handler_func(notification)
       
>>>>>>             if msg_type in _MAINTENANCE_MESSAGES and self.maintenance_push_handler_func:
>>>>>>                 parser_function = MSG_TYPE_TO_MAINT_NOTIFICATION_PARSER_MAPPING[
>>>>>>                     msg_type
>>>>>>                 ][1]
>>>>>>                 notification_type = MSG_TYPE_TO_MAINT_NOTIFICATION_PARSER_MAPPING[
>>>>>>                     msg_type
>>>>>>                 ][0]
>>>>>>                 notification = parser_function(response, notification_type)
       
>>>>>>                 if notification is not None:
>>>>>>                     return await self.maintenance_push_handler_func(notification)
>>>>>>         except Exception as e:
>>>>>>             logger.error(
>>>>>>                 "Error handling {} message ({}): {}".format(msg_type, response, e)
                   )
       
>>>>>>         return None
       
    1:     def set_pubsub_push_handler(self, pubsub_push_handler_func):
               """Set the pubsub push handler function"""
>>>>>>         self.pubsub_push_handler_func = pubsub_push_handler_func
       
    1:     def set_invalidation_push_handler(self, invalidation_push_handler_func):
               """Set the invalidation push handler function"""
>>>>>>         self.invalidation_push_handler_func = invalidation_push_handler_func
       
    1:     def set_node_moving_push_handler(self, node_moving_push_handler_func):
>>>>>>         self.node_moving_push_handler_func = node_moving_push_handler_func
       
    1:     def set_maintenance_push_handler(self, maintenance_push_handler_func):
>>>>>>         self.maintenance_push_handler_func = maintenance_push_handler_func
       
       
    2: class _AsyncRESPBase(AsyncBaseParser):
    1:     """Base class for async resp parsing"""
       
    1:     __slots__ = AsyncBaseParser.__slots__ + ("encoder", "_buffer", "_pos", "_chunks")
       
    1:     def __init__(self, socket_read_size: int):
>>>>>>         super().__init__(socket_read_size)
>>>>>>         self.encoder: Optional[Encoder] = None
>>>>>>         self._buffer = b""
>>>>>>         self._chunks = []
>>>>>>         self._pos = 0
       
    1:     def _clear(self):
>>>>>>         self._buffer = b""
>>>>>>         self._chunks.clear()
       
    1:     def on_connect(self, connection):
               """Called when the stream connects"""
>>>>>>         self._stream = connection._reader
>>>>>>         if self._stream is None:
>>>>>>             raise RedisError("Buffer is closed.")
>>>>>>         self.encoder = connection.encoder
>>>>>>         self._clear()
>>>>>>         self._connected = True
       
    1:     def on_disconnect(self):
               """Called when the stream disconnects"""
>>>>>>         self._connected = False
       
    1:     async def can_read_destructive(self) -> bool:
>>>>>>         if not self._connected:
>>>>>>             raise RedisError("Buffer is closed.")
>>>>>>         if self._buffer:
>>>>>>             return True
>>>>>>         try:
>>>>>>             async with async_timeout(0):
>>>>>>                 return self._stream.at_eof()
>>>>>>         except TimeoutError:
>>>>>>             return False
       
    1:     async def _read(self, length: int) -> bytes:
               """
               Read `length` bytes of data.  These are assumed to be followed
               by a '\r\n' terminator which is subsequently discarded.
               """
>>>>>>         want = length + 2
>>>>>>         end = self._pos + want
>>>>>>         if len(self._buffer) >= end:
>>>>>>             result = self._buffer[self._pos : end - 2]
               else:
>>>>>>             tail = self._buffer[self._pos :]
>>>>>>             try:
>>>>>>                 data = await self._stream.readexactly(want - len(tail))
>>>>>>             except IncompleteReadError as error:
>>>>>>                 raise ConnectionError(SERVER_CLOSED_CONNECTION_ERROR) from error
>>>>>>             result = (tail + data)[:-2]
>>>>>>             self._chunks.append(data)
>>>>>>         self._pos += want
>>>>>>         return result
       
    1:     async def _readline(self) -> bytes:
               """
               read an unknown number of bytes up to the next '\r\n'
               line separator, which is discarded.
               """
>>>>>>         found = self._buffer.find(b"\r\n", self._pos)
>>>>>>         if found >= 0:
>>>>>>             result = self._buffer[self._pos : found]
               else:
>>>>>>             tail = self._buffer[self._pos :]
>>>>>>             data = await self._stream.readline()
>>>>>>             if not data.endswith(b"\r\n"):
>>>>>>                 raise ConnectionError(SERVER_CLOSED_CONNECTION_ERROR)
>>>>>>             result = (tail + data)[:-2]
>>>>>>             self._chunks.append(data)
>>>>>>         self._pos += len(result) + 2
>>>>>>         return result
