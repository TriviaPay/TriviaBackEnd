    1: from __future__ import annotations
       
    1: import sys
    1: import typing
    1: import warnings
       
    1: if sys.version_info >= (3, 10):  # pragma: no cover
>>>>>>     from typing import ParamSpec
       else:  # pragma: no cover
    1:     from typing_extensions import ParamSpec
       
    1: from starlette.datastructures import State, URLPath
    1: from starlette.middleware import Middleware, _MiddlewareClass
    1: from starlette.middleware.base import BaseHTTPMiddleware
    1: from starlette.middleware.errors import ServerErrorMiddleware
    1: from starlette.middleware.exceptions import ExceptionMiddleware
    1: from starlette.requests import Request
    1: from starlette.responses import Response
    1: from starlette.routing import BaseRoute, Router
    1: from starlette.types import ASGIApp, ExceptionHandler, Lifespan, Receive, Scope, Send
    1: from starlette.websockets import WebSocket
       
    1: AppType = typing.TypeVar("AppType", bound="Starlette")
    1: P = ParamSpec("P")
       
       
    2: class Starlette:
    1:     """
           Creates an application instance.
       
           **Parameters:**
       
           * **debug** - Boolean indicating if debug tracebacks should be returned on errors.
           * **routes** - A list of routes to serve incoming HTTP and WebSocket requests.
           * **middleware** - A list of middleware to run for every request. A starlette
           application will always automatically include two middleware classes.
           `ServerErrorMiddleware` is added as the very outermost middleware, to handle
           any uncaught errors occurring anywhere in the entire stack.
           `ExceptionMiddleware` is added as the very innermost middleware, to deal
           with handled exception cases occurring in the routing or endpoints.
           * **exception_handlers** - A mapping of either integer status codes,
           or exception class types onto callables which handle the exceptions.
           Exception handler callables should be of the form
           `handler(request, exc) -> response` and may be either standard functions, or
           async functions.
           * **on_startup** - A list of callables to run on application startup.
           Startup handler callables do not take any arguments, and may be either
           standard functions, or async functions.
           * **on_shutdown** - A list of callables to run on application shutdown.
           Shutdown handler callables do not take any arguments, and may be either
           standard functions, or async functions.
           * **lifespan** - A lifespan context function, which can be used to perform
           startup and shutdown tasks. This is a newer style that replaces the
           `on_startup` and `on_shutdown` handlers. Use one or the other, not both.
           """
       
    1:     def __init__(
               self: AppType,
               debug: bool = False,
               routes: typing.Sequence[BaseRoute] | None = None,
               middleware: typing.Sequence[Middleware] | None = None,
               exception_handlers: typing.Mapping[typing.Any, ExceptionHandler] | None = None,
               on_startup: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,
               on_shutdown: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,
               lifespan: Lifespan[AppType] | None = None,
           ) -> None:
               # The lifespan context function is a newer style that replaces
               # on_startup / on_shutdown handlers. Use one or the other, not both.
>>>>>>         assert lifespan is None or (
>>>>>>             on_startup is None and on_shutdown is None
>>>>>>         ), "Use either 'lifespan' or 'on_startup'/'on_shutdown', not both."
       
>>>>>>         self.debug = debug
>>>>>>         self.state = State()
>>>>>>         self.router = Router(
>>>>>>             routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan
               )
>>>>>>         self.exception_handlers = (
>>>>>>             {} if exception_handlers is None else dict(exception_handlers)
               )
>>>>>>         self.user_middleware = [] if middleware is None else list(middleware)
>>>>>>         self.middleware_stack: typing.Optional[ASGIApp] = None
       
    1:     def build_middleware_stack(self) -> ASGIApp:
   12:         debug = self.debug
   12:         error_handler = None
   12:         exception_handlers: dict[
                   typing.Any, typing.Callable[[Request, Exception], Response]
   12:         ] = {}
       
   48:         for key, value in self.exception_handlers.items():
   36:             if key in (500, Exception):
>>>>>>                 error_handler = value
                   else:
   36:                 exception_handlers[key] = value
       
   12:         middleware = (
   36:             [Middleware(ServerErrorMiddleware, handler=error_handler, debug=debug)]
   12:             + self.user_middleware
   12:             + [
   24:                 Middleware(
   12:                     ExceptionMiddleware, handlers=exception_handlers, debug=debug
                       )
                   ]
               )
       
   12:         app = self.router
   36:         for cls, args, kwargs in reversed(middleware):
   24:             app = cls(app=app, *args, **kwargs)
   12:         return app
       
    1:     @property
    1:     def routes(self) -> list[BaseRoute]:
>>>>>>         return self.router.routes
       
    1:     def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:
>>>>>>         return self.router.url_path_for(name, **path_params)
       
    1:     async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
   24:         scope["app"] = self
   24:         if self.middleware_stack is None:
   12:             self.middleware_stack = self.build_middleware_stack()
   24:         await self.middleware_stack(scope, receive, send)
       
    1:     def on_event(self, event_type: str) -> typing.Callable:  # type: ignore[type-arg]
>>>>>>         return self.router.on_event(event_type)  # pragma: nocover
       
    1:     def mount(self, path: str, app: ASGIApp, name: str | None = None) -> None:
>>>>>>         self.router.mount(path, app=app, name=name)  # pragma: no cover
       
    1:     def host(self, host: str, app: ASGIApp, name: str | None = None) -> None:
>>>>>>         self.router.host(host, app=app, name=name)  # pragma: no cover
       
    1:     def add_middleware(
               self,
               middleware_class: typing.Type[_MiddlewareClass[P]],
               *args: P.args,
               **kwargs: P.kwargs,
           ) -> None:
>>>>>>         if self.middleware_stack is not None:  # pragma: no cover
>>>>>>             raise RuntimeError("Cannot add middleware after an application has started")
>>>>>>         self.user_middleware.insert(0, Middleware(middleware_class, *args, **kwargs))
       
    1:     def add_exception_handler(
               self,
               exc_class_or_status_code: int | typing.Type[Exception],
               handler: ExceptionHandler,
           ) -> None:  # pragma: no cover
>>>>>>         self.exception_handlers[exc_class_or_status_code] = handler
       
    1:     def add_event_handler(
               self,
               event_type: str,
               func: typing.Callable,  # type: ignore[type-arg]
           ) -> None:  # pragma: no cover
>>>>>>         self.router.add_event_handler(event_type, func)
       
    1:     def add_route(
               self,
               path: str,
               route: typing.Callable[[Request], typing.Awaitable[Response] | Response],
               methods: typing.Optional[typing.List[str]] = None,
               name: typing.Optional[str] = None,
               include_in_schema: bool = True,
           ) -> None:  # pragma: no cover
   96:         self.router.add_route(
   48:             path, route, methods=methods, name=name, include_in_schema=include_in_schema
               )
       
    1:     def add_websocket_route(
               self,
               path: str,
               route: typing.Callable[[WebSocket], typing.Awaitable[None]],
               name: str | None = None,
           ) -> None:  # pragma: no cover
>>>>>>         self.router.add_websocket_route(path, route, name=name)
       
    1:     def exception_handler(
               self, exc_class_or_status_code: int | typing.Type[Exception]
           ) -> typing.Callable:  # type: ignore[type-arg]
>>>>>>         warnings.warn(
>>>>>>             "The `exception_handler` decorator is deprecated, and will be removed in version 1.0.0. "  # noqa: E501
                   "Refer to https://www.starlette.io/exceptions/ for the recommended approach.",  # noqa: E501
>>>>>>             DeprecationWarning,
               )
       
>>>>>>         def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]  # noqa: E501
>>>>>>             self.add_exception_handler(exc_class_or_status_code, func)
>>>>>>             return func
       
>>>>>>         return decorator
       
    1:     def route(
               self,
               path: str,
               methods: list[str] | None = None,
               name: str | None = None,
               include_in_schema: bool = True,
           ) -> typing.Callable:  # type: ignore[type-arg]
               """
               We no longer document this decorator style API, and its usage is discouraged.
               Instead you should use the following approach:
       
               >>> routes = [Route(path, endpoint=...), ...]
               >>> app = Starlette(routes=routes)
               """
>>>>>>         warnings.warn(
>>>>>>             "The `route` decorator is deprecated, and will be removed in version 1.0.0. "  # noqa: E501
                   "Refer to https://www.starlette.io/routing/ for the recommended approach.",  # noqa: E501
>>>>>>             DeprecationWarning,
               )
       
>>>>>>         def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]  # noqa: E501
>>>>>>             self.router.add_route(
>>>>>>                 path,
>>>>>>                 func,
>>>>>>                 methods=methods,
>>>>>>                 name=name,
>>>>>>                 include_in_schema=include_in_schema,
                   )
>>>>>>             return func
       
>>>>>>         return decorator
       
    1:     def websocket_route(self, path: str, name: str | None = None) -> typing.Callable:  # type: ignore[type-arg]
               """
               We no longer document this decorator style API, and its usage is discouraged.
               Instead you should use the following approach:
       
               >>> routes = [WebSocketRoute(path, endpoint=...), ...]
               >>> app = Starlette(routes=routes)
               """
>>>>>>         warnings.warn(
>>>>>>             "The `websocket_route` decorator is deprecated, and will be removed in version 1.0.0. "  # noqa: E501
                   "Refer to https://www.starlette.io/routing/#websocket-routing for the recommended approach.",  # noqa: E501
>>>>>>             DeprecationWarning,
               )
       
>>>>>>         def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]  # noqa: E501
>>>>>>             self.router.add_websocket_route(path, func, name=name)
>>>>>>             return func
       
>>>>>>         return decorator
       
    1:     def middleware(self, middleware_type: str) -> typing.Callable:  # type: ignore[type-arg]  # noqa: E501
               """
               We no longer document this decorator style API, and its usage is discouraged.
               Instead you should use the following approach:
       
               >>> middleware = [Middleware(...), ...]
               >>> app = Starlette(middleware=middleware)
               """
>>>>>>         warnings.warn(
>>>>>>             "The `middleware` decorator is deprecated, and will be removed in version 1.0.0. "  # noqa: E501
                   "Refer to https://www.starlette.io/middleware/#using-middleware for recommended approach.",  # noqa: E501
>>>>>>             DeprecationWarning,
               )
>>>>>>         assert (
>>>>>>             middleware_type == "http"
>>>>>>         ), 'Currently only middleware("http") is supported.'
       
>>>>>>         def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]  # noqa: E501
>>>>>>             self.add_middleware(BaseHTTPMiddleware, dispatch=func)
>>>>>>             return func
       
>>>>>>         return decorator
