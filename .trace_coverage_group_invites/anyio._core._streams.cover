    1: from __future__ import annotations
       
    1: import math
    1: from typing import Any, TypeVar, overload
       
    1: from ..streams.memory import (
           MemoryObjectReceiveStream,
           MemoryObjectSendStream,
           MemoryObjectStreamState,
       )
       
    1: T_Item = TypeVar("T_Item")
       
       
    1: @overload
    1: def create_memory_object_stream(
           max_buffer_size: float = ...,
       ) -> tuple[MemoryObjectSendStream[Any], MemoryObjectReceiveStream[Any]]:
>>>>>>     ...
       
       
    1: @overload
    1: def create_memory_object_stream(
           max_buffer_size: float = ..., item_type: type[T_Item] = ...
       ) -> tuple[MemoryObjectSendStream[T_Item], MemoryObjectReceiveStream[T_Item]]:
>>>>>>     ...
       
       
    1: def create_memory_object_stream(
           max_buffer_size: float = 0, item_type: type[T_Item] | None = None
       ) -> tuple[MemoryObjectSendStream[Any], MemoryObjectReceiveStream[Any]]:
           """
           Create a memory object stream.
       
           :param max_buffer_size: number of items held in the buffer until ``send()`` starts blocking
           :param item_type: type of item, for marking the streams with the right generic type for
               static typing (not used at run time)
           :return: a tuple of (send stream, receive stream)
       
           """
   24:     if max_buffer_size != math.inf and not isinstance(max_buffer_size, int):
>>>>>>         raise ValueError("max_buffer_size must be either an integer or math.inf")
   24:     if max_buffer_size < 0:
>>>>>>         raise ValueError("max_buffer_size cannot be negative")
       
   24:     state: MemoryObjectStreamState = MemoryObjectStreamState(max_buffer_size)
   24:     return MemoryObjectSendStream(state), MemoryObjectReceiveStream(state)
