    1: from __future__ import annotations
       
    1: from abc import abstractmethod
    1: from typing import Any, Callable, Generic, TypeVar, Union
       
    1: from .._core._exceptions import EndOfStream
    1: from .._core._typedattr import TypedAttributeProvider
    1: from ._resources import AsyncResource
    1: from ._tasks import TaskGroup
       
    1: T_Item = TypeVar("T_Item")
    1: T_co = TypeVar("T_co", covariant=True)
    1: T_contra = TypeVar("T_contra", contravariant=True)
       
       
    3: class UnreliableObjectReceiveStream(
    1:     Generic[T_co], AsyncResource, TypedAttributeProvider
       ):
    1:     """
           An interface for receiving objects.
       
           This interface makes no guarantees that the received messages arrive in the order in which they
           were sent, or that no messages are missed.
       
           Asynchronously iterating over objects of this type will yield objects matching the given type
           parameter.
           """
       
    1:     def __aiter__(self) -> UnreliableObjectReceiveStream[T_co]:
>>>>>>         return self
       
    1:     async def __anext__(self) -> T_co:
>>>>>>         try:
>>>>>>             return await self.receive()
>>>>>>         except EndOfStream:
>>>>>>             raise StopAsyncIteration
       
    1:     @abstractmethod
    1:     async def receive(self) -> T_co:
               """
               Receive the next item.
       
               :raises ~anyio.ClosedResourceError: if the receive stream has been explicitly
                   closed
               :raises ~anyio.EndOfStream: if this stream has been closed from the other end
               :raises ~anyio.BrokenResourceError: if this stream has been rendered unusable
                   due to external causes
               """
       
       
    3: class UnreliableObjectSendStream(
    1:     Generic[T_contra], AsyncResource, TypedAttributeProvider
       ):
    1:     """
           An interface for sending objects.
       
           This interface makes no guarantees that the messages sent will reach the recipient(s) in the
           same order in which they were sent, or at all.
           """
       
    1:     @abstractmethod
    1:     async def send(self, item: T_contra) -> None:
               """
               Send an item to the peer(s).
       
               :param item: the item to send
               :raises ~anyio.ClosedResourceError: if the send stream has been explicitly
                   closed
               :raises ~anyio.BrokenResourceError: if this stream has been rendered unusable
                   due to external causes
               """
       
       
    3: class UnreliableObjectStream(
    1:     UnreliableObjectReceiveStream[T_Item], UnreliableObjectSendStream[T_Item]
       ):
    1:     """
           A bidirectional message stream which does not guarantee the order or reliability of message
           delivery.
           """
       
       
    2: class ObjectReceiveStream(UnreliableObjectReceiveStream[T_co]):
    1:     """
           A receive message stream which guarantees that messages are received in the same order in
           which they were sent, and that no messages are missed.
           """
       
       
    2: class ObjectSendStream(UnreliableObjectSendStream[T_contra]):
    1:     """
           A send message stream which guarantees that messages are delivered in the same order in which
           they were sent, without missing any messages in the middle.
           """
       
       
    3: class ObjectStream(
    1:     ObjectReceiveStream[T_Item],
    1:     ObjectSendStream[T_Item],
    1:     UnreliableObjectStream[T_Item],
       ):
    1:     """
           A bidirectional message stream which guarantees the order and reliability of message delivery.
           """
       
    1:     @abstractmethod
    1:     async def send_eof(self) -> None:
               """
               Send an end-of-file indication to the peer.
       
               You should not try to send any further data to this stream after calling this method.
               This method is idempotent (does nothing on successive calls).
               """
       
       
    2: class ByteReceiveStream(AsyncResource, TypedAttributeProvider):
    1:     """
           An interface for receiving bytes from a single peer.
       
           Iterating this byte stream will yield a byte string of arbitrary length, but no more than
           65536 bytes.
           """
       
    1:     def __aiter__(self) -> ByteReceiveStream:
>>>>>>         return self
       
    1:     async def __anext__(self) -> bytes:
>>>>>>         try:
>>>>>>             return await self.receive()
>>>>>>         except EndOfStream:
>>>>>>             raise StopAsyncIteration
       
    1:     @abstractmethod
    1:     async def receive(self, max_bytes: int = 65536) -> bytes:
               """
               Receive at most ``max_bytes`` bytes from the peer.
       
               .. note:: Implementors of this interface should not return an empty :class:`bytes` object,
                   and users should ignore them.
       
               :param max_bytes: maximum number of bytes to receive
               :return: the received bytes
               :raises ~anyio.EndOfStream: if this stream has been closed from the other end
               """
       
       
    2: class ByteSendStream(AsyncResource, TypedAttributeProvider):
    1:     """An interface for sending bytes to a single peer."""
       
    1:     @abstractmethod
    1:     async def send(self, item: bytes) -> None:
               """
               Send the given bytes to the peer.
       
               :param item: the bytes to send
               """
       
       
    2: class ByteStream(ByteReceiveStream, ByteSendStream):
    1:     """A bidirectional byte stream."""
       
    1:     @abstractmethod
    1:     async def send_eof(self) -> None:
               """
               Send an end-of-file indication to the peer.
       
               You should not try to send any further data to this stream after calling this method.
               This method is idempotent (does nothing on successive calls).
               """
       
       
       #: Type alias for all unreliable bytes-oriented receive streams.
    2: AnyUnreliableByteReceiveStream = Union[
    1:     UnreliableObjectReceiveStream[bytes], ByteReceiveStream
       ]
       #: Type alias for all unreliable bytes-oriented send streams.
    1: AnyUnreliableByteSendStream = Union[UnreliableObjectSendStream[bytes], ByteSendStream]
       #: Type alias for all unreliable bytes-oriented streams.
    1: AnyUnreliableByteStream = Union[UnreliableObjectStream[bytes], ByteStream]
       #: Type alias for all bytes-oriented receive streams.
    1: AnyByteReceiveStream = Union[ObjectReceiveStream[bytes], ByteReceiveStream]
       #: Type alias for all bytes-oriented send streams.
    1: AnyByteSendStream = Union[ObjectSendStream[bytes], ByteSendStream]
       #: Type alias for all bytes-oriented streams.
    1: AnyByteStream = Union[ObjectStream[bytes], ByteStream]
       
       
    2: class Listener(Generic[T_co], AsyncResource, TypedAttributeProvider):
    1:     """An interface for objects that let you accept incoming connections."""
       
    1:     @abstractmethod
    1:     async def serve(
               self,
               handler: Callable[[T_co], Any],
               task_group: TaskGroup | None = None,
           ) -> None:
               """
               Accept incoming connections as they come in and start tasks to handle them.
       
               :param handler: a callable that will be used to handle each accepted connection
               :param task_group: the task group that will be used to start tasks for handling each
                   accepted connection (if omitted, an ad-hoc task group will be created)
               """
