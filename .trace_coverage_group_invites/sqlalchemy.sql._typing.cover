       # sql/_typing.py
       # Copyright (C) 2022-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: from __future__ import annotations
       
    1: import operator
    1: from typing import Any
    1: from typing import Callable
    1: from typing import Dict
    1: from typing import Generic
    1: from typing import Iterable
    1: from typing import Mapping
    1: from typing import NoReturn
    1: from typing import Optional
    1: from typing import overload
    1: from typing import Set
    1: from typing import Tuple
    1: from typing import Type
    1: from typing import TYPE_CHECKING
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from . import roles
    1: from .. import exc
    1: from .. import util
    1: from ..inspection import Inspectable
    1: from ..util.typing import Literal
    1: from ..util.typing import Protocol
    1: from ..util.typing import TypeAlias
       
    1: if TYPE_CHECKING:
>>>>>>     from datetime import date
>>>>>>     from datetime import datetime
>>>>>>     from datetime import time
>>>>>>     from datetime import timedelta
>>>>>>     from decimal import Decimal
>>>>>>     from uuid import UUID
       
>>>>>>     from .base import Executable
>>>>>>     from .compiler import Compiled
>>>>>>     from .compiler import DDLCompiler
>>>>>>     from .compiler import SQLCompiler
>>>>>>     from .dml import UpdateBase
>>>>>>     from .dml import ValuesBase
>>>>>>     from .elements import ClauseElement
>>>>>>     from .elements import ColumnElement
>>>>>>     from .elements import KeyedColumnElement
>>>>>>     from .elements import quoted_name
>>>>>>     from .elements import SQLCoreOperations
>>>>>>     from .elements import TextClause
>>>>>>     from .lambdas import LambdaElement
>>>>>>     from .roles import FromClauseRole
>>>>>>     from .schema import Column
>>>>>>     from .selectable import Alias
>>>>>>     from .selectable import CTE
>>>>>>     from .selectable import FromClause
>>>>>>     from .selectable import Join
>>>>>>     from .selectable import NamedFromClause
>>>>>>     from .selectable import ReturnsRows
>>>>>>     from .selectable import Select
>>>>>>     from .selectable import Selectable
>>>>>>     from .selectable import SelectBase
>>>>>>     from .selectable import Subquery
>>>>>>     from .selectable import TableClause
>>>>>>     from .sqltypes import TableValueType
>>>>>>     from .sqltypes import TupleType
>>>>>>     from .type_api import TypeEngine
>>>>>>     from ..util.typing import TypeGuard
       
    1: _T = TypeVar("_T", bound=Any)
    1: _T_co = TypeVar("_T_co", bound=Any, covariant=True)
       
       
    1: _CE = TypeVar("_CE", bound="ColumnElement[Any]")
       
    1: _CLE = TypeVar("_CLE", bound="ClauseElement")
       
       
    2: class _HasClauseElement(Protocol, Generic[_T_co]):
    1:     """indicates a class that has a __clause_element__() method"""
       
    1:     def __clause_element__(self) -> roles.ExpressionElementRole[_T_co]: ...
       
       
    2: class _CoreAdapterProto(Protocol):
    1:     """protocol for the ClauseAdapter/ColumnAdapter.traverse() method."""
       
    1:     def __call__(self, obj: _CE) -> _CE: ...
       
       
       # match column types that are not ORM entities
    2: _NOT_ENTITY = TypeVar(
    1:     "_NOT_ENTITY",
    1:     int,
    1:     str,
    1:     "datetime",
    1:     "date",
    1:     "time",
    1:     "timedelta",
    1:     "UUID",
    1:     float,
    1:     "Decimal",
       )
       
    2: _MAYBE_ENTITY = TypeVar(
    1:     "_MAYBE_ENTITY",
    1:     roles.ColumnsClauseRole,
    1:     Literal["*", 1],
    1:     Type[Any],
    1:     Inspectable[_HasClauseElement[Any]],
    1:     _HasClauseElement[Any],
       )
       
       
       # convention:
       # XYZArgument - something that the end user is passing to a public API method
       # XYZElement - the internal representation that we use for the thing.
       # the coercions system is responsible for converting from XYZArgument to
       # XYZElement.
       
    2: _TextCoercedExpressionArgument = Union[
    2:     str,
    1:     "TextClause",
    1:     "ColumnElement[_T]",
    1:     _HasClauseElement[_T],
    1:     roles.ExpressionElementRole[_T],
       ]
       
    2: _ColumnsClauseArgument = Union[
    2:     roles.TypedColumnsClauseRole[_T],
    1:     roles.ColumnsClauseRole,
    1:     "SQLCoreOperations[_T]",
    1:     Literal["*", 1],
    1:     Type[_T],
    1:     Inspectable[_HasClauseElement[_T]],
    1:     _HasClauseElement[_T],
       ]
       """open-ended SELECT columns clause argument.
       
       Includes column expressions, tables, ORM mapped entities, a few literal values.
       
       This type is used for lists of columns  / entities to be returned in result
       sets; select(...), insert().returning(...), etc.
       
       
       """
       
    2: _TypedColumnClauseArgument = Union[
    2:     roles.TypedColumnsClauseRole[_T],
    1:     "SQLCoreOperations[_T]",
    1:     Type[_T],
       ]
       
    1: _TP = TypeVar("_TP", bound=Tuple[Any, ...])
       
    1: _T0 = TypeVar("_T0", bound=Any)
    1: _T1 = TypeVar("_T1", bound=Any)
    1: _T2 = TypeVar("_T2", bound=Any)
    1: _T3 = TypeVar("_T3", bound=Any)
    1: _T4 = TypeVar("_T4", bound=Any)
    1: _T5 = TypeVar("_T5", bound=Any)
    1: _T6 = TypeVar("_T6", bound=Any)
    1: _T7 = TypeVar("_T7", bound=Any)
    1: _T8 = TypeVar("_T8", bound=Any)
    1: _T9 = TypeVar("_T9", bound=Any)
       
       
    2: _ColumnExpressionArgument = Union[
    2:     "ColumnElement[_T]",
    1:     _HasClauseElement[_T],
    1:     "SQLCoreOperations[_T]",
    1:     roles.ExpressionElementRole[_T],
    1:     Callable[[], "ColumnElement[_T]"],
    1:     "LambdaElement",
       ]
       "See docs in public alias ColumnExpressionArgument."
       
    1: ColumnExpressionArgument: TypeAlias = _ColumnExpressionArgument[_T]
       """Narrower "column expression" argument.
       
       This type is used for all the other "column" kinds of expressions that
       typically represent a single SQL column expression, not a set of columns the
       way a table or ORM entity does.
       
       This includes ColumnElement, or ORM-mapped attributes that will have a
       ``__clause_element__()`` method, it also has the ExpressionElementRole
       overall which brings in the TextClause object also.
       
       .. versionadded:: 2.0.13
       
       """
       
    1: _ColumnExpressionOrLiteralArgument = Union[Any, _ColumnExpressionArgument[_T]]
       
    1: _ColumnExpressionOrStrLabelArgument = Union[str, _ColumnExpressionArgument[_T]]
       
    2: _ByArgument = Union[
    2:     Iterable[_ColumnExpressionOrStrLabelArgument[Any]],
    1:     _ColumnExpressionOrStrLabelArgument[Any],
       ]
       """Used for keyword-based ``order_by`` and ``partition_by`` parameters."""
       
       
    1: _InfoType = Dict[Any, Any]
       """the .info dictionary accepted and used throughout Core /ORM"""
       
    2: _FromClauseArgument = Union[
    2:     roles.FromClauseRole,
    1:     Type[Any],
    1:     Inspectable[_HasClauseElement[Any]],
    1:     _HasClauseElement[Any],
       ]
       """A FROM clause, like we would send to select().select_from().
       
       Also accommodates ORM entities and related constructs.
       
       """
       
    1: _JoinTargetArgument = Union[_FromClauseArgument, roles.JoinTargetRole]
       """target for join() builds on _FromClauseArgument to include additional
       join target roles such as those which come from the ORM.
       
       """
       
    1: _OnClauseArgument = Union[_ColumnExpressionArgument[Any], roles.OnClauseRole]
       """target for an ON clause, includes additional roles such as those which
       come from the ORM.
       
       """
       
    2: _SelectStatementForCompoundArgument = Union[
    1:     "SelectBase", roles.CompoundElementRole
       ]
       """SELECT statement acceptable by ``union()`` and other SQL set operations"""
       
    2: _DMLColumnArgument = Union[
    2:     str,
    1:     _HasClauseElement[Any],
    1:     roles.DMLColumnRole,
    1:     "SQLCoreOperations[Any]",
       ]
       """A DML column expression.  This is a "key" inside of insert().values(),
       update().values(), and related.
       
       These are usually strings or SQL table columns.
       
       There's also edge cases like JSON expression assignment, which we would want
       the DMLColumnRole to be able to accommodate.
       
       """
       
    1: _DMLKey = TypeVar("_DMLKey", bound=_DMLColumnArgument)
    1: _DMLColumnKeyMapping = Mapping[_DMLKey, Any]
       
       
    1: _DDLColumnArgument = Union[str, "Column[Any]", roles.DDLConstraintColumnRole]
       """DDL column.
       
       used for :class:`.PrimaryKeyConstraint`, :class:`.UniqueConstraint`, etc.
       
       """
       
    2: _DMLTableArgument = Union[
    2:     "TableClause",
    1:     "Join",
    1:     "Alias",
    1:     "CTE",
    1:     Type[Any],
    1:     Inspectable[_HasClauseElement[Any]],
    1:     _HasClauseElement[Any],
       ]
       
    1: _PropagateAttrsType = util.immutabledict[str, Any]
       
    1: _TypeEngineArgument = Union[Type["TypeEngine[_T]"], "TypeEngine[_T]"]
       
    1: _EquivalentColumnMap = Dict["ColumnElement[Any]", Set["ColumnElement[Any]"]]
       
    1: _LimitOffsetType = Union[int, _ColumnExpressionArgument[int], None]
       
    1: _AutoIncrementType = Union[bool, Literal["auto", "ignore_fk"]]
       
    1: if TYPE_CHECKING:
       
>>>>>>     def is_sql_compiler(c: Compiled) -> TypeGuard[SQLCompiler]: ...
       
>>>>>>     def is_ddl_compiler(c: Compiled) -> TypeGuard[DDLCompiler]: ...
       
>>>>>>     def is_named_from_clause(
               t: FromClauseRole,
>>>>>>     ) -> TypeGuard[NamedFromClause]: ...
       
>>>>>>     def is_column_element(
               c: ClauseElement,
>>>>>>     ) -> TypeGuard[ColumnElement[Any]]: ...
       
>>>>>>     def is_keyed_column_element(
               c: ClauseElement,
>>>>>>     ) -> TypeGuard[KeyedColumnElement[Any]]: ...
       
>>>>>>     def is_text_clause(c: ClauseElement) -> TypeGuard[TextClause]: ...
       
>>>>>>     def is_from_clause(c: ClauseElement) -> TypeGuard[FromClause]: ...
       
>>>>>>     def is_tuple_type(t: TypeEngine[Any]) -> TypeGuard[TupleType]: ...
       
>>>>>>     def is_table_value_type(
               t: TypeEngine[Any],
>>>>>>     ) -> TypeGuard[TableValueType]: ...
       
>>>>>>     def is_selectable(t: Any) -> TypeGuard[Selectable]: ...
       
>>>>>>     def is_select_base(
               t: Union[Executable, ReturnsRows]
>>>>>>     ) -> TypeGuard[SelectBase]: ...
       
>>>>>>     def is_select_statement(
               t: Union[Executable, ReturnsRows]
>>>>>>     ) -> TypeGuard[Select[Any]]: ...
       
>>>>>>     def is_table(t: FromClause) -> TypeGuard[TableClause]: ...
       
>>>>>>     def is_subquery(t: FromClause) -> TypeGuard[Subquery]: ...
       
>>>>>>     def is_dml(c: ClauseElement) -> TypeGuard[UpdateBase]: ...
       
       else:
    1:     is_sql_compiler = operator.attrgetter("is_sql")
    1:     is_ddl_compiler = operator.attrgetter("is_ddl")
    1:     is_named_from_clause = operator.attrgetter("named_with_column")
    1:     is_column_element = operator.attrgetter("_is_column_element")
    1:     is_keyed_column_element = operator.attrgetter("_is_keyed_column_element")
    1:     is_text_clause = operator.attrgetter("_is_text_clause")
    1:     is_from_clause = operator.attrgetter("_is_from_clause")
    1:     is_tuple_type = operator.attrgetter("_is_tuple_type")
    1:     is_table_value_type = operator.attrgetter("_is_table_value")
    1:     is_selectable = operator.attrgetter("is_selectable")
    1:     is_select_base = operator.attrgetter("_is_select_base")
    1:     is_select_statement = operator.attrgetter("_is_select_statement")
    1:     is_table = operator.attrgetter("_is_table")
    1:     is_subquery = operator.attrgetter("_is_subquery")
    1:     is_dml = operator.attrgetter("is_dml")
       
       
    1: def has_schema_attr(t: FromClauseRole) -> TypeGuard[TableClause]:
  153:     return hasattr(t, "schema")
       
       
    1: def is_quoted_name(s: str) -> TypeGuard[quoted_name]:
  306:     return hasattr(s, "quote")
       
       
    1: def is_has_clause_element(s: object) -> TypeGuard[_HasClauseElement[Any]]:
>>>>>>     return hasattr(s, "__clause_element__")
       
       
    1: def is_insert_update(c: ClauseElement) -> TypeGuard[ValuesBase]:
>>>>>>     return c.is_dml and (c.is_insert or c.is_update)  # type: ignore
       
       
    1: def _no_kw() -> exc.ArgumentError:
>>>>>>     return exc.ArgumentError(
>>>>>>         "Additional keyword arguments are not accepted by this "
               "function/method.  The presence of **kw is for pep-484 typing purposes"
           )
       
       
    1: def _unexpected_kw(methname: str, kw: Dict[str, Any]) -> NoReturn:
>>>>>>     k = list(kw)[0]
>>>>>>     raise TypeError(f"{methname} got an unexpected keyword argument '{k}'")
       
       
    1: @overload
    1: def Nullable(
           val: "SQLCoreOperations[_T]",
>>>>>> ) -> "SQLCoreOperations[Optional[_T]]": ...
       
       
    1: @overload
    1: def Nullable(
           val: roles.ExpressionElementRole[_T],
>>>>>> ) -> roles.ExpressionElementRole[Optional[_T]]: ...
       
       
    1: @overload
    1: def Nullable(val: Type[_T]) -> Type[Optional[_T]]: ...
       
       
    1: def Nullable(
           val: _TypedColumnClauseArgument[_T],
       ) -> _TypedColumnClauseArgument[Optional[_T]]:
           """Types a column or ORM class as nullable.
       
           This can be used in select and other contexts to express that the value of
           a column can be null, for example due to an outer join::
       
               stmt1 = select(A, Nullable(B)).outerjoin(A.bs)
               stmt2 = select(A.data, Nullable(B.data)).outerjoin(A.bs)
       
           At runtime this method returns the input unchanged.
       
           .. versionadded:: 2.0.20
           """
>>>>>>     return val
       
       
    1: @overload
    1: def NotNullable(
           val: "SQLCoreOperations[Optional[_T]]",
>>>>>> ) -> "SQLCoreOperations[_T]": ...
       
       
    1: @overload
    1: def NotNullable(
           val: roles.ExpressionElementRole[Optional[_T]],
>>>>>> ) -> roles.ExpressionElementRole[_T]: ...
       
       
    1: @overload
    1: def NotNullable(val: Type[Optional[_T]]) -> Type[_T]: ...
       
       
    1: @overload
    1: def NotNullable(val: Optional[Type[_T]]) -> Type[_T]: ...
       
       
    1: def NotNullable(
           val: Union[_TypedColumnClauseArgument[Optional[_T]], Optional[Type[_T]]],
       ) -> _TypedColumnClauseArgument[_T]:
           """Types a column or ORM class as not nullable.
       
           This can be used in select and other contexts to express that the value of
           a column cannot be null, for example due to a where condition on a
           nullable column::
       
               stmt = select(NotNullable(A.value)).where(A.value.is_not(None))
       
           At runtime this method returns the input unchanged.
       
           .. versionadded:: 2.0.20
           """
>>>>>>     return val  # type: ignore
