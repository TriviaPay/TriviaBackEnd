       # orm/loading.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       # mypy: ignore-errors
       
       
    1: """private module containing functions used to convert database
       rows into object instances and associated state.
       
       the functions here are called primarily by Query, Mapper,
       as well as some of the attribute loading strategies.
       
       """
       
    1: from __future__ import annotations
       
    1: from typing import Any
    1: from typing import Dict
    1: from typing import Iterable
    1: from typing import List
    1: from typing import Mapping
    1: from typing import Optional
    1: from typing import Sequence
    1: from typing import Tuple
    1: from typing import TYPE_CHECKING
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from . import attributes
    1: from . import exc as orm_exc
    1: from . import path_registry
    1: from .base import _DEFER_FOR_STATE
    1: from .base import _RAISE_FOR_STATE
    1: from .base import _SET_DEFERRED_EXPIRED
    1: from .base import PassiveFlag
    1: from .context import FromStatement
    1: from .context import ORMCompileState
    1: from .context import QueryContext
    1: from .util import _none_set
    1: from .util import state_str
    1: from .. import exc as sa_exc
    1: from .. import util
    1: from ..engine import result_tuple
    1: from ..engine.result import ChunkedIteratorResult
    1: from ..engine.result import FrozenResult
    1: from ..engine.result import SimpleResultMetaData
    1: from ..sql import select
    1: from ..sql import util as sql_util
    1: from ..sql.selectable import ForUpdateArg
    1: from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
    1: from ..sql.selectable import SelectState
    1: from ..util import EMPTY_DICT
       
    1: if TYPE_CHECKING:
>>>>>>     from ._typing import _IdentityKeyType
>>>>>>     from .base import LoaderCallableStatus
>>>>>>     from .interfaces import ORMOption
>>>>>>     from .mapper import Mapper
>>>>>>     from .query import Query
>>>>>>     from .session import Session
>>>>>>     from .state import InstanceState
>>>>>>     from ..engine.cursor import CursorResult
>>>>>>     from ..engine.interfaces import _ExecuteOptions
>>>>>>     from ..engine.result import Result
>>>>>>     from ..sql import Select
       
    1: _T = TypeVar("_T", bound=Any)
    1: _O = TypeVar("_O", bound=object)
    1: _new_runid = util.counter()
       
       
    1: _PopulatorDict = Dict[str, List[Tuple[str, Any]]]
       
       
    1: def instances(cursor: CursorResult[Any], context: QueryContext) -> Result[Any]:
           """Return a :class:`.Result` given an ORM query context.
       
           :param cursor: a :class:`.CursorResult`, generated by a statement
            which came from :class:`.ORMCompileState`
       
           :param context: a :class:`.QueryContext` object
       
           :return: a :class:`.Result` object representing ORM results
       
           .. versionchanged:: 1.4 The instances() function now uses
              :class:`.Result` objects and has an all new interface.
       
           """
       
   86:     context.runid = _new_runid()
       
   86:     if context.top_level_context:
>>>>>>         is_top_level = False
>>>>>>         context.post_load_paths = context.top_level_context.post_load_paths
           else:
   86:         is_top_level = True
   86:         context.post_load_paths = {}
       
   86:     compile_state = context.compile_state
   86:     filtered = compile_state._has_mapper_entities
   86:     single_entity = (
  172:         not context.load_options._only_return_tuples
   86:         and len(compile_state._entities) == 1
   86:         and compile_state._entities[0].supports_single_entity
           )
       
   86:     try:
  172:         (process, labels, extra) = list(
  172:             zip(
  344:                 *[
   86:                     query_entity.row_processor(context, cursor)
  172:                     for query_entity in context.compile_state._entities
                       ]
                   )
               )
       
   86:         if context.yield_per and (
>>>>>>             context.loaders_require_buffering
>>>>>>             or context.loaders_require_uniquing
               ):
>>>>>>             raise sa_exc.InvalidRequestError(
>>>>>>                 "Can't use yield_per with eager loaders that require uniquing "
                       "or row buffering, e.g. joinedload() against collections "
                       "or subqueryload().  Consider the selectinload() strategy "
                       "for better flexibility in loading objects."
                   )
       
>>>>>>     except Exception:
>>>>>>         with util.safe_reraise():
>>>>>>             cursor.close()
       
   86:     def _no_unique(entry):
>>>>>>         raise sa_exc.InvalidRequestError(
>>>>>>             "Can't use the ORM yield_per feature in conjunction with unique()"
               )
       
   86:     def _not_hashable(datatype, *, legacy=False, uncertain=False):
>>>>>>         if not legacy:
       
>>>>>>             def go(obj):
>>>>>>                 if uncertain:
>>>>>>                     try:
>>>>>>                         return hash(obj)
>>>>>>                     except:
>>>>>>                         pass
       
>>>>>>                 raise sa_exc.InvalidRequestError(
>>>>>>                     "Can't apply uniqueness to row tuple containing value of "
>>>>>>                     f"""type {datatype!r}; {
>>>>>>                         'the values returned appear to be'
>>>>>>                         if uncertain
>>>>>>                         else 'this datatype produces'
                           } non-hashable values"""
                       )
       
>>>>>>             return go
>>>>>>         elif not uncertain:
>>>>>>             return id
               else:
>>>>>>             _use_id = False
       
>>>>>>             def go(obj):
                       nonlocal _use_id
       
>>>>>>                 if not _use_id:
>>>>>>                     try:
>>>>>>                         return hash(obj)
>>>>>>                     except:
>>>>>>                         pass
       
                           # in #10459, we considered using a warning here, however
                           # as legacy query uses result.unique() in all cases, this
                           # would lead to too many warning cases.
>>>>>>                     _use_id = True
       
>>>>>>                 return id(obj)
       
>>>>>>             return go
       
  344:     unique_filters = [
               (
   86:             _no_unique
   86:             if context.yield_per
                   else (
   90:                 _not_hashable(
>>>>>>                     ent.column.type,  # type: ignore
>>>>>>                     legacy=context.load_options._legacy_uniquing,
>>>>>>                     uncertain=ent._null_column_type,
                       )
                       if (
   86:                     not ent.use_id_for_hash
    4:                     and (ent._non_hashable_value or ent._null_column_type)
                       )
   86:                 else id if ent.use_id_for_hash else None
                   )
               )
  172:         for ent in context.compile_state._entities
           ]
       
  172:     row_metadata = SimpleResultMetaData(
   86:         labels, extra, _unique_filters=unique_filters
           )
       
   86:     def chunks(size):  # type: ignore
               while True:
   86:             yield_per = size
       
   86:             context.partials = {}
       
   86:             if yield_per:
>>>>>>                 fetch = cursor.fetchmany(yield_per)
       
>>>>>>                 if not fetch:
>>>>>>                     break
                   else:
   86:                 fetch = cursor._raw_all_rows()
       
   86:             if single_entity:
   84:                 proc = process[0]
  247:                 rows = [proc(row) for row in fetch]
                   else:
    8:                 rows = [
    8:                     tuple([proc(row) for proc in process]) for row in fetch
                       ]
       
                   # if we are the originating load from a query, meaning we
                   # aren't being called as a result of a nested "post load",
                   # iterate through all the collected post loaders and fire them
                   # off.  Previously this used to work recursively, however that
                   # prevented deeply nested structures from being loadable
   86:             if is_top_level:
   86:                 if yield_per:
                           # if using yield per, memoize the state of the
                           # collection so that it can be restored
>>>>>>                     top_level_post_loads = list(
>>>>>>                         context.post_load_paths.items()
                           )
       
   86:                 while context.post_load_paths:
>>>>>>                     post_loads = list(context.post_load_paths.items())
>>>>>>                     context.post_load_paths.clear()
>>>>>>                     for path, post_load in post_loads:
>>>>>>                         post_load.invoke(context, path)
       
   86:                 if yield_per:
>>>>>>                     context.post_load_paths.clear()
>>>>>>                     context.post_load_paths.update(top_level_post_loads)
       
   86:             yield rows
       
   45:             if not yield_per:
   45:                 break
       
   86:     if context.execution_options.get("prebuffer_rows", False):
               # this is a bit of a hack at the moment.
               # I would rather have some option in the result to pre-buffer
               # internally.
>>>>>>         _prebuffered = list(chunks(None))
       
>>>>>>         def chunks(size):
>>>>>>             return iter(_prebuffered)
       
  172:     result = ChunkedIteratorResult(
   86:         row_metadata,
   86:         chunks,
   86:         source_supports_scalars=single_entity,
   86:         raw=cursor,
   86:         dynamic_yield_per=cursor.context._is_server_side,
           )
       
           # filtered and single_entity are used to indicate to legacy Query that the
           # query has ORM entities, so legacy deduping and scalars should be called
           # on the result.
  172:     result._attributes = result._attributes.union(
   86:         dict(filtered=filtered, is_single_entity=single_entity)
           )
       
           # multi_row_eager_loaders OTOH is specific to joinedload.
   86:     if context.compile_state.multi_row_eager_loaders:
       
>>>>>>         def require_unique(obj):
>>>>>>             raise sa_exc.InvalidRequestError(
>>>>>>                 "The unique() method must be invoked on this Result, "
                       "as it contains results that include joined eager loads "
                       "against collections"
                   )
       
>>>>>>         result._unique_filter_state = (None, require_unique)
       
   86:     if context.yield_per:
>>>>>>         result.yield_per(context.yield_per)
       
   86:     return result
       
       
    1: @util.preload_module("sqlalchemy.orm.context")
    1: def merge_frozen_result(session, statement, frozen_result, load=True):
           """Merge a :class:`_engine.FrozenResult` back into a :class:`_orm.Session`,
           returning a new :class:`_engine.Result` object with :term:`persistent`
           objects.
       
           See the section :ref:`do_orm_execute_re_executing` for an example.
       
           .. seealso::
       
               :ref:`do_orm_execute_re_executing`
       
               :meth:`_engine.Result.freeze`
       
               :class:`_engine.FrozenResult`
       
           """
>>>>>>     querycontext = util.preloaded.orm_context
       
>>>>>>     if load:
               # flush current contents if we expect to load data
>>>>>>         session._autoflush()
       
>>>>>>     ctx = querycontext.ORMSelectCompileState._create_entities_collection(
>>>>>>         statement, legacy=False
           )
       
>>>>>>     autoflush = session.autoflush
>>>>>>     try:
>>>>>>         session.autoflush = False
>>>>>>         mapped_entities = [
>>>>>>             i
>>>>>>             for i, e in enumerate(ctx._entities)
>>>>>>             if isinstance(e, querycontext._MapperEntity)
               ]
>>>>>>         keys = [ent._label_name for ent in ctx._entities]
       
>>>>>>         keyed_tuple = result_tuple(
>>>>>>             keys, [ent._extra_entities for ent in ctx._entities]
               )
       
>>>>>>         result = []
>>>>>>         for newrow in frozen_result.rewrite_rows():
>>>>>>             for i in mapped_entities:
>>>>>>                 if newrow[i] is not None:
>>>>>>                     newrow[i] = session._merge(
>>>>>>                         attributes.instance_state(newrow[i]),
>>>>>>                         attributes.instance_dict(newrow[i]),
>>>>>>                         load=load,
>>>>>>                         _recursive={},
>>>>>>                         _resolve_conflict_map={},
                           )
       
>>>>>>             result.append(keyed_tuple(newrow))
       
>>>>>>         return frozen_result.with_new_rows(result)
           finally:
>>>>>>         session.autoflush = autoflush
       
       
    2: @util.became_legacy_20(
    1:     ":func:`_orm.merge_result`",
    1:     alternative="The function as well as the method on :class:`_orm.Query` "
           "is superseded by the :func:`_orm.merge_frozen_result` function.",
       )
    1: @util.preload_module("sqlalchemy.orm.context")
    1: def merge_result(
           query: Query[Any],
           iterator: Union[FrozenResult, Iterable[Sequence[Any]], Iterable[object]],
           load: bool = True,
       ) -> Union[FrozenResult, Iterable[Any]]:
           """Merge a result into the given :class:`.Query` object's Session.
       
           See :meth:`_orm.Query.merge_result` for top-level documentation on this
           function.
       
           """
       
>>>>>>     querycontext = util.preloaded.orm_context
       
>>>>>>     session = query.session
>>>>>>     if load:
               # flush current contents if we expect to load data
>>>>>>         session._autoflush()
       
           # TODO: need test coverage and documentation for the FrozenResult
           # use case.
>>>>>>     if isinstance(iterator, FrozenResult):
>>>>>>         frozen_result = iterator
>>>>>>         iterator = iter(frozen_result.data)
           else:
>>>>>>         frozen_result = None
       
>>>>>>     ctx = querycontext.ORMSelectCompileState._create_entities_collection(
>>>>>>         query, legacy=True
           )
       
>>>>>>     autoflush = session.autoflush
>>>>>>     try:
>>>>>>         session.autoflush = False
>>>>>>         single_entity = not frozen_result and len(ctx._entities) == 1
       
>>>>>>         if single_entity:
>>>>>>             if isinstance(ctx._entities[0], querycontext._MapperEntity):
>>>>>>                 result = [
>>>>>>                     session._merge(
>>>>>>                         attributes.instance_state(instance),
>>>>>>                         attributes.instance_dict(instance),
>>>>>>                         load=load,
>>>>>>                         _recursive={},
>>>>>>                         _resolve_conflict_map={},
                           )
>>>>>>                     for instance in iterator
                       ]
                   else:
>>>>>>                 result = list(iterator)
               else:
>>>>>>             mapped_entities = [
>>>>>>                 i
>>>>>>                 for i, e in enumerate(ctx._entities)
>>>>>>                 if isinstance(e, querycontext._MapperEntity)
                   ]
>>>>>>             result = []
>>>>>>             keys = [ent._label_name for ent in ctx._entities]
       
>>>>>>             keyed_tuple = result_tuple(
>>>>>>                 keys, [ent._extra_entities for ent in ctx._entities]
                   )
       
>>>>>>             for row in iterator:
>>>>>>                 newrow = list(row)
>>>>>>                 for i in mapped_entities:
>>>>>>                     if newrow[i] is not None:
>>>>>>                         newrow[i] = session._merge(
>>>>>>                             attributes.instance_state(newrow[i]),
>>>>>>                             attributes.instance_dict(newrow[i]),
>>>>>>                             load=load,
>>>>>>                             _recursive={},
>>>>>>                             _resolve_conflict_map={},
                               )
>>>>>>                 result.append(keyed_tuple(newrow))
       
>>>>>>         if frozen_result:
>>>>>>             return frozen_result.with_new_rows(result)
               else:
>>>>>>             return iter(result)
           finally:
>>>>>>         session.autoflush = autoflush
       
       
    1: def get_from_identity(
           session: Session,
           mapper: Mapper[_O],
           key: _IdentityKeyType[_O],
           passive: PassiveFlag,
       ) -> Union[LoaderCallableStatus, Optional[_O]]:
           """Look up the given key in the given session's identity map,
           check the object for expired state if found.
       
           """
>>>>>>     instance = session.identity_map.get(key)
>>>>>>     if instance is not None:
>>>>>>         state = attributes.instance_state(instance)
       
>>>>>>         if mapper.inherits and not state.mapper.isa(mapper):
>>>>>>             return attributes.PASSIVE_CLASS_MISMATCH
       
               # expired - ensure it still exists
>>>>>>         if state.expired:
>>>>>>             if not passive & attributes.SQL_OK:
                       # TODO: no coverage here
>>>>>>                 return attributes.PASSIVE_NO_RESULT
>>>>>>             elif not passive & attributes.RELATED_OBJECT_OK:
                       # this mode is used within a flush and the instance's
                       # expired state will be checked soon enough, if necessary.
                       # also used by immediateloader for a mutually-dependent
                       # o2m->m2m load, :ticket:`6301`
>>>>>>                 return instance
>>>>>>             try:
>>>>>>                 state._load_expired(state, passive)
>>>>>>             except orm_exc.ObjectDeletedError:
>>>>>>                 session._remove_newly_deleted([state])
>>>>>>                 return None
>>>>>>         return instance
           else:
>>>>>>         return None
       
       
    1: def load_on_ident(
           session: Session,
           statement: Union[Select, FromStatement],
           key: Optional[_IdentityKeyType],
           *,
    1:     load_options: Optional[Sequence[ORMOption]] = None,
    1:     refresh_state: Optional[InstanceState[Any]] = None,
    1:     with_for_update: Optional[ForUpdateArg] = None,
    1:     only_load_props: Optional[Iterable[str]] = None,
    1:     no_autoflush: bool = False,
    1:     bind_arguments: Mapping[str, Any] = util.EMPTY_DICT,
    1:     execution_options: _ExecuteOptions = util.EMPTY_DICT,
    1:     require_pk_cols: bool = False,
    1:     is_user_refresh: bool = False,
       ):
           """Load the given identity key from the database."""
   37:     if key is not None:
   37:         ident = key[1]
   37:         identity_token = key[2]
           else:
>>>>>>         ident = identity_token = None
       
   74:     return load_on_pk_identity(
   37:         session,
   37:         statement,
   37:         ident,
   37:         load_options=load_options,
   37:         refresh_state=refresh_state,
   37:         with_for_update=with_for_update,
   37:         only_load_props=only_load_props,
   37:         identity_token=identity_token,
   37:         no_autoflush=no_autoflush,
   37:         bind_arguments=bind_arguments,
   37:         execution_options=execution_options,
   37:         require_pk_cols=require_pk_cols,
   37:         is_user_refresh=is_user_refresh,
           )
       
       
    1: def load_on_pk_identity(
           session: Session,
           statement: Union[Select, FromStatement],
           primary_key_identity: Optional[Tuple[Any, ...]],
           *,
    1:     load_options: Optional[Sequence[ORMOption]] = None,
    1:     refresh_state: Optional[InstanceState[Any]] = None,
    1:     with_for_update: Optional[ForUpdateArg] = None,
    1:     only_load_props: Optional[Iterable[str]] = None,
    1:     identity_token: Optional[Any] = None,
    1:     no_autoflush: bool = False,
    1:     bind_arguments: Mapping[str, Any] = util.EMPTY_DICT,
    1:     execution_options: _ExecuteOptions = util.EMPTY_DICT,
    1:     require_pk_cols: bool = False,
    1:     is_user_refresh: bool = False,
       ):
           """Load the given primary key identity from the database."""
       
   37:     query = statement
   37:     q = query._clone()
       
   37:     assert not q._is_lambda_element
       
   37:     if load_options is None:
   37:         load_options = QueryContext.default_load_options
       
   37:     if (
   74:         statement._compile_options
   37:         is SelectState.default_select_compile_options
           ):
   37:         compile_options = ORMCompileState.default_compile_options
           else:
>>>>>>         compile_options = statement._compile_options
       
   37:     if primary_key_identity is not None:
   37:         mapper = query._propagate_attrs["plugin_subject"]
       
   37:         (_get_clause, _get_params) = mapper._get_clause
       
               # None present in ident - turn those comparisons
               # into "IS NULL"
   37:         if None in primary_key_identity:
>>>>>>             nones = {
>>>>>>                 _get_params[col].key
>>>>>>                 for col, value in zip(mapper.primary_key, primary_key_identity)
>>>>>>                 if value is None
                   }
       
>>>>>>             _get_clause = sql_util.adapt_criterion_to_null(_get_clause, nones)
       
>>>>>>             if len(nones) == len(primary_key_identity):
>>>>>>                 util.warn(
>>>>>>                     "fully NULL primary key identity cannot load any "
                           "object.  This condition may raise an error in a future "
                           "release."
                       )
       
   37:         q._where_criteria = (
   37:             sql_util._deep_annotate(_get_clause, {"_orm_adapt": True}),
               )
       
  148:         params = {
   37:             _get_params[primary_key].key: id_val
  111:             for id_val, primary_key in zip(
   37:                 primary_key_identity, mapper.primary_key
                   )
               }
           else:
>>>>>>         params = None
       
   37:     if with_for_update is not None:
>>>>>>         version_check = True
>>>>>>         q._for_update_arg = with_for_update
   37:     elif query._for_update_arg is not None:
>>>>>>         version_check = True
>>>>>>         q._for_update_arg = query._for_update_arg
           else:
   37:         version_check = False
       
   37:     if require_pk_cols and only_load_props:
>>>>>>         if not refresh_state:
>>>>>>             raise sa_exc.ArgumentError(
>>>>>>                 "refresh_state is required when require_pk_cols is present"
                   )
       
>>>>>>         refresh_state_prokeys = refresh_state.mapper._primary_key_propkeys
>>>>>>         has_changes = {
>>>>>>             key
>>>>>>             for key in refresh_state_prokeys.difference(only_load_props)
>>>>>>             if refresh_state.attrs[key].history.has_changes()
               }
>>>>>>         if has_changes:
                   # raise if pending pk changes are present.
                   # technically, this could be limited to the case where we have
                   # relationships in the only_load_props collection to be refreshed
                   # also (and only ones that have a secondary eager loader, at that).
                   # however, the error is in place across the board so that behavior
                   # here is easier to predict.   The use case it prevents is one
                   # of mutating PK attrs, leaving them unflushed,
                   # calling session.refresh(), and expecting those attrs to remain
                   # still unflushed.   It seems likely someone doing all those
                   # things would be better off having the PK attributes flushed
                   # to the database before tinkering like that (session.refresh() is
                   # tinkering).
>>>>>>             raise sa_exc.InvalidRequestError(
>>>>>>                 f"Please flush pending primary key changes on "
                       "attributes "
>>>>>>                 f"{has_changes} for mapper {refresh_state.mapper} before "
                       "proceeding with a refresh"
                   )
       
               # overall, the ORM has no internal flow right now for "dont load the
               # primary row of an object at all, but fire off
               # selectinload/subqueryload/immediateload for some relationships".
               # It would probably be a pretty big effort to add such a flow.  So
               # here, the case for #8703 is introduced; user asks to refresh some
               # relationship attributes only which are
               # selectinload/subqueryload/immediateload/ etc. (not joinedload).
               # ORM complains there's no columns in the primary row to load.
               # So here, we just add the PK cols if that
               # case is detected, so that there is a SELECT emitted for the primary
               # row.
               #
               # Let's just state right up front, for this one little case,
               # the ORM here is adding a whole extra SELECT just to satisfy
               # limitations in the internal flow.  This is really not a thing
               # SQLAlchemy finds itself doing like, ever, obviously, we are
               # constantly working to *remove* SELECTs we don't need.   We
               # rationalize this for now based on 1. session.refresh() is not
               # commonly used 2. session.refresh() with only relationship attrs is
               # even less commonly used 3. the SELECT in question is very low
               # latency.
               #
               # to add the flow to not include the SELECT, the quickest way
               # might be to just manufacture a single-row result set to send off to
               # instances(), but we'd have to weave that into context.py and all
               # that.  For 2.0.0, we have enough big changes to navigate for now.
               #
>>>>>>         mp = refresh_state.mapper._props
>>>>>>         for p in only_load_props:
>>>>>>             if mp[p]._is_relationship:
>>>>>>                 only_load_props = refresh_state_prokeys.union(only_load_props)
>>>>>>                 break
       
   37:     if refresh_state and refresh_state.load_options:
>>>>>>         compile_options += {"_current_path": refresh_state.load_path.parent}
>>>>>>         q = q.options(*refresh_state.load_options)
       
   74:     new_compile_options, load_options = _set_get_options(
   37:         compile_options,
   37:         load_options,
   37:         version_check=version_check,
   37:         only_load_props=only_load_props,
   37:         refresh_state=refresh_state,
   37:         identity_token=identity_token,
   37:         is_user_refresh=is_user_refresh,
           )
       
   37:     q._compile_options = new_compile_options
   37:     q._order_by = None
       
   37:     if no_autoflush:
    1:         load_options += {"_autoflush": False}
       
   74:     execution_options = util.EMPTY_DICT.merge_with(
   37:         execution_options, {"_sa_orm_load_options": load_options}
           )
   37:     result = (
   74:         session.execute(
   37:             q,
   37:             params=params,
   37:             execution_options=execution_options,
   37:             bind_arguments=bind_arguments,
               )
               .unique()
               .scalars()
           )
       
   37:     try:
   37:         return result.one()
>>>>>>     except orm_exc.NoResultFound:
>>>>>>         return None
       
       
    1: def _set_get_options(
           compile_opt,
           load_opt,
           populate_existing=None,
           version_check=None,
           only_load_props=None,
           refresh_state=None,
           identity_token=None,
           is_user_refresh=None,
       ):
   37:     compile_options = {}
   37:     load_options = {}
   37:     if version_check:
>>>>>>         load_options["_version_check"] = version_check
   37:     if populate_existing:
>>>>>>         load_options["_populate_existing"] = populate_existing
   37:     if refresh_state:
   37:         load_options["_refresh_state"] = refresh_state
   37:         compile_options["_for_refresh_state"] = True
   37:     if only_load_props:
   36:         compile_options["_only_load_props"] = frozenset(only_load_props)
   37:     if identity_token:
>>>>>>         load_options["_identity_token"] = identity_token
       
   37:     if is_user_refresh:
    1:         load_options["_is_user_refresh"] = is_user_refresh
   37:     if load_options:
   37:         load_opt += load_options
   37:     if compile_options:
   37:         compile_opt += compile_options
       
   37:     return compile_opt, load_opt
       
       
    1: def _setup_entity_query(
           compile_state,
           mapper,
           query_entity,
           path,
           adapter,
           column_collection,
           with_polymorphic=None,
           only_load_props=None,
           polymorphic_discriminator=None,
           **kw,
       ):
   15:     if with_polymorphic:
>>>>>>         poly_properties = mapper._iterate_polymorphic_properties(
>>>>>>             with_polymorphic
               )
           else:
   15:         poly_properties = mapper._polymorphic_properties
       
   15:     quick_populators = {}
       
   15:     path.set(compile_state.attributes, "memoized_setups", quick_populators)
       
           # for the lead entities in the path, e.g. not eager loads, and
           # assuming a user-passed aliased class, e.g. not a from_self() or any
           # implicit aliasing, don't add columns to the SELECT that aren't
           # in the thing that's aliased.
   15:     check_for_adapt = adapter and len(path) == 1 and path[-1].is_aliased_class
       
  346:     for value in poly_properties:
  331:         if only_load_props and value.key not in only_load_props:
    2:             continue
 1316:         value.setup(
  329:             compile_state,
  329:             query_entity,
  329:             path,
  329:             adapter,
  329:             only_load_props=only_load_props,
  329:             column_collection=column_collection,
  329:             memoized_populators=quick_populators,
  329:             check_for_adapt=check_for_adapt,
  329:             **kw,
               )
       
   15:     if (
   15:         polymorphic_discriminator is not None
>>>>>>         and polymorphic_discriminator is not mapper.polymorphic_on
           ):
>>>>>>         if adapter:
>>>>>>             pd = adapter.columns[polymorphic_discriminator]
               else:
>>>>>>             pd = polymorphic_discriminator
>>>>>>         column_collection.append(pd)
       
       
    1: def _warn_for_runid_changed(state):
>>>>>>     util.warn(
>>>>>>         "Loading context for %s has changed within a load/refresh "
               "handler, suggesting a row refresh operation took place. If this "
               "event handler is expected to be "
               "emitting row refresh operations within an existing load or refresh "
               "operation, set restore_load_context=True when establishing the "
               "listener to ensure the context remains unchanged when the event "
>>>>>>         "handler completes." % (state_str(state),)
           )
       
       
    1: def _instance_processor(
           query_entity,
           mapper,
           context,
           result,
           path,
           adapter,
           only_load_props=None,
           refresh_state=None,
           polymorphic_discriminator=None,
           _polymorphic_from=None,
       ):
           """Produce a mapper level row processor callable
           which processes rows into mapped instances."""
       
           # note that this method, most of which exists in a closure
           # called _instance(), resists being broken out, as
           # attempts to do so tend to add significant function
           # call overhead.  _instance() is the most
           # performance-critical section in the whole ORM.
       
   84:     identity_class = mapper._identity_class
   84:     compile_state = context.compile_state
       
           # look for "row getter" functions that have been assigned along
           # with the compile state that were cached from a previous load.
           # these are operator.itemgetter() objects that each will extract a
           # particular column from each row.
       
   84:     getter_key = ("getters", mapper)
   84:     getters = path.get(compile_state.attributes, getter_key, None)
       
   84:     if getters is None:
               # no getters, so go through a list of attributes we are loading for,
               # and the ones that are column based will have already put information
               # for us in another collection "memoized_setups", which represents the
               # output of the LoaderStrategy.setup_query() method.  We can just as
               # easily call LoaderStrategy.create_row_processor for each, but by
               # getting it all at once from setup_query we save another method call
               # per attribute.
   14:         props = mapper._prop_set
   14:         if only_load_props is not None:
  112:             props = props.intersection(
  104:                 mapper._props[k] for k in only_load_props
                   )
       
   28:         quick_populators = path.get(
   14:             context.attributes, "memoized_setups", EMPTY_DICT
               )
       
   14:         todo = []
   14:         cached_populators = {
   14:             "new": [],
   14:             "quick": [],
   14:             "deferred": [],
   14:             "expire": [],
   14:             "existing": [],
   14:             "eager": [],
               }
       
   14:         if refresh_state is None:
                   # we can also get the "primary key" tuple getter function
    9:             pk_cols = mapper.primary_key
       
    9:             if adapter:
>>>>>>                 pk_cols = [adapter.columns[c] for c in pk_cols]
    9:             primary_key_getter = result._tuple_getter(pk_cols)
               else:
    5:             primary_key_getter = None
       
   14:         getters = {
   14:             "cached_populators": cached_populators,
   14:             "todo": todo,
   14:             "primary_key_getter": primary_key_getter,
               }
  337:         for prop in props:
  323:             if prop in quick_populators:
                       # this is an inlined path just for column-based attributes.
  224:                 col = quick_populators[prop]
  224:                 if col is _DEFER_FOR_STATE:
>>>>>>                     cached_populators["new"].append(
>>>>>>                         (prop.key, prop._deferred_column_loader)
                           )
  224:                 elif col is _SET_DEFERRED_EXPIRED:
                           # note that in this path, we are no longer
                           # searching in the result to see if the column might
                           # be present in some unexpected way.
>>>>>>                     cached_populators["expire"].append((prop.key, False))
  224:                 elif col is _RAISE_FOR_STATE:
>>>>>>                     cached_populators["new"].append(
>>>>>>                         (prop.key, prop._raise_column_loader)
                           )
                       else:
  224:                     getter = None
  224:                     if adapter:
                               # this logic had been removed for all 1.4 releases
                               # up until 1.4.18; the adapter here is particularly
                               # the compound eager adapter which isn't accommodated
                               # in the quick_populators right now.  The "fallback"
                               # logic below instead took over in many more cases
                               # until issue #6596 was identified.
       
                               # note there is still an issue where this codepath
                               # produces no "getter" for cases where a joined-inh
                               # mapping includes a labeled column property, meaning
                               # KeyError is caught internally and we fall back to
                               # _getter(col), which works anyway.   The adapter
                               # here for joined inh without any aliasing might not
                               # be useful.  Tests which see this include
                               # test.orm.inheritance.test_basic ->
                               # EagerTargetingTest.test_adapt_stringency
                               # OptimizedLoadTest.test_column_expression_joined
                               # PolymorphicOnNotLocalTest.test_polymorphic_on_column_prop  # noqa: E501
                               #
       
>>>>>>                         adapted_col = adapter.columns[col]
>>>>>>                         if adapted_col is not None:
>>>>>>                             getter = result._getter(adapted_col, False)
  224:                     if not getter:
  224:                         getter = result._getter(col, False)
  224:                     if getter:
  224:                         cached_populators["quick"].append((prop.key, getter))
                           else:
                               # fall back to the ColumnProperty itself, which
                               # will iterate through all of its columns
                               # to see if one fits
>>>>>>                         prop.create_row_processor(
>>>>>>                             context,
>>>>>>                             query_entity,
>>>>>>                             path,
>>>>>>                             mapper,
>>>>>>                             result,
>>>>>>                             adapter,
>>>>>>                             cached_populators,
                               )
                   else:
                       # loader strategies like subqueryload, selectinload,
                       # joinedload, basically relationships, these need to interact
                       # with the context each time to work correctly.
   99:                 todo.append(prop)
       
   14:         path.set(compile_state.attributes, getter_key, getters)
       
   84:     cached_populators = getters["cached_populators"]
       
  672:     populators = {key: list(value) for key, value in cached_populators.items()}
 1470:     for prop in getters["todo"]:
 2772:         prop.create_row_processor(
 1386:             context, query_entity, path, mapper, result, adapter, populators
               )
       
   84:     propagated_loader_options = context.propagated_loader_options
   84:     load_path = (
   84:         context.compile_state.current_path + path
   84:         if context.compile_state.current_path.path
   84:         else path
           )
       
   84:     session_identity_map = context.session.identity_map
       
   84:     populate_existing = context.populate_existing or mapper.always_refresh
   84:     load_evt = bool(mapper.class_manager.dispatch.load)
   84:     refresh_evt = bool(mapper.class_manager.dispatch.refresh)
   84:     persistent_evt = bool(context.session.dispatch.loaded_as_persistent)
   84:     if persistent_evt:
>>>>>>         loaded_as_persistent = context.session.dispatch.loaded_as_persistent
   84:     instance_state = attributes.instance_state
   84:     instance_dict = attributes.instance_dict
   84:     session_id = context.session.hash_key
   84:     runid = context.runid
   84:     identity_token = context.identity_token
       
   84:     version_check = context.version_check
   84:     if version_check:
>>>>>>         version_id_col = mapper.version_id_col
>>>>>>         if version_id_col is not None:
>>>>>>             if adapter:
>>>>>>                 version_id_col = adapter.columns[version_id_col]
>>>>>>             version_id_getter = result._getter(version_id_col)
               else:
>>>>>>             version_id_getter = None
       
   84:     if not refresh_state and _polymorphic_from is not None:
>>>>>>         key = ("loader", path.path)
       
>>>>>>         if key in context.attributes and context.attributes[key].strategy == (
                   ("selectinload_polymorphic", True),
               ):
>>>>>>             option_entities = context.attributes[key].local_opts["entities"]
               else:
>>>>>>             option_entities = None
>>>>>>         selectin_load_via = mapper._should_selectin_load(
>>>>>>             option_entities,
>>>>>>             _polymorphic_from,
               )
       
>>>>>>         if selectin_load_via and selectin_load_via is not _polymorphic_from:
                   # only_load_props goes w/ refresh_state only, and in a refresh
                   # we are a single row query for the exact entity; polymorphic
                   # loading does not apply
>>>>>>             assert only_load_props is None
       
>>>>>>             callable_ = _load_subclass_via_in(
>>>>>>                 context,
>>>>>>                 path,
>>>>>>                 selectin_load_via,
>>>>>>                 _polymorphic_from,
>>>>>>                 option_entities,
                   )
>>>>>>             PostLoad.callable_for_path(
>>>>>>                 context,
>>>>>>                 load_path,
>>>>>>                 selectin_load_via.mapper,
>>>>>>                 selectin_load_via,
>>>>>>                 callable_,
>>>>>>                 selectin_load_via,
                   )
       
   84:     post_load = PostLoad.for_context(context, load_path, only_load_props)
       
   84:     if refresh_state:
   37:         refresh_identity_key = refresh_state.key
   37:         if refresh_identity_key is None:
                   # super-rare condition; a refresh is being called
                   # on a non-instance-key instance; this is meant to only
                   # occur within a flush()
>>>>>>             refresh_identity_key = mapper._identity_key_from_state(
>>>>>>                 refresh_state
                   )
           else:
   47:         refresh_identity_key = None
       
   47:         primary_key_getter = getters["primary_key_getter"]
       
   84:     if mapper.allow_partial_pks:
   84:         is_not_primary_key = _none_set.issuperset
           else:
>>>>>>         is_not_primary_key = _none_set.intersection
       
   84:     def _instance(row):
               # determine the state that we'll be populating
   79:         if refresh_identity_key:
                   # fixed state that we're refreshing
   37:             state = refresh_state
   37:             instance = state.obj()
   37:             dict_ = instance_dict(instance)
   37:             isnew = state.runid != runid
   37:             currentload = True
   37:             loaded_instance = False
               else:
                   # look at the row, see if that identity is in the
                   # session, or we have to create a new one
   42:             identitykey = (
   42:                 identity_class,
   42:                 primary_key_getter(row),
   42:                 identity_token,
                   )
       
   42:             instance = session_identity_map.get(identitykey)
       
   42:             if instance is not None:
                       # existing instance
   39:                 state = instance_state(instance)
   39:                 dict_ = instance_dict(instance)
       
   39:                 isnew = state.runid != runid
   39:                 currentload = not isnew
   39:                 loaded_instance = False
       
   39:                 if version_check and version_id_getter and not currentload:
>>>>>>                     _validate_version_id(
>>>>>>                         mapper, state, dict_, row, version_id_getter
                           )
       
                   else:
                       # create a new instance
       
                       # check for non-NULL values in the primary key columns,
                       # else no entity is returned for the row
    3:                 if is_not_primary_key(identitykey[1]):
>>>>>>                     return None
       
    3:                 isnew = True
    3:                 currentload = True
    3:                 loaded_instance = True
       
    3:                 instance = mapper.class_manager.new_instance()
       
    3:                 dict_ = instance_dict(instance)
    3:                 state = instance_state(instance)
    3:                 state.key = identitykey
    3:                 state.identity_token = identity_token
       
                       # attach instance to session.
    3:                 state.session_id = session_id
    3:                 session_identity_map._add_unpresent(state, identitykey)
       
   79:         effective_populate_existing = populate_existing
   79:         if refresh_state is state:
   37:             effective_populate_existing = True
       
               # populate.  this looks at whether this state is new
               # for this load or was existing, and whether or not this
               # row is the first row with this identity.
   79:         if currentload or effective_populate_existing:
                   # full population routines.  Objects here are either
                   # just created, or we are doing a populate_existing
       
                   # be conservative about setting load_path when populate_existing
                   # is in effect; want to maintain options from the original
                   # load.  see test_expire->test_refresh_maintains_deferred_options
  120:             if isnew and (
   80:                 propagated_loader_options or not effective_populate_existing
                   ):
    3:                 state.load_options = propagated_loader_options
    3:                 state.load_path = load_path
       
   80:             _populate_full(
   40:                 context,
   40:                 row,
   40:                 state,
   40:                 dict_,
   40:                 isnew,
   40:                 load_path,
   40:                 loaded_instance,
   40:                 effective_populate_existing,
   40:                 populators,
                   )
       
   40:             if isnew:
                       # state.runid should be equal to context.runid / runid
                       # here, however for event checks we are being more conservative
                       # and checking against existing run id
                       # assert state.runid == runid
       
   40:                 existing_runid = state.runid
       
   40:                 if loaded_instance:
    3:                     if load_evt:
>>>>>>                         state.manager.dispatch.load(state, context)
>>>>>>                         if state.runid != existing_runid:
>>>>>>                             _warn_for_runid_changed(state)
    3:                     if persistent_evt:
>>>>>>                         loaded_as_persistent(context.session, state)
>>>>>>                         if state.runid != existing_runid:
>>>>>>                             _warn_for_runid_changed(state)
   37:                 elif refresh_evt:
>>>>>>                     state.manager.dispatch.refresh(
>>>>>>                         state, context, only_load_props
                           )
>>>>>>                     if state.runid != runid:
>>>>>>                         _warn_for_runid_changed(state)
       
   40:                 if effective_populate_existing or state.modified:
   37:                     if refresh_state and only_load_props:
   36:                         state._commit(dict_, only_load_props)
                           else:
    1:                         state._commit_all(dict_, session_identity_map)
       
   40:             if post_load:
>>>>>>                 post_load.add_state(state, True)
       
               else:
                   # partial population routines, for objects that were already
                   # in the Session, but a row matches them; apply eager loaders
                   # on existing objects, etc.
   39:             unloaded = state.unloaded
   39:             isnew = state not in context.partials
       
   39:             if not isnew or unloaded or populators["eager"]:
                       # state is having a partial set of its attributes
                       # refreshed.  Populate those attributes,
                       # and add to the "context.partials" collection.
       
   70:                 to_load = _populate_partial(
   35:                     context,
   35:                     row,
   35:                     state,
   35:                     dict_,
   35:                     isnew,
   35:                     load_path,
   35:                     unloaded,
   35:                     populators,
                       )
       
   35:                 if isnew:
   35:                     if refresh_evt:
>>>>>>                         existing_runid = state.runid
>>>>>>                         state.manager.dispatch.refresh(state, context, to_load)
>>>>>>                         if state.runid != existing_runid:
>>>>>>                             _warn_for_runid_changed(state)
       
   35:                     state._commit(dict_, to_load)
       
   39:             if post_load and context.invoke_all_eagers:
>>>>>>                 post_load.add_state(state, False)
       
   79:         return instance
       
   84:     if mapper.polymorphic_map and not _polymorphic_from and not refresh_state:
               # if we are doing polymorphic, dispatch to a different _instance()
               # method specific to the subclass mapper
>>>>>>         def ensure_no_pk(row):
>>>>>>             identitykey = (
>>>>>>                 identity_class,
>>>>>>                 primary_key_getter(row),
>>>>>>                 identity_token,
                   )
>>>>>>             if not is_not_primary_key(identitykey[1]):
>>>>>>                 return identitykey
                   else:
>>>>>>                 return None
       
>>>>>>         _instance = _decorate_polymorphic_switch(
>>>>>>             _instance,
>>>>>>             context,
>>>>>>             query_entity,
>>>>>>             mapper,
>>>>>>             result,
>>>>>>             path,
>>>>>>             polymorphic_discriminator,
>>>>>>             adapter,
>>>>>>             ensure_no_pk,
               )
       
   84:     return _instance
       
       
    1: def _load_subclass_via_in(
           context, path, entity, polymorphic_from, option_entities
       ):
>>>>>>     mapper = entity.mapper
       
           # TODO: polymorphic_from seems to be a Mapper in all cases.
           # this is likely not needed, but as we dont have typing in loading.py
           # yet, err on the safe side
>>>>>>     polymorphic_from_mapper = polymorphic_from.mapper
>>>>>>     not_against_basemost = polymorphic_from_mapper.inherits is not None
       
>>>>>>     zero_idx = len(mapper.base_mapper.primary_key) == 1
       
>>>>>>     if entity.is_aliased_class or not_against_basemost:
>>>>>>         q, enable_opt, disable_opt = mapper._subclass_load_via_in(
>>>>>>             entity, polymorphic_from
               )
           else:
>>>>>>         q, enable_opt, disable_opt = mapper._subclass_load_via_in_mapper
       
>>>>>>     def do_load(context, path, states, load_only, effective_entity):
>>>>>>         if not option_entities:
                   # filter out states for those that would have selectinloaded
                   # from another loader
                   # TODO: we are currently ignoring the case where the
                   # "selectin_polymorphic" option is used, as this is much more
                   # complex / specific / very uncommon API use
>>>>>>             states = [
>>>>>>                 (s, v)
>>>>>>                 for s, v in states
>>>>>>                 if s.mapper._would_selectin_load_only_from_given_mapper(mapper)
                   ]
       
>>>>>>             if not states:
>>>>>>                 return
       
>>>>>>         orig_query = context.query
       
>>>>>>         if path.parent:
>>>>>>             enable_opt_lcl = enable_opt._prepend_path(path)
>>>>>>             disable_opt_lcl = disable_opt._prepend_path(path)
               else:
>>>>>>             enable_opt_lcl = enable_opt
>>>>>>             disable_opt_lcl = disable_opt
>>>>>>         options = (
>>>>>>             (enable_opt_lcl,) + orig_query._with_options + (disable_opt_lcl,)
               )
       
>>>>>>         q2 = q.options(*options)
       
>>>>>>         q2._compile_options = context.compile_state.default_compile_options
>>>>>>         q2._compile_options += {"_current_path": path.parent}
       
>>>>>>         if context.populate_existing:
>>>>>>             q2 = q2.execution_options(populate_existing=True)
       
>>>>>>         context.session.execute(
>>>>>>             q2,
>>>>>>             dict(
>>>>>>                 primary_keys=[
>>>>>>                     state.key[1][0] if zero_idx else state.key[1]
>>>>>>                     for state, load_attrs in states
                       ]
                   ),
               ).unique().scalars().all()
       
>>>>>>     return do_load
       
       
    1: def _populate_full(
           context,
           row,
           state,
           dict_,
           isnew,
           load_path,
           loaded_instance,
           populate_existing,
           populators,
       ):
   40:     if isnew:
               # first time we are seeing a row with this identity.
   40:         state.runid = context.runid
       
 1095:         for key, getter in populators["quick"]:
 1055:             dict_[key] = getter(row)
   40:         if populate_existing:
   37:             for key, set_callable in populators["expire"]:
>>>>>>                 dict_.pop(key, None)
>>>>>>                 if set_callable:
>>>>>>                     state.expired_attributes.add(key)
               else:
    3:             for key, set_callable in populators["expire"]:
>>>>>>                 if set_callable:
>>>>>>                     state.expired_attributes.add(key)
       
   40:         for key, populator in populators["new"]:
>>>>>>             populator(state, dict_, row)
       
>>>>>>     elif load_path != state.load_path:
               # new load path, e.g. object is present in more than one
               # column position in a series of rows
>>>>>>         state.load_path = load_path
       
               # if we have data, and the data isn't in the dict, OK, let's put
               # it in.
>>>>>>         for key, getter in populators["quick"]:
>>>>>>             if key not in dict_:
>>>>>>                 dict_[key] = getter(row)
       
               # otherwise treat like an "already seen" row
>>>>>>         for key, populator in populators["existing"]:
>>>>>>             populator(state, dict_, row)
                   # TODO:  allow "existing" populator to know this is
                   # a new path for the state:
                   # populator(state, dict_, row, new_path=True)
       
           else:
               # have already seen rows with this identity in this same path.
>>>>>>         for key, populator in populators["existing"]:
>>>>>>             populator(state, dict_, row)
       
                   # TODO: same path
                   # populator(state, dict_, row, new_path=False)
       
       
    1: def _populate_partial(
           context, row, state, dict_, isnew, load_path, unloaded, populators
       ):
   35:     if not isnew:
>>>>>>         if unloaded:
                   # extra pass, see #8166
>>>>>>             for key, getter in populators["quick"]:
>>>>>>                 if key in unloaded:
>>>>>>                     dict_[key] = getter(row)
       
>>>>>>         to_load = context.partials[state]
>>>>>>         for key, populator in populators["existing"]:
>>>>>>             if key in to_load:
>>>>>>                 populator(state, dict_, row)
           else:
   35:         to_load = unloaded
   35:         context.partials[state] = to_load
       
 1145:         for key, getter in populators["quick"]:
 1110:             if key in to_load:
 1110:                 dict_[key] = getter(row)
   35:         for key, set_callable in populators["expire"]:
>>>>>>             if key in to_load:
>>>>>>                 dict_.pop(key, None)
>>>>>>                 if set_callable:
>>>>>>                     state.expired_attributes.add(key)
   35:         for key, populator in populators["new"]:
>>>>>>             if key in to_load:
>>>>>>                 populator(state, dict_, row)
       
   35:     for key, populator in populators["eager"]:
>>>>>>         if key not in unloaded:
>>>>>>             populator(state, dict_, row)
       
   35:     return to_load
       
       
    1: def _validate_version_id(mapper, state, dict_, row, getter):
>>>>>>     if mapper._get_state_attr_by_column(
>>>>>>         state, dict_, mapper.version_id_col
>>>>>>     ) != getter(row):
>>>>>>         raise orm_exc.StaleDataError(
>>>>>>             "Instance '%s' has version id '%s' which "
                   "does not match database-loaded version id '%s'."
>>>>>>             % (
>>>>>>                 state_str(state),
>>>>>>                 mapper._get_state_attr_by_column(
>>>>>>                     state, dict_, mapper.version_id_col
                       ),
>>>>>>                 getter(row),
                   )
               )
       
       
    1: def _decorate_polymorphic_switch(
           instance_fn,
           context,
           query_entity,
           mapper,
           result,
           path,
           polymorphic_discriminator,
           adapter,
           ensure_no_pk,
       ):
>>>>>>     if polymorphic_discriminator is not None:
>>>>>>         polymorphic_on = polymorphic_discriminator
           else:
>>>>>>         polymorphic_on = mapper.polymorphic_on
>>>>>>     if polymorphic_on is None:
>>>>>>         return instance_fn
       
>>>>>>     if adapter:
>>>>>>         polymorphic_on = adapter.columns[polymorphic_on]
       
>>>>>>     def configure_subclass_mapper(discriminator):
>>>>>>         try:
>>>>>>             sub_mapper = mapper.polymorphic_map[discriminator]
>>>>>>         except KeyError:
>>>>>>             raise AssertionError(
>>>>>>                 "No such polymorphic_identity %r is defined" % discriminator
                   )
               else:
>>>>>>             if sub_mapper is mapper:
>>>>>>                 return None
>>>>>>             elif not sub_mapper.isa(mapper):
>>>>>>                 return False
       
>>>>>>             return _instance_processor(
>>>>>>                 query_entity,
>>>>>>                 sub_mapper,
>>>>>>                 context,
>>>>>>                 result,
>>>>>>                 path,
>>>>>>                 adapter,
>>>>>>                 _polymorphic_from=mapper,
                   )
       
>>>>>>     polymorphic_instances = util.PopulateDict(configure_subclass_mapper)
       
>>>>>>     getter = result._getter(polymorphic_on)
       
>>>>>>     def polymorphic_instance(row):
>>>>>>         discriminator = getter(row)
>>>>>>         if discriminator is not None:
>>>>>>             _instance = polymorphic_instances[discriminator]
>>>>>>             if _instance:
>>>>>>                 return _instance(row)
>>>>>>             elif _instance is False:
>>>>>>                 identitykey = ensure_no_pk(row)
       
>>>>>>                 if identitykey:
>>>>>>                     raise sa_exc.InvalidRequestError(
>>>>>>                         "Row with identity key %s can't be loaded into an "
                               "object; the polymorphic discriminator column '%s' "
                               "refers to %s, which is not a sub-mapper of "
                               "the requested %s"
>>>>>>                         % (
>>>>>>                             identitykey,
>>>>>>                             polymorphic_on,
>>>>>>                             mapper.polymorphic_map[discriminator],
>>>>>>                             mapper,
                               )
                           )
                       else:
>>>>>>                     return None
                   else:
>>>>>>                 return instance_fn(row)
               else:
>>>>>>             identitykey = ensure_no_pk(row)
       
>>>>>>             if identitykey:
>>>>>>                 raise sa_exc.InvalidRequestError(
>>>>>>                     "Row with identity key %s can't be loaded into an "
                           "object; the polymorphic discriminator column '%s' is "
>>>>>>                     "NULL" % (identitykey, polymorphic_on)
                       )
                   else:
>>>>>>                 return None
       
>>>>>>     return polymorphic_instance
       
       
    2: class PostLoad:
    1:     """Track loaders and states for "post load" operations."""
       
    1:     __slots__ = "loaders", "states", "load_keys"
       
    1:     def __init__(self):
>>>>>>         self.loaders = {}
>>>>>>         self.states = util.OrderedDict()
>>>>>>         self.load_keys = None
       
    1:     def add_state(self, state, overwrite):
               # the states for a polymorphic load here are all shared
               # within a single PostLoad object among multiple subtypes.
               # Filtering of callables on a per-subclass basis needs to be done at
               # the invocation level
>>>>>>         self.states[state] = overwrite
       
    1:     def invoke(self, context, path):
>>>>>>         if not self.states:
>>>>>>             return
>>>>>>         path = path_registry.PathRegistry.coerce(path)
>>>>>>         for (
>>>>>>             effective_context,
>>>>>>             token,
>>>>>>             limit_to_mapper,
>>>>>>             loader,
>>>>>>             arg,
>>>>>>             kw,
>>>>>>         ) in self.loaders.values():
>>>>>>             states = [
>>>>>>                 (state, overwrite)
>>>>>>                 for state, overwrite in self.states.items()
>>>>>>                 if state.manager.mapper.isa(limit_to_mapper)
                   ]
>>>>>>             if states:
>>>>>>                 loader(
>>>>>>                     effective_context, path, states, self.load_keys, *arg, **kw
                       )
>>>>>>         self.states.clear()
       
    1:     @classmethod
    1:     def for_context(cls, context, path, only_load_props):
   84:         pl = context.post_load_paths.get(path.path)
   84:         if pl is not None and only_load_props:
>>>>>>             pl.load_keys = only_load_props
   84:         return pl
       
    1:     @classmethod
    1:     def path_exists(self, context, path, key):
>>>>>>         return (
>>>>>>             path.path in context.post_load_paths
>>>>>>             and key in context.post_load_paths[path.path].loaders
               )
       
    1:     @classmethod
    1:     def callable_for_path(
               cls, context, path, limit_to_mapper, token, loader_callable, *arg, **kw
           ):
>>>>>>         if path.path in context.post_load_paths:
>>>>>>             pl = context.post_load_paths[path.path]
               else:
>>>>>>             pl = context.post_load_paths[path.path] = PostLoad()
>>>>>>         pl.loaders[token] = (
>>>>>>             context,
>>>>>>             token,
>>>>>>             limit_to_mapper,
>>>>>>             loader_callable,
>>>>>>             arg,
>>>>>>             kw,
               )
       
       
    1: def load_scalar_attributes(mapper, state, attribute_names, passive):
           """initiate a column-based attribute refresh operation."""
       
           # assert mapper is _state_mapper(state)
   36:     session = state.session
   36:     if not session:
>>>>>>         raise orm_exc.DetachedInstanceError(
>>>>>>             "Instance %s is not bound to a Session; "
>>>>>>             "attribute refresh operation cannot proceed" % (state_str(state))
               )
       
   36:     no_autoflush = bool(passive & attributes.NO_AUTOFLUSH)
       
           # in the case of inheritance, particularly concrete and abstract
           # concrete inheritance, the class manager might have some keys
           # of attributes on the superclass that we didn't actually map.
           # These could be mapped as "concrete, don't load" or could be completely
           # excluded from the mapping and we know nothing about them.  Filter them
           # here to prevent them from coming through.
   36:     if attribute_names:
   36:         attribute_names = attribute_names.intersection(mapper.attrs.keys())
       
   36:     if mapper.inherits and not mapper.concrete:
               # load based on committed attributes in the object, formed into
               # a truncated SELECT that only includes relevant tables.  does not
               # currently use state.key
>>>>>>         statement = mapper._optimized_get_statement(state, attribute_names)
>>>>>>         if statement is not None:
                   # undefer() isn't needed here because statement has the
                   # columns needed already, this implicitly undefers that column
>>>>>>             stmt = FromStatement(mapper, statement)
       
>>>>>>             return load_on_ident(
>>>>>>                 session,
>>>>>>                 stmt,
>>>>>>                 None,
>>>>>>                 only_load_props=attribute_names,
>>>>>>                 refresh_state=state,
>>>>>>                 no_autoflush=no_autoflush,
                   )
       
           # normal load, use state.key as the identity to SELECT
   36:     has_key = bool(state.key)
       
   36:     if has_key:
   36:         identity_key = state.key
           else:
               # this codepath is rare - only valid when inside a flush, and the
               # object is becoming persistent but hasn't yet been assigned
               # an identity_key.
               # check here to ensure we have the attrs we need.
>>>>>>         pk_attrs = [
>>>>>>             mapper._columntoproperty[col].key for col in mapper.primary_key
               ]
>>>>>>         if state.expired_attributes.intersection(pk_attrs):
>>>>>>             raise sa_exc.InvalidRequestError(
>>>>>>                 "Instance %s cannot be refreshed - it's not "
                       " persistent and does not "
>>>>>>                 "contain a full primary key." % state_str(state)
                   )
>>>>>>         identity_key = mapper._identity_key_from_state(state)
       
   72:     if (
   36:         _none_set.issubset(identity_key) and not mapper.allow_partial_pks
   36:     ) or _none_set.issuperset(identity_key):
>>>>>>         util.warn_limited(
>>>>>>             "Instance %s to be refreshed doesn't "
                   "contain a full primary key - can't be refreshed "
                   "(and shouldn't be expired, either).",
>>>>>>             state_str(state),
               )
>>>>>>         return
       
   72:     result = load_on_ident(
   36:         session,
   36:         select(mapper).set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL),
   36:         identity_key,
   36:         refresh_state=state,
   36:         only_load_props=attribute_names,
   36:         no_autoflush=no_autoflush,
           )
       
           # if instance is pending, a refresh operation
           # may not complete (even if PK attributes are assigned)
   36:     if has_key and result is None:
>>>>>>         raise orm_exc.ObjectDeletedError(state)
