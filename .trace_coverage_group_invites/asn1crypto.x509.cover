       # coding: utf-8
       
    1: """
       ASN.1 type classes for X.509 certificates. Exports the following items:
       
        - Attributes()
        - Certificate()
        - Extensions()
        - GeneralName()
        - GeneralNames()
        - Name()
       
       Other type classes are defined that help compose the types listed above.
       """
       
    1: from __future__ import unicode_literals, division, absolute_import, print_function
       
    1: from contextlib import contextmanager
    1: from encodings import idna  # noqa
    1: import hashlib
    1: import re
    1: import socket
    1: import stringprep
    1: import sys
    1: import unicodedata
       
    1: from ._errors import unwrap
    1: from ._iri import iri_to_uri, uri_to_iri
    1: from ._ordereddict import OrderedDict
    1: from ._types import type_name, str_cls, bytes_to_list
    1: from .algos import AlgorithmIdentifier, AnyAlgorithmIdentifier, DigestAlgorithm, SignedDigestAlgorithm
    1: from .core import (
           Any,
           BitString,
           BMPString,
           Boolean,
           Choice,
           Concat,
           Enumerated,
           GeneralizedTime,
           GeneralString,
           IA5String,
           Integer,
           Null,
           NumericString,
           ObjectIdentifier,
           OctetBitString,
           OctetString,
           ParsableOctetString,
           PrintableString,
           Sequence,
           SequenceOf,
           Set,
           SetOf,
           TeletexString,
           UniversalString,
           UTCTime,
           UTF8String,
           VisibleString,
           VOID,
       )
    1: from .keys import PublicKeyInfo
    1: from .util import int_to_bytes, int_from_bytes, inet_ntop, inet_pton
       
       
       # The structures in this file are taken from https://tools.ietf.org/html/rfc5280
       # and a few other supplementary sources, mostly due to extra supported
       # extension and name OIDs
       
       
    2: class DNSName(IA5String):
       
    1:     _encoding = 'idna'
    1:     _bad_tag = (12, 19)
       
    1:     def __ne__(self, other):
>>>>>>         return not self == other
       
    1:     def __eq__(self, other):
               """
               Equality as defined by https://tools.ietf.org/html/rfc5280#section-7.2
       
               :param other:
                   Another DNSName object
       
               :return:
                   A boolean
               """
       
>>>>>>         if not isinstance(other, DNSName):
>>>>>>             return False
       
>>>>>>         return self.__unicode__().lower() == other.__unicode__().lower()
       
    1:     def set(self, value):
               """
               Sets the value of the DNS name
       
               :param value:
                   A unicode string
               """
       
>>>>>>         if not isinstance(value, str_cls):
>>>>>>             raise TypeError(unwrap(
>>>>>>                 '''
                       %s value must be a unicode string, not %s
                       ''',
>>>>>>                 type_name(self),
>>>>>>                 type_name(value)
                   ))
       
>>>>>>         if value.startswith('.'):
>>>>>>             encoded_value = b'.' + value[1:].encode(self._encoding)
               else:
>>>>>>             encoded_value = value.encode(self._encoding)
       
>>>>>>         self._unicode = value
>>>>>>         self.contents = encoded_value
>>>>>>         self._header = None
>>>>>>         if self._trailer != b'':
>>>>>>             self._trailer = b''
       
       
    2: class URI(IA5String):
       
    1:     def set(self, value):
               """
               Sets the value of the string
       
               :param value:
                   A unicode string
               """
       
>>>>>>         if not isinstance(value, str_cls):
>>>>>>             raise TypeError(unwrap(
>>>>>>                 '''
                       %s value must be a unicode string, not %s
                       ''',
>>>>>>                 type_name(self),
>>>>>>                 type_name(value)
                   ))
       
>>>>>>         self._unicode = value
>>>>>>         self.contents = iri_to_uri(value)
>>>>>>         self._header = None
>>>>>>         if self._trailer != b'':
>>>>>>             self._trailer = b''
       
    1:     def __ne__(self, other):
>>>>>>         return not self == other
       
    1:     def __eq__(self, other):
               """
               Equality as defined by https://tools.ietf.org/html/rfc5280#section-7.4
       
               :param other:
                   Another URI object
       
               :return:
                   A boolean
               """
       
>>>>>>         if not isinstance(other, URI):
>>>>>>             return False
       
>>>>>>         return iri_to_uri(self.native, True) == iri_to_uri(other.native, True)
       
    1:     def __unicode__(self):
               """
               :return:
                   A unicode string
               """
       
>>>>>>         if self.contents is None:
>>>>>>             return ''
>>>>>>         if self._unicode is None:
>>>>>>             self._unicode = uri_to_iri(self._merge_chunks())
>>>>>>         return self._unicode
       
       
    2: class EmailAddress(IA5String):
       
    1:     _contents = None
       
           # If the value has gone through the .set() method, thus normalizing it
    1:     _normalized = False
       
           # In the wild we've seen this encoded as a UTF8String and PrintableString
    1:     _bad_tag = (12, 19)
       
    1:     @property
    1:     def contents(self):
               """
               :return:
                   A byte string of the DER-encoded contents of the sequence
               """
       
>>>>>>         return self._contents
       
    1:     @contents.setter
    1:     def contents(self, value):
               """
               :param value:
                   A byte string of the DER-encoded contents of the sequence
               """
       
>>>>>>         self._normalized = False
>>>>>>         self._contents = value
       
    1:     def set(self, value):
               """
               Sets the value of the string
       
               :param value:
                   A unicode string
               """
       
>>>>>>         if not isinstance(value, str_cls):
>>>>>>             raise TypeError(unwrap(
>>>>>>                 '''
                       %s value must be a unicode string, not %s
                       ''',
>>>>>>                 type_name(self),
>>>>>>                 type_name(value)
                   ))
       
>>>>>>         if value.find('@') != -1:
>>>>>>             mailbox, hostname = value.rsplit('@', 1)
>>>>>>             encoded_value = mailbox.encode('ascii') + b'@' + hostname.encode('idna')
               else:
>>>>>>             encoded_value = value.encode('ascii')
       
>>>>>>         self._normalized = True
>>>>>>         self._unicode = value
>>>>>>         self.contents = encoded_value
>>>>>>         self._header = None
>>>>>>         if self._trailer != b'':
>>>>>>             self._trailer = b''
       
    1:     def __unicode__(self):
               """
               :return:
                   A unicode string
               """
       
               # We've seen this in the wild as a PrintableString, and since ascii is a
               # subset of cp1252, we use the later for decoding to be more user friendly
>>>>>>         if self._unicode is None:
>>>>>>             contents = self._merge_chunks()
>>>>>>             if contents.find(b'@') == -1:
>>>>>>                 self._unicode = contents.decode('cp1252')
                   else:
>>>>>>                 mailbox, hostname = contents.rsplit(b'@', 1)
>>>>>>                 self._unicode = mailbox.decode('cp1252') + '@' + hostname.decode('idna')
>>>>>>         return self._unicode
       
    1:     def __ne__(self, other):
>>>>>>         return not self == other
       
    1:     def __eq__(self, other):
               """
               Equality as defined by https://tools.ietf.org/html/rfc5280#section-7.5
       
               :param other:
                   Another EmailAddress object
       
               :return:
                   A boolean
               """
       
>>>>>>         if not isinstance(other, EmailAddress):
>>>>>>             return False
       
>>>>>>         if not self._normalized:
>>>>>>             self.set(self.native)
>>>>>>         if not other._normalized:
>>>>>>             other.set(other.native)
       
>>>>>>         if self._contents.find(b'@') == -1 or other._contents.find(b'@') == -1:
>>>>>>             return self._contents == other._contents
       
>>>>>>         other_mailbox, other_hostname = other._contents.rsplit(b'@', 1)
>>>>>>         mailbox, hostname = self._contents.rsplit(b'@', 1)
       
>>>>>>         if mailbox != other_mailbox:
>>>>>>             return False
       
>>>>>>         if hostname.lower() != other_hostname.lower():
>>>>>>             return False
       
>>>>>>         return True
       
       
    2: class IPAddress(OctetString):
    1:     def parse(self, spec=None, spec_params=None):
               """
               This method is not applicable to IP addresses
               """
       
>>>>>>         raise ValueError(unwrap(
>>>>>>             '''
                   IP address values can not be parsed
                   '''
               ))
       
    1:     def set(self, value):
               """
               Sets the value of the object
       
               :param value:
                   A unicode string containing an IPv4 address, IPv4 address with CIDR,
                   an IPv6 address or IPv6 address with CIDR
               """
       
>>>>>>         if not isinstance(value, str_cls):
>>>>>>             raise TypeError(unwrap(
>>>>>>                 '''
                       %s value must be a unicode string, not %s
                       ''',
>>>>>>                 type_name(self),
>>>>>>                 type_name(value)
                   ))
       
>>>>>>         original_value = value
       
>>>>>>         has_cidr = value.find('/') != -1
>>>>>>         cidr = 0
>>>>>>         if has_cidr:
>>>>>>             parts = value.split('/', 1)
>>>>>>             value = parts[0]
>>>>>>             cidr = int(parts[1])
>>>>>>             if cidr < 0:
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           %s value contains a CIDR range less than 0
                           ''',
>>>>>>                     type_name(self)
                       ))
       
>>>>>>         if value.find(':') != -1:
>>>>>>             family = socket.AF_INET6
>>>>>>             if cidr > 128:
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           %s value contains a CIDR range bigger than 128, the maximum
                           value for an IPv6 address
                           ''',
>>>>>>                     type_name(self)
                       ))
>>>>>>             cidr_size = 128
               else:
>>>>>>             family = socket.AF_INET
>>>>>>             if cidr > 32:
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           %s value contains a CIDR range bigger than 32, the maximum
                           value for an IPv4 address
                           ''',
>>>>>>                     type_name(self)
                       ))
>>>>>>             cidr_size = 32
       
>>>>>>         cidr_bytes = b''
>>>>>>         if has_cidr:
>>>>>>             cidr_mask = '1' * cidr
>>>>>>             cidr_mask += '0' * (cidr_size - len(cidr_mask))
>>>>>>             cidr_bytes = int_to_bytes(int(cidr_mask, 2))
>>>>>>             cidr_bytes = (b'\x00' * ((cidr_size // 8) - len(cidr_bytes))) + cidr_bytes
       
>>>>>>         self._native = original_value
>>>>>>         self.contents = inet_pton(family, value) + cidr_bytes
>>>>>>         self._bytes = self.contents
>>>>>>         self._header = None
>>>>>>         if self._trailer != b'':
>>>>>>             self._trailer = b''
       
    1:     @property
    1:     def native(self):
               """
               The native Python datatype representation of this value
       
               :return:
                   A unicode string or None
               """
       
>>>>>>         if self.contents is None:
>>>>>>             return None
       
>>>>>>         if self._native is None:
>>>>>>             byte_string = self.__bytes__()
>>>>>>             byte_len = len(byte_string)
>>>>>>             value = None
>>>>>>             cidr_int = None
>>>>>>             if byte_len in set([32, 16]):
>>>>>>                 value = inet_ntop(socket.AF_INET6, byte_string[0:16])
>>>>>>                 if byte_len > 16:
>>>>>>                     cidr_int = int_from_bytes(byte_string[16:])
>>>>>>             elif byte_len in set([8, 4]):
>>>>>>                 value = inet_ntop(socket.AF_INET, byte_string[0:4])
>>>>>>                 if byte_len > 4:
>>>>>>                     cidr_int = int_from_bytes(byte_string[4:])
>>>>>>             if cidr_int is not None:
>>>>>>                 cidr_bits = '{0:b}'.format(cidr_int)
>>>>>>                 cidr = len(cidr_bits.rstrip('0'))
>>>>>>                 value = value + '/' + str_cls(cidr)
>>>>>>             self._native = value
>>>>>>         return self._native
       
    1:     def __ne__(self, other):
>>>>>>         return not self == other
       
    1:     def __eq__(self, other):
               """
               :param other:
                   Another IPAddress object
       
               :return:
                   A boolean
               """
       
>>>>>>         if not isinstance(other, IPAddress):
>>>>>>             return False
       
>>>>>>         return self.__bytes__() == other.__bytes__()
       
       
    2: class Attribute(Sequence):
    1:     _fields = [
    1:         ('type', ObjectIdentifier),
    1:         ('values', SetOf, {'spec': Any}),
           ]
       
       
    2: class Attributes(SequenceOf):
    1:     _child_spec = Attribute
       
       
    2: class KeyUsage(BitString):
    1:     _map = {
    1:         0: 'digital_signature',
    1:         1: 'non_repudiation',
    1:         2: 'key_encipherment',
    1:         3: 'data_encipherment',
    1:         4: 'key_agreement',
    1:         5: 'key_cert_sign',
    1:         6: 'crl_sign',
    1:         7: 'encipher_only',
    1:         8: 'decipher_only',
           }
       
       
    2: class PrivateKeyUsagePeriod(Sequence):
    1:     _fields = [
    1:         ('not_before', GeneralizedTime, {'implicit': 0, 'optional': True}),
    1:         ('not_after', GeneralizedTime, {'implicit': 1, 'optional': True}),
           ]
       
       
    2: class NotReallyTeletexString(TeletexString):
    1:     """
           OpenSSL (and probably some other libraries) puts ISO-8859-1
           into TeletexString instead of ITU T.61. We use Windows-1252 when
           decoding since it is a superset of ISO-8859-1, and less likely to
           cause encoding issues, but we stay strict with encoding to prevent
           us from creating bad data.
           """
       
    1:     _decoding_encoding = 'cp1252'
       
    1:     def __unicode__(self):
               """
               :return:
                   A unicode string
               """
       
>>>>>>         if self.contents is None:
>>>>>>             return ''
>>>>>>         if self._unicode is None:
>>>>>>             self._unicode = self._merge_chunks().decode(self._decoding_encoding)
>>>>>>         return self._unicode
       
       
    1: @contextmanager
    1: def strict_teletex():
>>>>>>     try:
>>>>>>         NotReallyTeletexString._decoding_encoding = 'teletex'
>>>>>>         yield
           finally:
>>>>>>         NotReallyTeletexString._decoding_encoding = 'cp1252'
       
       
    2: class DirectoryString(Choice):
    1:     _alternatives = [
    1:         ('teletex_string', NotReallyTeletexString),
    1:         ('printable_string', PrintableString),
    1:         ('universal_string', UniversalString),
    1:         ('utf8_string', UTF8String),
    1:         ('bmp_string', BMPString),
               # This is an invalid/bad alternative, but some broken certs use it
    1:         ('ia5_string', IA5String),
           ]
       
       
    2: class NameType(ObjectIdentifier):
    1:     _map = {
    1:         '2.5.4.3': 'common_name',
    1:         '2.5.4.4': 'surname',
    1:         '2.5.4.5': 'serial_number',
    1:         '2.5.4.6': 'country_name',
    1:         '2.5.4.7': 'locality_name',
    1:         '2.5.4.8': 'state_or_province_name',
    1:         '2.5.4.9': 'street_address',
    1:         '2.5.4.10': 'organization_name',
    1:         '2.5.4.11': 'organizational_unit_name',
    1:         '2.5.4.12': 'title',
    1:         '2.5.4.15': 'business_category',
    1:         '2.5.4.17': 'postal_code',
    1:         '2.5.4.20': 'telephone_number',
    1:         '2.5.4.41': 'name',
    1:         '2.5.4.42': 'given_name',
    1:         '2.5.4.43': 'initials',
    1:         '2.5.4.44': 'generation_qualifier',
    1:         '2.5.4.45': 'unique_identifier',
    1:         '2.5.4.46': 'dn_qualifier',
    1:         '2.5.4.65': 'pseudonym',
    1:         '2.5.4.97': 'organization_identifier',
               # https://www.trustedcomputinggroup.org/wp-content/uploads/Credential_Profile_EK_V2.0_R14_published.pdf
    1:         '2.23.133.2.1': 'tpm_manufacturer',
    1:         '2.23.133.2.2': 'tpm_model',
    1:         '2.23.133.2.3': 'tpm_version',
    1:         '2.23.133.2.4': 'platform_manufacturer',
    1:         '2.23.133.2.5': 'platform_model',
    1:         '2.23.133.2.6': 'platform_version',
               # https://tools.ietf.org/html/rfc2985#page-26
    1:         '1.2.840.113549.1.9.1': 'email_address',
               # Page 10 of https://cabforum.org/wp-content/uploads/EV-V1_5_5.pdf
    1:         '1.3.6.1.4.1.311.60.2.1.1': 'incorporation_locality',
    1:         '1.3.6.1.4.1.311.60.2.1.2': 'incorporation_state_or_province',
    1:         '1.3.6.1.4.1.311.60.2.1.3': 'incorporation_country',
               # https://tools.ietf.org/html/rfc4519#section-2.39
    1:         '0.9.2342.19200300.100.1.1': 'user_id',
               # https://tools.ietf.org/html/rfc2247#section-4
    1:         '0.9.2342.19200300.100.1.25': 'domain_component',
               # http://www.alvestrand.no/objectid/0.2.262.1.10.7.20.html
    1:         '0.2.262.1.10.7.20': 'name_distinguisher',
           }
       
           # This order is largely based on observed order seen in EV certs from
           # Symantec and DigiCert. Some of the uncommon name-related fields are
           # just placed in what seems like a reasonable order.
    1:     preferred_order = [
               'incorporation_country',
               'incorporation_state_or_province',
               'incorporation_locality',
               'business_category',
               'serial_number',
               'country_name',
               'postal_code',
               'state_or_province_name',
               'locality_name',
               'street_address',
               'organization_name',
               'organizational_unit_name',
               'title',
               'common_name',
               'user_id',
               'initials',
               'generation_qualifier',
               'surname',
               'given_name',
               'name',
               'pseudonym',
               'dn_qualifier',
               'telephone_number',
               'email_address',
               'domain_component',
               'name_distinguisher',
               'organization_identifier',
               'tpm_manufacturer',
               'tpm_model',
               'tpm_version',
               'platform_manufacturer',
               'platform_model',
               'platform_version',
           ]
       
    1:     @classmethod
    1:     def preferred_ordinal(cls, attr_name):
               """
               Returns an ordering value for a particular attribute key.
       
               Unrecognized attributes and OIDs will be sorted lexically at the end.
       
               :return:
                   An orderable value.
       
               """
       
>>>>>>         attr_name = cls.map(attr_name)
>>>>>>         if attr_name in cls.preferred_order:
>>>>>>             ordinal = cls.preferred_order.index(attr_name)
               else:
>>>>>>             ordinal = len(cls.preferred_order)
       
>>>>>>         return (ordinal, attr_name)
       
    1:     @property
    1:     def human_friendly(self):
               """
               :return:
                   A human-friendly unicode string to display to users
               """
       
>>>>>>         return {
>>>>>>             'common_name': 'Common Name',
>>>>>>             'surname': 'Surname',
>>>>>>             'serial_number': 'Serial Number',
>>>>>>             'country_name': 'Country',
>>>>>>             'locality_name': 'Locality',
>>>>>>             'state_or_province_name': 'State/Province',
>>>>>>             'street_address': 'Street Address',
>>>>>>             'organization_name': 'Organization',
>>>>>>             'organizational_unit_name': 'Organizational Unit',
>>>>>>             'title': 'Title',
>>>>>>             'business_category': 'Business Category',
>>>>>>             'postal_code': 'Postal Code',
>>>>>>             'telephone_number': 'Telephone Number',
>>>>>>             'name': 'Name',
>>>>>>             'given_name': 'Given Name',
>>>>>>             'initials': 'Initials',
>>>>>>             'generation_qualifier': 'Generation Qualifier',
>>>>>>             'unique_identifier': 'Unique Identifier',
>>>>>>             'dn_qualifier': 'DN Qualifier',
>>>>>>             'pseudonym': 'Pseudonym',
>>>>>>             'email_address': 'Email Address',
>>>>>>             'incorporation_locality': 'Incorporation Locality',
>>>>>>             'incorporation_state_or_province': 'Incorporation State/Province',
>>>>>>             'incorporation_country': 'Incorporation Country',
>>>>>>             'domain_component': 'Domain Component',
>>>>>>             'name_distinguisher': 'Name Distinguisher',
>>>>>>             'organization_identifier': 'Organization Identifier',
>>>>>>             'tpm_manufacturer': 'TPM Manufacturer',
>>>>>>             'tpm_model': 'TPM Model',
>>>>>>             'tpm_version': 'TPM Version',
>>>>>>             'platform_manufacturer': 'Platform Manufacturer',
>>>>>>             'platform_model': 'Platform Model',
>>>>>>             'platform_version': 'Platform Version',
>>>>>>             'user_id': 'User ID',
>>>>>>         }.get(self.native, self.native)
       
       
    2: class NameTypeAndValue(Sequence):
    1:     _fields = [
    1:         ('type', NameType),
    1:         ('value', Any),
           ]
       
    1:     _oid_pair = ('type', 'value')
    1:     _oid_specs = {
    1:         'common_name': DirectoryString,
    1:         'surname': DirectoryString,
    1:         'serial_number': DirectoryString,
    1:         'country_name': DirectoryString,
    1:         'locality_name': DirectoryString,
    1:         'state_or_province_name': DirectoryString,
    1:         'street_address': DirectoryString,
    1:         'organization_name': DirectoryString,
    1:         'organizational_unit_name': DirectoryString,
    1:         'title': DirectoryString,
    1:         'business_category': DirectoryString,
    1:         'postal_code': DirectoryString,
    1:         'telephone_number': PrintableString,
    1:         'name': DirectoryString,
    1:         'given_name': DirectoryString,
    1:         'initials': DirectoryString,
    1:         'generation_qualifier': DirectoryString,
    1:         'unique_identifier': OctetBitString,
    1:         'dn_qualifier': DirectoryString,
    1:         'pseudonym': DirectoryString,
               # https://tools.ietf.org/html/rfc2985#page-26
    1:         'email_address': EmailAddress,
               # Page 10 of https://cabforum.org/wp-content/uploads/EV-V1_5_5.pdf
    1:         'incorporation_locality': DirectoryString,
    1:         'incorporation_state_or_province': DirectoryString,
    1:         'incorporation_country': DirectoryString,
    1:         'domain_component': DNSName,
    1:         'name_distinguisher': DirectoryString,
    1:         'organization_identifier': DirectoryString,
    1:         'tpm_manufacturer': UTF8String,
    1:         'tpm_model': UTF8String,
    1:         'tpm_version': UTF8String,
    1:         'platform_manufacturer': UTF8String,
    1:         'platform_model': UTF8String,
    1:         'platform_version': UTF8String,
    1:         'user_id': DirectoryString,
           }
       
    1:     _prepped = None
       
    1:     @property
    1:     def prepped_value(self):
               """
               Returns the value after being processed by the internationalized string
               preparation as specified by RFC 5280
       
               :return:
                   A unicode string
               """
       
>>>>>>         if self._prepped is None:
>>>>>>             self._prepped = self._ldap_string_prep(self['value'].native)
>>>>>>         return self._prepped
       
    1:     def __ne__(self, other):
>>>>>>         return not self == other
       
    1:     def __eq__(self, other):
               """
               Equality as defined by https://tools.ietf.org/html/rfc5280#section-7.1
       
               :param other:
                   Another NameTypeAndValue object
       
               :return:
                   A boolean
               """
       
>>>>>>         if not isinstance(other, NameTypeAndValue):
>>>>>>             return False
       
>>>>>>         if other['type'].native != self['type'].native:
>>>>>>             return False
       
>>>>>>         return other.prepped_value == self.prepped_value
       
    1:     def _ldap_string_prep(self, string):
               """
               Implements the internationalized string preparation algorithm from
               RFC 4518. https://tools.ietf.org/html/rfc4518#section-2
       
               :param string:
                   A unicode string to prepare
       
               :return:
                   A prepared unicode string, ready for comparison
               """
       
               # Map step
>>>>>>         string = re.sub('[\u00ad\u1806\u034f\u180b-\u180d\ufe0f-\uff00\ufffc]+', '', string)
>>>>>>         string = re.sub('[\u0009\u000a\u000b\u000c\u000d\u0085]', ' ', string)
>>>>>>         if sys.maxunicode == 0xffff:
                   # Some installs of Python 2.7 don't support 8-digit unicode escape
                   # ranges, so we have to break them into pieces
                   # Original was: \U0001D173-\U0001D17A and \U000E0020-\U000E007F
>>>>>>             string = re.sub('\ud834[\udd73-\udd7a]|\udb40[\udc20-\udc7f]|\U000e0001', '', string)
               else:
>>>>>>             string = re.sub('[\U0001D173-\U0001D17A\U000E0020-\U000E007F\U000e0001]', '', string)
>>>>>>         string = re.sub(
>>>>>>             '[\u0000-\u0008\u000e-\u001f\u007f-\u0084\u0086-\u009f\u06dd\u070f\u180e\u200c-\u200f'
                   '\u202a-\u202e\u2060-\u2063\u206a-\u206f\ufeff\ufff9-\ufffb]+',
>>>>>>             '',
>>>>>>             string
               )
>>>>>>         string = string.replace('\u200b', '')
>>>>>>         string = re.sub('[\u00a0\u1680\u2000-\u200a\u2028-\u2029\u202f\u205f\u3000]', ' ', string)
       
>>>>>>         string = ''.join(map(stringprep.map_table_b2, string))
       
               # Normalize step
>>>>>>         string = unicodedata.normalize('NFKC', string)
       
               # Prohibit step
>>>>>>         for char in string:
>>>>>>             if stringprep.in_table_a1(char):
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           X.509 Name objects may not contain unassigned code points
                           '''
                       ))
       
>>>>>>             if stringprep.in_table_c8(char):
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           X.509 Name objects may not contain change display or
                           zzzzdeprecated characters
                           '''
                       ))
       
>>>>>>             if stringprep.in_table_c3(char):
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           X.509 Name objects may not contain private use characters
                           '''
                       ))
       
>>>>>>             if stringprep.in_table_c4(char):
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           X.509 Name objects may not contain non-character code points
                           '''
                       ))
       
>>>>>>             if stringprep.in_table_c5(char):
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           X.509 Name objects may not contain surrogate code points
                           '''
                       ))
       
>>>>>>             if char == '\ufffd':
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           X.509 Name objects may not contain the replacement character
                           '''
                       ))
       
               # Check bidirectional step - here we ensure that we are not mixing
               # left-to-right and right-to-left text in the string
>>>>>>         has_r_and_al_cat = False
>>>>>>         has_l_cat = False
>>>>>>         for char in string:
>>>>>>             if stringprep.in_table_d1(char):
>>>>>>                 has_r_and_al_cat = True
>>>>>>             elif stringprep.in_table_d2(char):
>>>>>>                 has_l_cat = True
       
>>>>>>         if has_r_and_al_cat:
>>>>>>             first_is_r_and_al = stringprep.in_table_d1(string[0])
>>>>>>             last_is_r_and_al = stringprep.in_table_d1(string[-1])
       
>>>>>>             if has_l_cat or not first_is_r_and_al or not last_is_r_and_al:
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           X.509 Name object contains a malformed bidirectional
                           sequence
                           '''
                       ))
       
               # Insignificant space handling step
>>>>>>         string = ' ' + re.sub(' +', '  ', string).strip() + ' '
       
>>>>>>         return string
       
       
    2: class RelativeDistinguishedName(SetOf):
    1:     _child_spec = NameTypeAndValue
       
    1:     @property
    1:     def hashable(self):
               """
               :return:
                   A unicode string that can be used as a dict key or in a set
               """
       
>>>>>>         output = []
>>>>>>         values = self._get_values(self)
>>>>>>         for key in sorted(values.keys()):
>>>>>>             output.append('%s: %s' % (key, values[key]))
               # Unit separator is used here since the normalization process for
               # values moves any such character, and the keys are all dotted integers
               # or under_score_words
>>>>>>         return '\x1F'.join(output)
       
    1:     def __ne__(self, other):
>>>>>>         return not self == other
       
    1:     def __eq__(self, other):
               """
               Equality as defined by https://tools.ietf.org/html/rfc5280#section-7.1
       
               :param other:
                   Another RelativeDistinguishedName object
       
               :return:
                   A boolean
               """
       
>>>>>>         if not isinstance(other, RelativeDistinguishedName):
>>>>>>             return False
       
>>>>>>         if len(self) != len(other):
>>>>>>             return False
       
>>>>>>         self_types = self._get_types(self)
>>>>>>         other_types = self._get_types(other)
       
>>>>>>         if self_types != other_types:
>>>>>>             return False
       
>>>>>>         self_values = self._get_values(self)
>>>>>>         other_values = self._get_values(other)
       
>>>>>>         for type_name_ in self_types:
>>>>>>             if self_values[type_name_] != other_values[type_name_]:
>>>>>>                 return False
       
>>>>>>         return True
       
    1:     def _get_types(self, rdn):
               """
               Returns a set of types contained in an RDN
       
               :param rdn:
                   A RelativeDistinguishedName object
       
               :return:
                   A set object with unicode strings of NameTypeAndValue type field
                   values
               """
       
>>>>>>         return set([ntv['type'].native for ntv in rdn])
       
    1:     def _get_values(self, rdn):
               """
               Returns a dict of prepped values contained in an RDN
       
               :param rdn:
                   A RelativeDistinguishedName object
       
               :return:
                   A dict object with unicode strings of NameTypeAndValue value field
                   values that have been prepped for comparison
               """
       
>>>>>>         output = {}
>>>>>>         [output.update([(ntv['type'].native, ntv.prepped_value)]) for ntv in rdn]
>>>>>>         return output
       
       
    2: class RDNSequence(SequenceOf):
    1:     _child_spec = RelativeDistinguishedName
       
    1:     @property
    1:     def hashable(self):
               """
               :return:
                   A unicode string that can be used as a dict key or in a set
               """
       
               # Record separator is used here since the normalization process for
               # values moves any such character, and the keys are all dotted integers
               # or under_score_words
>>>>>>         return '\x1E'.join(rdn.hashable for rdn in self)
       
    1:     def __ne__(self, other):
>>>>>>         return not self == other
       
    1:     def __eq__(self, other):
               """
               Equality as defined by https://tools.ietf.org/html/rfc5280#section-7.1
       
               :param other:
                   Another RDNSequence object
       
               :return:
                   A boolean
               """
       
>>>>>>         if not isinstance(other, RDNSequence):
>>>>>>             return False
       
>>>>>>         if len(self) != len(other):
>>>>>>             return False
       
>>>>>>         for index, self_rdn in enumerate(self):
>>>>>>             if other[index] != self_rdn:
>>>>>>                 return False
       
>>>>>>         return True
       
       
    2: class Name(Choice):
    1:     _alternatives = [
    1:         ('', RDNSequence),
           ]
       
    1:     _human_friendly = None
    1:     _sha1 = None
    1:     _sha256 = None
       
    1:     @classmethod
    1:     def build(cls, name_dict, use_printable=False):
               """
               Creates a Name object from a dict of unicode string keys and values.
               The keys should be from NameType._map, or a dotted-integer OID unicode
               string.
       
               :param name_dict:
                   A dict of name information, e.g. {"common_name": "Will Bond",
                   "country_name": "US", "organization_name": "Codex Non Sufficit LC"}
       
               :param use_printable:
                   A bool - if PrintableString should be used for encoding instead of
                   UTF8String. This is for backwards compatibility with old software.
       
               :return:
                   An x509.Name object
               """
       
>>>>>>         rdns = []
>>>>>>         if not use_printable:
>>>>>>             encoding_name = 'utf8_string'
>>>>>>             encoding_class = UTF8String
               else:
>>>>>>             encoding_name = 'printable_string'
>>>>>>             encoding_class = PrintableString
       
               # Sort the attributes according to NameType.preferred_order
>>>>>>         name_dict = OrderedDict(
>>>>>>             sorted(
>>>>>>                 name_dict.items(),
>>>>>>                 key=lambda item: NameType.preferred_ordinal(item[0])
                   )
               )
       
>>>>>>         for attribute_name, attribute_value in name_dict.items():
>>>>>>             attribute_name = NameType.map(attribute_name)
>>>>>>             if attribute_name == 'email_address':
>>>>>>                 value = EmailAddress(attribute_value)
>>>>>>             elif attribute_name == 'domain_component':
>>>>>>                 value = DNSName(attribute_value)
>>>>>>             elif attribute_name in set(['dn_qualifier', 'country_name', 'serial_number']):
>>>>>>                 value = DirectoryString(
>>>>>>                     name='printable_string',
>>>>>>                     value=PrintableString(attribute_value)
                       )
                   else:
>>>>>>                 value = DirectoryString(
>>>>>>                     name=encoding_name,
>>>>>>                     value=encoding_class(attribute_value)
                       )
       
>>>>>>             rdns.append(RelativeDistinguishedName([
>>>>>>                 NameTypeAndValue({
>>>>>>                     'type': attribute_name,
>>>>>>                     'value': value
                       })
                   ]))
       
>>>>>>         return cls(name='', value=RDNSequence(rdns))
       
    1:     @property
    1:     def hashable(self):
               """
               :return:
                   A unicode string that can be used as a dict key or in a set
               """
       
>>>>>>         return self.chosen.hashable
       
    1:     def __len__(self):
>>>>>>         return len(self.chosen)
       
    1:     def __ne__(self, other):
>>>>>>         return not self == other
       
    1:     def __eq__(self, other):
               """
               Equality as defined by https://tools.ietf.org/html/rfc5280#section-7.1
       
               :param other:
                   Another Name object
       
               :return:
                   A boolean
               """
       
>>>>>>         if not isinstance(other, Name):
>>>>>>             return False
>>>>>>         return self.chosen == other.chosen
       
    1:     @property
    1:     def native(self):
>>>>>>         if self._native is None:
>>>>>>             self._native = OrderedDict()
>>>>>>             for rdn in self.chosen.native:
>>>>>>                 for type_val in rdn:
>>>>>>                     field_name = type_val['type']
>>>>>>                     if field_name in self._native:
>>>>>>                         existing = self._native[field_name]
>>>>>>                         if not isinstance(existing, list):
>>>>>>                             existing = self._native[field_name] = [existing]
>>>>>>                         existing.append(type_val['value'])
                           else:
>>>>>>                         self._native[field_name] = type_val['value']
>>>>>>         return self._native
       
    1:     @property
    1:     def human_friendly(self):
               """
               :return:
                   A human-friendly unicode string containing the parts of the name
               """
       
>>>>>>         if self._human_friendly is None:
>>>>>>             data = OrderedDict()
>>>>>>             last_field = None
>>>>>>             for rdn in self.chosen:
>>>>>>                 for type_val in rdn:
>>>>>>                     field_name = type_val['type'].human_friendly
>>>>>>                     last_field = field_name
>>>>>>                     if field_name in data:
>>>>>>                         data[field_name] = [data[field_name]]
>>>>>>                         data[field_name].append(type_val['value'])
                           else:
>>>>>>                         data[field_name] = type_val['value']
>>>>>>             to_join = []
>>>>>>             keys = data.keys()
>>>>>>             if last_field == 'Country':
>>>>>>                 keys = reversed(list(keys))
>>>>>>             for key in keys:
>>>>>>                 value = data[key]
>>>>>>                 native_value = self._recursive_humanize(value)
>>>>>>                 to_join.append('%s: %s' % (key, native_value))
       
>>>>>>             has_comma = False
>>>>>>             for element in to_join:
>>>>>>                 if element.find(',') != -1:
>>>>>>                     has_comma = True
>>>>>>                     break
       
>>>>>>             separator = ', ' if not has_comma else '; '
>>>>>>             self._human_friendly = separator.join(to_join[::-1])
       
>>>>>>         return self._human_friendly
       
    1:     def _recursive_humanize(self, value):
               """
               Recursively serializes data compiled from the RDNSequence
       
               :param value:
                   An Asn1Value object, or a list of Asn1Value objects
       
               :return:
                   A unicode string
               """
       
>>>>>>         if isinstance(value, list):
>>>>>>             return ', '.join(
>>>>>>                 reversed([self._recursive_humanize(sub_value) for sub_value in value])
                   )
>>>>>>         return value.native
       
    1:     @property
    1:     def sha1(self):
               """
               :return:
                   The SHA1 hash of the DER-encoded bytes of this name
               """
       
>>>>>>         if self._sha1 is None:
>>>>>>             self._sha1 = hashlib.sha1(self.dump()).digest()
>>>>>>         return self._sha1
       
    1:     @property
    1:     def sha256(self):
               """
               :return:
                   The SHA-256 hash of the DER-encoded bytes of this name
               """
       
>>>>>>         if self._sha256 is None:
>>>>>>             self._sha256 = hashlib.sha256(self.dump()).digest()
>>>>>>         return self._sha256
       
       
    2: class AnotherName(Sequence):
    1:     _fields = [
    1:         ('type_id', ObjectIdentifier),
    1:         ('value', Any, {'explicit': 0}),
           ]
       
       
    2: class CountryName(Choice):
    1:     class_ = 1
    1:     tag = 1
       
    1:     _alternatives = [
    1:         ('x121_dcc_code', NumericString),
    1:         ('iso_3166_alpha2_code', PrintableString),
           ]
       
       
    2: class AdministrationDomainName(Choice):
    1:     class_ = 1
    1:     tag = 2
       
    1:     _alternatives = [
    1:         ('numeric', NumericString),
    1:         ('printable', PrintableString),
           ]
       
       
    2: class PrivateDomainName(Choice):
    1:     _alternatives = [
    1:         ('numeric', NumericString),
    1:         ('printable', PrintableString),
           ]
       
       
    2: class PersonalName(Set):
    1:     _fields = [
    1:         ('surname', PrintableString, {'implicit': 0}),
    1:         ('given_name', PrintableString, {'implicit': 1, 'optional': True}),
    1:         ('initials', PrintableString, {'implicit': 2, 'optional': True}),
    1:         ('generation_qualifier', PrintableString, {'implicit': 3, 'optional': True}),
           ]
       
       
    2: class TeletexPersonalName(Set):
    1:     _fields = [
    1:         ('surname', TeletexString, {'implicit': 0}),
    1:         ('given_name', TeletexString, {'implicit': 1, 'optional': True}),
    1:         ('initials', TeletexString, {'implicit': 2, 'optional': True}),
    1:         ('generation_qualifier', TeletexString, {'implicit': 3, 'optional': True}),
           ]
       
       
    2: class OrganizationalUnitNames(SequenceOf):
    1:     _child_spec = PrintableString
       
       
    2: class TeletexOrganizationalUnitNames(SequenceOf):
    1:     _child_spec = TeletexString
       
       
    2: class BuiltInStandardAttributes(Sequence):
    1:     _fields = [
    1:         ('country_name', CountryName, {'optional': True}),
    1:         ('administration_domain_name', AdministrationDomainName, {'optional': True}),
    1:         ('network_address', NumericString, {'implicit': 0, 'optional': True}),
    1:         ('terminal_identifier', PrintableString, {'implicit': 1, 'optional': True}),
    1:         ('private_domain_name', PrivateDomainName, {'explicit': 2, 'optional': True}),
    1:         ('organization_name', PrintableString, {'implicit': 3, 'optional': True}),
    1:         ('numeric_user_identifier', NumericString, {'implicit': 4, 'optional': True}),
    1:         ('personal_name', PersonalName, {'implicit': 5, 'optional': True}),
    1:         ('organizational_unit_names', OrganizationalUnitNames, {'implicit': 6, 'optional': True}),
           ]
       
       
    2: class BuiltInDomainDefinedAttribute(Sequence):
    1:     _fields = [
    1:         ('type', PrintableString),
    1:         ('value', PrintableString),
           ]
       
       
    2: class BuiltInDomainDefinedAttributes(SequenceOf):
    1:     _child_spec = BuiltInDomainDefinedAttribute
       
       
    2: class TeletexDomainDefinedAttribute(Sequence):
    1:     _fields = [
    1:         ('type', TeletexString),
    1:         ('value', TeletexString),
           ]
       
       
    2: class TeletexDomainDefinedAttributes(SequenceOf):
    1:     _child_spec = TeletexDomainDefinedAttribute
       
       
    2: class PhysicalDeliveryCountryName(Choice):
    1:     _alternatives = [
    1:         ('x121_dcc_code', NumericString),
    1:         ('iso_3166_alpha2_code', PrintableString),
           ]
       
       
    2: class PostalCode(Choice):
    1:     _alternatives = [
    1:         ('numeric_code', NumericString),
    1:         ('printable_code', PrintableString),
           ]
       
       
    2: class PDSParameter(Set):
    1:     _fields = [
    1:         ('printable_string', PrintableString, {'optional': True}),
    1:         ('teletex_string', TeletexString, {'optional': True}),
           ]
       
       
    2: class PrintableAddress(SequenceOf):
    1:     _child_spec = PrintableString
       
       
    2: class UnformattedPostalAddress(Set):
    1:     _fields = [
    1:         ('printable_address', PrintableAddress, {'optional': True}),
    1:         ('teletex_string', TeletexString, {'optional': True}),
           ]
       
       
    2: class E1634Address(Sequence):
    1:     _fields = [
    1:         ('number', NumericString, {'implicit': 0}),
    1:         ('sub_address', NumericString, {'implicit': 1, 'optional': True}),
           ]
       
       
    2: class NAddresses(SetOf):
    1:     _child_spec = OctetString
       
       
    2: class PresentationAddress(Sequence):
    1:     _fields = [
    1:         ('p_selector', OctetString, {'explicit': 0, 'optional': True}),
    1:         ('s_selector', OctetString, {'explicit': 1, 'optional': True}),
    1:         ('t_selector', OctetString, {'explicit': 2, 'optional': True}),
    1:         ('n_addresses', NAddresses, {'explicit': 3}),
           ]
       
       
    2: class ExtendedNetworkAddress(Choice):
    1:     _alternatives = [
    1:         ('e163_4_address', E1634Address),
    1:         ('psap_address', PresentationAddress, {'implicit': 0})
           ]
       
       
    2: class TerminalType(Integer):
    1:     _map = {
    1:         3: 'telex',
    1:         4: 'teletex',
    1:         5: 'g3_facsimile',
    1:         6: 'g4_facsimile',
    1:         7: 'ia5_terminal',
    1:         8: 'videotex',
           }
       
       
    2: class ExtensionAttributeType(Integer):
    1:     _map = {
    1:         1: 'common_name',
    1:         2: 'teletex_common_name',
    1:         3: 'teletex_organization_name',
    1:         4: 'teletex_personal_name',
    1:         5: 'teletex_organization_unit_names',
    1:         6: 'teletex_domain_defined_attributes',
    1:         7: 'pds_name',
    1:         8: 'physical_delivery_country_name',
    1:         9: 'postal_code',
    1:         10: 'physical_delivery_office_name',
    1:         11: 'physical_delivery_office_number',
    1:         12: 'extension_of_address_components',
    1:         13: 'physical_delivery_personal_name',
    1:         14: 'physical_delivery_organization_name',
    1:         15: 'extension_physical_delivery_address_components',
    1:         16: 'unformatted_postal_address',
    1:         17: 'street_address',
    1:         18: 'post_office_box_address',
    1:         19: 'poste_restante_address',
    1:         20: 'unique_postal_name',
    1:         21: 'local_postal_attributes',
    1:         22: 'extended_network_address',
    1:         23: 'terminal_type',
           }
       
       
    2: class ExtensionAttribute(Sequence):
    1:     _fields = [
    1:         ('extension_attribute_type', ExtensionAttributeType, {'implicit': 0}),
    1:         ('extension_attribute_value', Any, {'explicit': 1}),
           ]
       
    1:     _oid_pair = ('extension_attribute_type', 'extension_attribute_value')
    1:     _oid_specs = {
    1:         'common_name': PrintableString,
    1:         'teletex_common_name': TeletexString,
    1:         'teletex_organization_name': TeletexString,
    1:         'teletex_personal_name': TeletexPersonalName,
    1:         'teletex_organization_unit_names': TeletexOrganizationalUnitNames,
    1:         'teletex_domain_defined_attributes': TeletexDomainDefinedAttributes,
    1:         'pds_name': PrintableString,
    1:         'physical_delivery_country_name': PhysicalDeliveryCountryName,
    1:         'postal_code': PostalCode,
    1:         'physical_delivery_office_name': PDSParameter,
    1:         'physical_delivery_office_number': PDSParameter,
    1:         'extension_of_address_components': PDSParameter,
    1:         'physical_delivery_personal_name': PDSParameter,
    1:         'physical_delivery_organization_name': PDSParameter,
    1:         'extension_physical_delivery_address_components': PDSParameter,
    1:         'unformatted_postal_address': UnformattedPostalAddress,
    1:         'street_address': PDSParameter,
    1:         'post_office_box_address': PDSParameter,
    1:         'poste_restante_address': PDSParameter,
    1:         'unique_postal_name': PDSParameter,
    1:         'local_postal_attributes': PDSParameter,
    1:         'extended_network_address': ExtendedNetworkAddress,
    1:         'terminal_type': TerminalType,
           }
       
       
    2: class ExtensionAttributes(SequenceOf):
    1:     _child_spec = ExtensionAttribute
       
       
    2: class ORAddress(Sequence):
    1:     _fields = [
    1:         ('built_in_standard_attributes', BuiltInStandardAttributes),
    1:         ('built_in_domain_defined_attributes', BuiltInDomainDefinedAttributes, {'optional': True}),
    1:         ('extension_attributes', ExtensionAttributes, {'optional': True}),
           ]
       
       
    2: class EDIPartyName(Sequence):
    1:     _fields = [
    1:         ('name_assigner', DirectoryString, {'implicit': 0, 'optional': True}),
    1:         ('party_name', DirectoryString, {'implicit': 1}),
           ]
       
       
    2: class GeneralName(Choice):
    1:     _alternatives = [
    1:         ('other_name', AnotherName, {'implicit': 0}),
    1:         ('rfc822_name', EmailAddress, {'implicit': 1}),
    1:         ('dns_name', DNSName, {'implicit': 2}),
    1:         ('x400_address', ORAddress, {'implicit': 3}),
    1:         ('directory_name', Name, {'explicit': 4}),
    1:         ('edi_party_name', EDIPartyName, {'implicit': 5}),
    1:         ('uniform_resource_identifier', URI, {'implicit': 6}),
    1:         ('ip_address', IPAddress, {'implicit': 7}),
    1:         ('registered_id', ObjectIdentifier, {'implicit': 8}),
           ]
       
    1:     def __ne__(self, other):
>>>>>>         return not self == other
       
    1:     def __eq__(self, other):
               """
               Does not support other_name, x400_address or edi_party_name
       
               :param other:
                   The other GeneralName to compare to
       
               :return:
                   A boolean
               """
       
>>>>>>         if self.name in ('other_name', 'x400_address', 'edi_party_name'):
>>>>>>             raise ValueError(unwrap(
>>>>>>                 '''
                       Comparison is not supported for GeneralName objects of
                       choice %s
                       ''',
>>>>>>                 self.name
                   ))
       
>>>>>>         if other.name in ('other_name', 'x400_address', 'edi_party_name'):
>>>>>>             raise ValueError(unwrap(
>>>>>>                 '''
                       Comparison is not supported for GeneralName objects of choice
                       %s''',
>>>>>>                 other.name
                   ))
       
>>>>>>         if self.name != other.name:
>>>>>>             return False
       
>>>>>>         return self.chosen == other.chosen
       
       
    2: class GeneralNames(SequenceOf):
    1:     _child_spec = GeneralName
       
       
    2: class Time(Choice):
    1:     _alternatives = [
    1:         ('utc_time', UTCTime),
    1:         ('general_time', GeneralizedTime),
           ]
       
       
    2: class Validity(Sequence):
    1:     _fields = [
    1:         ('not_before', Time),
    1:         ('not_after', Time),
           ]
       
       
    2: class BasicConstraints(Sequence):
    1:     _fields = [
    1:         ('ca', Boolean, {'default': False}),
    1:         ('path_len_constraint', Integer, {'optional': True}),
           ]
       
       
    2: class AuthorityKeyIdentifier(Sequence):
    1:     _fields = [
    1:         ('key_identifier', OctetString, {'implicit': 0, 'optional': True}),
    1:         ('authority_cert_issuer', GeneralNames, {'implicit': 1, 'optional': True}),
    1:         ('authority_cert_serial_number', Integer, {'implicit': 2, 'optional': True}),
           ]
       
       
    2: class DistributionPointName(Choice):
    1:     _alternatives = [
    1:         ('full_name', GeneralNames, {'implicit': 0}),
    1:         ('name_relative_to_crl_issuer', RelativeDistinguishedName, {'implicit': 1}),
           ]
       
       
    2: class ReasonFlags(BitString):
    1:     _map = {
    1:         0: 'unused',
    1:         1: 'key_compromise',
    1:         2: 'ca_compromise',
    1:         3: 'affiliation_changed',
    1:         4: 'superseded',
    1:         5: 'cessation_of_operation',
    1:         6: 'certificate_hold',
    1:         7: 'privilege_withdrawn',
    1:         8: 'aa_compromise',
           }
       
       
    2: class GeneralSubtree(Sequence):
    1:     _fields = [
    1:         ('base', GeneralName),
    1:         ('minimum', Integer, {'implicit': 0, 'default': 0}),
    1:         ('maximum', Integer, {'implicit': 1, 'optional': True}),
           ]
       
       
    2: class GeneralSubtrees(SequenceOf):
    1:     _child_spec = GeneralSubtree
       
       
    2: class NameConstraints(Sequence):
    1:     _fields = [
    1:         ('permitted_subtrees', GeneralSubtrees, {'implicit': 0, 'optional': True}),
    1:         ('excluded_subtrees', GeneralSubtrees, {'implicit': 1, 'optional': True}),
           ]
       
       
    2: class DistributionPoint(Sequence):
    1:     _fields = [
    1:         ('distribution_point', DistributionPointName, {'explicit': 0, 'optional': True}),
    1:         ('reasons', ReasonFlags, {'implicit': 1, 'optional': True}),
    1:         ('crl_issuer', GeneralNames, {'implicit': 2, 'optional': True}),
           ]
       
    1:     _url = False
       
    1:     @property
    1:     def url(self):
               """
               :return:
                   None or a unicode string of the distribution point's URL
               """
       
>>>>>>         if self._url is False:
>>>>>>             self._url = None
>>>>>>             name = self['distribution_point']
>>>>>>             if name.name != 'full_name':
>>>>>>                 raise ValueError(unwrap(
>>>>>>                     '''
                           CRL distribution points that are relative to the issuer are
                           not supported
                           '''
                       ))
       
>>>>>>             for general_name in name.chosen:
>>>>>>                 if general_name.name == 'uniform_resource_identifier':
>>>>>>                     url = general_name.native
>>>>>>                     if url.lower().startswith(('http://', 'https://', 'ldap://', 'ldaps://')):
>>>>>>                         self._url = url
>>>>>>                         break
       
>>>>>>         return self._url
       
       
    2: class CRLDistributionPoints(SequenceOf):
    1:     _child_spec = DistributionPoint
       
       
    2: class DisplayText(Choice):
    1:     _alternatives = [
    1:         ('ia5_string', IA5String),
    1:         ('visible_string', VisibleString),
    1:         ('bmp_string', BMPString),
    1:         ('utf8_string', UTF8String),
           ]
       
       
    2: class NoticeNumbers(SequenceOf):
    1:     _child_spec = Integer
       
       
    2: class NoticeReference(Sequence):
    1:     _fields = [
    1:         ('organization', DisplayText),
    1:         ('notice_numbers', NoticeNumbers),
           ]
       
       
    2: class UserNotice(Sequence):
    1:     _fields = [
    1:         ('notice_ref', NoticeReference, {'optional': True}),
    1:         ('explicit_text', DisplayText, {'optional': True}),
           ]
       
       
    2: class PolicyQualifierId(ObjectIdentifier):
    1:     _map = {
    1:         '1.3.6.1.5.5.7.2.1': 'certification_practice_statement',
    1:         '1.3.6.1.5.5.7.2.2': 'user_notice',
           }
       
       
    2: class PolicyQualifierInfo(Sequence):
    1:     _fields = [
    1:         ('policy_qualifier_id', PolicyQualifierId),
    1:         ('qualifier', Any),
           ]
       
    1:     _oid_pair = ('policy_qualifier_id', 'qualifier')
    1:     _oid_specs = {
    1:         'certification_practice_statement': IA5String,
    1:         'user_notice': UserNotice,
           }
       
       
    2: class PolicyQualifierInfos(SequenceOf):
    1:     _child_spec = PolicyQualifierInfo
       
       
    2: class PolicyIdentifier(ObjectIdentifier):
    1:     _map = {
    1:         '2.5.29.32.0': 'any_policy',
           }
       
       
    2: class PolicyInformation(Sequence):
    1:     _fields = [
    1:         ('policy_identifier', PolicyIdentifier),
    1:         ('policy_qualifiers', PolicyQualifierInfos, {'optional': True})
           ]
       
       
    2: class CertificatePolicies(SequenceOf):
    1:     _child_spec = PolicyInformation
       
       
    2: class PolicyMapping(Sequence):
    1:     _fields = [
    1:         ('issuer_domain_policy', PolicyIdentifier),
    1:         ('subject_domain_policy', PolicyIdentifier),
           ]
       
       
    2: class PolicyMappings(SequenceOf):
    1:     _child_spec = PolicyMapping
       
       
    2: class PolicyConstraints(Sequence):
    1:     _fields = [
    1:         ('require_explicit_policy', Integer, {'implicit': 0, 'optional': True}),
    1:         ('inhibit_policy_mapping', Integer, {'implicit': 1, 'optional': True}),
           ]
       
       
    2: class KeyPurposeId(ObjectIdentifier):
    1:     _map = {
               # https://tools.ietf.org/html/rfc5280#page-45
    1:         '2.5.29.37.0': 'any_extended_key_usage',
    1:         '1.3.6.1.5.5.7.3.1': 'server_auth',
    1:         '1.3.6.1.5.5.7.3.2': 'client_auth',
    1:         '1.3.6.1.5.5.7.3.3': 'code_signing',
    1:         '1.3.6.1.5.5.7.3.4': 'email_protection',
    1:         '1.3.6.1.5.5.7.3.5': 'ipsec_end_system',
    1:         '1.3.6.1.5.5.7.3.6': 'ipsec_tunnel',
    1:         '1.3.6.1.5.5.7.3.7': 'ipsec_user',
    1:         '1.3.6.1.5.5.7.3.8': 'time_stamping',
    1:         '1.3.6.1.5.5.7.3.9': 'ocsp_signing',
               # http://tools.ietf.org/html/rfc3029.html#page-9
    1:         '1.3.6.1.5.5.7.3.10': 'dvcs',
               # http://tools.ietf.org/html/rfc6268.html#page-16
    1:         '1.3.6.1.5.5.7.3.13': 'eap_over_ppp',
    1:         '1.3.6.1.5.5.7.3.14': 'eap_over_lan',
               # https://tools.ietf.org/html/rfc5055#page-76
    1:         '1.3.6.1.5.5.7.3.15': 'scvp_server',
    1:         '1.3.6.1.5.5.7.3.16': 'scvp_client',
               # https://tools.ietf.org/html/rfc4945#page-31
    1:         '1.3.6.1.5.5.7.3.17': 'ipsec_ike',
               # https://tools.ietf.org/html/rfc5415#page-38
    1:         '1.3.6.1.5.5.7.3.18': 'capwap_ac',
    1:         '1.3.6.1.5.5.7.3.19': 'capwap_wtp',
               # https://tools.ietf.org/html/rfc5924#page-8
    1:         '1.3.6.1.5.5.7.3.20': 'sip_domain',
               # https://tools.ietf.org/html/rfc6187#page-7
    1:         '1.3.6.1.5.5.7.3.21': 'secure_shell_client',
    1:         '1.3.6.1.5.5.7.3.22': 'secure_shell_server',
               # https://tools.ietf.org/html/rfc6494#page-7
    1:         '1.3.6.1.5.5.7.3.23': 'send_router',
    1:         '1.3.6.1.5.5.7.3.24': 'send_proxied_router',
    1:         '1.3.6.1.5.5.7.3.25': 'send_owner',
    1:         '1.3.6.1.5.5.7.3.26': 'send_proxied_owner',
               # https://tools.ietf.org/html/rfc6402#page-10
    1:         '1.3.6.1.5.5.7.3.27': 'cmc_ca',
    1:         '1.3.6.1.5.5.7.3.28': 'cmc_ra',
    1:         '1.3.6.1.5.5.7.3.29': 'cmc_archive',
               # https://tools.ietf.org/html/draft-ietf-sidr-bgpsec-pki-profiles-15#page-6
    1:         '1.3.6.1.5.5.7.3.30': 'bgpspec_router',
               # https://www.ietf.org/proceedings/44/I-D/draft-ietf-ipsec-pki-req-01.txt
    1:         '1.3.6.1.5.5.8.2.2': 'ike_intermediate',
               # https://msdn.microsoft.com/en-us/library/windows/desktop/aa378132(v=vs.85).aspx
               # and https://support.microsoft.com/en-us/kb/287547
    1:         '1.3.6.1.4.1.311.10.3.1': 'microsoft_trust_list_signing',
    1:         '1.3.6.1.4.1.311.10.3.2': 'microsoft_time_stamp_signing',
    1:         '1.3.6.1.4.1.311.10.3.3': 'microsoft_server_gated',
    1:         '1.3.6.1.4.1.311.10.3.3.1': 'microsoft_serialized',
    1:         '1.3.6.1.4.1.311.10.3.4': 'microsoft_efs',
    1:         '1.3.6.1.4.1.311.10.3.4.1': 'microsoft_efs_recovery',
    1:         '1.3.6.1.4.1.311.10.3.5': 'microsoft_whql',
    1:         '1.3.6.1.4.1.311.10.3.6': 'microsoft_nt5',
    1:         '1.3.6.1.4.1.311.10.3.7': 'microsoft_oem_whql',
    1:         '1.3.6.1.4.1.311.10.3.8': 'microsoft_embedded_nt',
    1:         '1.3.6.1.4.1.311.10.3.9': 'microsoft_root_list_signer',
    1:         '1.3.6.1.4.1.311.10.3.10': 'microsoft_qualified_subordination',
    1:         '1.3.6.1.4.1.311.10.3.11': 'microsoft_key_recovery',
    1:         '1.3.6.1.4.1.311.10.3.12': 'microsoft_document_signing',
    1:         '1.3.6.1.4.1.311.10.3.13': 'microsoft_lifetime_signing',
    1:         '1.3.6.1.4.1.311.10.3.14': 'microsoft_mobile_device_software',
               # https://support.microsoft.com/en-us/help/287547/object-ids-associated-with-microsoft-cryptography
    1:         '1.3.6.1.4.1.311.20.2.2': 'microsoft_smart_card_logon',
               # https://opensource.apple.com/source
               #  - /Security/Security-57031.40.6/Security/libsecurity_keychain/lib/SecPolicy.cpp
               #  - /libsecurity_cssm/libsecurity_cssm-36064/lib/oidsalg.c
    1:         '1.2.840.113635.100.1.2': 'apple_x509_basic',
    1:         '1.2.840.113635.100.1.3': 'apple_ssl',
    1:         '1.2.840.113635.100.1.4': 'apple_local_cert_gen',
    1:         '1.2.840.113635.100.1.5': 'apple_csr_gen',
    1:         '1.2.840.113635.100.1.6': 'apple_revocation_crl',
    1:         '1.2.840.113635.100.1.7': 'apple_revocation_ocsp',
    1:         '1.2.840.113635.100.1.8': 'apple_smime',
    1:         '1.2.840.113635.100.1.9': 'apple_eap',
    1:         '1.2.840.113635.100.1.10': 'apple_software_update_signing',
    1:         '1.2.840.113635.100.1.11': 'apple_ipsec',
    1:         '1.2.840.113635.100.1.12': 'apple_ichat',
    1:         '1.2.840.113635.100.1.13': 'apple_resource_signing',
    1:         '1.2.840.113635.100.1.14': 'apple_pkinit_client',
    1:         '1.2.840.113635.100.1.15': 'apple_pkinit_server',
    1:         '1.2.840.113635.100.1.16': 'apple_code_signing',
    1:         '1.2.840.113635.100.1.17': 'apple_package_signing',
    1:         '1.2.840.113635.100.1.18': 'apple_id_validation',
    1:         '1.2.840.113635.100.1.20': 'apple_time_stamping',
    1:         '1.2.840.113635.100.1.21': 'apple_revocation',
    1:         '1.2.840.113635.100.1.22': 'apple_passbook_signing',
    1:         '1.2.840.113635.100.1.23': 'apple_mobile_store',
    1:         '1.2.840.113635.100.1.24': 'apple_escrow_service',
    1:         '1.2.840.113635.100.1.25': 'apple_profile_signer',
    1:         '1.2.840.113635.100.1.26': 'apple_qa_profile_signer',
    1:         '1.2.840.113635.100.1.27': 'apple_test_mobile_store',
    1:         '1.2.840.113635.100.1.28': 'apple_otapki_signer',
    1:         '1.2.840.113635.100.1.29': 'apple_test_otapki_signer',
    1:         '1.2.840.113625.100.1.30': 'apple_id_validation_record_signing_policy',
    1:         '1.2.840.113625.100.1.31': 'apple_smp_encryption',
    1:         '1.2.840.113625.100.1.32': 'apple_test_smp_encryption',
    1:         '1.2.840.113635.100.1.33': 'apple_server_authentication',
    1:         '1.2.840.113635.100.1.34': 'apple_pcs_escrow_service',
               # http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.201-2.pdf
    1:         '2.16.840.1.101.3.6.8': 'piv_card_authentication',
    1:         '2.16.840.1.101.3.6.7': 'piv_content_signing',
               # https://tools.ietf.org/html/rfc4556.html
    1:         '1.3.6.1.5.2.3.4': 'pkinit_kpclientauth',
    1:         '1.3.6.1.5.2.3.5': 'pkinit_kpkdc',
               # https://www.adobe.com/devnet-docs/acrobatetk/tools/DigSig/changes.html
    1:         '1.2.840.113583.1.1.5': 'adobe_authentic_documents_trust',
               # https://www.idmanagement.gov/wp-content/uploads/sites/1171/uploads/fpki-pivi-cert-profiles.pdf
    1:         '2.16.840.1.101.3.8.7': 'fpki_pivi_content_signing'
           }
       
       
    2: class ExtKeyUsageSyntax(SequenceOf):
    1:     _child_spec = KeyPurposeId
       
       
    2: class AccessMethod(ObjectIdentifier):
    1:     _map = {
    1:         '1.3.6.1.5.5.7.48.1': 'ocsp',
    1:         '1.3.6.1.5.5.7.48.2': 'ca_issuers',
    1:         '1.3.6.1.5.5.7.48.3': 'time_stamping',
    1:         '1.3.6.1.5.5.7.48.5': 'ca_repository',
           }
       
       
    2: class AccessDescription(Sequence):
    1:     _fields = [
    1:         ('access_method', AccessMethod),
    1:         ('access_location', GeneralName),
           ]
       
       
    2: class AuthorityInfoAccessSyntax(SequenceOf):
    1:     _child_spec = AccessDescription
       
       
    2: class SubjectInfoAccessSyntax(SequenceOf):
    1:     _child_spec = AccessDescription
       
       
       # https://tools.ietf.org/html/rfc7633
    2: class Features(SequenceOf):
    1:     _child_spec = Integer
       
       
    2: class EntrustVersionInfo(Sequence):
    1:     _fields = [
    1:         ('entrust_vers', GeneralString),
    1:         ('entrust_info_flags', BitString)
           ]
       
       
    2: class NetscapeCertificateType(BitString):
    1:     _map = {
    1:         0: 'ssl_client',
    1:         1: 'ssl_server',
    1:         2: 'email',
    1:         3: 'object_signing',
    1:         4: 'reserved',
    1:         5: 'ssl_ca',
    1:         6: 'email_ca',
    1:         7: 'object_signing_ca',
           }
       
       
    2: class Version(Integer):
    1:     _map = {
    1:         0: 'v1',
    1:         1: 'v2',
    1:         2: 'v3',
           }
       
       
    2: class TPMSpecification(Sequence):
    1:     _fields = [
    1:         ('family', UTF8String),
    1:         ('level', Integer),
    1:         ('revision', Integer),
           ]
       
       
    2: class SetOfTPMSpecification(SetOf):
    1:     _child_spec = TPMSpecification
       
       
    2: class TCGSpecificationVersion(Sequence):
    1:     _fields = [
    1:         ('major_version', Integer),
    1:         ('minor_version', Integer),
    1:         ('revision', Integer),
           ]
       
       
    2: class TCGPlatformSpecification(Sequence):
    1:     _fields = [
    1:         ('version', TCGSpecificationVersion),
    1:         ('platform_class', OctetString),
           ]
       
       
    2: class SetOfTCGPlatformSpecification(SetOf):
    1:     _child_spec = TCGPlatformSpecification
       
       
    2: class EKGenerationType(Enumerated):
    1:     _map = {
    1:         0: 'internal',
    1:         1: 'injected',
    1:         2: 'internal_revocable',
    1:         3: 'injected_revocable',
           }
       
       
    2: class EKGenerationLocation(Enumerated):
    1:     _map = {
    1:         0: 'tpm_manufacturer',
    1:         1: 'platform_manufacturer',
    1:         2: 'ek_cert_signer',
           }
       
       
    2: class EKCertificateGenerationLocation(Enumerated):
    1:     _map = {
    1:         0: 'tpm_manufacturer',
    1:         1: 'platform_manufacturer',
    1:         2: 'ek_cert_signer',
           }
       
       
    2: class EvaluationAssuranceLevel(Enumerated):
    1:     _map = {
    1:         1: 'level1',
    1:         2: 'level2',
    1:         3: 'level3',
    1:         4: 'level4',
    1:         5: 'level5',
    1:         6: 'level6',
    1:         7: 'level7',
           }
       
       
    2: class EvaluationStatus(Enumerated):
    1:     _map = {
    1:         0: 'designed_to_meet',
    1:         1: 'evaluation_in_progress',
    1:         2: 'evaluation_completed',
           }
       
       
    2: class StrengthOfFunction(Enumerated):
    1:     _map = {
    1:         0: 'basic',
    1:         1: 'medium',
    1:         2: 'high',
           }
       
       
    2: class URIReference(Sequence):
    1:     _fields = [
    1:         ('uniform_resource_identifier', IA5String),
    1:         ('hash_algorithm', DigestAlgorithm, {'optional': True}),
    1:         ('hash_value', BitString, {'optional': True}),
           ]
       
       
    2: class CommonCriteriaMeasures(Sequence):
    1:     _fields = [
    1:         ('version', IA5String),
    1:         ('assurance_level', EvaluationAssuranceLevel),
    1:         ('evaluation_status', EvaluationStatus),
    1:         ('plus', Boolean, {'default': False}),
    1:         ('strengh_of_function', StrengthOfFunction, {'implicit': 0, 'optional': True}),
    1:         ('profile_oid', ObjectIdentifier, {'implicit': 1, 'optional': True}),
    1:         ('profile_url', URIReference, {'implicit': 2, 'optional': True}),
    1:         ('target_oid', ObjectIdentifier, {'implicit': 3, 'optional': True}),
    1:         ('target_uri', URIReference, {'implicit': 4, 'optional': True}),
           ]
       
       
    2: class SecurityLevel(Enumerated):
    1:     _map = {
    1:         1: 'level1',
    1:         2: 'level2',
    1:         3: 'level3',
    1:         4: 'level4',
           }
       
       
    2: class FIPSLevel(Sequence):
    1:     _fields = [
    1:         ('version', IA5String),
    1:         ('level', SecurityLevel),
    1:         ('plus', Boolean, {'default': False}),
           ]
       
       
    2: class TPMSecurityAssertions(Sequence):
    1:     _fields = [
    1:         ('version', Version, {'default': 'v1'}),
    1:         ('field_upgradable', Boolean, {'default': False}),
    1:         ('ek_generation_type', EKGenerationType, {'implicit': 0, 'optional': True}),
    1:         ('ek_generation_location', EKGenerationLocation, {'implicit': 1, 'optional': True}),
    1:         ('ek_certificate_generation_location', EKCertificateGenerationLocation, {'implicit': 2, 'optional': True}),
    1:         ('cc_info', CommonCriteriaMeasures, {'implicit': 3, 'optional': True}),
    1:         ('fips_level', FIPSLevel, {'implicit': 4, 'optional': True}),
    1:         ('iso_9000_certified', Boolean, {'implicit': 5, 'default': False}),
    1:         ('iso_9000_uri', IA5String, {'optional': True}),
           ]
       
       
    2: class SetOfTPMSecurityAssertions(SetOf):
    1:     _child_spec = TPMSecurityAssertions
       
       
    2: class SubjectDirectoryAttributeId(ObjectIdentifier):
    1:     _map = {
               # https://tools.ietf.org/html/rfc2256#page-11
    1:         '2.5.4.52': 'supported_algorithms',
               # https://www.trustedcomputinggroup.org/wp-content/uploads/Credential_Profile_EK_V2.0_R14_published.pdf
    1:         '2.23.133.2.16': 'tpm_specification',
    1:         '2.23.133.2.17': 'tcg_platform_specification',
    1:         '2.23.133.2.18': 'tpm_security_assertions',
               # https://tools.ietf.org/html/rfc3739#page-18
    1:         '1.3.6.1.5.5.7.9.1': 'pda_date_of_birth',
    1:         '1.3.6.1.5.5.7.9.2': 'pda_place_of_birth',
    1:         '1.3.6.1.5.5.7.9.3': 'pda_gender',
    1:         '1.3.6.1.5.5.7.9.4': 'pda_country_of_citizenship',
    1:         '1.3.6.1.5.5.7.9.5': 'pda_country_of_residence',
               # https://holtstrom.com/michael/tools/asn1decoder.php
    1:         '1.2.840.113533.7.68.29': 'entrust_user_role',
           }
       
       
    2: class SetOfGeneralizedTime(SetOf):
    1:     _child_spec = GeneralizedTime
       
       
    2: class SetOfDirectoryString(SetOf):
    1:     _child_spec = DirectoryString
       
       
    2: class SetOfPrintableString(SetOf):
    1:     _child_spec = PrintableString
       
       
    2: class SupportedAlgorithm(Sequence):
    1:     _fields = [
    1:         ('algorithm_identifier', AnyAlgorithmIdentifier),
    1:         ('intended_usage', KeyUsage, {'explicit': 0, 'optional': True}),
    1:         ('intended_certificate_policies', CertificatePolicies, {'explicit': 1, 'optional': True}),
           ]
       
       
    2: class SetOfSupportedAlgorithm(SetOf):
    1:     _child_spec = SupportedAlgorithm
       
       
    2: class SubjectDirectoryAttribute(Sequence):
    1:     _fields = [
    1:         ('type', SubjectDirectoryAttributeId),
    1:         ('values', Any),
           ]
       
    1:     _oid_pair = ('type', 'values')
    1:     _oid_specs = {
    1:         'supported_algorithms': SetOfSupportedAlgorithm,
    1:         'tpm_specification': SetOfTPMSpecification,
    1:         'tcg_platform_specification': SetOfTCGPlatformSpecification,
    1:         'tpm_security_assertions': SetOfTPMSecurityAssertions,
    1:         'pda_date_of_birth': SetOfGeneralizedTime,
    1:         'pda_place_of_birth': SetOfDirectoryString,
    1:         'pda_gender': SetOfPrintableString,
    1:         'pda_country_of_citizenship': SetOfPrintableString,
    1:         'pda_country_of_residence': SetOfPrintableString,
           }
       
    1:     def _values_spec(self):
>>>>>>         type_ = self['type'].native
>>>>>>         if type_ in self._oid_specs:
>>>>>>             return self._oid_specs[type_]
>>>>>>         return SetOf
       
    1:     _spec_callbacks = {
    1:         'values': _values_spec
           }
       
       
    2: class SubjectDirectoryAttributes(SequenceOf):
    1:     _child_spec = SubjectDirectoryAttribute
       
       
    2: class ExtensionId(ObjectIdentifier):
    1:     _map = {
    1:         '2.5.29.9': 'subject_directory_attributes',
    1:         '2.5.29.14': 'key_identifier',
    1:         '2.5.29.15': 'key_usage',
    1:         '2.5.29.16': 'private_key_usage_period',
    1:         '2.5.29.17': 'subject_alt_name',
    1:         '2.5.29.18': 'issuer_alt_name',
    1:         '2.5.29.19': 'basic_constraints',
    1:         '2.5.29.30': 'name_constraints',
    1:         '2.5.29.31': 'crl_distribution_points',
    1:         '2.5.29.32': 'certificate_policies',
    1:         '2.5.29.33': 'policy_mappings',
    1:         '2.5.29.35': 'authority_key_identifier',
    1:         '2.5.29.36': 'policy_constraints',
    1:         '2.5.29.37': 'extended_key_usage',
    1:         '2.5.29.46': 'freshest_crl',
    1:         '2.5.29.54': 'inhibit_any_policy',
    1:         '1.3.6.1.5.5.7.1.1': 'authority_information_access',
    1:         '1.3.6.1.5.5.7.1.11': 'subject_information_access',
               # https://tools.ietf.org/html/rfc7633
    1:         '1.3.6.1.5.5.7.1.24': 'tls_feature',
    1:         '1.3.6.1.5.5.7.48.1.5': 'ocsp_no_check',
    1:         '1.2.840.113533.7.65.0': 'entrust_version_extension',
    1:         '2.16.840.1.113730.1.1': 'netscape_certificate_type',
               # https://tools.ietf.org/html/rfc6962.html#page-14
    1:         '1.3.6.1.4.1.11129.2.4.2': 'signed_certificate_timestamp_list',
               # https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wcce/3aec3e50-511a-42f9-a5d5-240af503e470
    1:         '1.3.6.1.4.1.311.20.2': 'microsoft_enroll_certtype',
           }
       
       
    2: class Extension(Sequence):
    1:     _fields = [
    1:         ('extn_id', ExtensionId),
    1:         ('critical', Boolean, {'default': False}),
    1:         ('extn_value', ParsableOctetString),
           ]
       
    1:     _oid_pair = ('extn_id', 'extn_value')
    1:     _oid_specs = {
    1:         'subject_directory_attributes': SubjectDirectoryAttributes,
    1:         'key_identifier': OctetString,
    1:         'key_usage': KeyUsage,
    1:         'private_key_usage_period': PrivateKeyUsagePeriod,
    1:         'subject_alt_name': GeneralNames,
    1:         'issuer_alt_name': GeneralNames,
    1:         'basic_constraints': BasicConstraints,
    1:         'name_constraints': NameConstraints,
    1:         'crl_distribution_points': CRLDistributionPoints,
    1:         'certificate_policies': CertificatePolicies,
    1:         'policy_mappings': PolicyMappings,
    1:         'authority_key_identifier': AuthorityKeyIdentifier,
    1:         'policy_constraints': PolicyConstraints,
    1:         'extended_key_usage': ExtKeyUsageSyntax,
    1:         'freshest_crl': CRLDistributionPoints,
    1:         'inhibit_any_policy': Integer,
    1:         'authority_information_access': AuthorityInfoAccessSyntax,
    1:         'subject_information_access': SubjectInfoAccessSyntax,
    1:         'tls_feature': Features,
    1:         'ocsp_no_check': Null,
    1:         'entrust_version_extension': EntrustVersionInfo,
    1:         'netscape_certificate_type': NetscapeCertificateType,
    1:         'signed_certificate_timestamp_list': OctetString,
               # Not UTF8String as Microsofts docs claim, see:
               # https://www.alvestrand.no/objectid/1.3.6.1.4.1.311.20.2.html
    1:         'microsoft_enroll_certtype': BMPString,
           }
       
       
    2: class Extensions(SequenceOf):
    1:     _child_spec = Extension
       
       
    2: class TbsCertificate(Sequence):
    1:     _fields = [
    1:         ('version', Version, {'explicit': 0, 'default': 'v1'}),
    1:         ('serial_number', Integer),
    1:         ('signature', SignedDigestAlgorithm),
    1:         ('issuer', Name),
    1:         ('validity', Validity),
    1:         ('subject', Name),
    1:         ('subject_public_key_info', PublicKeyInfo),
    1:         ('issuer_unique_id', OctetBitString, {'implicit': 1, 'optional': True}),
    1:         ('subject_unique_id', OctetBitString, {'implicit': 2, 'optional': True}),
    1:         ('extensions', Extensions, {'explicit': 3, 'optional': True}),
           ]
       
       
    2: class Certificate(Sequence):
    1:     _fields = [
    1:         ('tbs_certificate', TbsCertificate),
    1:         ('signature_algorithm', SignedDigestAlgorithm),
    1:         ('signature_value', OctetBitString),
           ]
       
    1:     _processed_extensions = False
    1:     _critical_extensions = None
    1:     _subject_directory_attributes_value = None
    1:     _key_identifier_value = None
    1:     _key_usage_value = None
    1:     _subject_alt_name_value = None
    1:     _issuer_alt_name_value = None
    1:     _basic_constraints_value = None
    1:     _name_constraints_value = None
    1:     _crl_distribution_points_value = None
    1:     _certificate_policies_value = None
    1:     _policy_mappings_value = None
    1:     _authority_key_identifier_value = None
    1:     _policy_constraints_value = None
    1:     _freshest_crl_value = None
    1:     _inhibit_any_policy_value = None
    1:     _extended_key_usage_value = None
    1:     _authority_information_access_value = None
    1:     _subject_information_access_value = None
    1:     _private_key_usage_period_value = None
    1:     _tls_feature_value = None
    1:     _ocsp_no_check_value = None
    1:     _issuer_serial = None
    1:     _authority_issuer_serial = False
    1:     _crl_distribution_points = None
    1:     _delta_crl_distribution_points = None
    1:     _valid_domains = None
    1:     _valid_ips = None
    1:     _self_issued = None
    1:     _self_signed = None
    1:     _sha1 = None
    1:     _sha256 = None
       
    1:     def _set_extensions(self):
               """
               Sets common named extensions to private attributes and creates a list
               of critical extensions
               """
       
>>>>>>         self._critical_extensions = set()
       
>>>>>>         for extension in self['tbs_certificate']['extensions']:
>>>>>>             name = extension['extn_id'].native
>>>>>>             attribute_name = '_%s_value' % name
>>>>>>             if hasattr(self, attribute_name):
>>>>>>                 setattr(self, attribute_name, extension['extn_value'].parsed)
>>>>>>             if extension['critical'].native:
>>>>>>                 self._critical_extensions.add(name)
       
>>>>>>         self._processed_extensions = True
       
    1:     @property
    1:     def critical_extensions(self):
               """
               Returns a set of the names (or OID if not a known extension) of the
               extensions marked as critical
       
               :return:
                   A set of unicode strings
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._critical_extensions
       
    1:     @property
    1:     def private_key_usage_period_value(self):
               """
               This extension is used to constrain the period over which the subject
               private key may be used
       
               :return:
                   None or a PrivateKeyUsagePeriod object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._private_key_usage_period_value
       
    1:     @property
    1:     def subject_directory_attributes_value(self):
               """
               This extension is used to contain additional identification attributes
               about the subject.
       
               :return:
                   None or a SubjectDirectoryAttributes object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._subject_directory_attributes_value
       
    1:     @property
    1:     def key_identifier_value(self):
               """
               This extension is used to help in creating certificate validation paths.
               It contains an identifier that should generally, but is not guaranteed
               to, be unique.
       
               :return:
                   None or an OctetString object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._key_identifier_value
       
    1:     @property
    1:     def key_usage_value(self):
               """
               This extension is used to define the purpose of the public key
               contained within the certificate.
       
               :return:
                   None or a KeyUsage
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._key_usage_value
       
    1:     @property
    1:     def subject_alt_name_value(self):
               """
               This extension allows for additional names to be associate with the
               subject of the certificate. While it may contain a whole host of
               possible names, it is usually used to allow certificates to be used
               with multiple different domain names.
       
               :return:
                   None or a GeneralNames object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._subject_alt_name_value
       
    1:     @property
    1:     def issuer_alt_name_value(self):
               """
               This extension allows associating one or more alternative names with
               the issuer of the certificate.
       
               :return:
                   None or an x509.GeneralNames object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._issuer_alt_name_value
       
    1:     @property
    1:     def basic_constraints_value(self):
               """
               This extension is used to determine if the subject of the certificate
               is a CA, and if so, what the maximum number of intermediate CA certs
               after this are, before an end-entity certificate is found.
       
               :return:
                   None or a BasicConstraints object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._basic_constraints_value
       
    1:     @property
    1:     def name_constraints_value(self):
               """
               This extension is used in CA certificates, and is used to limit the
               possible names of certificates issued.
       
               :return:
                   None or a NameConstraints object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._name_constraints_value
       
    1:     @property
    1:     def crl_distribution_points_value(self):
               """
               This extension is used to help in locating the CRL for this certificate.
       
               :return:
                   None or a CRLDistributionPoints object
                   extension
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._crl_distribution_points_value
       
    1:     @property
    1:     def certificate_policies_value(self):
               """
               This extension defines policies in CA certificates under which
               certificates may be issued. In end-entity certificates, the inclusion
               of a policy indicates the issuance of the certificate follows the
               policy.
       
               :return:
                   None or a CertificatePolicies object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._certificate_policies_value
       
    1:     @property
    1:     def policy_mappings_value(self):
               """
               This extension allows mapping policy OIDs to other OIDs. This is used
               to allow different policies to be treated as equivalent in the process
               of validation.
       
               :return:
                   None or a PolicyMappings object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._policy_mappings_value
       
    1:     @property
    1:     def authority_key_identifier_value(self):
               """
               This extension helps in identifying the public key with which to
               validate the authenticity of the certificate.
       
               :return:
                   None or an AuthorityKeyIdentifier object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._authority_key_identifier_value
       
    1:     @property
    1:     def policy_constraints_value(self):
               """
               This extension is used to control if policy mapping is allowed and
               when policies are required.
       
               :return:
                   None or a PolicyConstraints object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._policy_constraints_value
       
    1:     @property
    1:     def freshest_crl_value(self):
               """
               This extension is used to help locate any available delta CRLs
       
               :return:
                   None or an CRLDistributionPoints object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._freshest_crl_value
       
    1:     @property
    1:     def inhibit_any_policy_value(self):
               """
               This extension is used to prevent mapping of the any policy to
               specific requirements
       
               :return:
                   None or a Integer object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._inhibit_any_policy_value
       
    1:     @property
    1:     def extended_key_usage_value(self):
               """
               This extension is used to define additional purposes for the public key
               beyond what is contained in the basic constraints.
       
               :return:
                   None or an ExtKeyUsageSyntax object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._extended_key_usage_value
       
    1:     @property
    1:     def authority_information_access_value(self):
               """
               This extension is used to locate the CA certificate used to sign this
               certificate, or the OCSP responder for this certificate.
       
               :return:
                   None or an AuthorityInfoAccessSyntax object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._authority_information_access_value
       
    1:     @property
    1:     def subject_information_access_value(self):
               """
               This extension is used to access information about the subject of this
               certificate.
       
               :return:
                   None or a SubjectInfoAccessSyntax object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._subject_information_access_value
       
    1:     @property
    1:     def tls_feature_value(self):
               """
               This extension is used to list the TLS features a server must respond
               with if a client initiates a request supporting them.
       
               :return:
                   None or a Features object
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._tls_feature_value
       
    1:     @property
    1:     def ocsp_no_check_value(self):
               """
               This extension is used on certificates of OCSP responders, indicating
               that revocation information for the certificate should never need to
               be verified, thus preventing possible loops in path validation.
       
               :return:
                   None or a Null object (if present)
               """
       
>>>>>>         if not self._processed_extensions:
>>>>>>             self._set_extensions()
>>>>>>         return self._ocsp_no_check_value
       
    1:     @property
    1:     def signature(self):
               """
               :return:
                   A byte string of the signature
               """
       
>>>>>>         return self['signature_value'].native
       
    1:     @property
    1:     def signature_algo(self):
               """
               :return:
                   A unicode string of "rsassa_pkcs1v15", "rsassa_pss", "dsa", "ecdsa"
               """
       
>>>>>>         return self['signature_algorithm'].signature_algo
       
    1:     @property
    1:     def hash_algo(self):
               """
               :return:
                   A unicode string of "md2", "md5", "sha1", "sha224", "sha256",
                   "sha384", "sha512", "sha512_224", "sha512_256"
               """
       
>>>>>>         return self['signature_algorithm'].hash_algo
       
    1:     @property
    1:     def public_key(self):
               """
               :return:
                   The PublicKeyInfo object for this certificate
               """
       
>>>>>>         return self['tbs_certificate']['subject_public_key_info']
       
    1:     @property
    1:     def subject(self):
               """
               :return:
                   The Name object for the subject of this certificate
               """
       
>>>>>>         return self['tbs_certificate']['subject']
       
    1:     @property
    1:     def issuer(self):
               """
               :return:
                   The Name object for the issuer of this certificate
               """
       
>>>>>>         return self['tbs_certificate']['issuer']
       
    1:     @property
    1:     def serial_number(self):
               """
               :return:
                   An integer of the certificate's serial number
               """
       
>>>>>>         return self['tbs_certificate']['serial_number'].native
       
    1:     @property
    1:     def key_identifier(self):
               """
               :return:
                   None or a byte string of the certificate's key identifier from the
                   key identifier extension
               """
       
>>>>>>         if not self.key_identifier_value:
>>>>>>             return None
       
>>>>>>         return self.key_identifier_value.native
       
    1:     @property
    1:     def issuer_serial(self):
               """
               :return:
                   A byte string of the SHA-256 hash of the issuer concatenated with
                   the ascii character ":", concatenated with the serial number as
                   an ascii string
               """
       
>>>>>>         if self._issuer_serial is None:
>>>>>>             self._issuer_serial = self.issuer.sha256 + b':' + str_cls(self.serial_number).encode('ascii')
>>>>>>         return self._issuer_serial
       
    1:     @property
    1:     def not_valid_after(self):
               """
               :return:
                   A datetime of latest time when the certificate is still valid
               """
>>>>>>         return self['tbs_certificate']['validity']['not_after'].native
       
    1:     @property
    1:     def not_valid_before(self):
               """
               :return:
                   A datetime of the earliest time when the certificate is valid
               """
>>>>>>         return self['tbs_certificate']['validity']['not_before'].native
       
    1:     @property
    1:     def authority_key_identifier(self):
               """
               :return:
                   None or a byte string of the key_identifier from the authority key
                   identifier extension
               """
       
>>>>>>         if not self.authority_key_identifier_value:
>>>>>>             return None
       
>>>>>>         return self.authority_key_identifier_value['key_identifier'].native
       
    1:     @property
    1:     def authority_issuer_serial(self):
               """
               :return:
                   None or a byte string of the SHA-256 hash of the isser from the
                   authority key identifier extension concatenated with the ascii
                   character ":", concatenated with the serial number from the
                   authority key identifier extension as an ascii string
               """
       
>>>>>>         if self._authority_issuer_serial is False:
>>>>>>             akiv = self.authority_key_identifier_value
>>>>>>             if akiv and akiv['authority_cert_issuer'].native:
>>>>>>                 issuer = self.authority_key_identifier_value['authority_cert_issuer'][0].chosen
                       # We untag the element since it is tagged via being a choice from GeneralName
>>>>>>                 issuer = issuer.untag()
>>>>>>                 authority_serial = self.authority_key_identifier_value['authority_cert_serial_number'].native
>>>>>>                 self._authority_issuer_serial = issuer.sha256 + b':' + str_cls(authority_serial).encode('ascii')
                   else:
>>>>>>                 self._authority_issuer_serial = None
>>>>>>         return self._authority_issuer_serial
       
    1:     @property
    1:     def crl_distribution_points(self):
               """
               Returns complete CRL URLs - does not include delta CRLs
       
               :return:
                   A list of zero or more DistributionPoint objects
               """
       
>>>>>>         if self._crl_distribution_points is None:
>>>>>>             self._crl_distribution_points = self._get_http_crl_distribution_points(self.crl_distribution_points_value)
>>>>>>         return self._crl_distribution_points
       
    1:     @property
    1:     def delta_crl_distribution_points(self):
               """
               Returns delta CRL URLs - does not include complete CRLs
       
               :return:
                   A list of zero or more DistributionPoint objects
               """
       
>>>>>>         if self._delta_crl_distribution_points is None:
>>>>>>             self._delta_crl_distribution_points = self._get_http_crl_distribution_points(self.freshest_crl_value)
>>>>>>         return self._delta_crl_distribution_points
       
    1:     def _get_http_crl_distribution_points(self, crl_distribution_points):
               """
               Fetches the DistributionPoint object for non-relative, HTTP CRLs
               referenced by the certificate
       
               :param crl_distribution_points:
                   A CRLDistributionPoints object to grab the DistributionPoints from
       
               :return:
                   A list of zero or more DistributionPoint objects
               """
       
>>>>>>         output = []
       
>>>>>>         if crl_distribution_points is None:
>>>>>>             return []
       
>>>>>>         for distribution_point in crl_distribution_points:
>>>>>>             distribution_point_name = distribution_point['distribution_point']
>>>>>>             if distribution_point_name is VOID:
>>>>>>                 continue
                   # RFC 5280 indicates conforming CA should not use the relative form
>>>>>>             if distribution_point_name.name == 'name_relative_to_crl_issuer':
>>>>>>                 continue
                   # This library is currently only concerned with HTTP-based CRLs
>>>>>>             for general_name in distribution_point_name.chosen:
>>>>>>                 if general_name.name == 'uniform_resource_identifier':
>>>>>>                     output.append(distribution_point)
       
>>>>>>         return output
       
    1:     @property
    1:     def ocsp_urls(self):
               """
               :return:
                   A list of zero or more unicode strings of the OCSP URLs for this
                   cert
               """
       
>>>>>>         if not self.authority_information_access_value:
>>>>>>             return []
       
>>>>>>         output = []
>>>>>>         for entry in self.authority_information_access_value:
>>>>>>             if entry['access_method'].native == 'ocsp':
>>>>>>                 location = entry['access_location']
>>>>>>                 if location.name != 'uniform_resource_identifier':
>>>>>>                     continue
>>>>>>                 url = location.native
>>>>>>                 if url.lower().startswith(('http://', 'https://', 'ldap://', 'ldaps://')):
>>>>>>                     output.append(url)
>>>>>>         return output
       
    1:     @property
    1:     def valid_domains(self):
               """
               :return:
                   A list of unicode strings of valid domain names for the certificate.
                   Wildcard certificates will have a domain in the form: *.example.com
               """
       
>>>>>>         if self._valid_domains is None:
>>>>>>             self._valid_domains = []
       
                   # For the subject alt name extension, we can look at the name of
                   # the choice selected since it distinguishes between domain names,
                   # email addresses, IPs, etc
>>>>>>             if self.subject_alt_name_value:
>>>>>>                 for general_name in self.subject_alt_name_value:
>>>>>>                     if general_name.name == 'dns_name' and general_name.native not in self._valid_domains:
>>>>>>                         self._valid_domains.append(general_name.native)
       
                   # If there was no subject alt name extension, and the common name
                   # in the subject looks like a domain, that is considered the valid
                   # list. This is done because according to
                   # https://tools.ietf.org/html/rfc6125#section-6.4.4, the common
                   # name should not be used if the subject alt name is present.
                   else:
>>>>>>                 pattern = re.compile('^(\\*\\.)?(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$')
>>>>>>                 for rdn in self.subject.chosen:
>>>>>>                     for name_type_value in rdn:
>>>>>>                         if name_type_value['type'].native == 'common_name':
>>>>>>                             value = name_type_value['value'].native
>>>>>>                             if pattern.match(value):
>>>>>>                                 self._valid_domains.append(value)
       
>>>>>>         return self._valid_domains
       
    1:     @property
    1:     def valid_ips(self):
               """
               :return:
                   A list of unicode strings of valid IP addresses for the certificate
               """
       
>>>>>>         if self._valid_ips is None:
>>>>>>             self._valid_ips = []
       
>>>>>>             if self.subject_alt_name_value:
>>>>>>                 for general_name in self.subject_alt_name_value:
>>>>>>                     if general_name.name == 'ip_address':
>>>>>>                         self._valid_ips.append(general_name.native)
       
>>>>>>         return self._valid_ips
       
    1:     @property
    1:     def ca(self):
               """
               :return;
                   A boolean - if the certificate is marked as a CA
               """
       
>>>>>>         return self.basic_constraints_value and self.basic_constraints_value['ca'].native
       
    1:     @property
    1:     def max_path_length(self):
               """
               :return;
                   None or an integer of the maximum path length
               """
       
>>>>>>         if not self.ca:
>>>>>>             return None
>>>>>>         return self.basic_constraints_value['path_len_constraint'].native
       
    1:     @property
    1:     def self_issued(self):
               """
               :return:
                   A boolean - if the certificate is self-issued, as defined by RFC
                   5280
               """
       
>>>>>>         if self._self_issued is None:
>>>>>>             self._self_issued = self.subject == self.issuer
>>>>>>         return self._self_issued
       
    1:     @property
    1:     def self_signed(self):
               """
               :return:
                   A unicode string of "no" or "maybe". The "maybe" result will
                   be returned if the certificate issuer and subject are the same.
                   If a key identifier and authority key identifier are present,
                   they will need to match otherwise "no" will be returned.
       
                   To verify is a certificate is truly self-signed, the signature
                   will need to be verified. See the certvalidator package for
                   one possible solution.
               """
       
>>>>>>         if self._self_signed is None:
>>>>>>             self._self_signed = 'no'
>>>>>>             if self.self_issued:
>>>>>>                 if self.key_identifier:
>>>>>>                     if not self.authority_key_identifier:
>>>>>>                         self._self_signed = 'maybe'
>>>>>>                     elif self.authority_key_identifier == self.key_identifier:
>>>>>>                         self._self_signed = 'maybe'
                       else:
>>>>>>                     self._self_signed = 'maybe'
>>>>>>         return self._self_signed
       
    1:     @property
    1:     def sha1(self):
               """
               :return:
                   The SHA-1 hash of the DER-encoded bytes of this complete certificate
               """
       
>>>>>>         if self._sha1 is None:
>>>>>>             self._sha1 = hashlib.sha1(self.dump()).digest()
>>>>>>         return self._sha1
       
    1:     @property
    1:     def sha1_fingerprint(self):
               """
               :return:
                   A unicode string of the SHA-1 hash, formatted using hex encoding
                   with a space between each pair of characters, all uppercase
               """
       
>>>>>>         return ' '.join('%02X' % c for c in bytes_to_list(self.sha1))
       
    1:     @property
    1:     def sha256(self):
               """
               :return:
                   The SHA-256 hash of the DER-encoded bytes of this complete
                   certificate
               """
       
>>>>>>         if self._sha256 is None:
>>>>>>             self._sha256 = hashlib.sha256(self.dump()).digest()
>>>>>>         return self._sha256
       
    1:     @property
    1:     def sha256_fingerprint(self):
               """
               :return:
                   A unicode string of the SHA-256 hash, formatted using hex encoding
                   with a space between each pair of characters, all uppercase
               """
       
>>>>>>         return ' '.join('%02X' % c for c in bytes_to_list(self.sha256))
       
    1:     def is_valid_domain_ip(self, domain_ip):
               """
               Check if a domain name or IP address is valid according to the
               certificate
       
               :param domain_ip:
                   A unicode string of a domain name or IP address
       
               :return:
                   A boolean - if the domain or IP is valid for the certificate
               """
       
>>>>>>         if not isinstance(domain_ip, str_cls):
>>>>>>             raise TypeError(unwrap(
>>>>>>                 '''
                       domain_ip must be a unicode string, not %s
                       ''',
>>>>>>                 type_name(domain_ip)
                   ))
       
>>>>>>         encoded_domain_ip = domain_ip.encode('idna').decode('ascii').lower()
       
>>>>>>         is_ipv6 = encoded_domain_ip.find(':') != -1
>>>>>>         is_ipv4 = not is_ipv6 and re.match('^\\d+\\.\\d+\\.\\d+\\.\\d+$', encoded_domain_ip)
>>>>>>         is_domain = not is_ipv6 and not is_ipv4
       
               # Handle domain name checks
>>>>>>         if is_domain:
>>>>>>             if not self.valid_domains:
>>>>>>                 return False
       
>>>>>>             domain_labels = encoded_domain_ip.split('.')
       
>>>>>>             for valid_domain in self.valid_domains:
>>>>>>                 encoded_valid_domain = valid_domain.encode('idna').decode('ascii').lower()
>>>>>>                 valid_domain_labels = encoded_valid_domain.split('.')
       
                       # The domain must be equal in label length to match
>>>>>>                 if len(valid_domain_labels) != len(domain_labels):
>>>>>>                     continue
       
>>>>>>                 if valid_domain_labels == domain_labels:
>>>>>>                     return True
       
>>>>>>                 is_wildcard = self._is_wildcard_domain(encoded_valid_domain)
>>>>>>                 if is_wildcard and self._is_wildcard_match(domain_labels, valid_domain_labels):
>>>>>>                     return True
       
>>>>>>             return False
       
               # Handle IP address checks
>>>>>>         if not self.valid_ips:
>>>>>>             return False
       
>>>>>>         family = socket.AF_INET if is_ipv4 else socket.AF_INET6
>>>>>>         normalized_ip = inet_pton(family, encoded_domain_ip)
       
>>>>>>         for valid_ip in self.valid_ips:
>>>>>>             valid_family = socket.AF_INET if valid_ip.find('.') != -1 else socket.AF_INET6
>>>>>>             normalized_valid_ip = inet_pton(valid_family, valid_ip)
       
>>>>>>             if normalized_valid_ip == normalized_ip:
>>>>>>                 return True
       
>>>>>>         return False
       
    1:     def _is_wildcard_domain(self, domain):
               """
               Checks if a domain is a valid wildcard according to
               https://tools.ietf.org/html/rfc6125#section-6.4.3
       
               :param domain:
                   A unicode string of the domain name, where any U-labels from an IDN
                   have been converted to A-labels
       
               :return:
                   A boolean - if the domain is a valid wildcard domain
               """
       
               # The * character must be present for a wildcard match, and if there is
               # most than one, it is an invalid wildcard specification
>>>>>>         if domain.count('*') != 1:
>>>>>>             return False
       
>>>>>>         labels = domain.lower().split('.')
       
>>>>>>         if not labels:
>>>>>>             return False
       
               # Wildcards may only appear in the left-most label
>>>>>>         if labels[0].find('*') == -1:
>>>>>>             return False
       
               # Wildcards may not be embedded in an A-label from an IDN
>>>>>>         if labels[0][0:4] == 'xn--':
>>>>>>             return False
       
>>>>>>         return True
       
    1:     def _is_wildcard_match(self, domain_labels, valid_domain_labels):
               """
               Determines if the labels in a domain are a match for labels from a
               wildcard valid domain name
       
               :param domain_labels:
                   A list of unicode strings, with A-label form for IDNs, of the labels
                   in the domain name to check
       
               :param valid_domain_labels:
                   A list of unicode strings, with A-label form for IDNs, of the labels
                   in a wildcard domain pattern
       
               :return:
                   A boolean - if the domain matches the valid domain
               """
       
>>>>>>         first_domain_label = domain_labels[0]
>>>>>>         other_domain_labels = domain_labels[1:]
       
>>>>>>         wildcard_label = valid_domain_labels[0]
>>>>>>         other_valid_domain_labels = valid_domain_labels[1:]
       
               # The wildcard is only allowed in the first label, so if
               # The subsequent labels are not equal, there is no match
>>>>>>         if other_domain_labels != other_valid_domain_labels:
>>>>>>             return False
       
>>>>>>         if wildcard_label == '*':
>>>>>>             return True
       
>>>>>>         wildcard_regex = re.compile('^' + wildcard_label.replace('*', '.*') + '$')
>>>>>>         if wildcard_regex.match(first_domain_label):
>>>>>>             return True
       
>>>>>>         return False
       
       
       # The structures are taken from the OpenSSL source file x_x509a.c, and specify
       # extra information that is added to X.509 certificates to store trust
       # information about the certificate.
       
    2: class KeyPurposeIdentifiers(SequenceOf):
    1:     _child_spec = KeyPurposeId
       
       
    2: class SequenceOfAlgorithmIdentifiers(SequenceOf):
    1:     _child_spec = AlgorithmIdentifier
       
       
    2: class CertificateAux(Sequence):
    1:     _fields = [
    1:         ('trust', KeyPurposeIdentifiers, {'optional': True}),
    1:         ('reject', KeyPurposeIdentifiers, {'implicit': 0, 'optional': True}),
    1:         ('alias', UTF8String, {'optional': True}),
    1:         ('keyid', OctetString, {'optional': True}),
    1:         ('other', SequenceOfAlgorithmIdentifiers, {'implicit': 1, 'optional': True}),
           ]
       
       
    2: class TrustedCertificate(Concat):
    1:     _child_specs = [Certificate, CertificateAux]
