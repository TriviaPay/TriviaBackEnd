    1: """
       Custom transports, with nicely configured defaults.
       
       The following additional keyword arguments are currently supported by httpcore...
       
       * uds: str
       * local_address: str
       * retries: int
       
       Example usages...
       
       # Disable HTTP/2 on a single specific domain.
       mounts = {
           "all://": httpx.HTTPTransport(http2=True),
           "all://*example.org": httpx.HTTPTransport()
       }
       
       # Using advanced httpcore configuration, with connection retries.
       transport = httpx.HTTPTransport(retries=1)
       client = httpx.Client(transport=transport)
       
       # Using advanced httpcore configuration, with unix domain sockets.
       transport = httpx.HTTPTransport(uds="socket.uds")
       client = httpx.Client(transport=transport)
       """
    1: import contextlib
    1: import typing
    1: from types import TracebackType
       
    1: import httpcore
       
    1: from .._config import DEFAULT_LIMITS, Limits, Proxy, create_ssl_context
    1: from .._exceptions import (
           ConnectError,
           ConnectTimeout,
           LocalProtocolError,
           NetworkError,
           PoolTimeout,
           ProtocolError,
           ProxyError,
           ReadError,
           ReadTimeout,
           RemoteProtocolError,
           TimeoutException,
           UnsupportedProtocol,
           WriteError,
           WriteTimeout,
       )
    1: from .._models import Request, Response
    1: from .._types import AsyncByteStream, CertTypes, SyncByteStream, VerifyTypes
    1: from .base import AsyncBaseTransport, BaseTransport
       
    1: T = typing.TypeVar("T", bound="HTTPTransport")
    1: A = typing.TypeVar("A", bound="AsyncHTTPTransport")
       
    2: SOCKET_OPTION = typing.Union[
    2:     typing.Tuple[int, int, int],
    1:     typing.Tuple[int, int, typing.Union[bytes, bytearray]],
    1:     typing.Tuple[int, int, None, int],
       ]
       
       
    1: @contextlib.contextmanager
    1: def map_httpcore_exceptions() -> typing.Iterator[None]:
>>>>>>     try:
>>>>>>         yield
>>>>>>     except Exception as exc:  # noqa: PIE-786
>>>>>>         mapped_exc = None
       
>>>>>>         for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
>>>>>>             if not isinstance(exc, from_exc):
>>>>>>                 continue
                   # We want to map to the most specific exception we can find.
                   # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                   # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
>>>>>>             if mapped_exc is None or issubclass(to_exc, mapped_exc):
>>>>>>                 mapped_exc = to_exc
       
>>>>>>         if mapped_exc is None:  # pragma: no cover
>>>>>>             raise
       
>>>>>>         message = str(exc)
>>>>>>         raise mapped_exc(message) from exc
       
       
    1: HTTPCORE_EXC_MAP = {
    1:     httpcore.TimeoutException: TimeoutException,
    1:     httpcore.ConnectTimeout: ConnectTimeout,
    1:     httpcore.ReadTimeout: ReadTimeout,
    1:     httpcore.WriteTimeout: WriteTimeout,
    1:     httpcore.PoolTimeout: PoolTimeout,
    1:     httpcore.NetworkError: NetworkError,
    1:     httpcore.ConnectError: ConnectError,
    1:     httpcore.ReadError: ReadError,
    1:     httpcore.WriteError: WriteError,
    1:     httpcore.ProxyError: ProxyError,
    1:     httpcore.UnsupportedProtocol: UnsupportedProtocol,
    1:     httpcore.ProtocolError: ProtocolError,
    1:     httpcore.LocalProtocolError: LocalProtocolError,
    1:     httpcore.RemoteProtocolError: RemoteProtocolError,
       }
       
       
    2: class ResponseStream(SyncByteStream):
    1:     def __init__(self, httpcore_stream: typing.Iterable[bytes]):
>>>>>>         self._httpcore_stream = httpcore_stream
       
    1:     def __iter__(self) -> typing.Iterator[bytes]:
>>>>>>         with map_httpcore_exceptions():
>>>>>>             for part in self._httpcore_stream:
>>>>>>                 yield part
       
    1:     def close(self) -> None:
>>>>>>         if hasattr(self._httpcore_stream, "close"):
>>>>>>             self._httpcore_stream.close()
       
       
    2: class HTTPTransport(BaseTransport):
    2:     def __init__(
               self,
    2:         verify: VerifyTypes = True,
    2:         cert: typing.Optional[CertTypes] = None,
    2:         http1: bool = True,
    2:         http2: bool = False,
    2:         limits: Limits = DEFAULT_LIMITS,
    2:         trust_env: bool = True,
    2:         proxy: typing.Optional[Proxy] = None,
    2:         uds: typing.Optional[str] = None,
    2:         local_address: typing.Optional[str] = None,
    2:         retries: int = 0,
    2:         socket_options: typing.Optional[typing.Iterable[SOCKET_OPTION]] = None,
    1:     ) -> None:
>>>>>>         ssl_context = create_ssl_context(verify=verify, cert=cert, trust_env=trust_env)
       
>>>>>>         if proxy is None:
>>>>>>             self._pool = httpcore.ConnectionPool(
>>>>>>                 ssl_context=ssl_context,
>>>>>>                 max_connections=limits.max_connections,
>>>>>>                 max_keepalive_connections=limits.max_keepalive_connections,
>>>>>>                 keepalive_expiry=limits.keepalive_expiry,
>>>>>>                 http1=http1,
>>>>>>                 http2=http2,
>>>>>>                 uds=uds,
>>>>>>                 local_address=local_address,
>>>>>>                 retries=retries,
>>>>>>                 socket_options=socket_options,
                   )
>>>>>>         elif proxy.url.scheme in ("http", "https"):
>>>>>>             self._pool = httpcore.HTTPProxy(
>>>>>>                 proxy_url=httpcore.URL(
>>>>>>                     scheme=proxy.url.raw_scheme,
>>>>>>                     host=proxy.url.raw_host,
>>>>>>                     port=proxy.url.port,
>>>>>>                     target=proxy.url.raw_path,
                       ),
>>>>>>                 proxy_auth=proxy.raw_auth,
>>>>>>                 proxy_headers=proxy.headers.raw,
>>>>>>                 ssl_context=ssl_context,
>>>>>>                 proxy_ssl_context=proxy.ssl_context,
>>>>>>                 max_connections=limits.max_connections,
>>>>>>                 max_keepalive_connections=limits.max_keepalive_connections,
>>>>>>                 keepalive_expiry=limits.keepalive_expiry,
>>>>>>                 http1=http1,
>>>>>>                 http2=http2,
>>>>>>                 socket_options=socket_options,
                   )
>>>>>>         elif proxy.url.scheme == "socks5":
>>>>>>             try:
>>>>>>                 import socksio  # noqa
>>>>>>             except ImportError:  # pragma: no cover
>>>>>>                 raise ImportError(
>>>>>>                     "Using SOCKS proxy, but the 'socksio' package is not installed. "
                           "Make sure to install httpx using `pip install httpx[socks]`."
>>>>>>                 ) from None
       
>>>>>>             self._pool = httpcore.SOCKSProxy(
>>>>>>                 proxy_url=httpcore.URL(
>>>>>>                     scheme=proxy.url.raw_scheme,
>>>>>>                     host=proxy.url.raw_host,
>>>>>>                     port=proxy.url.port,
>>>>>>                     target=proxy.url.raw_path,
                       ),
>>>>>>                 proxy_auth=proxy.raw_auth,
>>>>>>                 ssl_context=ssl_context,
>>>>>>                 max_connections=limits.max_connections,
>>>>>>                 max_keepalive_connections=limits.max_keepalive_connections,
>>>>>>                 keepalive_expiry=limits.keepalive_expiry,
>>>>>>                 http1=http1,
>>>>>>                 http2=http2,
                   )
               else:  # pragma: no cover
>>>>>>             raise ValueError(
>>>>>>                 f"Proxy protocol must be either 'http', 'https', or 'socks5', but got {proxy.url.scheme!r}."
                   )
       
    1:     def __enter__(self: T) -> T:  # Use generics for subclass support.
>>>>>>         self._pool.__enter__()
>>>>>>         return self
       
    2:     def __exit__(
               self,
    1:         exc_type: typing.Optional[typing.Type[BaseException]] = None,
    1:         exc_value: typing.Optional[BaseException] = None,
    1:         traceback: typing.Optional[TracebackType] = None,
    1:     ) -> None:
>>>>>>         with map_httpcore_exceptions():
>>>>>>             self._pool.__exit__(exc_type, exc_value, traceback)
       
    1:     def handle_request(
               self,
    1:         request: Request,
    1:     ) -> Response:
>>>>>>         assert isinstance(request.stream, SyncByteStream)
       
>>>>>>         req = httpcore.Request(
>>>>>>             method=request.method,
>>>>>>             url=httpcore.URL(
>>>>>>                 scheme=request.url.raw_scheme,
>>>>>>                 host=request.url.raw_host,
>>>>>>                 port=request.url.port,
>>>>>>                 target=request.url.raw_path,
                   ),
>>>>>>             headers=request.headers.raw,
>>>>>>             content=request.stream,
>>>>>>             extensions=request.extensions,
               )
>>>>>>         with map_httpcore_exceptions():
>>>>>>             resp = self._pool.handle_request(req)
       
>>>>>>         assert isinstance(resp.stream, typing.Iterable)
       
>>>>>>         return Response(
>>>>>>             status_code=resp.status,
>>>>>>             headers=resp.headers,
>>>>>>             stream=ResponseStream(resp.stream),
>>>>>>             extensions=resp.extensions,
               )
       
    1:     def close(self) -> None:
>>>>>>         self._pool.close()
       
       
    2: class AsyncResponseStream(AsyncByteStream):
    1:     def __init__(self, httpcore_stream: typing.AsyncIterable[bytes]):
>>>>>>         self._httpcore_stream = httpcore_stream
       
    1:     async def __aiter__(self) -> typing.AsyncIterator[bytes]:
>>>>>>         with map_httpcore_exceptions():
>>>>>>             async for part in self._httpcore_stream:
>>>>>>                 yield part
       
    1:     async def aclose(self) -> None:
>>>>>>         if hasattr(self._httpcore_stream, "aclose"):
>>>>>>             await self._httpcore_stream.aclose()
       
       
    2: class AsyncHTTPTransport(AsyncBaseTransport):
    2:     def __init__(
               self,
    2:         verify: VerifyTypes = True,
    2:         cert: typing.Optional[CertTypes] = None,
    2:         http1: bool = True,
    2:         http2: bool = False,
    2:         limits: Limits = DEFAULT_LIMITS,
    2:         trust_env: bool = True,
    2:         proxy: typing.Optional[Proxy] = None,
    2:         uds: typing.Optional[str] = None,
    2:         local_address: typing.Optional[str] = None,
    2:         retries: int = 0,
    2:         socket_options: typing.Optional[typing.Iterable[SOCKET_OPTION]] = None,
    1:     ) -> None:
>>>>>>         ssl_context = create_ssl_context(verify=verify, cert=cert, trust_env=trust_env)
       
>>>>>>         if proxy is None:
>>>>>>             self._pool = httpcore.AsyncConnectionPool(
>>>>>>                 ssl_context=ssl_context,
>>>>>>                 max_connections=limits.max_connections,
>>>>>>                 max_keepalive_connections=limits.max_keepalive_connections,
>>>>>>                 keepalive_expiry=limits.keepalive_expiry,
>>>>>>                 http1=http1,
>>>>>>                 http2=http2,
>>>>>>                 uds=uds,
>>>>>>                 local_address=local_address,
>>>>>>                 retries=retries,
>>>>>>                 socket_options=socket_options,
                   )
>>>>>>         elif proxy.url.scheme in ("http", "https"):
>>>>>>             self._pool = httpcore.AsyncHTTPProxy(
>>>>>>                 proxy_url=httpcore.URL(
>>>>>>                     scheme=proxy.url.raw_scheme,
>>>>>>                     host=proxy.url.raw_host,
>>>>>>                     port=proxy.url.port,
>>>>>>                     target=proxy.url.raw_path,
                       ),
>>>>>>                 proxy_auth=proxy.raw_auth,
>>>>>>                 proxy_headers=proxy.headers.raw,
>>>>>>                 ssl_context=ssl_context,
>>>>>>                 max_connections=limits.max_connections,
>>>>>>                 max_keepalive_connections=limits.max_keepalive_connections,
>>>>>>                 keepalive_expiry=limits.keepalive_expiry,
>>>>>>                 http1=http1,
>>>>>>                 http2=http2,
>>>>>>                 socket_options=socket_options,
                   )
>>>>>>         elif proxy.url.scheme == "socks5":
>>>>>>             try:
>>>>>>                 import socksio  # noqa
>>>>>>             except ImportError:  # pragma: no cover
>>>>>>                 raise ImportError(
>>>>>>                     "Using SOCKS proxy, but the 'socksio' package is not installed. "
                           "Make sure to install httpx using `pip install httpx[socks]`."
>>>>>>                 ) from None
       
>>>>>>             self._pool = httpcore.AsyncSOCKSProxy(
>>>>>>                 proxy_url=httpcore.URL(
>>>>>>                     scheme=proxy.url.raw_scheme,
>>>>>>                     host=proxy.url.raw_host,
>>>>>>                     port=proxy.url.port,
>>>>>>                     target=proxy.url.raw_path,
                       ),
>>>>>>                 proxy_auth=proxy.raw_auth,
>>>>>>                 ssl_context=ssl_context,
>>>>>>                 max_connections=limits.max_connections,
>>>>>>                 max_keepalive_connections=limits.max_keepalive_connections,
>>>>>>                 keepalive_expiry=limits.keepalive_expiry,
>>>>>>                 http1=http1,
>>>>>>                 http2=http2,
                   )
               else:  # pragma: no cover
>>>>>>             raise ValueError(
>>>>>>                 f"Proxy protocol must be either 'http', 'https', or 'socks5', but got {proxy.url.scheme!r}."
                   )
       
    1:     async def __aenter__(self: A) -> A:  # Use generics for subclass support.
>>>>>>         await self._pool.__aenter__()
>>>>>>         return self
       
    2:     async def __aexit__(
               self,
    1:         exc_type: typing.Optional[typing.Type[BaseException]] = None,
    1:         exc_value: typing.Optional[BaseException] = None,
    1:         traceback: typing.Optional[TracebackType] = None,
    1:     ) -> None:
>>>>>>         with map_httpcore_exceptions():
>>>>>>             await self._pool.__aexit__(exc_type, exc_value, traceback)
       
    1:     async def handle_async_request(
               self,
    1:         request: Request,
    1:     ) -> Response:
>>>>>>         assert isinstance(request.stream, AsyncByteStream)
       
>>>>>>         req = httpcore.Request(
>>>>>>             method=request.method,
>>>>>>             url=httpcore.URL(
>>>>>>                 scheme=request.url.raw_scheme,
>>>>>>                 host=request.url.raw_host,
>>>>>>                 port=request.url.port,
>>>>>>                 target=request.url.raw_path,
                   ),
>>>>>>             headers=request.headers.raw,
>>>>>>             content=request.stream,
>>>>>>             extensions=request.extensions,
               )
>>>>>>         with map_httpcore_exceptions():
>>>>>>             resp = await self._pool.handle_async_request(req)
       
>>>>>>         assert isinstance(resp.stream, typing.AsyncIterable)
       
>>>>>>         return Response(
>>>>>>             status_code=resp.status,
>>>>>>             headers=resp.headers,
>>>>>>             stream=AsyncResponseStream(resp.stream),
>>>>>>             extensions=resp.extensions,
               )
       
    1:     async def aclose(self) -> None:
>>>>>>         await self._pool.aclose()
