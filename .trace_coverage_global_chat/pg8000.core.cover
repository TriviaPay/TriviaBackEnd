    1: import codecs
    1: import socket
    1: from collections import defaultdict, deque
    1: from hashlib import md5
    1: from importlib.metadata import version
    1: from io import IOBase, TextIOBase
    1: from itertools import count
    1: from struct import Struct
       
    1: import scramp
       
    1: from pg8000.converters import (
           PG_PY_ENCODINGS,
           PG_TYPES,
           PY_TYPES,
           make_params,
           string_in,
       )
    1: from pg8000.exceptions import DatabaseError, Error, InterfaceError
       
       
    1: ver = version("pg8000")
       
       
    1: def pack_funcs(fmt):
    7:     struc = Struct(f"!{fmt}")
    7:     return struc.pack, struc.unpack_from
       
       
    1: i_pack, i_unpack = pack_funcs("i")
    1: H_pack, H_unpack = pack_funcs("H")
    1: ii_pack, ii_unpack = pack_funcs("ii")
    1: ihihih_pack, ihihih_unpack = pack_funcs("ihihih")
    1: ci_pack, ci_unpack = pack_funcs("ci")
    1: bh_pack, bh_unpack = pack_funcs("bh")
    1: cccc_pack, cccc_unpack = pack_funcs("cccc")
       
       
       # Copyright (c) 2007-2009, Mathieu Fenniak
       # Copyright (c) The Contributors
       # All rights reserved.
       #
       # Redistribution and use in source and binary forms, with or without
       # modification, are permitted provided that the following conditions are
       # met:
       #
       # * Redistributions of source code must retain the above copyright notice,
       # this list of conditions and the following disclaimer.
       # * Redistributions in binary form must reproduce the above copyright notice,
       # this list of conditions and the following disclaimer in the documentation
       # and/or other materials provided with the distribution.
       # * The name of the author may not be used to endorse or promote products
       # derived from this software without specific prior written permission.
       #
       # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
       # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
       # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
       # ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
       # LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
       # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
       # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
       # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
       # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
       # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
       # POSSIBILITY OF SUCH DAMAGE.
       
    1: __author__ = "Mathieu Fenniak"
       
       
    1: NULL_BYTE = b"\x00"
       
       
       # Message codes
    1: NOTICE_RESPONSE = b"N"
    1: AUTHENTICATION_REQUEST = b"R"
    1: PARAMETER_STATUS = b"S"
    1: BACKEND_KEY_DATA = b"K"
    1: READY_FOR_QUERY = b"Z"
    1: ROW_DESCRIPTION = b"T"
    1: ERROR_RESPONSE = b"E"
    1: DATA_ROW = b"D"
    1: COMMAND_COMPLETE = b"C"
    1: PARSE_COMPLETE = b"1"
    1: BIND_COMPLETE = b"2"
    1: CLOSE_COMPLETE = b"3"
    1: PORTAL_SUSPENDED = b"s"
    1: NO_DATA = b"n"
    1: PARAMETER_DESCRIPTION = b"t"
    1: NOTIFICATION_RESPONSE = b"A"
    1: COPY_DONE = b"c"
    1: COPY_DATA = b"d"
    1: COPY_IN_RESPONSE = b"G"
    1: COPY_OUT_RESPONSE = b"H"
    1: EMPTY_QUERY_RESPONSE = b"I"
       
    1: BIND = b"B"
    1: PARSE = b"P"
    1: QUERY = b"Q"
    1: EXECUTE = b"E"
    1: FLUSH = b"H"
    1: SYNC = b"S"
    1: PASSWORD = b"p"
    1: DESCRIBE = b"D"
    1: TERMINATE = b"X"
    1: CLOSE = b"C"
       
       
    1: def _create_message(code, data=b""):
    5:     return code + i_pack(len(data) + 4) + data
       
       
    1: FLUSH_MSG = _create_message(FLUSH)
    1: SYNC_MSG = _create_message(SYNC)
    1: TERMINATE_MSG = _create_message(TERMINATE)
    1: COPY_DONE_MSG = _create_message(COPY_DONE)
    1: EXECUTE_MSG = _create_message(EXECUTE, NULL_BYTE + i_pack(0))
       
       # DESCRIBE constants
    1: STATEMENT = b"S"
    1: PORTAL = b"P"
       
       # ErrorResponse codes
    1: RESPONSE_SEVERITY = "S"  # always present
    1: RESPONSE_SEVERITY = "V"  # always present
    1: RESPONSE_CODE = "C"  # always present
    1: RESPONSE_MSG = "M"  # always present
    1: RESPONSE_DETAIL = "D"
    1: RESPONSE_HINT = "H"
    1: RESPONSE_POSITION = "P"
    1: RESPONSE__POSITION = "p"
    1: RESPONSE__QUERY = "q"
    1: RESPONSE_WHERE = "W"
    1: RESPONSE_FILE = "F"
    1: RESPONSE_LINE = "L"
    1: RESPONSE_ROUTINE = "R"
       
    1: IDLE = b"I"
    1: IN_TRANSACTION = b"T"
    1: IN_FAILED_TRANSACTION = b"E"
       
       
    1: def _flush(sock):
   18:     try:
   18:         sock.flush()
>>>>>>     except OSError as e:
>>>>>>         raise InterfaceError("network error") from e
       
       
    1: def _read(sock, size):
  130:     got = 0
  130:     buff = []
  130:     try:
  252:         while got < size:
  122:             block = sock.read(size - got)
  122:             if block == b"":
>>>>>>                 raise InterfaceError("network error")
  122:             buff.append(block)
  122:             got += len(block)
>>>>>>     except OSError as e:
>>>>>>         raise InterfaceError("network error") from e
       
  130:     return b"".join(buff)
       
       
    1: def _write(sock, d):
   77:     try:
   77:         sock.write(d)
>>>>>>     except OSError as e:
>>>>>>         raise InterfaceError("network error") from e
       
       
    1: def _make_socket(
           unix_sock, sock, host, port, timeout, source_address, tcp_keepalive, ssl_context
       ):
    1:     if unix_sock is not None:
>>>>>>         if sock is not None:
>>>>>>             raise InterfaceError("If unix_sock is provided, sock must be None")
       
>>>>>>         try:
>>>>>>             if not hasattr(socket, "AF_UNIX"):
>>>>>>                 raise InterfaceError(
>>>>>>                     "attempt to connect to unix socket on unsupported platform"
                       )
>>>>>>             sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
>>>>>>             sock.settimeout(timeout)
>>>>>>             sock.connect(unix_sock)
>>>>>>             if tcp_keepalive:
>>>>>>                 sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
>>>>>>         except socket.error as e:
>>>>>>             if sock is not None:
>>>>>>                 sock.close()
>>>>>>             raise InterfaceError("communication error") from e
       
    1:     elif sock is not None:
>>>>>>         pass
       
    1:     elif host is not None:
    1:         try:
    1:             sock = socket.create_connection((host, port), timeout, source_address)
>>>>>>         except socket.error as e:
>>>>>>             raise InterfaceError(
>>>>>>                 f"Can't create a connection to host {host} and port {port} "
>>>>>>                 f"(timeout is {timeout} and source_address is {source_address})."
>>>>>>             ) from e
       
    1:         if tcp_keepalive:
    1:             sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
       
           else:
>>>>>>         raise InterfaceError("one of host, sock or unix_sock must be provided")
       
    1:     channel_binding = None
    1:     if ssl_context is not None:
    1:         try:
    1:             import ssl
       
    1:             if ssl_context is True:
>>>>>>                 ssl_context = ssl.create_default_context()
       
    1:             request_ssl = getattr(ssl_context, "request_ssl", True)
       
    1:             if request_ssl:
                       # Int32(8) - Message length, including self.
                       # Int32(80877103) - The SSL request code.
    1:                 sock.sendall(ii_pack(8, 80877103))
    1:                 resp = sock.recv(1)
    1:                 if resp != b"S":
>>>>>>                     raise InterfaceError("Server refuses SSL")
       
    1:             sock = ssl_context.wrap_socket(sock, server_hostname=host)
       
    1:             if request_ssl:
    2:                 channel_binding = scramp.make_channel_binding(
    1:                     "tls-server-end-point", sock
                       )
       
>>>>>>         except ImportError:
>>>>>>             raise InterfaceError(
>>>>>>                 "SSL required but ssl module not available in this python "
                       "installation."
                   )
    1:     return channel_binding, sock
       
       
    2: class CoreConnection:
    1:     def __enter__(self):
>>>>>>         return self
       
    1:     def __exit__(self, exc_type, exc_value, traceback):
>>>>>>         self.close()
       
    1:     def __init__(
               self,
               user,
               host="localhost",
               database=None,
               port=5432,
               password=None,
               source_address=None,
               unix_sock=None,
               ssl_context=None,
               timeout=None,
               tcp_keepalive=True,
               application_name=None,
               replication=None,
               sock=None,
           ):
    1:         self._client_encoding = "utf8"
    1:         self._commands_with_count = (
                   b"INSERT",
                   b"DELETE",
                   b"UPDATE",
                   b"MOVE",
                   b"FETCH",
                   b"COPY",
                   b"SELECT",
               )
    1:         self.notifications = deque(maxlen=100)
    1:         self.notices = deque(maxlen=100)
    1:         self.parameter_statuses = {}
       
    1:         if user is None:
>>>>>>             raise InterfaceError("The 'user' connection parameter cannot be None")
       
    1:         init_params = {
    1:             "user": user,
    1:             "database": database,
    1:             "application_name": application_name,
    1:             "replication": replication,
               }
       
    5:         for k, v in tuple(init_params.items()):
    4:             if isinstance(v, str):
    2:                 init_params[k] = v.encode("utf8")
    2:             elif v is None:
    2:                 del init_params[k]
>>>>>>             elif not isinstance(v, (bytes, bytearray)):
>>>>>>                 raise InterfaceError(f"The parameter {k} can't be of type {type(v)}.")
       
    1:         self.user = init_params["user"]
       
    1:         if isinstance(password, str):
    1:             self.password = password.encode("utf8")
               else:
>>>>>>             self.password = password
       
    1:         self._xid = None
    1:         self._statement_nums = set()
       
    1:         self._caches = {}
       
    2:         self.channel_binding, self._usock = _make_socket(
    1:             unix_sock,
    1:             sock,
    1:             host,
    1:             port,
    1:             timeout,
    1:             source_address,
    1:             tcp_keepalive,
    1:             ssl_context,
               )
       
    1:         self._sock = self._usock.makefile(mode="rwb")
       
    1:         self._backend_key_data = None
       
    1:         self.pg_types = defaultdict(lambda: string_in, PG_TYPES)
    1:         self.py_types = dict(PY_TYPES)
       
    1:         self.message_types = {
    1:             NOTICE_RESPONSE: self.handle_NOTICE_RESPONSE,
    1:             AUTHENTICATION_REQUEST: self.handle_AUTHENTICATION_REQUEST,
    1:             PARAMETER_STATUS: self.handle_PARAMETER_STATUS,
    1:             BACKEND_KEY_DATA: self.handle_BACKEND_KEY_DATA,
    1:             READY_FOR_QUERY: self.handle_READY_FOR_QUERY,
    1:             ROW_DESCRIPTION: self.handle_ROW_DESCRIPTION,
    1:             ERROR_RESPONSE: self.handle_ERROR_RESPONSE,
    1:             EMPTY_QUERY_RESPONSE: self.handle_EMPTY_QUERY_RESPONSE,
    1:             DATA_ROW: self.handle_DATA_ROW,
    1:             COMMAND_COMPLETE: self.handle_COMMAND_COMPLETE,
    1:             PARSE_COMPLETE: self.handle_PARSE_COMPLETE,
    1:             BIND_COMPLETE: self.handle_BIND_COMPLETE,
    1:             CLOSE_COMPLETE: self.handle_CLOSE_COMPLETE,
    1:             PORTAL_SUSPENDED: self.handle_PORTAL_SUSPENDED,
    1:             NO_DATA: self.handle_NO_DATA,
    1:             PARAMETER_DESCRIPTION: self.handle_PARAMETER_DESCRIPTION,
    1:             NOTIFICATION_RESPONSE: self.handle_NOTIFICATION_RESPONSE,
    1:             COPY_DONE: self.handle_COPY_DONE,
    1:             COPY_DATA: self.handle_COPY_DATA,
    1:             COPY_IN_RESPONSE: self.handle_COPY_IN_RESPONSE,
    1:             COPY_OUT_RESPONSE: self.handle_COPY_OUT_RESPONSE,
               }
       
               # Int32 - Message length, including self.
               # Int32(196608) - Protocol version number.  Version 3.0.
               # Any number of key/value pairs, terminated by a zero byte:
               #   String - A parameter name (user, database, or options)
               #   String - Parameter value
    1:         protocol = 196608
    1:         val = bytearray(i_pack(protocol))
       
    3:         for k, v in init_params.items():
    2:             val.extend(k.encode("ascii") + NULL_BYTE + v + NULL_BYTE)
    1:         val.append(0)
    1:         _write(self._sock, i_pack(len(val) + 4))
    1:         _write(self._sock, val)
    1:         _flush(self._sock)
       
    1:         try:
    1:             code = None
    1:             context = Context(None)
   22:             while code not in (READY_FOR_QUERY, ERROR_RESPONSE):
   21:                 code, data_len = ci_unpack(_read(self._sock, 5))
       
   21:                 self.message_types[code](_read(self._sock, data_len - 4), context)
       
    1:             if context.error is not None:
>>>>>>                 raise context.error
       
>>>>>>         except Error as e:
>>>>>>             self.close()
>>>>>>             raise e
       
    1:         self._transaction_status = None
       
    1:     def register_out_adapter(self, typ, out_func):
>>>>>>         self.py_types[typ] = out_func
       
    1:     def register_in_adapter(self, oid, in_func):
>>>>>>         self.pg_types[oid] = in_func
       
    1:     def handle_ERROR_RESPONSE(self, data, context):
>>>>>>         msg = {
>>>>>>             s[:1].decode("ascii"): s[1:].decode(self._client_encoding, errors="replace")
>>>>>>             for s in data.split(NULL_BYTE)
>>>>>>             if s != b""
               }
       
>>>>>>         context.error = DatabaseError(msg)
       
    1:     def handle_EMPTY_QUERY_RESPONSE(self, data, context):
>>>>>>         pass
       
    1:     def handle_CLOSE_COMPLETE(self, data, context):
>>>>>>         pass
       
    1:     def handle_PARSE_COMPLETE(self, data, context):
               # Byte1('1') - Identifier.
               # Int32(4) - Message length, including self.
    3:         pass
       
    1:     def handle_BIND_COMPLETE(self, data, context):
    3:         pass
       
    1:     def handle_PORTAL_SUSPENDED(self, data, context):
>>>>>>         pass
       
    1:     def handle_PARAMETER_DESCRIPTION(self, data, context):
    3:         """https://www.postgresql.org/docs/current/protocol-message-formats.html"""
       
               # count = h_unpack(data)[0]
               # context.parameter_oids = unpack_from("!" + "i" * count, data, 2)
       
    1:     def handle_COPY_DONE(self, data, context):
>>>>>>         pass
       
    1:     def handle_COPY_OUT_RESPONSE(self, data, context):
               """https://www.postgresql.org/docs/current/protocol-message-formats.html"""
       
>>>>>>         is_binary, num_cols = bh_unpack(data)
               # column_formats = unpack_from('!' + 'h' * num_cols, data, 3)
       
>>>>>>         if context.stream is None:
>>>>>>             raise InterfaceError(
>>>>>>                 "An output stream is required for the COPY OUT response."
                   )
       
>>>>>>         elif isinstance(context.stream, TextIOBase):
>>>>>>             if is_binary:
>>>>>>                 raise InterfaceError(
>>>>>>                     "The COPY OUT stream is binary, but the stream parameter is text."
                       )
                   else:
>>>>>>                 decode = codecs.getdecoder(self._client_encoding)
       
>>>>>>                 def w(data):
>>>>>>                     context.stream.write(decode(data)[0])
       
>>>>>>                 context.stream_write = w
       
               else:
>>>>>>             context.stream_write = context.stream.write
       
    1:     def handle_COPY_DATA(self, data, context):
>>>>>>         context.stream_write(data)
       
    1:     def handle_COPY_IN_RESPONSE(self, data, context):
               """https://www.postgresql.org/docs/current/protocol-message-formats.html"""
>>>>>>         is_binary, num_cols = bh_unpack(data)
               # column_formats = unpack_from('!' + 'h' * num_cols, data, 3)
       
>>>>>>         if context.stream is None:
>>>>>>             raise InterfaceError(
>>>>>>                 "The 'stream' parameter is required for the COPY IN response. The "
                       "'stream' parameter can be an I/O stream or an iterable."
                   )
       
>>>>>>         if isinstance(context.stream, IOBase):
>>>>>>             if isinstance(context.stream, TextIOBase):
>>>>>>                 if is_binary:
>>>>>>                     raise InterfaceError(
>>>>>>                         "The COPY IN stream is binary, but the stream parameter is a "
                               "text stream."
                           )
       
                       else:
       
>>>>>>                     def ri(bffr):
>>>>>>                         bffr.clear()
>>>>>>                         bffr.extend(
>>>>>>                             context.stream.read(4096).encode(self._client_encoding)
                               )
>>>>>>                         return len(bffr)
       
>>>>>>                     readinto = ri
                   else:
>>>>>>                 readinto = context.stream.readinto
       
>>>>>>             bffr = bytearray(8192)
                   while True:
>>>>>>                 bytes_read = readinto(bffr)
>>>>>>                 if bytes_read == 0:
>>>>>>                     break
>>>>>>                 _write(self._sock, COPY_DATA)
>>>>>>                 _write(self._sock, i_pack(bytes_read + 4))
>>>>>>                 _write(self._sock, bffr[:bytes_read])
>>>>>>                 _flush(self._sock)
       
               else:
>>>>>>             for k in context.stream:
>>>>>>                 if isinstance(k, str):
>>>>>>                     if is_binary:
>>>>>>                         raise InterfaceError(
>>>>>>                             "The COPY IN stream is binary, but the stream parameter "
                                   "is an iterable with str type items."
                               )
>>>>>>                     b = k.encode(self._client_encoding)
                       else:
>>>>>>                     b = k
       
>>>>>>                 self._send_message(COPY_DATA, b)
>>>>>>                 _flush(self._sock)
       
               # Send CopyDone
>>>>>>         _write(self._sock, COPY_DONE_MSG)
>>>>>>         _write(self._sock, SYNC_MSG)
>>>>>>         _flush(self._sock)
       
    1:     def handle_NOTIFICATION_RESPONSE(self, data, context):
               """https://www.postgresql.org/docs/current/protocol-message-formats.html"""
>>>>>>         backend_pid = i_unpack(data)[0]
>>>>>>         idx = 4
>>>>>>         null_idx = data.find(NULL_BYTE, idx)
>>>>>>         channel = data[idx:null_idx].decode("ascii")
>>>>>>         payload = data[null_idx + 1 : -1].decode("ascii")
       
>>>>>>         self.notifications.append((backend_pid, channel, payload))
       
    1:     def close(self):
               """Closes the database connection.
       
               This function is part of the `DBAPI 2.0 specification
               <http://www.python.org/dev/peps/pep-0249/>`_.
               """
       
>>>>>>         if self._usock is None:
>>>>>>             raise InterfaceError("connection is closed")
       
>>>>>>         try:
>>>>>>             _write(self._sock, TERMINATE_MSG)
>>>>>>             _flush(self._sock)
               finally:
>>>>>>             try:
>>>>>>                 self._usock.close()
>>>>>>             except socket.error as e:
>>>>>>                 raise InterfaceError("network error") from e
                   finally:
>>>>>>                 self._sock = None
>>>>>>                 self._usock = None
       
    1:     def handle_AUTHENTICATION_REQUEST(self, data, context):
               """https://www.postgresql.org/docs/current/protocol-message-formats.html"""
       
    4:         auth_code = i_unpack(data)[0]
    4:         if auth_code == 0:
    1:             pass
    3:         elif auth_code == 3:
>>>>>>             if self.password is None:
>>>>>>                 raise InterfaceError(
>>>>>>                     "server requesting password authentication, but no password was "
                           "provided"
                       )
>>>>>>             self._send_message(PASSWORD, self.password + NULL_BYTE)
>>>>>>             _flush(self._sock)
       
    3:         elif auth_code == 5:
>>>>>>             salt = b"".join(cccc_unpack(data, 4))
>>>>>>             if self.password is None:
>>>>>>                 raise InterfaceError(
>>>>>>                     "server requesting MD5 password authentication, but no password "
                           "was provided"
                       )
>>>>>>             pwd = b"md5" + md5(
>>>>>>                 md5(self.password + self.user).hexdigest().encode("ascii") + salt
>>>>>>             ).hexdigest().encode("ascii")
>>>>>>             self._send_message(PASSWORD, pwd + NULL_BYTE)
>>>>>>             _flush(self._sock)
       
    3:         elif auth_code == 10:
                   # AuthenticationSASL
    4:             mechanisms = [m.decode("ascii") for m in data[4:-2].split(NULL_BYTE)]
       
    2:             self.auth = scramp.ScramClient(
    1:                 mechanisms,
    1:                 self.user.decode("utf8"),
    1:                 self.password.decode("utf8"),
    1:                 channel_binding=self.channel_binding,
                   )
       
    1:             init = self.auth.get_client_first().encode("utf8")
    1:             mech = self.auth.mechanism_name.encode("ascii") + NULL_BYTE
       
                   # SASLInitialResponse
    1:             self._send_message(PASSWORD, mech + i_pack(len(init)) + init)
    1:             _flush(self._sock)
       
    2:         elif auth_code == 11:
                   # AuthenticationSASLContinue
    1:             self.auth.set_server_first(data[4:].decode("utf8"))
       
                   # SASLResponse
    1:             msg = self.auth.get_client_final().encode("utf8")
    1:             self._send_message(PASSWORD, msg)
    1:             _flush(self._sock)
       
    1:         elif auth_code == 12:
                   # AuthenticationSASLFinal
    1:             self.auth.set_server_final(data[4:].decode("utf8"))
       
>>>>>>         elif auth_code in (2, 4, 6, 7, 8, 9):
>>>>>>             raise InterfaceError(
>>>>>>                 f"Authentication method {auth_code} not supported by pg8000."
                   )
               else:
>>>>>>             raise InterfaceError(
>>>>>>                 f"Authentication method {auth_code} not recognized by pg8000."
                   )
       
    1:     def handle_READY_FOR_QUERY(self, data, context):
   16:         self._transaction_status = data
       
    1:     def handle_BACKEND_KEY_DATA(self, data, context):
    1:         self._backend_key_data = data
       
    1:     def handle_ROW_DESCRIPTION(self, data, context):
    5:         count = H_unpack(data)[0]
    5:         idx = 2
    5:         columns = []
    5:         input_funcs = []
   17:         for i in range(count):
   12:             name = data[idx : data.find(NULL_BYTE, idx)]
   12:             idx += len(name) + 1
   24:             field = dict(
   24:                 zip(
   12:                     (
                               "table_oid",
                               "column_attrnum",
                               "type_oid",
                               "type_size",
                               "type_modifier",
                               "format",
                           ),
   12:                     ihihih_unpack(data, idx),
                       )
                   )
   12:             field["name"] = name.decode(self._client_encoding)
   12:             idx += 18
   12:             columns.append(field)
   12:             input_funcs.append(self.pg_types[field["type_oid"]])
       
    5:         context.columns = columns
    5:         context.input_funcs = input_funcs
    5:         if context.rows is None:
    5:             context.rows = []
       
    1:     def send_PARSE(self, statement_name_bin, statement, oids=()):
    3:         val = bytearray(statement_name_bin)
    3:         val.extend(statement.encode(self._client_encoding) + NULL_BYTE)
    3:         val.extend(H_pack(len(oids)))
    3:         for oid in oids:
>>>>>>             val.extend(i_pack(0 if oid == -1 else oid))
       
    3:         self._send_message(PARSE, val)
    3:         _write(self._sock, FLUSH_MSG)
       
    1:     def send_DESCRIBE_STATEMENT(self, statement_name_bin):
    3:         self._send_message(DESCRIBE, STATEMENT + statement_name_bin)
    3:         _write(self._sock, FLUSH_MSG)
       
    1:     def send_QUERY(self, sql):
    6:         self._send_message(QUERY, sql.encode(self._client_encoding) + NULL_BYTE)
       
    1:     def execute_simple(self, statement):
    6:         context = Context(statement)
       
    6:         self.send_QUERY(statement)
    6:         _flush(self._sock)
    6:         self.handle_messages(context)
       
    6:         return context
       
    1:     def execute_unnamed(self, statement, vals=(), oids=(), stream=None):
    3:         context = Context(statement, stream=stream)
       
    3:         self.send_PARSE(NULL_BYTE, statement, oids)
    3:         _write(self._sock, SYNC_MSG)
    3:         _flush(self._sock)
    3:         self.handle_messages(context)
    3:         self.send_DESCRIBE_STATEMENT(NULL_BYTE)
       
    3:         _write(self._sock, SYNC_MSG)
       
    3:         try:
    3:             _flush(self._sock)
>>>>>>         except AttributeError as e:
>>>>>>             if self._sock is None:
>>>>>>                 raise InterfaceError("connection is closed")
                   else:
>>>>>>                 raise e
    3:         params = make_params(self.py_types, vals)
    3:         self.send_BIND(NULL_BYTE, params)
    3:         self.handle_messages(context)
    3:         self.send_EXECUTE()
       
    3:         _write(self._sock, SYNC_MSG)
    3:         _flush(self._sock)
    3:         self.handle_messages(context)
       
    3:         return context
       
    1:     def prepare_statement(self, statement, oids=None):
>>>>>>         for i in count():
>>>>>>             statement_name = f"pg8000_statement_{i}"
>>>>>>             statement_name_bin = statement_name.encode("ascii") + NULL_BYTE
>>>>>>             if statement_name_bin not in self._statement_nums:
>>>>>>                 self._statement_nums.add(statement_name_bin)
>>>>>>                 break
       
>>>>>>         self.send_PARSE(statement_name_bin, statement, oids)
>>>>>>         self.send_DESCRIBE_STATEMENT(statement_name_bin)
>>>>>>         _write(self._sock, SYNC_MSG)
       
>>>>>>         try:
>>>>>>             _flush(self._sock)
>>>>>>         except AttributeError as e:
>>>>>>             if self._sock is None:
>>>>>>                 raise InterfaceError("connection is closed")
                   else:
>>>>>>                 raise e
       
>>>>>>         context = Context(statement)
>>>>>>         self.handle_messages(context)
       
>>>>>>         return statement_name_bin, context.columns, context.input_funcs
       
    1:     def execute_named(
               self, statement_name_bin, params, columns, input_funcs, statement
           ):
>>>>>>         context = Context(columns=columns, input_funcs=input_funcs, statement=statement)
       
>>>>>>         self.send_BIND(statement_name_bin, params)
>>>>>>         self.send_EXECUTE()
>>>>>>         _write(self._sock, SYNC_MSG)
>>>>>>         _flush(self._sock)
>>>>>>         self.handle_messages(context)
>>>>>>         return context
       
    1:     def _send_message(self, code, data):
   17:         try:
   17:             _write(self._sock, code)
   17:             _write(self._sock, i_pack(len(data) + 4))
   17:             _write(self._sock, data)
>>>>>>         except ValueError as e:
>>>>>>             if str(e) == "write to closed file":
>>>>>>                 raise InterfaceError("connection is closed")
                   else:
>>>>>>                 raise e
>>>>>>         except AttributeError:
>>>>>>             raise InterfaceError("connection is closed")
       
    1:     def send_BIND(self, statement_name_bin, params):
               """https://www.postgresql.org/docs/current/protocol-message-formats.html"""
       
    6:         retval = bytearray(
    3:             NULL_BYTE + statement_name_bin + H_pack(0) + H_pack(len(params))
               )
       
    4:         for value in params:
    1:             if value is None:
>>>>>>                 retval.extend(i_pack(-1))
                   else:
    1:                 val = value.encode(self._client_encoding)
    1:                 retval.extend(i_pack(len(val)))
    1:                 retval.extend(val)
    3:         retval.extend(H_pack(0))
       
    3:         self._send_message(BIND, retval)
    3:         _write(self._sock, FLUSH_MSG)
       
    1:     def send_EXECUTE(self):
               """https://www.postgresql.org/docs/current/protocol-message-formats.html"""
    3:         _write(self._sock, EXECUTE_MSG)
    3:         _write(self._sock, FLUSH_MSG)
       
    1:     def handle_NO_DATA(self, msg, context):
    2:         pass
       
    1:     def handle_COMMAND_COMPLETE(self, data, context):
    9:         if self._transaction_status == IN_FAILED_TRANSACTION and context.error is None:
>>>>>>             sql = context.statement.split()[0].rstrip(";").upper()
>>>>>>             if sql != "ROLLBACK":
>>>>>>                 context.error = InterfaceError("in failed transaction block")
       
    9:         values = data[:-1].split(b" ")
    9:         try:
    9:             row_count = int(values[-1])
    3:             if context.row_count == -1:
    3:                 context.row_count = row_count
                   else:
>>>>>>                 context.row_count += row_count
    6:         except ValueError:
    6:             pass
       
    1:     def handle_DATA_ROW(self, data, context):
    4:         idx = 2
    4:         row = []
    8:         for func in context.input_funcs:
    4:             vlen = i_unpack(data, idx)[0]
    4:             idx += 4
    4:             if vlen == -1:
>>>>>>                 v = None
                   else:
    4:                 v = func(str(data[idx : idx + vlen], encoding=self._client_encoding))
    4:                 idx += vlen
    4:             row.append(v)
    4:         context.rows.append(row)
       
    1:     def handle_messages(self, context):
   15:         code = None
       
   59:         while code != READY_FOR_QUERY:
   44:             code, data_len = ci_unpack(_read(self._sock, 5))
       
   44:             self.message_types[code](_read(self._sock, data_len - 4), context)
       
   15:         if context.error is not None:
>>>>>>             raise context.error
       
    1:     def close_prepared_statement(self, statement_name_bin):
               """https://www.postgresql.org/docs/current/protocol-message-formats.html"""
>>>>>>         self._send_message(CLOSE, STATEMENT + statement_name_bin)
>>>>>>         _write(self._sock, FLUSH_MSG)
>>>>>>         _write(self._sock, SYNC_MSG)
>>>>>>         _flush(self._sock)
>>>>>>         context = Context(None)
>>>>>>         self.handle_messages(context)
>>>>>>         self._statement_nums.remove(statement_name_bin)
       
    1:     def handle_NOTICE_RESPONSE(self, data, context):
               """https://www.postgresql.org/docs/current/protocol-message-formats.html"""
>>>>>>         self.notices.append({s[0:1]: s[1:] for s in data.split(NULL_BYTE)})
       
    1:     def handle_PARAMETER_STATUS(self, data, context):
   15:         pos = data.find(NULL_BYTE)
   15:         key, value = data[:pos].decode("ascii"), data[pos + 1 : -1].decode("ascii")
   15:         self.parameter_statuses[key] = value
   15:         if key == "client_encoding":
    1:             encoding = value.lower()
    1:             self._client_encoding = PG_PY_ENCODINGS.get(encoding, encoding)
       
   14:         elif key == "integer_datetimes":
    1:             if value == "on":
    1:                 pass
       
                   else:
>>>>>>                 pass
       
   13:         elif key == "server_version":
   15:             pass
       
       
    2: class Context:
    1:     def __init__(self, statement, stream=None, columns=None, input_funcs=None):
   10:         self.statement = statement
   10:         self.rows = None if columns is None else []
   10:         self.row_count = -1
   10:         self.columns = columns
   10:         self.stream = stream
   10:         self.input_funcs = [] if input_funcs is None else input_funcs
   10:         self.error = None
