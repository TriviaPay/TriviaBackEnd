       # inspection.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: """The inspection module provides the :func:`_sa.inspect` function,
       which delivers runtime information about a wide variety
       of SQLAlchemy objects, both within the Core as well as the
       ORM.
       
       The :func:`_sa.inspect` function is the entry point to SQLAlchemy's
       public API for viewing the configuration and construction
       of in-memory objects.   Depending on the type of object
       passed to :func:`_sa.inspect`, the return value will either be
       a related object which provides a known interface, or in many
       cases it will return the object itself.
       
       The rationale for :func:`_sa.inspect` is twofold.  One is that
       it replaces the need to be aware of a large variety of "information
       getting" functions in SQLAlchemy, such as
       :meth:`_reflection.Inspector.from_engine` (deprecated in 1.4),
       :func:`.orm.attributes.instance_state`, :func:`_orm.class_mapper`,
       and others.    The other is that the return value of :func:`_sa.inspect`
       is guaranteed to obey a documented API, thus allowing third party
       tools which build on top of SQLAlchemy configurations to be constructed
       in a forwards-compatible way.
       
       """
    1: from __future__ import annotations
       
    1: from typing import Any
    1: from typing import Callable
    1: from typing import Dict
    1: from typing import Generic
    1: from typing import Optional
    1: from typing import overload
    1: from typing import Type
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from . import exc
    1: from .util.typing import Literal
    1: from .util.typing import Protocol
       
    1: _T = TypeVar("_T", bound=Any)
    1: _TCov = TypeVar("_TCov", bound=Any, covariant=True)
    1: _F = TypeVar("_F", bound=Callable[..., Any])
       
    1: _IN = TypeVar("_IN", bound=Any)
       
    1: _registrars: Dict[type, Union[Literal[True], Callable[[Any], Any]]] = {}
       
       
    2: class Inspectable(Generic[_T]):
    1:     """define a class as inspectable.
       
           This allows typing to set up a linkage between an object that
           can be inspected and the type of inspection it returns.
       
           Unfortunately we cannot at the moment get all classes that are
           returned by inspection to suit this interface as we get into
           MRO issues.
       
           """
       
    1:     __slots__ = ()
       
       
    2: class _InspectableTypeProtocol(Protocol[_TCov]):
    1:     """a protocol defining a method that's used when a type (ie the class
           itself) is passed to inspect().
       
           """
       
    1:     def _sa_inspect_type(self) -> _TCov: ...
       
       
    2: class _InspectableProtocol(Protocol[_TCov]):
    1:     """a protocol defining a method that's used when an instance is
           passed to inspect().
       
           """
       
    1:     def _sa_inspect_instance(self) -> _TCov: ...
       
       
    1: @overload
    1: def inspect(
           subject: Type[_InspectableTypeProtocol[_IN]], raiseerr: bool = True
>>>>>> ) -> _IN: ...
       
       
    1: @overload
    1: def inspect(
           subject: _InspectableProtocol[_IN], raiseerr: bool = True
>>>>>> ) -> _IN: ...
       
       
    1: @overload
    1: def inspect(subject: Inspectable[_IN], raiseerr: bool = True) -> _IN: ...
       
       
    1: @overload
    1: def inspect(subject: Any, raiseerr: Literal[False] = ...) -> Optional[Any]: ...
       
       
    1: @overload
    1: def inspect(subject: Any, raiseerr: bool = True) -> Any: ...
       
       
    1: def inspect(subject: Any, raiseerr: bool = True) -> Any:
           """Produce an inspection object for the given target.
       
           The returned value in some cases may be the
           same object as the one given, such as if a
           :class:`_orm.Mapper` object is passed.   In other
           cases, it will be an instance of the registered
           inspection type for the given object, such as
           if an :class:`_engine.Engine` is passed, an
           :class:`_reflection.Inspector` object is returned.
       
           :param subject: the subject to be inspected.
           :param raiseerr: When ``True``, if the given subject
            does not
            correspond to a known SQLAlchemy inspected type,
            :class:`sqlalchemy.exc.NoInspectionAvailable`
            is raised.  If ``False``, ``None`` is returned.
       
           """
  329:     type_ = type(subject)
  766:     for cls in type_.__mro__:
  675:         if cls in _registrars:
  509:             reg = _registrars.get(cls, None)
  509:             if reg is None:
>>>>>>                 continue
  509:             elif reg is True:
  178:                 return subject
  331:             ret = reg(subject)
  331:             if ret is not None:
   60:                 return ret
           else:
   91:         reg = ret = None
       
   91:     if raiseerr and (reg is None or ret is None):
>>>>>>         raise exc.NoInspectionAvailable(
>>>>>>             "No inspection system is "
>>>>>>             "available for object of type %s" % type_
               )
   91:     return ret
       
       
    1: def _inspects(
           *types: Type[Any],
       ) -> Callable[[_F], _F]:
    9:     def decorate(fn_or_cls: _F) -> _F:
   20:         for type_ in types:
   11:             if type_ in _registrars:
>>>>>>                 raise AssertionError("Type %s is already registered" % type_)
   11:             _registrars[type_] = fn_or_cls
    9:         return fn_or_cls
       
    9:     return decorate
       
       
    1: _TT = TypeVar("_TT", bound="Type[Any]")
       
       
    1: def _self_inspects(cls: _TT) -> _TT:
   12:     if cls in _registrars:
>>>>>>         raise AssertionError("Type %s is already registered" % cls)
   12:     _registrars[cls] = True
   12:     return cls
