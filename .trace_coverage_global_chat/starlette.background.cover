    1: from __future__ import annotations
       
    1: import sys
    1: import typing
       
    1: if sys.version_info >= (3, 10):  # pragma: no cover
>>>>>>     from typing import ParamSpec
       else:  # pragma: no cover
    1:     from typing_extensions import ParamSpec
       
    1: from starlette._utils import is_async_callable
    1: from starlette.concurrency import run_in_threadpool
       
    1: P = ParamSpec("P")
       
       
    2: class BackgroundTask:
    1:     def __init__(
               self, func: typing.Callable[P, typing.Any], *args: P.args, **kwargs: P.kwargs
           ) -> None:
    2:         self.func = func
    2:         self.args = args
    2:         self.kwargs = kwargs
    2:         self.is_async = is_async_callable(func)
       
    1:     async def __call__(self) -> None:
    2:         if self.is_async:
>>>>>>             await self.func(*self.args, **self.kwargs)
               else:
    2:             await run_in_threadpool(self.func, *self.args, **self.kwargs)
       
       
    2: class BackgroundTasks(BackgroundTask):
    1:     def __init__(self, tasks: typing.Sequence[BackgroundTask] | None = None):
    6:         self.tasks = list(tasks) if tasks else []
       
    1:     def add_task(
               self, func: typing.Callable[P, typing.Any], *args: P.args, **kwargs: P.kwargs
           ) -> None:
    2:         task = BackgroundTask(func, *args, **kwargs)
    2:         self.tasks.append(task)
       
    1:     async def __call__(self) -> None:
    4:         for task in self.tasks:
    2:             await task()
