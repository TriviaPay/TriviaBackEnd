       # -*- coding: utf-8 -*-
       
    1: from __future__ import (
           print_function,
           unicode_literals,
           absolute_import,
           division)
       
    1: import json
    1: import re
    1: import six
    1: import sys
    1: import base64
       
    1: channel_name_re = re.compile(r'\A[-a-zA-Z0-9_=@,.;]+\Z')
    1: app_id_re = re.compile(r'\A[0-9]+\Z')
    1: pusher_url_re = re.compile(r'\A(http|https)://(.*):(.*)@(.*)/apps/([0-9]+)\Z')
    1: socket_id_re = re.compile(r'\A\d+\.\d+\Z')
       
       
    1: if sys.version_info < (3,):
>>>>>>     text = 'a unicode string'
       else:
    1:     text = 'a string'
       
       
    1: if sys.version_info < (3,):
>>>>>>     byte_type = 'a python2 str'
       else:
    1:     byte_type = 'a python3 bytes'
       
    1: def ensure_text(obj, name):
   10:     if isinstance(obj, six.text_type):
   10:         return obj
       
>>>>>>     if isinstance(obj, six.string_types):
>>>>>>        return six.text_type(obj)
       
>>>>>>     if isinstance(obj, six.binary_type):
>>>>>>       return bytes(obj).decode('utf-8')
       
>>>>>>     raise TypeError("%s should be %s instead it is a %s" % (name, text, type(obj)))
       
    1: def ensure_binary(obj, name):
           """
           ensure_binary() ensures that the value is a
           python2 str or python3 bytes
           more on this here: https://pythonhosted.org/six/#six.binary_type
           """
>>>>>>     if isinstance(obj, six.binary_type):
>>>>>>       return obj
       
>>>>>>     if isinstance(obj, six.text_type) or isinstance(obj, six.string_types):
>>>>>>        return obj.encode("utf-8")
       
>>>>>>     raise TypeError("%s should be %s instead it is a %s" % (name, byte_type, type(obj)))
       
       
    1: def is_base64(s):
           """
           is_base64 tests whether a string is valid base64 by testing that it round-trips accurately.
           This is required because python 2.7 does not have a Validate option to the decoder.
           """
>>>>>>     try:
>>>>>>         s = six.ensure_binary(s, "utf-8")
>>>>>>         return base64.b64encode(base64.b64decode(s)) == s
>>>>>>     except Exception as e:
>>>>>>         return False
       
    1: def validate_user_id(user_id):
>>>>>>     user_id = ensure_text(user_id, "user_id")
       
>>>>>>     length = len(user_id)
>>>>>>     if length == 0:
>>>>>>         raise ValueError("User id is empty")
       
>>>>>>     if length > 200:
>>>>>>         raise ValueError("User id too long: '{}'".format(user_id))
       
>>>>>>     if not channel_name_re.match(user_id):
>>>>>>         raise ValueError("Invalid user id: '{}'".format(user_id))
       
>>>>>>     return user_id
       
    1: def validate_channel(channel):
    1:     channel = ensure_text(channel, "channel")
       
    1:     if len(channel) > 200:
>>>>>>         raise ValueError("Channel too long: %s" % channel)
       
    1:     if not channel_name_re.match(channel):
>>>>>>         raise ValueError("Invalid Channel: %s" % channel)
       
    1:     return channel
       
       
    1: def validate_socket_id(socket_id):
>>>>>>     socket_id = ensure_text(socket_id, "socket_id")
       
>>>>>>     if not socket_id_re.match(socket_id):
>>>>>>         raise ValueError("Invalid socket ID: %s" % socket_id)
       
>>>>>>     return socket_id
       
       
    1: def join_attributes(attributes):
>>>>>>     return six.text_type(',').join(attributes)
       
       
    1: def data_to_string(data, json_encoder):
    1:     if isinstance(data, six.string_types):
>>>>>>         return ensure_text(data, "data")
       
           else:
    1:         return json.dumps(data, cls=json_encoder)
       
       
    1: def doc_string(doc):
   14:     def decorator(f):
   14:         f.__doc__ = doc
   14:         return f
       
   14:     return decorator
