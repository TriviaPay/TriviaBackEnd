       # orm/base.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: """Constants and rudimental functions used throughout the ORM.
       
       """
       
    1: from __future__ import annotations
       
    1: from enum import Enum
    1: import operator
    1: import typing
    1: from typing import Any
    1: from typing import Callable
    1: from typing import Dict
    1: from typing import Generic
    1: from typing import no_type_check
    1: from typing import Optional
    1: from typing import overload
    1: from typing import Type
    1: from typing import TYPE_CHECKING
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from . import exc
    1: from ._typing import insp_is_mapper
    1: from .. import exc as sa_exc
    1: from .. import inspection
    1: from .. import util
    1: from ..sql import roles
    1: from ..sql.elements import SQLColumnExpression
    1: from ..sql.elements import SQLCoreOperations
    1: from ..util import FastIntFlag
    1: from ..util.langhelpers import TypingOnly
    1: from ..util.typing import Literal
       
    1: if typing.TYPE_CHECKING:
>>>>>>     from ._typing import _EntityType
>>>>>>     from ._typing import _ExternalEntityType
>>>>>>     from ._typing import _InternalEntityType
>>>>>>     from .attributes import InstrumentedAttribute
>>>>>>     from .dynamic import AppenderQuery
>>>>>>     from .instrumentation import ClassManager
>>>>>>     from .interfaces import PropComparator
>>>>>>     from .mapper import Mapper
>>>>>>     from .state import InstanceState
>>>>>>     from .util import AliasedClass
>>>>>>     from .writeonly import WriteOnlyCollection
>>>>>>     from ..sql._typing import _ColumnExpressionArgument
>>>>>>     from ..sql._typing import _InfoType
>>>>>>     from ..sql.elements import ColumnElement
>>>>>>     from ..sql.operators import OperatorType
       
    1: _T = TypeVar("_T", bound=Any)
    1: _T_co = TypeVar("_T_co", bound=Any, covariant=True)
       
    1: _O = TypeVar("_O", bound=object)
       
       
    2: class LoaderCallableStatus(Enum):
    1:     PASSIVE_NO_RESULT = 0
           """Symbol returned by a loader callable or other attribute/history
           retrieval operation when a value could not be determined, based
           on loader callable flags.
           """
       
    1:     PASSIVE_CLASS_MISMATCH = 1
           """Symbol indicating that an object is locally present for a given
           primary key identity but it is not of the requested class.  The
           return value is therefore None and no SQL should be emitted."""
       
    1:     ATTR_WAS_SET = 2
           """Symbol returned by a loader callable to indicate the
           retrieved value, or values, were assigned to their attributes
           on the target object.
           """
       
    1:     ATTR_EMPTY = 3
           """Symbol used internally to indicate an attribute had no callable."""
       
    1:     NO_VALUE = 4
           """Symbol which may be placed as the 'previous' value of an attribute,
           indicating no value was loaded for an attribute when it was modified,
           and flags indicated we were not to load it.
           """
       
    1:     NEVER_SET = NO_VALUE
    1:     """
           Synonymous with NO_VALUE
       
           .. versionchanged:: 1.4   NEVER_SET was merged with NO_VALUE
       
           """
       
       
    1: (
    1:     PASSIVE_NO_RESULT,
    1:     PASSIVE_CLASS_MISMATCH,
    1:     ATTR_WAS_SET,
    1:     ATTR_EMPTY,
    1:     NO_VALUE,
    1: ) = tuple(LoaderCallableStatus)
       
    1: NEVER_SET = NO_VALUE
       
       
    2: class PassiveFlag(FastIntFlag):
    1:     """Bitflag interface that passes options onto loader callables"""
       
    1:     NO_CHANGE = 0
           """No callables or SQL should be emitted on attribute access
           and no state should change
           """
       
    1:     CALLABLES_OK = 1
           """Loader callables can be fired off if a value
           is not present.
           """
       
    1:     SQL_OK = 2
           """Loader callables can emit SQL at least on scalar value attributes."""
       
    1:     RELATED_OBJECT_OK = 4
           """Callables can use SQL to load related objects as well
           as scalar value attributes.
           """
       
    1:     INIT_OK = 8
           """Attributes should be initialized with a blank
           value (None or an empty collection) upon get, if no other
           value can be obtained.
           """
       
    1:     NON_PERSISTENT_OK = 16
           """Callables can be emitted if the parent is not persistent."""
       
    1:     LOAD_AGAINST_COMMITTED = 32
           """Callables should use committed values as primary/foreign keys during a
           load.
           """
       
    1:     NO_AUTOFLUSH = 64
           """Loader callables should disable autoflush.""",
       
    1:     NO_RAISE = 128
           """Loader callables should not raise any assertions"""
       
    1:     DEFERRED_HISTORY_LOAD = 256
           """indicates special load of the previous value of an attribute"""
       
    1:     INCLUDE_PENDING_MUTATIONS = 512
       
           # pre-packaged sets of flags used as inputs
    1:     PASSIVE_OFF = (
    1:         RELATED_OBJECT_OK | NON_PERSISTENT_OK | INIT_OK | CALLABLES_OK | SQL_OK
           )
           "Callables can be emitted in all cases."
       
    1:     PASSIVE_RETURN_NO_VALUE = PASSIVE_OFF ^ INIT_OK
           """PASSIVE_OFF ^ INIT_OK"""
       
    1:     PASSIVE_NO_INITIALIZE = PASSIVE_RETURN_NO_VALUE ^ CALLABLES_OK
           "PASSIVE_RETURN_NO_VALUE ^ CALLABLES_OK"
       
    1:     PASSIVE_NO_FETCH = PASSIVE_OFF ^ SQL_OK
           "PASSIVE_OFF ^ SQL_OK"
       
    1:     PASSIVE_NO_FETCH_RELATED = PASSIVE_OFF ^ RELATED_OBJECT_OK
           "PASSIVE_OFF ^ RELATED_OBJECT_OK"
       
    1:     PASSIVE_ONLY_PERSISTENT = PASSIVE_OFF ^ NON_PERSISTENT_OK
           "PASSIVE_OFF ^ NON_PERSISTENT_OK"
       
    1:     PASSIVE_MERGE = PASSIVE_OFF | NO_RAISE
    1:     """PASSIVE_OFF | NO_RAISE
       
           Symbol used specifically for session.merge() and similar cases
       
           """
       
       
    1: (
    1:     NO_CHANGE,
    1:     CALLABLES_OK,
    1:     SQL_OK,
    1:     RELATED_OBJECT_OK,
    1:     INIT_OK,
    1:     NON_PERSISTENT_OK,
    1:     LOAD_AGAINST_COMMITTED,
    1:     NO_AUTOFLUSH,
    1:     NO_RAISE,
    1:     DEFERRED_HISTORY_LOAD,
    1:     INCLUDE_PENDING_MUTATIONS,
    1:     PASSIVE_OFF,
    1:     PASSIVE_RETURN_NO_VALUE,
    1:     PASSIVE_NO_INITIALIZE,
    1:     PASSIVE_NO_FETCH,
    1:     PASSIVE_NO_FETCH_RELATED,
    1:     PASSIVE_ONLY_PERSISTENT,
    1:     PASSIVE_MERGE,
    1: ) = PassiveFlag.__members__.values()
       
    1: DEFAULT_MANAGER_ATTR = "_sa_class_manager"
    1: DEFAULT_STATE_ATTR = "_sa_instance_state"
       
       
    2: class EventConstants(Enum):
    1:     EXT_CONTINUE = 1
    1:     EXT_STOP = 2
    1:     EXT_SKIP = 3
    1:     NO_KEY = 4
    1:     """indicates an :class:`.AttributeEvent` event that did not have any
           key argument.
       
           .. versionadded:: 2.0
       
           """
       
       
    1: EXT_CONTINUE, EXT_STOP, EXT_SKIP, NO_KEY = tuple(EventConstants)
       
       
    2: class RelationshipDirection(Enum):
    1:     """enumeration which indicates the 'direction' of a
           :class:`_orm.RelationshipProperty`.
       
           :class:`.RelationshipDirection` is accessible from the
           :attr:`_orm.Relationship.direction` attribute of
           :class:`_orm.RelationshipProperty`.
       
           """
       
    1:     ONETOMANY = 1
           """Indicates the one-to-many direction for a :func:`_orm.relationship`.
       
           This symbol is typically used by the internals but may be exposed within
           certain API features.
       
           """
       
    1:     MANYTOONE = 2
           """Indicates the many-to-one direction for a :func:`_orm.relationship`.
       
           This symbol is typically used by the internals but may be exposed within
           certain API features.
       
           """
       
    1:     MANYTOMANY = 3
    1:     """Indicates the many-to-many direction for a :func:`_orm.relationship`.
       
           This symbol is typically used by the internals but may be exposed within
           certain API features.
       
           """
       
       
    1: ONETOMANY, MANYTOONE, MANYTOMANY = tuple(RelationshipDirection)
       
       
    2: class InspectionAttrExtensionType(Enum):
    1:     """Symbols indicating the type of extension that a
           :class:`.InspectionAttr` is part of."""
       
       
    2: class NotExtension(InspectionAttrExtensionType):
    1:     NOT_EXTENSION = "not_extension"
    1:     """Symbol indicating an :class:`InspectionAttr` that's
           not part of sqlalchemy.ext.
       
           Is assigned to the :attr:`.InspectionAttr.extension_type`
           attribute.
       
           """
       
       
    1: _never_set = frozenset([NEVER_SET])
       
    1: _none_set = frozenset([None, NEVER_SET, PASSIVE_NO_RESULT])
       
    1: _SET_DEFERRED_EXPIRED = util.symbol("SET_DEFERRED_EXPIRED")
       
    1: _DEFER_FOR_STATE = util.symbol("DEFER_FOR_STATE")
       
    1: _RAISE_FOR_STATE = util.symbol("RAISE_FOR_STATE")
       
       
    1: _F = TypeVar("_F", bound=Callable[..., Any])
    1: _Self = TypeVar("_Self")
       
       
    1: def _assertions(
           *assertions: Any,
       ) -> Callable[[_F], _F]:
   10:     @util.decorator
   10:     def generate(fn: _F, self: _Self, *args: Any, **kw: Any) -> _Self:
  251:         for assertion in assertions:
  151:             assertion(self, fn.__name__)
  100:         fn(self, *args, **kw)
  100:         return self
       
   10:     return generate
       
       
    1: if TYPE_CHECKING:
       
>>>>>>     def manager_of_class(cls: Type[_O]) -> ClassManager[_O]: ...
       
>>>>>>     @overload
>>>>>>     def opt_manager_of_class(cls: AliasedClass[Any]) -> None: ...
       
>>>>>>     @overload
>>>>>>     def opt_manager_of_class(
               cls: _ExternalEntityType[_O],
>>>>>>     ) -> Optional[ClassManager[_O]]: ...
       
>>>>>>     def opt_manager_of_class(
               cls: _ExternalEntityType[_O],
>>>>>>     ) -> Optional[ClassManager[_O]]: ...
       
>>>>>>     def instance_state(instance: _O) -> InstanceState[_O]: ...
       
>>>>>>     def instance_dict(instance: object) -> Dict[str, Any]: ...
       
       else:
           # these can be replaced by sqlalchemy.ext.instrumentation
           # if augmented class instrumentation is enabled.
       
    1:     def manager_of_class(cls):
 1231:         try:
 1231:             return cls.__dict__[DEFAULT_MANAGER_ATTR]
>>>>>>         except KeyError as ke:
>>>>>>             raise exc.UnmappedClassError(
>>>>>>                 cls, f"Can't locate an instrumentation manager for class {cls}"
>>>>>>             ) from ke
       
    1:     def opt_manager_of_class(cls):
 1899:         return cls.__dict__.get(DEFAULT_MANAGER_ATTR)
       
    1:     instance_state = operator.attrgetter(DEFAULT_STATE_ATTR)
       
    1:     instance_dict = operator.attrgetter("__dict__")
       
       
    1: def instance_str(instance: object) -> str:
           """Return a string describing an instance."""
       
>>>>>>     return state_str(instance_state(instance))
       
       
    1: def state_str(state: InstanceState[Any]) -> str:
           """Return a string describing an instance via its InstanceState."""
       
>>>>>>     if state is None:
>>>>>>         return "None"
           else:
>>>>>>         return "<%s at 0x%x>" % (state.class_.__name__, id(state.obj()))
       
       
    1: def state_class_str(state: InstanceState[Any]) -> str:
           """Return a string describing an instance's class via its
           InstanceState.
           """
       
>>>>>>     if state is None:
>>>>>>         return "None"
           else:
>>>>>>         return "<%s>" % (state.class_.__name__,)
       
       
    1: def attribute_str(instance: object, attribute: str) -> str:
>>>>>>     return instance_str(instance) + "." + attribute
       
       
    1: def state_attribute_str(state: InstanceState[Any], attribute: str) -> str:
>>>>>>     return state_str(state) + "." + attribute
       
       
    1: def object_mapper(instance: _T) -> Mapper[_T]:
           """Given an object, return the primary Mapper associated with the object
           instance.
       
           Raises :class:`sqlalchemy.orm.exc.UnmappedInstanceError`
           if no mapping is configured.
       
           This function is available via the inspection system as::
       
               inspect(instance).mapper
       
           Using the inspection system will raise
           :class:`sqlalchemy.exc.NoInspectionAvailable` if the instance is
           not part of a mapping.
       
           """
    1:     return object_state(instance).mapper
       
       
    1: def object_state(instance: _T) -> InstanceState[_T]:
           """Given an object, return the :class:`.InstanceState`
           associated with the object.
       
           Raises :class:`sqlalchemy.orm.exc.UnmappedInstanceError`
           if no mapping is configured.
       
           Equivalent functionality is available via the :func:`_sa.inspect`
           function as::
       
               inspect(instance)
       
           Using the inspection system will raise
           :class:`sqlalchemy.exc.NoInspectionAvailable` if the instance is
           not part of a mapping.
       
           """
    1:     state = _inspect_mapped_object(instance)
    1:     if state is None:
>>>>>>         raise exc.UnmappedInstanceError(instance)
           else:
    1:         return state
       
       
    1: @inspection._inspects(object)
    1: def _inspect_mapped_object(instance: _T) -> Optional[InstanceState[_T]]:
   92:     try:
   92:         return instance_state(instance)
   91:     except (exc.UnmappedClassError,) + exc.NO_STATE:
   91:         return None
       
       
    1: def _class_to_mapper(
           class_or_mapper: Union[Mapper[_T], Type[_T]]
       ) -> Mapper[_T]:
           # can't get mypy to see an overload for this
>>>>>>     insp = inspection.inspect(class_or_mapper, False)
>>>>>>     if insp is not None:
>>>>>>         return insp.mapper  # type: ignore
           else:
>>>>>>         assert isinstance(class_or_mapper, type)
>>>>>>         raise exc.UnmappedClassError(class_or_mapper)
       
       
    1: def _mapper_or_none(
           entity: Union[Type[_T], _InternalEntityType[_T]]
       ) -> Optional[Mapper[_T]]:
           """Return the :class:`_orm.Mapper` for the given class or None if the
           class is not mapped.
           """
       
           # can't get mypy to see an overload for this
>>>>>>     insp = inspection.inspect(entity, False)
>>>>>>     if insp is not None:
>>>>>>         return insp.mapper  # type: ignore
           else:
>>>>>>         return None
       
       
    1: def _is_mapped_class(entity: Any) -> bool:
           """Return True if the given object is a mapped class,
           :class:`_orm.Mapper`, or :class:`.AliasedClass`.
           """
       
   90:     insp = inspection.inspect(entity, False)
   90:     return (
   90:         insp is not None
>>>>>>         and not insp.is_clause_element
>>>>>>         and (insp.is_mapper or insp.is_aliased_class)
           )
       
       
    1: def _is_aliased_class(entity: Any) -> bool:
>>>>>>     insp = inspection.inspect(entity, False)
>>>>>>     return insp is not None and getattr(insp, "is_aliased_class", False)
       
       
    1: @no_type_check
    1: def _entity_descriptor(entity: _EntityType[Any], key: str) -> Any:
           """Return a class attribute given an entity and string name.
       
           May return :class:`.InstrumentedAttribute` or user-defined
           attribute.
       
           """
>>>>>>     insp = inspection.inspect(entity)
>>>>>>     if insp.is_selectable:
>>>>>>         description = entity
>>>>>>         entity = insp.c
>>>>>>     elif insp.is_aliased_class:
>>>>>>         entity = insp.entity
>>>>>>         description = entity
>>>>>>     elif hasattr(insp, "mapper"):
>>>>>>         description = entity = insp.mapper.class_
           else:
>>>>>>         description = entity
       
>>>>>>     try:
>>>>>>         return getattr(entity, key)
>>>>>>     except AttributeError as err:
>>>>>>         raise sa_exc.InvalidRequestError(
>>>>>>             "Entity '%s' has no property '%s'" % (description, key)
>>>>>>         ) from err
       
       
    1: if TYPE_CHECKING:
       
>>>>>>     def _state_mapper(state: InstanceState[_O]) -> Mapper[_O]: ...
       
       else:
    1:     _state_mapper = util.dottedgetter("manager.mapper")
       
       
    1: def _inspect_mapped_class(
           class_: Type[_O], configure: bool = False
       ) -> Optional[Mapper[_O]]:
  204:     try:
  204:         class_manager = opt_manager_of_class(class_)
  204:         if class_manager is None or not class_manager.is_mapped:
   90:             return None
  114:         mapper = class_manager.mapper
>>>>>>     except exc.NO_STATE:
>>>>>>         return None
           else:
  114:         if configure:
>>>>>>             mapper._check_configure()
  114:         return mapper
       
       
    1: def _parse_mapper_argument(arg: Union[Mapper[_O], Type[_O]]) -> Mapper[_O]:
>>>>>>     insp = inspection.inspect(arg, raiseerr=False)
>>>>>>     if insp_is_mapper(insp):
>>>>>>         return insp
       
>>>>>>     raise sa_exc.ArgumentError(f"Mapper or mapped class expected, got {arg!r}")
       
       
    1: def class_mapper(class_: Type[_O], configure: bool = True) -> Mapper[_O]:
           """Given a class, return the primary :class:`_orm.Mapper` associated
           with the key.
       
           Raises :exc:`.UnmappedClassError` if no mapping is configured
           on the given class, or :exc:`.ArgumentError` if a non-class
           object is passed.
       
           Equivalent functionality is available via the :func:`_sa.inspect`
           function as::
       
               inspect(some_mapped_class)
       
           Using the inspection system will raise
           :class:`sqlalchemy.exc.NoInspectionAvailable` if the class is not mapped.
       
           """
   57:     mapper = _inspect_mapped_class(class_, configure=configure)
   57:     if mapper is None:
>>>>>>         if not isinstance(class_, type):
>>>>>>             raise sa_exc.ArgumentError(
>>>>>>                 "Class object expected, got '%r'." % (class_,)
                   )
>>>>>>         raise exc.UnmappedClassError(class_)
           else:
   57:         return mapper
       
       
    2: class InspectionAttr:
    1:     """A base class applied to all ORM objects and attributes that are
           related to things that can be returned by the :func:`_sa.inspect` function.
       
           The attributes defined here allow the usage of simple boolean
           checks to test basic facts about the object returned.
       
           While the boolean checks here are basically the same as using
           the Python isinstance() function, the flags here can be used without
           the need to import all of these classes, and also such that
           the SQLAlchemy class system can change while leaving the flags
           here intact for forwards-compatibility.
       
           """
       
    1:     __slots__ = ()
       
    1:     is_selectable = False
           """Return True if this object is an instance of
           :class:`_expression.Selectable`."""
       
    1:     is_aliased_class = False
           """True if this object is an instance of :class:`.AliasedClass`."""
       
    1:     is_instance = False
           """True if this object is an instance of :class:`.InstanceState`."""
       
    1:     is_mapper = False
           """True if this object is an instance of :class:`_orm.Mapper`."""
       
    1:     is_bundle = False
           """True if this object is an instance of :class:`.Bundle`."""
       
    1:     is_property = False
           """True if this object is an instance of :class:`.MapperProperty`."""
       
    1:     is_attribute = False
           """True if this object is a Python :term:`descriptor`.
       
           This can refer to one of many types.   Usually a
           :class:`.QueryableAttribute` which handles attributes events on behalf
           of a :class:`.MapperProperty`.   But can also be an extension type
           such as :class:`.AssociationProxy` or :class:`.hybrid_property`.
           The :attr:`.InspectionAttr.extension_type` will refer to a constant
           identifying the specific subtype.
       
           .. seealso::
       
               :attr:`_orm.Mapper.all_orm_descriptors`
       
           """
       
    1:     _is_internal_proxy = False
           """True if this object is an internal proxy object.
       
           .. versionadded:: 1.2.12
       
           """
       
    1:     is_clause_element = False
           """True if this object is an instance of
           :class:`_expression.ClauseElement`."""
       
    1:     extension_type: InspectionAttrExtensionType = NotExtension.NOT_EXTENSION
    1:     """The extension type, if any.
           Defaults to :attr:`.interfaces.NotExtension.NOT_EXTENSION`
       
           .. seealso::
       
               :class:`.HybridExtensionType`
       
               :class:`.AssociationProxyExtensionType`
       
           """
       
       
    2: class InspectionAttrInfo(InspectionAttr):
    1:     """Adds the ``.info`` attribute to :class:`.InspectionAttr`.
       
           The rationale for :class:`.InspectionAttr` vs. :class:`.InspectionAttrInfo`
           is that the former is compatible as a mixin for classes that specify
           ``__slots__``; this is essentially an implementation artifact.
       
           """
       
    1:     __slots__ = ()
       
    1:     @util.ro_memoized_property
    1:     def info(self) -> _InfoType:
               """Info dictionary associated with the object, allowing user-defined
               data to be associated with this :class:`.InspectionAttr`.
       
               The dictionary is generated when first accessed.  Alternatively,
               it can be specified as a constructor argument to the
               :func:`.column_property`, :func:`_orm.relationship`, or
               :func:`.composite`
               functions.
       
               .. seealso::
       
                   :attr:`.QueryableAttribute.info`
       
                   :attr:`.SchemaItem.info`
       
               """
>>>>>>         return {}
       
       
    2: class SQLORMOperations(SQLCoreOperations[_T_co], TypingOnly):
    1:     __slots__ = ()
       
    1:     if typing.TYPE_CHECKING:
       
>>>>>>         def of_type(
                   self, class_: _EntityType[Any]
>>>>>>         ) -> PropComparator[_T_co]: ...
       
>>>>>>         def and_(
                   self, *criteria: _ColumnExpressionArgument[bool]
>>>>>>         ) -> PropComparator[bool]: ...
       
>>>>>>         def any(  # noqa: A001
                   self,
                   criterion: Optional[_ColumnExpressionArgument[bool]] = None,
                   **kwargs: Any,
>>>>>>         ) -> ColumnElement[bool]: ...
       
>>>>>>         def has(
                   self,
                   criterion: Optional[_ColumnExpressionArgument[bool]] = None,
                   **kwargs: Any,
>>>>>>         ) -> ColumnElement[bool]: ...
       
       
    2: class ORMDescriptor(Generic[_T_co], TypingOnly):
    1:     """Represent any Python descriptor that provides a SQL expression
           construct at the class level."""
       
    1:     __slots__ = ()
       
    1:     if typing.TYPE_CHECKING:
       
>>>>>>         @overload
>>>>>>         def __get__(
                   self, instance: Any, owner: Literal[None]
>>>>>>         ) -> ORMDescriptor[_T_co]: ...
       
>>>>>>         @overload
>>>>>>         def __get__(
                   self, instance: Literal[None], owner: Any
>>>>>>         ) -> SQLCoreOperations[_T_co]: ...
       
>>>>>>         @overload
>>>>>>         def __get__(self, instance: object, owner: Any) -> _T_co: ...
       
>>>>>>         def __get__(
                   self, instance: object, owner: Any
>>>>>>         ) -> Union[ORMDescriptor[_T_co], SQLCoreOperations[_T_co], _T_co]: ...
       
       
    2: class _MappedAnnotationBase(Generic[_T_co], TypingOnly):
    1:     """common class for Mapped and similar ORM container classes.
       
           these are classes that can appear on the left side of an ORM declarative
           mapping, containing a mapped class or in some cases a collection
           surrounding a mapped class.
       
           """
       
    1:     __slots__ = ()
       
       
    3: class SQLORMExpression(
    1:     SQLORMOperations[_T_co], SQLColumnExpression[_T_co], TypingOnly
       ):
    1:     """A type that may be used to indicate any ORM-level attribute or
           object that acts in place of one, in the context of SQL expression
           construction.
       
           :class:`.SQLORMExpression` extends from the Core
           :class:`.SQLColumnExpression` to add additional SQL methods that are ORM
           specific, such as :meth:`.PropComparator.of_type`, and is part of the bases
           for :class:`.InstrumentedAttribute`. It may be used in :pep:`484` typing to
           indicate arguments or return values that should behave as ORM-level
           attribute expressions.
       
           .. versionadded:: 2.0.0b4
       
       
           """
       
    1:     __slots__ = ()
       
       
    3: class Mapped(
    1:     SQLORMExpression[_T_co],
    1:     ORMDescriptor[_T_co],
    1:     _MappedAnnotationBase[_T_co],
    1:     roles.DDLConstraintColumnRole,
       ):
    1:     """Represent an ORM mapped attribute on a mapped class.
       
           This class represents the complete descriptor interface for any class
           attribute that will have been :term:`instrumented` by the ORM
           :class:`_orm.Mapper` class.   Provides appropriate information to type
           checkers such as pylance and mypy so that ORM-mapped attributes
           are correctly typed.
       
           The most prominent use of :class:`_orm.Mapped` is in
           the :ref:`Declarative Mapping <orm_explicit_declarative_base>` form
           of :class:`_orm.Mapper` configuration, where used explicitly it drives
           the configuration of ORM attributes such as :func:`_orm.mapped_class`
           and :func:`_orm.relationship`.
       
           .. seealso::
       
               :ref:`orm_explicit_declarative_base`
       
               :ref:`orm_declarative_table`
       
           .. tip::
       
               The :class:`_orm.Mapped` class represents attributes that are handled
               directly by the :class:`_orm.Mapper` class. It does not include other
               Python descriptor classes that are provided as extensions, including
               :ref:`hybrids_toplevel` and the :ref:`associationproxy_toplevel`.
               While these systems still make use of ORM-specific superclasses
               and structures, they are not :term:`instrumented` by the
               :class:`_orm.Mapper` and instead provide their own functionality
               when they are accessed on a class.
       
           .. versionadded:: 1.4
       
       
           """
       
    1:     __slots__ = ()
       
    1:     if typing.TYPE_CHECKING:
       
>>>>>>         @overload
>>>>>>         def __get__(
                   self, instance: None, owner: Any
>>>>>>         ) -> InstrumentedAttribute[_T_co]: ...
       
>>>>>>         @overload
>>>>>>         def __get__(self, instance: object, owner: Any) -> _T_co: ...
       
>>>>>>         def __get__(
                   self, instance: Optional[object], owner: Any
>>>>>>         ) -> Union[InstrumentedAttribute[_T_co], _T_co]: ...
       
>>>>>>         @classmethod
>>>>>>         def _empty_constructor(cls, arg1: Any) -> Mapped[_T_co]: ...
       
>>>>>>         def __set__(
                   self, instance: Any, value: Union[SQLCoreOperations[_T_co], _T_co]
>>>>>>         ) -> None: ...
       
>>>>>>         def __delete__(self, instance: Any) -> None: ...
       
       
    2: class _MappedAttribute(Generic[_T_co], TypingOnly):
    1:     """Mixin for attributes which should be replaced by mapper-assigned
           attributes.
       
           """
       
    1:     __slots__ = ()
       
       
    2: class _DeclarativeMapped(Mapped[_T_co], _MappedAttribute[_T_co]):
    1:     """Mixin for :class:`.MapperProperty` subclasses that allows them to
           be compatible with ORM-annotated declarative mappings.
       
           """
       
    1:     __slots__ = ()
       
           # MappedSQLExpression, Relationship, Composite etc. dont actually do
           # SQL expression behavior.  yet there is code that compares them with
           # __eq__(), __ne__(), etc.   Since #8847 made Mapped even more full
           # featured including ColumnOperators, we need to have those methods
           # be no-ops for these objects, so return NotImplemented to fall back
           # to normal comparison behavior.
    1:     def operate(self, op: OperatorType, *other: Any, **kwargs: Any) -> Any:
>>>>>>         return NotImplemented
       
    1:     __sa_operate__ = operate
       
    1:     def reverse_operate(
               self, op: OperatorType, other: Any, **kwargs: Any
           ) -> Any:
>>>>>>         return NotImplemented
       
       
    2: class DynamicMapped(_MappedAnnotationBase[_T_co]):
    1:     """Represent the ORM mapped attribute type for a "dynamic" relationship.
       
           The :class:`_orm.DynamicMapped` type annotation may be used in an
           :ref:`Annotated Declarative Table <orm_declarative_mapped_column>` mapping
           to indicate that the ``lazy="dynamic"`` loader strategy should be used
           for a particular :func:`_orm.relationship`.
       
           .. legacy::  The "dynamic" lazy loader strategy is the legacy form of what
              is now the "write_only" strategy described in the section
              :ref:`write_only_relationship`.
       
           E.g.::
       
               class User(Base):
                   __tablename__ = "user"
                   id: Mapped[int] = mapped_column(primary_key=True)
                   addresses: DynamicMapped[Address] = relationship(
                       cascade="all,delete-orphan"
                   )
       
           See the section :ref:`dynamic_relationship` for background.
       
           .. versionadded:: 2.0
       
           .. seealso::
       
               :ref:`dynamic_relationship` - complete background
       
               :class:`.WriteOnlyMapped` - fully 2.0 style version
       
           """
       
    1:     __slots__ = ()
       
    1:     if TYPE_CHECKING:
       
>>>>>>         @overload
>>>>>>         def __get__(
                   self, instance: None, owner: Any
>>>>>>         ) -> InstrumentedAttribute[_T_co]: ...
       
>>>>>>         @overload
>>>>>>         def __get__(
                   self, instance: object, owner: Any
>>>>>>         ) -> AppenderQuery[_T_co]: ...
       
>>>>>>         def __get__(
                   self, instance: Optional[object], owner: Any
>>>>>>         ) -> Union[InstrumentedAttribute[_T_co], AppenderQuery[_T_co]]: ...
       
>>>>>>         def __set__(
                   self, instance: Any, value: typing.Collection[_T_co]
>>>>>>         ) -> None: ...
       
       
    2: class WriteOnlyMapped(_MappedAnnotationBase[_T_co]):
    1:     """Represent the ORM mapped attribute type for a "write only" relationship.
       
           The :class:`_orm.WriteOnlyMapped` type annotation may be used in an
           :ref:`Annotated Declarative Table <orm_declarative_mapped_column>` mapping
           to indicate that the ``lazy="write_only"`` loader strategy should be used
           for a particular :func:`_orm.relationship`.
       
           E.g.::
       
               class User(Base):
                   __tablename__ = "user"
                   id: Mapped[int] = mapped_column(primary_key=True)
                   addresses: WriteOnlyMapped[Address] = relationship(
                       cascade="all,delete-orphan"
                   )
       
           See the section :ref:`write_only_relationship` for background.
       
           .. versionadded:: 2.0
       
           .. seealso::
       
               :ref:`write_only_relationship` - complete background
       
               :class:`.DynamicMapped` - includes legacy :class:`_orm.Query` support
       
           """
       
    1:     __slots__ = ()
       
    1:     if TYPE_CHECKING:
       
>>>>>>         @overload
>>>>>>         def __get__(
                   self, instance: None, owner: Any
>>>>>>         ) -> InstrumentedAttribute[_T_co]: ...
       
>>>>>>         @overload
>>>>>>         def __get__(
                   self, instance: object, owner: Any
>>>>>>         ) -> WriteOnlyCollection[_T_co]: ...
       
>>>>>>         def __get__(
                   self, instance: Optional[object], owner: Any
               ) -> Union[
                   InstrumentedAttribute[_T_co], WriteOnlyCollection[_T_co]
>>>>>>         ]: ...
       
>>>>>>         def __set__(
                   self, instance: Any, value: typing.Collection[_T_co]
>>>>>>         ) -> None: ...
