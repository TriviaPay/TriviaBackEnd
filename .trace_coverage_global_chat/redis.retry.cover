    1: import abc
    1: import socket
    1: from time import sleep
    1: from typing import (
           TYPE_CHECKING,
           Any,
           Callable,
           Generic,
           Iterable,
           Optional,
           Tuple,
           Type,
           TypeVar,
       )
       
    1: from redis.exceptions import ConnectionError, TimeoutError
       
    1: T = TypeVar("T")
    1: E = TypeVar("E", bound=Exception, covariant=True)
       
    1: if TYPE_CHECKING:
>>>>>>     from redis.backoff import AbstractBackoff
       
       
    2: class AbstractRetry(Generic[E], abc.ABC):
    1:     """Retry a specific number of times after a failure"""
       
    1:     _supported_errors: Tuple[Type[E], ...]
       
    1:     def __init__(
               self,
    1:         backoff: "AbstractBackoff",
    1:         retries: int,
    1:         supported_errors: Tuple[Type[E], ...],
           ):
               """
               Initialize a `Retry` object with a `Backoff` object
               that retries a maximum of `retries` times.
               `retries` can be negative to retry forever.
               You can specify the types of supported errors which trigger
               a retry with the `supported_errors` parameter.
               """
    2:         self._backoff = backoff
    2:         self._retries = retries
    2:         self._supported_errors = supported_errors
       
    1:     @abc.abstractmethod
    1:     def __eq__(self, other: Any) -> bool:
>>>>>>         return NotImplemented
       
    1:     def __hash__(self) -> int:
>>>>>>         return hash((self._backoff, self._retries, frozenset(self._supported_errors)))
       
    1:     def update_supported_errors(self, specified_errors: Iterable[Type[E]]) -> None:
               """
               Updates the supported errors with the specified error types
               """
>>>>>>         self._supported_errors = tuple(
>>>>>>             set(self._supported_errors + tuple(specified_errors))
               )
       
    1:     def get_retries(self) -> int:
               """
               Get the number of retries.
               """
>>>>>>         return self._retries
       
    1:     def update_retries(self, value: int) -> None:
               """
               Set the number of retries.
               """
>>>>>>         self._retries = value
       
       
    2: class Retry(AbstractRetry[Exception]):
    1:     __hash__ = AbstractRetry.__hash__
       
    2:     def __init__(
               self,
    1:         backoff: "AbstractBackoff",
    1:         retries: int,
    2:         supported_errors: Tuple[Type[Exception], ...] = (
    1:             ConnectionError,
    1:             TimeoutError,
    1:             socket.timeout,
               ),
           ):
    1:         super().__init__(backoff, retries, supported_errors)
       
    1:     def __eq__(self, other: Any) -> bool:
>>>>>>         if not isinstance(other, Retry):
>>>>>>             return NotImplemented
       
>>>>>>         return (
>>>>>>             self._backoff == other._backoff
>>>>>>             and self._retries == other._retries
>>>>>>             and set(self._supported_errors) == set(other._supported_errors)
               )
       
    2:     def call_with_retry(
               self,
    1:         do: Callable[[], T],
    1:         fail: Callable[[Exception], Any],
    1:         is_retryable: Optional[Callable[[Exception], bool]] = None,
    1:     ) -> T:
               """
               Execute an operation that might fail and returns its result, or
               raise the exception that was thrown depending on the `Backoff` object.
               `do`: the operation to call. Expects no argument.
               `fail`: the failure handler, expects the last error that was thrown
               """
>>>>>>         self._backoff.reset()
>>>>>>         failures = 0
               while True:
>>>>>>             try:
>>>>>>                 return do()
>>>>>>             except self._supported_errors as error:
>>>>>>                 if is_retryable and not is_retryable(error):
>>>>>>                     raise
>>>>>>                 failures += 1
>>>>>>                 fail(error)
>>>>>>                 if self._retries >= 0 and failures > self._retries:
>>>>>>                     raise error
>>>>>>                 backoff = self._backoff.compute(failures)
>>>>>>                 if backoff > 0:
>>>>>>                     sleep(backoff)
