    1: from __future__ import annotations
       
    1: from _pytest import nodes
    1: from _pytest.cacheprovider import Cache
    1: from _pytest.config import Config
    1: from _pytest.config.argparsing import Parser
    1: from _pytest.main import Session
    1: from _pytest.reports import TestReport
       
       
    1: STEPWISE_CACHE_DIR = "cache/stepwise"
       
       
    1: def pytest_addoption(parser: Parser) -> None:
    1:     group = parser.getgroup("general")
    2:     group.addoption(
    1:         "--sw",
    1:         "--stepwise",
    1:         action="store_true",
    1:         default=False,
    1:         dest="stepwise",
    1:         help="Exit on test failure and continue from last failing test next time",
           )
    2:     group.addoption(
    1:         "--sw-skip",
    1:         "--stepwise-skip",
    1:         action="store_true",
    1:         default=False,
    1:         dest="stepwise_skip",
    1:         help="Ignore the first failing test but stop on the next failing test. "
               "Implicitly enables --stepwise.",
           )
       
       
    1: def pytest_configure(config: Config) -> None:
    1:     if config.option.stepwise_skip:
               # allow --stepwise-skip to work on its own merits.
>>>>>>         config.option.stepwise = True
    1:     if config.getoption("stepwise"):
>>>>>>         config.pluginmanager.register(StepwisePlugin(config), "stepwiseplugin")
       
       
    1: def pytest_sessionfinish(session: Session) -> None:
    1:     if not session.config.getoption("stepwise"):
    1:         assert session.config.cache is not None
    1:         if hasattr(session.config, "workerinput"):
                   # Do not update cache if this process is a xdist worker to prevent
                   # race conditions (#10641).
>>>>>>             return
               # Clear the list of failing tests if the plugin is not active.
    1:         session.config.cache.set(STEPWISE_CACHE_DIR, [])
       
       
    2: class StepwisePlugin:
    1:     def __init__(self, config: Config) -> None:
>>>>>>         self.config = config
>>>>>>         self.session: Session | None = None
>>>>>>         self.report_status = ""
>>>>>>         assert config.cache is not None
>>>>>>         self.cache: Cache = config.cache
>>>>>>         self.lastfailed: str | None = self.cache.get(STEPWISE_CACHE_DIR, None)
>>>>>>         self.skip: bool = config.getoption("stepwise_skip")
       
    1:     def pytest_sessionstart(self, session: Session) -> None:
>>>>>>         self.session = session
       
    1:     def pytest_collection_modifyitems(
               self, config: Config, items: list[nodes.Item]
           ) -> None:
>>>>>>         if not self.lastfailed:
>>>>>>             self.report_status = "no previously failed tests, not skipping."
>>>>>>             return
       
               # check all item nodes until we find a match on last failed
>>>>>>         failed_index = None
>>>>>>         for index, item in enumerate(items):
>>>>>>             if item.nodeid == self.lastfailed:
>>>>>>                 failed_index = index
>>>>>>                 break
       
               # If the previously failed test was not found among the test items,
               # do not skip any tests.
>>>>>>         if failed_index is None:
>>>>>>             self.report_status = "previously failed test not found, not skipping."
               else:
>>>>>>             self.report_status = f"skipping {failed_index} already passed items."
>>>>>>             deselected = items[:failed_index]
>>>>>>             del items[:failed_index]
>>>>>>             config.hook.pytest_deselected(items=deselected)
       
    1:     def pytest_runtest_logreport(self, report: TestReport) -> None:
>>>>>>         if report.failed:
>>>>>>             if self.skip:
                       # Remove test from the failed ones (if it exists) and unset the skip option
                       # to make sure the following tests will not be skipped.
>>>>>>                 if report.nodeid == self.lastfailed:
>>>>>>                     self.lastfailed = None
       
>>>>>>                 self.skip = False
                   else:
                       # Mark test as the last failing and interrupt the test session.
>>>>>>                 self.lastfailed = report.nodeid
>>>>>>                 assert self.session is not None
>>>>>>                 self.session.shouldstop = (
>>>>>>                     "Test failed, continuing from this test next run."
                       )
       
               else:
                   # If the test was actually run and did pass.
>>>>>>             if report.when == "call":
                       # Remove test from the failed ones, if exists.
>>>>>>                 if report.nodeid == self.lastfailed:
>>>>>>                     self.lastfailed = None
       
    1:     def pytest_report_collectionfinish(self) -> str | None:
>>>>>>         if self.config.get_verbosity() >= 0 and self.report_status:
>>>>>>             return f"stepwise: {self.report_status}"
>>>>>>         return None
       
    1:     def pytest_sessionfinish(self) -> None:
>>>>>>         if hasattr(self.config, "workerinput"):
                   # Do not update cache if this process is a xdist worker to prevent
                   # race conditions (#10641).
>>>>>>             return
>>>>>>         self.cache.set(STEPWISE_CACHE_DIR, self.lastfailed)
