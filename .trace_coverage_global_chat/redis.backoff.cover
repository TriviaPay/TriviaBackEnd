    1: import random
    1: from abc import ABC, abstractmethod
       
       # Maximum backoff between each retry in seconds
    1: DEFAULT_CAP = 0.512
       # Minimum backoff between each retry in seconds
    1: DEFAULT_BASE = 0.008
       
       
    2: class AbstractBackoff(ABC):
    1:     """Backoff interface"""
       
    1:     def reset(self):
               """
               Reset internal state before an operation.
               `reset` is called once at the beginning of
               every call to `Retry.call_with_retry`
               """
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def compute(self, failures: int) -> float:
               """Compute backoff in seconds upon failure"""
>>>>>>         pass
       
       
    2: class ConstantBackoff(AbstractBackoff):
    1:     """Constant backoff upon failure"""
       
    1:     def __init__(self, backoff: float) -> None:
               """`backoff`: backoff time in seconds"""
>>>>>>         self._backoff = backoff
       
    1:     def __hash__(self) -> int:
>>>>>>         return hash((self._backoff,))
       
    1:     def __eq__(self, other) -> bool:
>>>>>>         if not isinstance(other, ConstantBackoff):
>>>>>>             return NotImplemented
       
>>>>>>         return self._backoff == other._backoff
       
    1:     def compute(self, failures: int) -> float:
>>>>>>         return self._backoff
       
       
    2: class NoBackoff(ConstantBackoff):
    1:     """No backoff upon failure"""
       
    1:     def __init__(self) -> None:
>>>>>>         super().__init__(0)
       
       
    2: class ExponentialBackoff(AbstractBackoff):
    1:     """Exponential backoff upon failure"""
       
    1:     def __init__(self, cap: float = DEFAULT_CAP, base: float = DEFAULT_BASE):
               """
               `cap`: maximum backoff time in seconds
               `base`: base backoff time in seconds
               """
>>>>>>         self._cap = cap
>>>>>>         self._base = base
       
    1:     def __hash__(self) -> int:
>>>>>>         return hash((self._base, self._cap))
       
    1:     def __eq__(self, other) -> bool:
>>>>>>         if not isinstance(other, ExponentialBackoff):
>>>>>>             return NotImplemented
       
>>>>>>         return self._base == other._base and self._cap == other._cap
       
    1:     def compute(self, failures: int) -> float:
>>>>>>         return min(self._cap, self._base * 2**failures)
       
       
    2: class FullJitterBackoff(AbstractBackoff):
    1:     """Full jitter backoff upon failure"""
       
    1:     def __init__(self, cap: float = DEFAULT_CAP, base: float = DEFAULT_BASE) -> None:
               """
               `cap`: maximum backoff time in seconds
               `base`: base backoff time in seconds
               """
>>>>>>         self._cap = cap
>>>>>>         self._base = base
       
    1:     def __hash__(self) -> int:
>>>>>>         return hash((self._base, self._cap))
       
    1:     def __eq__(self, other) -> bool:
>>>>>>         if not isinstance(other, FullJitterBackoff):
>>>>>>             return NotImplemented
       
>>>>>>         return self._base == other._base and self._cap == other._cap
       
    1:     def compute(self, failures: int) -> float:
>>>>>>         return random.uniform(0, min(self._cap, self._base * 2**failures))
       
       
    2: class EqualJitterBackoff(AbstractBackoff):
    1:     """Equal jitter backoff upon failure"""
       
    1:     def __init__(self, cap: float = DEFAULT_CAP, base: float = DEFAULT_BASE) -> None:
               """
               `cap`: maximum backoff time in seconds
               `base`: base backoff time in seconds
               """
>>>>>>         self._cap = cap
>>>>>>         self._base = base
       
    1:     def __hash__(self) -> int:
>>>>>>         return hash((self._base, self._cap))
       
    1:     def __eq__(self, other) -> bool:
>>>>>>         if not isinstance(other, EqualJitterBackoff):
>>>>>>             return NotImplemented
       
>>>>>>         return self._base == other._base and self._cap == other._cap
       
    1:     def compute(self, failures: int) -> float:
>>>>>>         temp = min(self._cap, self._base * 2**failures) / 2
>>>>>>         return temp + random.uniform(0, temp)
       
       
    2: class DecorrelatedJitterBackoff(AbstractBackoff):
    1:     """Decorrelated jitter backoff upon failure"""
       
    1:     def __init__(self, cap: float = DEFAULT_CAP, base: float = DEFAULT_BASE) -> None:
               """
               `cap`: maximum backoff time in seconds
               `base`: base backoff time in seconds
               """
>>>>>>         self._cap = cap
>>>>>>         self._base = base
>>>>>>         self._previous_backoff = 0
       
    1:     def __hash__(self) -> int:
>>>>>>         return hash((self._base, self._cap))
       
    1:     def __eq__(self, other) -> bool:
>>>>>>         if not isinstance(other, DecorrelatedJitterBackoff):
>>>>>>             return NotImplemented
       
>>>>>>         return self._base == other._base and self._cap == other._cap
       
    1:     def reset(self) -> None:
>>>>>>         self._previous_backoff = 0
       
    1:     def compute(self, failures: int) -> float:
>>>>>>         max_backoff = max(self._base, self._previous_backoff * 3)
>>>>>>         temp = random.uniform(self._base, max_backoff)
>>>>>>         self._previous_backoff = min(self._cap, temp)
>>>>>>         return self._previous_backoff
       
       
    2: class ExponentialWithJitterBackoff(AbstractBackoff):
    1:     """Exponential backoff upon failure, with jitter"""
       
    1:     def __init__(self, cap: float = DEFAULT_CAP, base: float = DEFAULT_BASE) -> None:
               """
               `cap`: maximum backoff time in seconds
               `base`: base backoff time in seconds
               """
    2:         self._cap = cap
    2:         self._base = base
       
    1:     def __hash__(self) -> int:
>>>>>>         return hash((self._base, self._cap))
       
    1:     def __eq__(self, other) -> bool:
>>>>>>         if not isinstance(other, ExponentialWithJitterBackoff):
>>>>>>             return NotImplemented
       
>>>>>>         return self._base == other._base and self._cap == other._cap
       
    1:     def compute(self, failures: int) -> float:
>>>>>>         return min(self._cap, random.random() * self._base * 2**failures)
       
       
    1: def default_backoff():
>>>>>>     return EqualJitterBackoff()
