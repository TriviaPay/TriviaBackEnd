       # mock.py
       # Test tools for mocking and patching.
       # Maintained by Michael Foord
       # Backport for other versions of Python available from
       # https://pypi.org/project/mock
       
    1: __all__ = (
           'Mock',
           'MagicMock',
           'patch',
           'sentinel',
           'DEFAULT',
           'ANY',
           'call',
           'create_autospec',
           'AsyncMock',
           'FILTER_DIR',
           'NonCallableMock',
           'NonCallableMagicMock',
           'mock_open',
           'PropertyMock',
           'seal',
       )
       
       
    1: import asyncio
    1: import contextlib
    1: import io
    1: import inspect
    1: import pprint
    1: import sys
    1: import builtins
    1: from asyncio import iscoroutinefunction
    1: from types import CodeType, ModuleType, MethodType
    1: from unittest.util import safe_repr
    1: from functools import wraps, partial
       
       
  154: _builtins = {name for name in dir(builtins) if not name.startswith('_')}
       
    1: FILTER_DIR = True
       
       # Workaround for issue #12370
       # Without this, the __class__ properties wouldn't be set correctly
    1: _safe_super = super
       
    1: def _is_async_obj(obj):
   46:     if _is_instance_mock(obj) and not isinstance(obj, AsyncMock):
>>>>>>         return False
   46:     if hasattr(obj, '__func__'):
>>>>>>         obj = getattr(obj, '__func__')
   46:     return iscoroutinefunction(obj) or inspect.isawaitable(obj)
       
       
    1: def _is_async_func(func):
>>>>>>     if getattr(func, '__code__', None):
>>>>>>         return iscoroutinefunction(func)
           else:
>>>>>>         return False
       
       
    1: def _is_instance_mock(obj):
           # can't use isinstance on Mock objects because they override __class__
           # The base class for all mocks is NonCallableMock
   92:     return issubclass(type(obj), NonCallableMock)
       
       
    1: def _is_exception(obj):
>>>>>>     return (
>>>>>>         isinstance(obj, BaseException) or
>>>>>>         isinstance(obj, type) and issubclass(obj, BaseException)
           )
       
       
    1: def _extract_mock(obj):
           # Autospecced functions will return a FunctionType with "mock" attribute
           # which is the actual mock object that needs to be used.
   46:     if isinstance(obj, FunctionTypes) and hasattr(obj, 'mock'):
>>>>>>         return obj.mock
           else:
   46:         return obj
       
       
    1: def _get_signature_object(func, as_instance, eat_self):
           """
           Given an arbitrary, possibly callable object, try to create a suitable
           signature object.
           Return a (reduced func, signature) tuple, or None.
           """
   45:     if isinstance(func, type) and not as_instance:
               # If it's a type and should be modelled as a type, use __init__.
   45:         func = func.__init__
               # Skip the `self` argument in __init__
   45:         eat_self = True
>>>>>>     elif not isinstance(func, FunctionTypes):
               # If we really want to model an instance of the passed type,
               # __call__ should be looked up, not __init__.
>>>>>>         try:
>>>>>>             func = func.__call__
>>>>>>         except AttributeError:
>>>>>>             return None
   45:     if eat_self:
   45:         sig_func = partial(func, None)
           else:
>>>>>>         sig_func = func
   45:     try:
   45:         return func, inspect.signature(sig_func)
>>>>>>     except ValueError:
               # Certain callable types are not supported by inspect.signature()
>>>>>>         return None
       
       
    1: def _check_signature(func, mock, skipfirst, instance=False):
>>>>>>     sig = _get_signature_object(func, instance, skipfirst)
>>>>>>     if sig is None:
>>>>>>         return
>>>>>>     func, sig = sig
>>>>>>     def checksig(self, /, *args, **kwargs):
>>>>>>         sig.bind(*args, **kwargs)
>>>>>>     _copy_func_details(func, checksig)
>>>>>>     type(mock)._mock_check_sig = checksig
>>>>>>     type(mock).__signature__ = sig
       
       
    1: def _copy_func_details(func, funcopy):
           # we explicitly don't copy func.__dict__ into this copy as it would
           # expose original attributes that should be mocked
>>>>>>     for attribute in (
               '__name__', '__doc__', '__text_signature__',
               '__module__', '__defaults__', '__kwdefaults__',
           ):
>>>>>>         try:
>>>>>>             setattr(funcopy, attribute, getattr(func, attribute))
>>>>>>         except AttributeError:
>>>>>>             pass
       
       
    1: def _callable(obj):
>>>>>>     if isinstance(obj, type):
>>>>>>         return True
>>>>>>     if isinstance(obj, (staticmethod, classmethod, MethodType)):
>>>>>>         return _callable(obj.__func__)
>>>>>>     if getattr(obj, '__call__', None) is not None:
>>>>>>         return True
>>>>>>     return False
       
       
    1: def _is_list(obj):
           # checks for list or tuples
           # XXXX badly named!
   45:     return type(obj) in (list, tuple)
       
       
    1: def _instance_callable(obj):
           """Given an object, return True if the object is callable.
           For classes, return True if instances would be callable."""
>>>>>>     if not isinstance(obj, type):
               # already an instance
>>>>>>         return getattr(obj, '__call__', None) is not None
       
           # *could* be broken by a class overriding __mro__ or __dict__ via
           # a metaclass
>>>>>>     for base in (obj,) + obj.__mro__:
>>>>>>         if base.__dict__.get('__call__') is not None:
>>>>>>             return True
>>>>>>     return False
       
       
    1: def _set_signature(mock, original, instance=False):
           # creates a function with signature (*args, **kwargs) that delegates to a
           # mock. It still does signature checking by calling a lambda with the same
           # signature as the original.
       
>>>>>>     skipfirst = isinstance(original, type)
>>>>>>     result = _get_signature_object(original, instance, skipfirst)
>>>>>>     if result is None:
>>>>>>         return mock
>>>>>>     func, sig = result
>>>>>>     def checksig(*args, **kwargs):
>>>>>>         sig.bind(*args, **kwargs)
>>>>>>     _copy_func_details(func, checksig)
       
>>>>>>     name = original.__name__
>>>>>>     if not name.isidentifier():
>>>>>>         name = 'funcopy'
>>>>>>     context = {'_checksig_': checksig, 'mock': mock}
>>>>>>     src = """def %s(*args, **kwargs):
           _checksig_(*args, **kwargs)
>>>>>>     return mock(*args, **kwargs)""" % name
>>>>>>     exec (src, context)
>>>>>>     funcopy = context[name]
>>>>>>     _setup_func(funcopy, mock, sig)
>>>>>>     return funcopy
       
       
    1: def _setup_func(funcopy, mock, sig):
>>>>>>     funcopy.mock = mock
       
>>>>>>     def assert_called_with(*args, **kwargs):
>>>>>>         return mock.assert_called_with(*args, **kwargs)
>>>>>>     def assert_called(*args, **kwargs):
>>>>>>         return mock.assert_called(*args, **kwargs)
>>>>>>     def assert_not_called(*args, **kwargs):
>>>>>>         return mock.assert_not_called(*args, **kwargs)
>>>>>>     def assert_called_once(*args, **kwargs):
>>>>>>         return mock.assert_called_once(*args, **kwargs)
>>>>>>     def assert_called_once_with(*args, **kwargs):
>>>>>>         return mock.assert_called_once_with(*args, **kwargs)
>>>>>>     def assert_has_calls(*args, **kwargs):
>>>>>>         return mock.assert_has_calls(*args, **kwargs)
>>>>>>     def assert_any_call(*args, **kwargs):
>>>>>>         return mock.assert_any_call(*args, **kwargs)
>>>>>>     def reset_mock():
>>>>>>         funcopy.method_calls = _CallList()
>>>>>>         funcopy.mock_calls = _CallList()
>>>>>>         mock.reset_mock()
>>>>>>         ret = funcopy.return_value
>>>>>>         if _is_instance_mock(ret) and not ret is mock:
>>>>>>             ret.reset_mock()
       
>>>>>>     funcopy.called = False
>>>>>>     funcopy.call_count = 0
>>>>>>     funcopy.call_args = None
>>>>>>     funcopy.call_args_list = _CallList()
>>>>>>     funcopy.method_calls = _CallList()
>>>>>>     funcopy.mock_calls = _CallList()
       
>>>>>>     funcopy.return_value = mock.return_value
>>>>>>     funcopy.side_effect = mock.side_effect
>>>>>>     funcopy._mock_children = mock._mock_children
       
>>>>>>     funcopy.assert_called_with = assert_called_with
>>>>>>     funcopy.assert_called_once_with = assert_called_once_with
>>>>>>     funcopy.assert_has_calls = assert_has_calls
>>>>>>     funcopy.assert_any_call = assert_any_call
>>>>>>     funcopy.reset_mock = reset_mock
>>>>>>     funcopy.assert_called = assert_called
>>>>>>     funcopy.assert_not_called = assert_not_called
>>>>>>     funcopy.assert_called_once = assert_called_once
>>>>>>     funcopy.__signature__ = sig
       
>>>>>>     mock._mock_delegate = funcopy
       
       
    1: def _setup_async_mock(mock):
>>>>>>     mock._is_coroutine = asyncio.coroutines._is_coroutine
>>>>>>     mock.await_count = 0
>>>>>>     mock.await_args = None
>>>>>>     mock.await_args_list = _CallList()
       
           # Mock is not configured yet so the attributes are set
           # to a function and then the corresponding mock helper function
           # is called when the helper is accessed similar to _setup_func.
>>>>>>     def wrapper(attr, /, *args, **kwargs):
>>>>>>         return getattr(mock.mock, attr)(*args, **kwargs)
       
>>>>>>     for attribute in ('assert_awaited',
                             'assert_awaited_once',
                             'assert_awaited_with',
                             'assert_awaited_once_with',
                             'assert_any_await',
                             'assert_has_awaits',
                             'assert_not_awaited'):
       
               # setattr(mock, attribute, wrapper) causes late binding
               # hence attribute will always be the last value in the loop
               # Use partial(wrapper, attribute) to ensure the attribute is bound
               # correctly.
>>>>>>         setattr(mock, attribute, partial(wrapper, attribute))
       
       
    1: def _is_magic(name):
>>>>>>     return '__%s__' % name[2:-2] == name
       
       
    2: class _SentinelObject(object):
    1:     "A unique, named, sentinel object."
    1:     def __init__(self, name):
    3:         self.name = name
       
    1:     def __repr__(self):
>>>>>>         return 'sentinel.%s' % self.name
       
    1:     def __reduce__(self):
>>>>>>         return 'sentinel.%s' % self.name
       
       
    2: class _Sentinel(object):
    1:     """Access attributes to return a named object, usable as a sentinel."""
    1:     def __init__(self):
    1:         self._sentinels = {}
       
    1:     def __getattr__(self, name):
    3:         if name == '__bases__':
                   # Without this help(unittest.mock) raises an exception
>>>>>>             raise AttributeError
    3:         return self._sentinels.setdefault(name, _SentinelObject(name))
       
    1:     def __reduce__(self):
>>>>>>         return 'sentinel'
       
       
    1: sentinel = _Sentinel()
       
    1: DEFAULT = sentinel.DEFAULT
    1: _missing = sentinel.MISSING
    1: _deleted = sentinel.DELETED
       
       
    1: _allowed_names = {
           'return_value', '_mock_return_value', 'side_effect',
           '_mock_side_effect', '_mock_parent', '_mock_new_parent',
           '_mock_name', '_mock_new_name'
       }
       
       
    1: def _delegating_property(name):
    8:     _allowed_names.add(name)
    8:     _the_name = '_mock_' + name
    8:     def _get(self, name=name, _the_name=_the_name):
   70:         sig = self._mock_delegate
   70:         if sig is None:
   70:             return getattr(self, _the_name)
>>>>>>         return getattr(sig, name)
    8:     def _set(self, value, name=name, _the_name=_the_name):
   68:         sig = self._mock_delegate
   68:         if sig is None:
   68:             self.__dict__[_the_name] = value
               else:
>>>>>>             setattr(sig, name, value)
       
    8:     return property(_get, _set)
       
       
       
    2: class _CallList(list):
       
    1:     def __contains__(self, value):
>>>>>>         if not isinstance(value, list):
>>>>>>             return list.__contains__(self, value)
>>>>>>         len_value = len(value)
>>>>>>         len_self = len(self)
>>>>>>         if len_value > len_self:
>>>>>>             return False
       
>>>>>>         for i in range(0, len_self - len_value + 1):
>>>>>>             sub_list = self[i:i+len_value]
>>>>>>             if sub_list == value:
>>>>>>                 return True
>>>>>>         return False
       
    1:     def __repr__(self):
>>>>>>         return pprint.pformat(list(self))
       
       
    1: def _check_and_set_parent(parent, value, name, new_name):
   46:     value = _extract_mock(value)
       
   46:     if not _is_instance_mock(value):
   45:         return False
    1:     if ((value._mock_name or value._mock_new_name) or
>>>>>>         (value._mock_parent is not None) or
>>>>>>         (value._mock_new_parent is not None)):
    1:         return False
       
>>>>>>     _parent = parent
>>>>>>     while _parent is not None:
               # setting a mock (value) as a child or return value of itself
               # should not modify the mock
>>>>>>         if _parent is value:
>>>>>>             return False
>>>>>>         _parent = _parent._mock_new_parent
       
>>>>>>     if new_name:
>>>>>>         value._mock_new_parent = parent
>>>>>>         value._mock_new_name = new_name
>>>>>>     if name:
>>>>>>         value._mock_parent = parent
>>>>>>         value._mock_name = name
>>>>>>     return True
       
       # Internal class to identify if we wrapped an iterator object or not.
    2: class _MockIter(object):
    1:     def __init__(self, obj):
>>>>>>         self.obj = iter(obj)
    1:     def __next__(self):
>>>>>>         return next(self.obj)
       
    2: class Base(object):
    1:     _mock_return_value = DEFAULT
    1:     _mock_side_effect = None
    1:     def __init__(self, /, *args, **kwargs):
   92:         pass
       
       
       
    2: class NonCallableMock(Base):
    1:     """A non-callable version of `Mock`"""
       
    1:     def __new__(cls, /, *args, **kw):
               # every instance has its own class
               # so we can create magic methods on the
               # class without stomping on other mocks
   92:         bases = (cls,)
   92:         if not issubclass(cls, AsyncMockMixin):
                   # Check if spec is an async object or function
   47:             bound_args = _MOCK_SIG.bind_partial(cls, *args, **kw).arguments
   47:             spec_arg = bound_args.get('spec_set', bound_args.get('spec'))
   47:             if spec_arg is not None and _is_async_obj(spec_arg):
>>>>>>                 bases = (AsyncMockMixin, cls)
   92:         new = type(cls.__name__, bases, {'__doc__': cls.__doc__})
   92:         instance = _safe_super(NonCallableMock, cls).__new__(new)
   92:         return instance
       
       
    1:     def __init__(
                   self, spec=None, wraps=None, name=None, spec_set=None,
                   parent=None, _spec_state=None, _new_name='', _new_parent=None,
                   _spec_as_instance=False, _eat_self=None, unsafe=False, **kwargs
               ):
   92:         if _new_parent is None:
   91:             _new_parent = parent
       
   92:         __dict__ = self.__dict__
   92:         __dict__['_mock_parent'] = parent
   92:         __dict__['_mock_name'] = name
   92:         __dict__['_mock_new_name'] = _new_name
   92:         __dict__['_mock_new_parent'] = _new_parent
   92:         __dict__['_mock_sealed'] = False
       
   92:         if spec_set is not None:
   45:             spec = spec_set
   45:             spec_set = True
   92:         if _eat_self is None:
   92:             _eat_self = parent is not None
       
   92:         self._mock_add_spec(spec, spec_set, _spec_as_instance, _eat_self)
       
   92:         __dict__['_mock_children'] = {}
   92:         __dict__['_mock_wraps'] = wraps
   92:         __dict__['_mock_delegate'] = None
       
   92:         __dict__['_mock_called'] = False
   92:         __dict__['_mock_call_args'] = None
   92:         __dict__['_mock_call_count'] = 0
   92:         __dict__['_mock_call_args_list'] = _CallList()
   92:         __dict__['_mock_mock_calls'] = _CallList()
       
   92:         __dict__['method_calls'] = _CallList()
   92:         __dict__['_mock_unsafe'] = unsafe
       
   92:         if kwargs:
>>>>>>             self.configure_mock(**kwargs)
       
  184:         _safe_super(NonCallableMock, self).__init__(
   92:             spec, wraps, name, spec_set, parent,
   92:             _spec_state
               )
       
       
    1:     def attach_mock(self, mock, attribute):
               """
               Attach a mock as an attribute of this one, replacing its name and
               parent. Calls to the attached mock will be recorded in the
               `method_calls` and `mock_calls` attributes of this one."""
>>>>>>         inner_mock = _extract_mock(mock)
       
>>>>>>         inner_mock._mock_parent = None
>>>>>>         inner_mock._mock_new_parent = None
>>>>>>         inner_mock._mock_name = ''
>>>>>>         inner_mock._mock_new_name = None
       
>>>>>>         setattr(self, attribute, mock)
       
       
    1:     def mock_add_spec(self, spec, spec_set=False):
               """Add a spec to a mock. `spec` can either be an object or a
               list of strings. Only attributes on the `spec` can be fetched as
               attributes from the mock.
       
               If `spec_set` is True then only attributes on the spec can be set."""
>>>>>>         self._mock_add_spec(spec, spec_set)
       
       
    1:     def _mock_add_spec(self, spec, spec_set, _spec_as_instance=False,
                              _eat_self=False):
   92:         _spec_class = None
   92:         _spec_signature = None
   92:         _spec_asyncs = []
       
 3020:         for attr in dir(spec):
 2928:             if iscoroutinefunction(getattr(spec, attr, None)):
>>>>>>                 _spec_asyncs.append(attr)
       
   92:         if spec is not None and not _is_list(spec):
   45:             if isinstance(spec, type):
   45:                 _spec_class = spec
                   else:
>>>>>>                 _spec_class = type(spec)
   90:             res = _get_signature_object(spec,
   45:                                         _spec_as_instance, _eat_self)
   45:             _spec_signature = res and res[1]
       
   45:             spec = dir(spec)
       
   92:         __dict__ = self.__dict__
   92:         __dict__['_spec_class'] = _spec_class
   92:         __dict__['_spec_set'] = spec_set
   92:         __dict__['_spec_signature'] = _spec_signature
   92:         __dict__['_mock_methods'] = spec
   92:         __dict__['_spec_asyncs'] = _spec_asyncs
       
    1:     def __get_return_value(self):
   14:         ret = self._mock_return_value
   14:         if self._mock_delegate is not None:
>>>>>>             ret = self._mock_delegate.return_value
       
   14:         if ret is DEFAULT:
    2:             ret = self._get_child_mock(
    1:                 _new_parent=self, _new_name='()'
                   )
    1:             self.return_value = ret
   14:         return ret
       
       
    1:     def __set_return_value(self, value):
    1:         if self._mock_delegate is not None:
>>>>>>             self._mock_delegate.return_value = value
               else:
    1:             self._mock_return_value = value
    1:             _check_and_set_parent(self, value, None, '()')
       
    1:     __return_value_doc = "The value to be returned when the mock is called."
    2:     return_value = property(__get_return_value, __set_return_value,
    1:                             __return_value_doc)
       
       
    1:     @property
    1:     def __class__(self):
   46:         if self._spec_class is None:
   46:             return type(self)
>>>>>>         return self._spec_class
       
    1:     called = _delegating_property('called')
    1:     call_count = _delegating_property('call_count')
    1:     call_args = _delegating_property('call_args')
    1:     call_args_list = _delegating_property('call_args_list')
    1:     mock_calls = _delegating_property('mock_calls')
       
       
    1:     def __get_side_effect(self):
   14:         delegated = self._mock_delegate
   14:         if delegated is None:
   14:             return self._mock_side_effect
>>>>>>         sf = delegated.side_effect
>>>>>>         if (sf is not None and not callable(sf)
>>>>>>                 and not isinstance(sf, _MockIter) and not _is_exception(sf)):
>>>>>>             sf = _MockIter(sf)
>>>>>>             delegated.side_effect = sf
>>>>>>         return sf
       
    1:     def __set_side_effect(self, value):
   47:         value = _try_iter(value)
   47:         delegated = self._mock_delegate
   47:         if delegated is None:
   47:             self._mock_side_effect = value
               else:
>>>>>>             delegated.side_effect = value
       
    1:     side_effect = property(__get_side_effect, __set_side_effect)
       
       
    1:     def reset_mock(self,  visited=None,*, return_value=False, side_effect=False):
               "Restore the mock object to its initial state."
>>>>>>         if visited is None:
>>>>>>             visited = []
>>>>>>         if id(self) in visited:
>>>>>>             return
>>>>>>         visited.append(id(self))
       
>>>>>>         self.called = False
>>>>>>         self.call_args = None
>>>>>>         self.call_count = 0
>>>>>>         self.mock_calls = _CallList()
>>>>>>         self.call_args_list = _CallList()
>>>>>>         self.method_calls = _CallList()
       
>>>>>>         if return_value:
>>>>>>             self._mock_return_value = DEFAULT
>>>>>>         if side_effect:
>>>>>>             self._mock_side_effect = None
       
>>>>>>         for child in self._mock_children.values():
>>>>>>             if isinstance(child, _SpecState) or child is _deleted:
>>>>>>                 continue
>>>>>>             child.reset_mock(visited, return_value=return_value, side_effect=side_effect)
       
>>>>>>         ret = self._mock_return_value
>>>>>>         if _is_instance_mock(ret) and ret is not self:
>>>>>>             ret.reset_mock(visited)
       
       
    1:     def configure_mock(self, /, **kwargs):
               """Set attributes on the mock through keyword arguments.
       
               Attributes plus return values and side effects can be set on child
               mocks using standard dot notation and unpacking a dictionary in the
               method call:
       
               >>> attrs = {'method.return_value': 3, 'other.side_effect': KeyError}
               >>> mock.configure_mock(**attrs)"""
>>>>>>         for arg, val in sorted(kwargs.items(),
                                      # we sort on the number of dots so that
                                      # attributes are set before we set attributes on
                                      # attributes
>>>>>>                                key=lambda entry: entry[0].count('.')):
>>>>>>             args = arg.split('.')
>>>>>>             final = args.pop()
>>>>>>             obj = self
>>>>>>             for entry in args:
>>>>>>                 obj = getattr(obj, entry)
>>>>>>             setattr(obj, final, val)
       
       
    1:     def __getattr__(self, name):
   92:         if name in {'_mock_methods', '_mock_unsafe'}:
   92:             raise AttributeError(name)
>>>>>>         elif self._mock_methods is not None:
>>>>>>             if name not in self._mock_methods or name in _all_magics:
>>>>>>                 raise AttributeError("Mock object has no attribute %r" % name)
>>>>>>         elif _is_magic(name):
>>>>>>             raise AttributeError(name)
>>>>>>         if not self._mock_unsafe:
>>>>>>             if name.startswith(('assert', 'assret')):
>>>>>>                 raise AttributeError("Attributes cannot start with 'assert' "
                                            "or 'assret'")
       
>>>>>>         result = self._mock_children.get(name)
>>>>>>         if result is _deleted:
>>>>>>             raise AttributeError(name)
>>>>>>         elif result is None:
>>>>>>             wraps = None
>>>>>>             if self._mock_wraps is not None:
                       # XXXX should we get the attribute without triggering code
                       # execution?
>>>>>>                 wraps = getattr(self._mock_wraps, name)
       
>>>>>>             result = self._get_child_mock(
>>>>>>                 parent=self, name=name, wraps=wraps, _new_name=name,
>>>>>>                 _new_parent=self
                   )
>>>>>>             self._mock_children[name]  = result
       
>>>>>>         elif isinstance(result, _SpecState):
>>>>>>             result = create_autospec(
>>>>>>                 result.spec, result.spec_set, result.instance,
>>>>>>                 result.parent, result.name
                   )
>>>>>>             self._mock_children[name]  = result
       
>>>>>>         return result
       
       
    1:     def _extract_mock_name(self):
>>>>>>         _name_list = [self._mock_new_name]
>>>>>>         _parent = self._mock_new_parent
>>>>>>         last = self
       
>>>>>>         dot = '.'
>>>>>>         if _name_list == ['()']:
>>>>>>             dot = ''
       
>>>>>>         while _parent is not None:
>>>>>>             last = _parent
       
>>>>>>             _name_list.append(_parent._mock_new_name + dot)
>>>>>>             dot = '.'
>>>>>>             if _parent._mock_new_name == '()':
>>>>>>                 dot = ''
       
>>>>>>             _parent = _parent._mock_new_parent
       
>>>>>>         _name_list = list(reversed(_name_list))
>>>>>>         _first = last._mock_name or 'mock'
>>>>>>         if len(_name_list) > 1:
>>>>>>             if _name_list[1] not in ('()', '().'):
>>>>>>                 _first += '.'
>>>>>>         _name_list[0] = _first
>>>>>>         return ''.join(_name_list)
       
    1:     def __repr__(self):
>>>>>>         name = self._extract_mock_name()
       
>>>>>>         name_string = ''
>>>>>>         if name not in ('mock', 'mock.'):
>>>>>>             name_string = ' name=%r' % name
       
>>>>>>         spec_string = ''
>>>>>>         if self._spec_class is not None:
>>>>>>             spec_string = ' spec=%r'
>>>>>>             if self._spec_set:
>>>>>>                 spec_string = ' spec_set=%r'
>>>>>>             spec_string = spec_string % self._spec_class.__name__
>>>>>>         return "<%s%s%s id='%s'>" % (
>>>>>>             type(self).__name__,
>>>>>>             name_string,
>>>>>>             spec_string,
>>>>>>             id(self)
               )
       
       
    1:     def __dir__(self):
               """Filter the output of `dir(mock)` to only useful members."""
>>>>>>         if not FILTER_DIR:
>>>>>>             return object.__dir__(self)
       
>>>>>>         extras = self._mock_methods or []
>>>>>>         from_type = dir(type(self))
>>>>>>         from_dict = list(self.__dict__)
>>>>>>         from_child_mocks = [
>>>>>>             m_name for m_name, m_value in self._mock_children.items()
>>>>>>             if m_value is not _deleted]
       
>>>>>>         from_type = [e for e in from_type if not e.startswith('_')]
>>>>>>         from_dict = [e for e in from_dict if not e.startswith('_') or
>>>>>>                      _is_magic(e)]
>>>>>>         return sorted(set(extras + from_type + from_dict + from_child_mocks))
       
       
    1:     def __setattr__(self, name, value):
  209:         if name in _allowed_names:
                   # property setters go through here
  164:             return object.__setattr__(self, name, value)
   90:         elif (self._spec_set and self._mock_methods is not None and
   45:             name not in self._mock_methods and
>>>>>>             name not in self.__dict__):
>>>>>>             raise AttributeError("Mock object has no attribute '%s'" % name)
   45:         elif name in _unsupported_magics:
>>>>>>             msg = 'Attempting to set unsupported magic method %r.' % name
>>>>>>             raise AttributeError(msg)
   45:         elif name in _all_magics:
>>>>>>             if self._mock_methods is not None and name not in self._mock_methods:
>>>>>>                 raise AttributeError("Mock object has no attribute '%s'" % name)
       
>>>>>>             if not _is_instance_mock(value):
>>>>>>                 setattr(type(self), name, _get_method(name, value))
>>>>>>                 original = value
>>>>>>                 value = lambda *args, **kw: original(self, *args, **kw)
                   else:
                       # only set _new_name and not name so that mock_calls is tracked
                       # but not method calls
>>>>>>                 _check_and_set_parent(self, value, None, name)
>>>>>>                 setattr(type(self), name, value)
>>>>>>                 self._mock_children[name] = value
   45:         elif name == '__class__':
>>>>>>             self._spec_class = value
>>>>>>             return
               else:
   45:             if _check_and_set_parent(self, value, name, name):
>>>>>>                 self._mock_children[name] = value
       
   45:         if self._mock_sealed and not hasattr(self, name):
>>>>>>             mock_name = f'{self._extract_mock_name()}.{name}'
>>>>>>             raise AttributeError(f'Cannot set {mock_name}')
       
   45:         return object.__setattr__(self, name, value)
       
       
    1:     def __delattr__(self, name):
>>>>>>         if name in _all_magics and name in type(self).__dict__:
>>>>>>             delattr(type(self), name)
>>>>>>             if name not in self.__dict__:
                       # for magic methods that are still MagicProxy objects and
                       # not set on the instance itself
>>>>>>                 return
       
>>>>>>         obj = self._mock_children.get(name, _missing)
>>>>>>         if name in self.__dict__:
>>>>>>             _safe_super(NonCallableMock, self).__delattr__(name)
>>>>>>         elif obj is _deleted:
>>>>>>             raise AttributeError(name)
>>>>>>         if obj is not _missing:
>>>>>>             del self._mock_children[name]
>>>>>>         self._mock_children[name] = _deleted
       
       
    1:     def _format_mock_call_signature(self, args, kwargs):
>>>>>>         name = self._mock_name or 'mock'
>>>>>>         return _format_call_signature(name, args, kwargs)
       
       
    1:     def _format_mock_failure_message(self, args, kwargs, action='call'):
>>>>>>         message = 'expected %s not found.\nExpected: %s\nActual: %s'
>>>>>>         expected_string = self._format_mock_call_signature(args, kwargs)
>>>>>>         call_args = self.call_args
>>>>>>         actual_string = self._format_mock_call_signature(*call_args)
>>>>>>         return message % (action, expected_string, actual_string)
       
       
    1:     def _get_call_signature_from_name(self, name):
               """
               * If call objects are asserted against a method/function like obj.meth1
               then there could be no name for the call object to lookup. Hence just
               return the spec_signature of the method/function being asserted against.
               * If the name is not empty then remove () and split by '.' to get
               list of names to iterate through the children until a potential
               match is found. A child mock is created only during attribute access
               so if we get a _SpecState then no attributes of the spec were accessed
               and can be safely exited.
               """
>>>>>>         if not name:
>>>>>>             return self._spec_signature
       
>>>>>>         sig = None
>>>>>>         names = name.replace('()', '').split('.')
>>>>>>         children = self._mock_children
       
>>>>>>         for name in names:
>>>>>>             child = children.get(name)
>>>>>>             if child is None or isinstance(child, _SpecState):
>>>>>>                 break
                   else:
                       # If an autospecced object is attached using attach_mock the
                       # child would be a function with mock object as attribute from
                       # which signature has to be derived.
>>>>>>                 child = _extract_mock(child)
>>>>>>                 children = child._mock_children
>>>>>>                 sig = child._spec_signature
       
>>>>>>         return sig
       
       
    1:     def _call_matcher(self, _call):
               """
               Given a call (or simply an (args, kwargs) tuple), return a
               comparison key suitable for matching with other calls.
               This is a best effort method which relies on the spec's signature,
               if available, or falls back on the arguments themselves.
               """
       
>>>>>>         if isinstance(_call, tuple) and len(_call) > 2:
>>>>>>             sig = self._get_call_signature_from_name(_call[0])
               else:
>>>>>>             sig = self._spec_signature
       
>>>>>>         if sig is not None:
>>>>>>             if len(_call) == 2:
>>>>>>                 name = ''
>>>>>>                 args, kwargs = _call
                   else:
>>>>>>                 name, args, kwargs = _call
>>>>>>             try:
>>>>>>                 bound_call = sig.bind(*args, **kwargs)
>>>>>>                 return call(name, bound_call.args, bound_call.kwargs)
>>>>>>             except TypeError as e:
>>>>>>                 return e.with_traceback(None)
               else:
>>>>>>             return _call
       
    1:     def assert_not_called(self):
               """assert that the mock was never called.
               """
>>>>>>         if self.call_count != 0:
>>>>>>             msg = ("Expected '%s' to not have been called. Called %s times.%s"
>>>>>>                    % (self._mock_name or 'mock',
>>>>>>                       self.call_count,
>>>>>>                       self._calls_repr()))
>>>>>>             raise AssertionError(msg)
       
    1:     def assert_called(self):
               """assert that the mock was called at least once
               """
>>>>>>         if self.call_count == 0:
>>>>>>             msg = ("Expected '%s' to have been called." %
>>>>>>                    (self._mock_name or 'mock'))
>>>>>>             raise AssertionError(msg)
       
    1:     def assert_called_once(self):
               """assert that the mock was called only once.
               """
>>>>>>         if not self.call_count == 1:
>>>>>>             msg = ("Expected '%s' to have been called once. Called %s times.%s"
>>>>>>                    % (self._mock_name or 'mock',
>>>>>>                       self.call_count,
>>>>>>                       self._calls_repr()))
>>>>>>             raise AssertionError(msg)
       
    1:     def assert_called_with(self, /, *args, **kwargs):
               """assert that the last call was made with the specified arguments.
       
               Raises an AssertionError if the args and keyword args passed in are
               different to the last call to the mock."""
>>>>>>         if self.call_args is None:
>>>>>>             expected = self._format_mock_call_signature(args, kwargs)
>>>>>>             actual = 'not called.'
>>>>>>             error_message = ('expected call not found.\nExpected: %s\nActual: %s'
>>>>>>                     % (expected, actual))
>>>>>>             raise AssertionError(error_message)
       
>>>>>>         def _error_message():
>>>>>>             msg = self._format_mock_failure_message(args, kwargs)
>>>>>>             return msg
>>>>>>         expected = self._call_matcher(_Call((args, kwargs), two=True))
>>>>>>         actual = self._call_matcher(self.call_args)
>>>>>>         if actual != expected:
>>>>>>             cause = expected if isinstance(expected, Exception) else None
>>>>>>             raise AssertionError(_error_message()) from cause
       
       
    1:     def assert_called_once_with(self, /, *args, **kwargs):
               """assert that the mock was called exactly once and that that call was
               with the specified arguments."""
>>>>>>         if not self.call_count == 1:
>>>>>>             msg = ("Expected '%s' to be called once. Called %s times.%s"
>>>>>>                    % (self._mock_name or 'mock',
>>>>>>                       self.call_count,
>>>>>>                       self._calls_repr()))
>>>>>>             raise AssertionError(msg)
>>>>>>         return self.assert_called_with(*args, **kwargs)
       
       
    1:     def assert_has_calls(self, calls, any_order=False):
               """assert the mock has been called with the specified calls.
               The `mock_calls` list is checked for the calls.
       
               If `any_order` is False (the default) then the calls must be
               sequential. There can be extra calls before or after the
               specified calls.
       
               If `any_order` is True then the calls can be in any order, but
               they must all appear in `mock_calls`."""
>>>>>>         expected = [self._call_matcher(c) for c in calls]
>>>>>>         cause = next((e for e in expected if isinstance(e, Exception)), None)
>>>>>>         all_calls = _CallList(self._call_matcher(c) for c in self.mock_calls)
>>>>>>         if not any_order:
>>>>>>             if expected not in all_calls:
>>>>>>                 if cause is None:
>>>>>>                     problem = 'Calls not found.'
                       else:
>>>>>>                     problem = ('Error processing expected calls.\n'
                                      'Errors: {}').format(
>>>>>>                                    [e if isinstance(e, Exception) else None
>>>>>>                                     for e in expected])
>>>>>>                 raise AssertionError(
>>>>>>                     f'{problem}\n'
>>>>>>                     f'Expected: {_CallList(calls)}'
>>>>>>                     f'{self._calls_repr(prefix="Actual").rstrip(".")}'
>>>>>>                 ) from cause
>>>>>>             return
       
>>>>>>         all_calls = list(all_calls)
       
>>>>>>         not_found = []
>>>>>>         for kall in expected:
>>>>>>             try:
>>>>>>                 all_calls.remove(kall)
>>>>>>             except ValueError:
>>>>>>                 not_found.append(kall)
>>>>>>         if not_found:
>>>>>>             raise AssertionError(
>>>>>>                 '%r does not contain all of %r in its call list, '
>>>>>>                 'found %r instead' % (self._mock_name or 'mock',
>>>>>>                                       tuple(not_found), all_calls)
>>>>>>             ) from cause
       
       
    1:     def assert_any_call(self, /, *args, **kwargs):
               """assert the mock has been called with the specified arguments.
       
               The assert passes if the mock has *ever* been called, unlike
               `assert_called_with` and `assert_called_once_with` that only pass if
               the call is the most recent one."""
>>>>>>         expected = self._call_matcher(_Call((args, kwargs), two=True))
>>>>>>         cause = expected if isinstance(expected, Exception) else None
>>>>>>         actual = [self._call_matcher(c) for c in self.call_args_list]
>>>>>>         if cause or expected not in _AnyComparer(actual):
>>>>>>             expected_string = self._format_mock_call_signature(args, kwargs)
>>>>>>             raise AssertionError(
>>>>>>                 '%s call not found' % expected_string
>>>>>>             ) from cause
       
       
    1:     def _get_child_mock(self, /, **kw):
               """Create the child mocks for attributes and return value.
               By default child mocks will be the same type as the parent.
               Subclasses of Mock may want to override this to customize the way
               child mocks are made.
       
               For non-callable mocks the callable variant will be used (rather than
               any custom subclass)."""
    1:         _new_name = kw.get("_new_name")
    1:         if _new_name in self.__dict__['_spec_asyncs']:
>>>>>>             return AsyncMock(**kw)
       
    1:         _type = type(self)
    1:         if issubclass(_type, MagicMock) and _new_name in _async_method_magics:
                   # Any asynchronous magic becomes an AsyncMock
>>>>>>             klass = AsyncMock
    1:         elif issubclass(_type, AsyncMockMixin):
>>>>>>             if (_new_name in _all_sync_magics or
>>>>>>                     self._mock_methods and _new_name in self._mock_methods):
                       # Any synchronous method on AsyncMock becomes a MagicMock
>>>>>>                 klass = MagicMock
                   else:
>>>>>>                 klass = AsyncMock
    1:         elif not issubclass(_type, CallableMixin):
>>>>>>             if issubclass(_type, NonCallableMagicMock):
>>>>>>                 klass = MagicMock
>>>>>>             elif issubclass(_type, NonCallableMock):
>>>>>>                 klass = Mock
               else:
    1:             klass = _type.__mro__[1]
       
    1:         if self._mock_sealed:
>>>>>>             attribute = "." + kw["name"] if "name" in kw else "()"
>>>>>>             mock_name = self._extract_mock_name() + attribute
>>>>>>             raise AttributeError(mock_name)
       
    1:         return klass(**kw)
       
       
    1:     def _calls_repr(self, prefix="Calls"):
               """Renders self.mock_calls as a string.
       
               Example: "\nCalls: [call(1), call(2)]."
       
               If self.mock_calls is empty, an empty string is returned. The
               output will be truncated if very long.
               """
>>>>>>         if not self.mock_calls:
>>>>>>             return ""
>>>>>>         return f"\n{prefix}: {safe_repr(self.mock_calls)}."
       
       
    1: _MOCK_SIG = inspect.signature(NonCallableMock.__init__)
       
       
    2: class _AnyComparer(list):
    1:     """A list which checks if it contains a call which may have an
           argument of ANY, flipping the components of item and self from
           their traditional locations so that ANY is guaranteed to be on
           the left."""
    1:     def __contains__(self, item):
>>>>>>         for _call in self:
>>>>>>             assert len(item) == len(_call)
>>>>>>             if all([
>>>>>>                 expected == actual
>>>>>>                 for expected, actual in zip(item, _call)
                   ]):
>>>>>>                 return True
>>>>>>         return False
       
       
    1: def _try_iter(obj):
   47:     if obj is None:
   47:         return obj
>>>>>>     if _is_exception(obj):
>>>>>>         return obj
>>>>>>     if _callable(obj):
>>>>>>         return obj
>>>>>>     try:
>>>>>>         return iter(obj)
>>>>>>     except TypeError:
               # XXXX backwards compatibility
               # but this will blow up on first call - so maybe we should fail early?
>>>>>>         return obj
       
       
    2: class CallableMixin(Base):
       
    2:     def __init__(self, spec=None, side_effect=None, return_value=DEFAULT,
    1:                  wraps=None, name=None, spec_set=None, parent=None,
    1:                  _spec_state=None, _new_name='', _new_parent=None, **kwargs):
   47:         self.__dict__['_mock_return_value'] = return_value
  141:         _safe_super(CallableMixin, self).__init__(
   47:             spec, wraps, name, spec_set, parent,
   94:             _spec_state, _new_name, _new_parent, **kwargs
               )
       
   47:         self.side_effect = side_effect
       
       
    1:     def _mock_check_sig(self, /, *args, **kwargs):
               # stub method that can be replaced with one with a specific signature
   14:         pass
       
       
    1:     def __call__(self, /, *args, **kwargs):
               # can't use self in-case a function / method we are mocking uses self
               # in the signature
   14:         self._mock_check_sig(*args, **kwargs)
   14:         self._increment_mock_call(*args, **kwargs)
   14:         return self._mock_call(*args, **kwargs)
       
       
    1:     def _mock_call(self, /, *args, **kwargs):
   14:         return self._execute_mock_call(*args, **kwargs)
       
    1:     def _increment_mock_call(self, /, *args, **kwargs):
   14:         self.called = True
   14:         self.call_count += 1
       
               # handle call_args
               # needs to be set here so assertions on call arguments pass before
               # execution in the case of awaited calls
   14:         _call = _Call((args, kwargs), two=True)
   14:         self.call_args = _call
   14:         self.call_args_list.append(_call)
       
               # initial stuff for method_calls:
   14:         do_method_calls = self._mock_parent is not None
   14:         method_call_name = self._mock_name
       
               # initial stuff for mock_calls:
   14:         mock_call_name = self._mock_new_name
   14:         is_a_call = mock_call_name == '()'
   14:         self.mock_calls.append(_Call(('', args, kwargs)))
       
               # follow up the chain of mocks:
   14:         _new_parent = self._mock_new_parent
   14:         while _new_parent is not None:
       
                   # handle method_calls:
>>>>>>             if do_method_calls:
>>>>>>                 _new_parent.method_calls.append(_Call((method_call_name, args, kwargs)))
>>>>>>                 do_method_calls = _new_parent._mock_parent is not None
>>>>>>                 if do_method_calls:
>>>>>>                     method_call_name = _new_parent._mock_name + '.' + method_call_name
       
                   # handle mock_calls:
>>>>>>             this_mock_call = _Call((mock_call_name, args, kwargs))
>>>>>>             _new_parent.mock_calls.append(this_mock_call)
       
>>>>>>             if _new_parent._mock_new_name:
>>>>>>                 if is_a_call:
>>>>>>                     dot = ''
                       else:
>>>>>>                     dot = '.'
>>>>>>                 is_a_call = _new_parent._mock_new_name == '()'
>>>>>>                 mock_call_name = _new_parent._mock_new_name + dot + mock_call_name
       
                   # follow the parental chain:
>>>>>>             _new_parent = _new_parent._mock_new_parent
       
    1:     def _execute_mock_call(self, /, *args, **kwargs):
               # separate from _increment_mock_call so that awaited functions are
               # executed separately from their call, also AsyncMock overrides this method
       
    1:         effect = self.side_effect
    1:         if effect is not None:
>>>>>>             if _is_exception(effect):
>>>>>>                 raise effect
>>>>>>             elif not _callable(effect):
>>>>>>                 result = next(effect)
>>>>>>                 if _is_exception(result):
>>>>>>                     raise result
                   else:
>>>>>>                 result = effect(*args, **kwargs)
       
>>>>>>             if result is not DEFAULT:
>>>>>>                 return result
       
    1:         if self._mock_return_value is not DEFAULT:
>>>>>>             return self.return_value
       
    1:         if self._mock_wraps is not None:
>>>>>>             return self._mock_wraps(*args, **kwargs)
       
    1:         return self.return_value
       
       
       
    2: class Mock(CallableMixin, NonCallableMock):
    1:     """
           Create a new `Mock` object. `Mock` takes several optional arguments
           that specify the behaviour of the Mock object:
       
           * `spec`: This can be either a list of strings or an existing object (a
             class or instance) that acts as the specification for the mock object. If
             you pass in an object then a list of strings is formed by calling dir on
             the object (excluding unsupported magic attributes and methods). Accessing
             any attribute not in this list will raise an `AttributeError`.
       
             If `spec` is an object (rather than a list of strings) then
             `mock.__class__` returns the class of the spec object. This allows mocks
             to pass `isinstance` tests.
       
           * `spec_set`: A stricter variant of `spec`. If used, attempting to *set*
             or get an attribute on the mock that isn't on the object passed as
             `spec_set` will raise an `AttributeError`.
       
           * `side_effect`: A function to be called whenever the Mock is called. See
             the `side_effect` attribute. Useful for raising exceptions or
             dynamically changing return values. The function is called with the same
             arguments as the mock, and unless it returns `DEFAULT`, the return
             value of this function is used as the return value.
       
             If `side_effect` is an iterable then each call to the mock will return
             the next value from the iterable. If any of the members of the iterable
             are exceptions they will be raised instead of returned.
       
           * `return_value`: The value returned when the mock is called. By default
             this is a new Mock (created on first access). See the
             `return_value` attribute.
       
           * `wraps`: Item for the mock object to wrap. If `wraps` is not None then
             calling the Mock will pass the call through to the wrapped object
             (returning the real result). Attribute access on the mock will return a
             Mock object that wraps the corresponding attribute of the wrapped object
             (so attempting to access an attribute that doesn't exist will raise an
             `AttributeError`).
       
             If the mock has an explicit `return_value` set then calls are not passed
             to the wrapped object and the `return_value` is returned instead.
       
           * `name`: If the mock has a name then it will be used in the repr of the
             mock. This can be useful for debugging. The name is propagated to child
             mocks.
       
           Mocks can also be called with arbitrary keyword arguments. These will be
           used to set attributes on the mock after it is created.
           """
       
       
    1: def _dot_lookup(thing, comp, import_path):
    4:     try:
    4:         return getattr(thing, comp)
    1:     except AttributeError:
    1:         __import__(import_path)
    1:         return getattr(thing, comp)
       
       
    1: def _importer(target):
    4:     components = target.split('.')
    4:     import_path = components.pop(0)
    4:     thing = __import__(import_path)
       
    8:     for comp in components:
    4:         import_path += ".%s" % comp
    4:         thing = _dot_lookup(thing, comp, import_path)
    4:     return thing
       
       
    2: class _patch(object):
       
    1:     attribute_name = None
    1:     _active_patches = []
       
    1:     def __init__(
                   self, getter, attribute, new, spec, create,
                   spec_set, autospec, new_callable, kwargs
               ):
    3:         if new_callable is not None:
>>>>>>             if new is not DEFAULT:
>>>>>>                 raise ValueError(
>>>>>>                     "Cannot use 'new' and 'new_callable' together"
                       )
>>>>>>             if autospec is not None:
>>>>>>                 raise ValueError(
>>>>>>                     "Cannot use 'autospec' and 'new_callable' together"
                       )
       
    3:         self.getter = getter
    3:         self.attribute = attribute
    3:         self.new = new
    3:         self.new_callable = new_callable
    3:         self.spec = spec
    3:         self.create = create
    3:         self.has_local = False
    3:         self.spec_set = spec_set
    3:         self.autospec = autospec
    3:         self.kwargs = kwargs
    3:         self.additional_patchers = []
       
       
    1:     def copy(self):
>>>>>>         patcher = _patch(
>>>>>>             self.getter, self.attribute, self.new, self.spec,
>>>>>>             self.create, self.spec_set,
>>>>>>             self.autospec, self.new_callable, self.kwargs
               )
>>>>>>         patcher.attribute_name = self.attribute_name
>>>>>>         patcher.additional_patchers = [
>>>>>>             p.copy() for p in self.additional_patchers
               ]
>>>>>>         return patcher
       
       
    1:     def __call__(self, func):
>>>>>>         if isinstance(func, type):
>>>>>>             return self.decorate_class(func)
>>>>>>         if inspect.iscoroutinefunction(func):
>>>>>>             return self.decorate_async_callable(func)
>>>>>>         return self.decorate_callable(func)
       
       
    1:     def decorate_class(self, klass):
>>>>>>         for attr in dir(klass):
>>>>>>             if not attr.startswith(patch.TEST_PREFIX):
>>>>>>                 continue
       
>>>>>>             attr_value = getattr(klass, attr)
>>>>>>             if not hasattr(attr_value, "__call__"):
>>>>>>                 continue
       
>>>>>>             patcher = self.copy()
>>>>>>             setattr(klass, attr, patcher(attr_value))
>>>>>>         return klass
       
       
    1:     @contextlib.contextmanager
    1:     def decoration_helper(self, patched, args, keywargs):
>>>>>>         extra_args = []
>>>>>>         with contextlib.ExitStack() as exit_stack:
>>>>>>             for patching in patched.patchings:
>>>>>>                 arg = exit_stack.enter_context(patching)
>>>>>>                 if patching.attribute_name is not None:
>>>>>>                     keywargs.update(arg)
>>>>>>                 elif patching.new is DEFAULT:
>>>>>>                     extra_args.append(arg)
       
>>>>>>             args += tuple(extra_args)
>>>>>>             yield (args, keywargs)
       
       
    1:     def decorate_callable(self, func):
               # NB. Keep the method in sync with decorate_async_callable()
>>>>>>         if hasattr(func, 'patchings'):
>>>>>>             func.patchings.append(self)
>>>>>>             return func
       
>>>>>>         @wraps(func)
>>>>>>         def patched(*args, **keywargs):
>>>>>>             with self.decoration_helper(patched,
>>>>>>                                         args,
>>>>>>                                         keywargs) as (newargs, newkeywargs):
>>>>>>                 return func(*newargs, **newkeywargs)
       
>>>>>>         patched.patchings = [self]
>>>>>>         return patched
       
       
    1:     def decorate_async_callable(self, func):
               # NB. Keep the method in sync with decorate_callable()
>>>>>>         if hasattr(func, 'patchings'):
>>>>>>             func.patchings.append(self)
>>>>>>             return func
       
>>>>>>         @wraps(func)
>>>>>>         async def patched(*args, **keywargs):
>>>>>>             with self.decoration_helper(patched,
>>>>>>                                         args,
>>>>>>                                         keywargs) as (newargs, newkeywargs):
>>>>>>                 return await func(*newargs, **newkeywargs)
       
>>>>>>         patched.patchings = [self]
>>>>>>         return patched
       
       
    1:     def get_original(self):
    3:         target = self.getter()
    3:         name = self.attribute
       
    3:         original = DEFAULT
    3:         local = False
       
    3:         try:
    3:             original = target.__dict__[name]
>>>>>>         except (AttributeError, KeyError):
>>>>>>             original = getattr(target, name, DEFAULT)
               else:
    3:             local = True
       
    3:         if name in _builtins and isinstance(target, ModuleType):
>>>>>>             self.create = True
       
    3:         if not self.create and original is DEFAULT:
>>>>>>             raise AttributeError(
>>>>>>                 "%s does not have the attribute %r" % (target, name)
                   )
    3:         return original, local
       
       
    1:     def __enter__(self):
               """Perform the patch."""
    3:         new, spec, spec_set = self.new, self.spec, self.spec_set
    3:         autospec, kwargs = self.autospec, self.kwargs
    3:         new_callable = self.new_callable
    3:         self.target = self.getter()
       
               # normalise False to None
    3:         if spec is False:
>>>>>>             spec = None
    3:         if spec_set is False:
>>>>>>             spec_set = None
    3:         if autospec is False:
>>>>>>             autospec = None
       
    3:         if spec is not None and autospec is not None:
>>>>>>             raise TypeError("Can't specify spec and autospec")
    3:         if ((spec is not None or autospec is not None) and
>>>>>>             spec_set not in (True, None)):
>>>>>>             raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
       
    3:         original, local = self.get_original()
       
    3:         if new is DEFAULT and autospec is None:
    1:             inherit = False
    1:             if spec is True:
                       # set spec to the object we are replacing
>>>>>>                 spec = original
>>>>>>                 if spec_set is True:
>>>>>>                     spec_set = original
>>>>>>                     spec = None
    1:             elif spec is not None:
>>>>>>                 if spec_set is True:
>>>>>>                     spec_set = spec
>>>>>>                     spec = None
    1:             elif spec_set is True:
>>>>>>                 spec_set = original
       
    1:             if spec is not None or spec_set is not None:
>>>>>>                 if original is DEFAULT:
>>>>>>                     raise TypeError("Can't use 'spec' with create=True")
>>>>>>                 if isinstance(original, type):
                           # If we're patching out a class and there is a spec
>>>>>>                     inherit = True
    1:             if spec is None and _is_async_obj(original):
>>>>>>                 Klass = AsyncMock
                   else:
    1:                 Klass = MagicMock
    1:             _kwargs = {}
    1:             if new_callable is not None:
>>>>>>                 Klass = new_callable
    1:             elif spec is not None or spec_set is not None:
>>>>>>                 this_spec = spec
>>>>>>                 if spec_set is not None:
>>>>>>                     this_spec = spec_set
>>>>>>                 if _is_list(this_spec):
>>>>>>                     not_callable = '__call__' not in this_spec
                       else:
>>>>>>                     not_callable = not callable(this_spec)
>>>>>>                 if _is_async_obj(this_spec):
>>>>>>                     Klass = AsyncMock
>>>>>>                 elif not_callable:
>>>>>>                     Klass = NonCallableMagicMock
       
    1:             if spec is not None:
>>>>>>                 _kwargs['spec'] = spec
    1:             if spec_set is not None:
>>>>>>                 _kwargs['spec_set'] = spec_set
       
                   # add a name to mocks
    3:             if (isinstance(Klass, type) and
    2:                 issubclass(Klass, NonCallableMock) and self.attribute):
    1:                 _kwargs['name'] = self.attribute
       
    1:             _kwargs.update(kwargs)
    1:             new = Klass(**_kwargs)
       
    1:             if inherit and _is_instance_mock(new):
                       # we can only tell if the instance should be callable if the
                       # spec is not a list
>>>>>>                 this_spec = spec
>>>>>>                 if spec_set is not None:
>>>>>>                     this_spec = spec_set
>>>>>>                 if (not _is_list(this_spec) and not
>>>>>>                     _instance_callable(this_spec)):
>>>>>>                     Klass = NonCallableMagicMock
       
>>>>>>                 _kwargs.pop('name')
>>>>>>                 new.return_value = Klass(_new_parent=new, _new_name='()',
>>>>>>                                          **_kwargs)
    2:         elif autospec is not None:
                   # spec is ignored, new *must* be default, spec_set is treated
                   # as a boolean. Should we check spec is not None and that spec_set
                   # is a bool?
>>>>>>             if new is not DEFAULT:
>>>>>>                 raise TypeError(
>>>>>>                     "autospec creates the mock for you. Can't specify "
                           "autospec and new."
                       )
>>>>>>             if original is DEFAULT:
>>>>>>                 raise TypeError("Can't use 'autospec' with create=True")
>>>>>>             spec_set = bool(spec_set)
>>>>>>             if autospec is True:
>>>>>>                 autospec = original
       
>>>>>>             new = create_autospec(autospec, spec_set=spec_set,
>>>>>>                                   _name=self.attribute, **kwargs)
    2:         elif kwargs:
                   # can't set keyword args when we aren't creating the mock
                   # XXXX If new is a Mock we could call new.configure_mock(**kwargs)
>>>>>>             raise TypeError("Can't pass kwargs to a mock we aren't creating")
       
    3:         new_attr = new
       
    3:         self.temp_original = original
    3:         self.is_local = local
    3:         self._exit_stack = contextlib.ExitStack()
    3:         try:
    3:             setattr(self.target, self.attribute, new_attr)
    3:             if self.attribute_name is not None:
>>>>>>                 extra_args = {}
>>>>>>                 if self.new is DEFAULT:
>>>>>>                     extra_args[self.attribute_name] =  new
>>>>>>                 for patching in self.additional_patchers:
>>>>>>                     arg = self._exit_stack.enter_context(patching)
>>>>>>                     if patching.new is DEFAULT:
>>>>>>                         extra_args.update(arg)
>>>>>>                 return extra_args
       
    3:             return new
>>>>>>         except:
>>>>>>             if not self.__exit__(*sys.exc_info()):
>>>>>>                 raise
       
    1:     def __exit__(self, *exc_info):
               """Undo the patch."""
    3:         if self.is_local and self.temp_original is not DEFAULT:
    3:             setattr(self.target, self.attribute, self.temp_original)
               else:
>>>>>>             delattr(self.target, self.attribute)
>>>>>>             if not self.create and (not hasattr(self.target, self.attribute) or
>>>>>>                         self.attribute in ('__doc__', '__module__',
                                                  '__defaults__', '__annotations__',
                                                  '__kwdefaults__')):
                       # needed for proxy objects like django settings
>>>>>>                 setattr(self.target, self.attribute, self.temp_original)
       
    3:         del self.temp_original
    3:         del self.is_local
    3:         del self.target
    3:         exit_stack = self._exit_stack
    3:         del self._exit_stack
    3:         return exit_stack.__exit__(*exc_info)
       
       
    1:     def start(self):
               """Activate a patch, returning any created mock."""
>>>>>>         result = self.__enter__()
>>>>>>         self._active_patches.append(self)
>>>>>>         return result
       
       
    1:     def stop(self):
               """Stop an active patch."""
>>>>>>         try:
>>>>>>             self._active_patches.remove(self)
>>>>>>         except ValueError:
                   # If the patch hasn't been started this will fail
>>>>>>             return None
       
>>>>>>         return self.__exit__(None, None, None)
       
       
       
    1: def _get_target(target):
    2:     try:
    2:         target, attribute = target.rsplit('.', 1)
>>>>>>     except (TypeError, ValueError):
>>>>>>         raise TypeError("Need a valid target to patch. You supplied: %r" %
>>>>>>                         (target,))
    6:     getter = lambda: _importer(target)
    2:     return getter, attribute
       
       
    1: def _patch_object(
    1:         target, attribute, new=DEFAULT, spec=None,
    1:         create=False, spec_set=None, autospec=None,
    1:         new_callable=None, **kwargs
           ):
           """
           patch the named member (`attribute`) on an object (`target`) with a mock
           object.
       
           `patch.object` can be used as a decorator, class decorator or a context
           manager. Arguments `new`, `spec`, `create`, `spec_set`,
           `autospec` and `new_callable` have the same meaning as for `patch`. Like
           `patch`, `patch.object` takes arbitrary keyword arguments for configuring
           the mock object it creates.
       
           When used as a class decorator `patch.object` honours `patch.TEST_PREFIX`
           for choosing which methods to wrap.
           """
    1:     if type(target) is str:
>>>>>>         raise TypeError(
>>>>>>             f"{target!r} must be the actual object to be patched, not a str"
               )
    3:     getter = lambda: target
    2:     return _patch(
    1:         getter, attribute, new, spec, create,
    1:         spec_set, autospec, new_callable, kwargs
           )
       
       
    1: def _patch_multiple(target, spec=None, create=False, spec_set=None,
                           autospec=None, new_callable=None, **kwargs):
           """Perform multiple patches in a single call. It takes the object to be
           patched (either as an object or a string to fetch the object by importing)
           and keyword arguments for the patches::
       
               with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):
                   ...
       
           Use `DEFAULT` as the value if you want `patch.multiple` to create
           mocks for you. In this case the created mocks are passed into a decorated
           function by keyword, and a dictionary is returned when `patch.multiple` is
           used as a context manager.
       
           `patch.multiple` can be used as a decorator, class decorator or a context
           manager. The arguments `spec`, `spec_set`, `create`,
           `autospec` and `new_callable` have the same meaning as for `patch`. These
           arguments will be applied to *all* patches done by `patch.multiple`.
       
           When used as a class decorator `patch.multiple` honours `patch.TEST_PREFIX`
           for choosing which methods to wrap.
           """
>>>>>>     if type(target) is str:
>>>>>>         getter = lambda: _importer(target)
           else:
>>>>>>         getter = lambda: target
       
>>>>>>     if not kwargs:
>>>>>>         raise ValueError(
>>>>>>             'Must supply at least one keyword argument with patch.multiple'
               )
           # need to wrap in a list for python 3, where items is a view
>>>>>>     items = list(kwargs.items())
>>>>>>     attribute, new = items[0]
>>>>>>     patcher = _patch(
>>>>>>         getter, attribute, new, spec, create, spec_set,
>>>>>>         autospec, new_callable, {}
           )
>>>>>>     patcher.attribute_name = attribute
>>>>>>     for attribute, new in items[1:]:
>>>>>>         this_patcher = _patch(
>>>>>>             getter, attribute, new, spec, create, spec_set,
>>>>>>             autospec, new_callable, {}
               )
>>>>>>         this_patcher.attribute_name = attribute
>>>>>>         patcher.additional_patchers.append(this_patcher)
>>>>>>     return patcher
       
       
    1: def patch(
    1:         target, new=DEFAULT, spec=None, create=False,
    1:         spec_set=None, autospec=None, new_callable=None, **kwargs
           ):
           """
           `patch` acts as a function decorator, class decorator or a context
           manager. Inside the body of the function or with statement, the `target`
           is patched with a `new` object. When the function/with statement exits
           the patch is undone.
       
           If `new` is omitted, then the target is replaced with an
           `AsyncMock if the patched object is an async function or a
           `MagicMock` otherwise. If `patch` is used as a decorator and `new` is
           omitted, the created mock is passed in as an extra argument to the
           decorated function. If `patch` is used as a context manager the created
           mock is returned by the context manager.
       
           `target` should be a string in the form `'package.module.ClassName'`. The
           `target` is imported and the specified object replaced with the `new`
           object, so the `target` must be importable from the environment you are
           calling `patch` from. The target is imported when the decorated function
           is executed, not at decoration time.
       
           The `spec` and `spec_set` keyword arguments are passed to the `MagicMock`
           if patch is creating one for you.
       
           In addition you can pass `spec=True` or `spec_set=True`, which causes
           patch to pass in the object being mocked as the spec/spec_set object.
       
           `new_callable` allows you to specify a different class, or callable object,
           that will be called to create the `new` object. By default `AsyncMock` is
           used for async functions and `MagicMock` for the rest.
       
           A more powerful form of `spec` is `autospec`. If you set `autospec=True`
           then the mock will be created with a spec from the object being replaced.
           All attributes of the mock will also have the spec of the corresponding
           attribute of the object being replaced. Methods and functions being
           mocked will have their arguments checked and will raise a `TypeError` if
           they are called with the wrong signature. For mocks replacing a class,
           their return value (the 'instance') will have the same spec as the class.
       
           Instead of `autospec=True` you can pass `autospec=some_object` to use an
           arbitrary object as the spec instead of the one being replaced.
       
           By default `patch` will fail to replace attributes that don't exist. If
           you pass in `create=True`, and the attribute doesn't exist, patch will
           create the attribute for you when the patched function is called, and
           delete it again afterwards. This is useful for writing tests against
           attributes that your production code creates at runtime. It is off by
           default because it can be dangerous. With it switched on you can write
           passing tests against APIs that don't actually exist!
       
           Patch can be used as a `TestCase` class decorator. It works by
           decorating each test method in the class. This reduces the boilerplate
           code when your test methods share a common patchings set. `patch` finds
           tests by looking for method names that start with `patch.TEST_PREFIX`.
           By default this is `test`, which matches the way `unittest` finds tests.
           You can specify an alternative prefix by setting `patch.TEST_PREFIX`.
       
           Patch can be used as a context manager, with the with statement. Here the
           patching applies to the indented block after the with statement. If you
           use "as" then the patched object will be bound to the name after the
           "as"; very useful if `patch` is creating a mock object for you.
       
           `patch` takes arbitrary keyword arguments. These will be passed to
           `AsyncMock` if the patched object is asynchronous, to `MagicMock`
           otherwise or to `new_callable` if specified.
       
           `patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are
           available for alternate use-cases.
           """
    2:     getter, attribute = _get_target(target)
    4:     return _patch(
    2:         getter, attribute, new, spec, create,
    2:         spec_set, autospec, new_callable, kwargs
           )
       
       
    2: class _patch_dict(object):
    1:     """
           Patch a dictionary, or dictionary like object, and restore the dictionary
           to its original state after the test.
       
           `in_dict` can be a dictionary or a mapping like container. If it is a
           mapping then it must at least support getting, setting and deleting items
           plus iterating over keys.
       
           `in_dict` can also be a string specifying the name of the dictionary, which
           will then be fetched by importing it.
       
           `values` can be a dictionary of values to set in the dictionary. `values`
           can also be an iterable of `(key, value)` pairs.
       
           If `clear` is True then the dictionary will be cleared before the new
           values are set.
       
           `patch.dict` can also be called with arbitrary keyword arguments to set
           values in the dictionary::
       
               with patch.dict('sys.modules', mymodule=Mock(), other_module=Mock()):
                   ...
       
           `patch.dict` can be used as a context manager, decorator or class
           decorator. When used as a class decorator `patch.dict` honours
           `patch.TEST_PREFIX` for choosing which methods to wrap.
           """
       
    1:     def __init__(self, in_dict, values=(), clear=False, **kwargs):
>>>>>>         self.in_dict = in_dict
               # support any argument supported by dict(...) constructor
>>>>>>         self.values = dict(values)
>>>>>>         self.values.update(kwargs)
>>>>>>         self.clear = clear
>>>>>>         self._original = None
       
       
    1:     def __call__(self, f):
>>>>>>         if isinstance(f, type):
>>>>>>             return self.decorate_class(f)
>>>>>>         @wraps(f)
>>>>>>         def _inner(*args, **kw):
>>>>>>             self._patch_dict()
>>>>>>             try:
>>>>>>                 return f(*args, **kw)
                   finally:
>>>>>>                 self._unpatch_dict()
       
>>>>>>         return _inner
       
       
    1:     def decorate_class(self, klass):
>>>>>>         for attr in dir(klass):
>>>>>>             attr_value = getattr(klass, attr)
>>>>>>             if (attr.startswith(patch.TEST_PREFIX) and
>>>>>>                  hasattr(attr_value, "__call__")):
>>>>>>                 decorator = _patch_dict(self.in_dict, self.values, self.clear)
>>>>>>                 decorated = decorator(attr_value)
>>>>>>                 setattr(klass, attr, decorated)
>>>>>>         return klass
       
       
    1:     def __enter__(self):
               """Patch the dict."""
>>>>>>         self._patch_dict()
>>>>>>         return self.in_dict
       
       
    1:     def _patch_dict(self):
>>>>>>         values = self.values
>>>>>>         if isinstance(self.in_dict, str):
>>>>>>             self.in_dict = _importer(self.in_dict)
>>>>>>         in_dict = self.in_dict
>>>>>>         clear = self.clear
       
>>>>>>         try:
>>>>>>             original = in_dict.copy()
>>>>>>         except AttributeError:
                   # dict like object with no copy method
                   # must support iteration over keys
>>>>>>             original = {}
>>>>>>             for key in in_dict:
>>>>>>                 original[key] = in_dict[key]
>>>>>>         self._original = original
       
>>>>>>         if clear:
>>>>>>             _clear_dict(in_dict)
       
>>>>>>         try:
>>>>>>             in_dict.update(values)
>>>>>>         except AttributeError:
                   # dict like object with no update method
>>>>>>             for key in values:
>>>>>>                 in_dict[key] = values[key]
       
       
    1:     def _unpatch_dict(self):
>>>>>>         in_dict = self.in_dict
>>>>>>         original = self._original
       
>>>>>>         _clear_dict(in_dict)
       
>>>>>>         try:
>>>>>>             in_dict.update(original)
>>>>>>         except AttributeError:
>>>>>>             for key in original:
>>>>>>                 in_dict[key] = original[key]
       
       
    1:     def __exit__(self, *args):
               """Unpatch the dict."""
>>>>>>         if self._original is not None:
>>>>>>             self._unpatch_dict()
>>>>>>         return False
       
       
    1:     def start(self):
               """Activate a patch, returning any created mock."""
>>>>>>         result = self.__enter__()
>>>>>>         _patch._active_patches.append(self)
>>>>>>         return result
       
       
    1:     def stop(self):
               """Stop an active patch."""
>>>>>>         try:
>>>>>>             _patch._active_patches.remove(self)
>>>>>>         except ValueError:
                   # If the patch hasn't been started this will fail
>>>>>>             return None
       
>>>>>>         return self.__exit__(None, None, None)
       
       
    1: def _clear_dict(in_dict):
>>>>>>     try:
>>>>>>         in_dict.clear()
>>>>>>     except AttributeError:
>>>>>>         keys = list(in_dict)
>>>>>>         for key in keys:
>>>>>>             del in_dict[key]
       
       
    1: def _patch_stopall():
           """Stop all active patches. LIFO to unroll nested patches."""
>>>>>>     for patch in reversed(_patch._active_patches):
>>>>>>         patch.stop()
       
       
    1: patch.object = _patch_object
    1: patch.dict = _patch_dict
    1: patch.multiple = _patch_multiple
    1: patch.stopall = _patch_stopall
    1: patch.TEST_PREFIX = 'test'
       
    1: magic_methods = (
    1:     "lt le gt ge eq ne "
           "getitem setitem delitem "
           "len contains iter "
           "hash str sizeof "
           "enter exit "
           # we added divmod and rdivmod here instead of numerics
           # because there is no idivmod
           "divmod rdivmod neg pos abs invert "
           "complex int float index "
           "round trunc floor ceil "
           "bool next "
           "fspath "
           "aiter "
       )
       
    1: numerics = (
    1:     "add sub mul matmul div floordiv mod lshift rshift and xor or pow truediv"
       )
   16: inplace = ' '.join('i%s' % n for n in numerics.split())
   16: right = ' '.join('r%s' % n for n in numerics.split())
       
       # not including __prepare__, __instancecheck__, __subclasscheck__
       # (as they are metaclass methods)
       # __del__ is not supported at all as it causes problems if it exists
       
    1: _non_defaults = {
           '__get__', '__set__', '__delete__', '__reversed__', '__missing__',
           '__reduce__', '__reduce_ex__', '__getinitargs__', '__getnewargs__',
           '__getstate__', '__setstate__', '__getformat__', '__setformat__',
           '__repr__', '__dir__', '__subclasses__', '__format__',
           '__getnewargs_ex__',
       }
       
       
    1: def _get_method(name, func):
           "Turns a callable object (like a mock) into a real function"
>>>>>>     def method(self, /, *args, **kw):
>>>>>>         return func(self, *args, **kw)
>>>>>>     method.__name__ = name
>>>>>>     return method
       
       
   80: _magics = {
   77:     '__%s__' % method for method in
    1:     ' '.join([magic_methods, numerics, inplace, right]).split()
       }
       
       # Magic methods used for async `with` statements
    1: _async_method_magics = {"__aenter__", "__aexit__", "__anext__"}
       # Magic methods that are only used with async calls but are synchronous functions themselves
    1: _sync_async_magics = {"__aiter__"}
    1: _async_magics = _async_method_magics | _sync_async_magics
       
    1: _all_sync_magics = _magics | _non_defaults
    1: _all_magics = _all_sync_magics | _async_magics
       
    1: _unsupported_magics = {
           '__getattr__', '__setattr__',
           '__init__', '__new__', '__prepare__',
           '__instancecheck__', '__subclasscheck__',
           '__del__'
       }
       
    1: _calculate_return_value = {
    1:     '__hash__': lambda self: object.__hash__(self),
    1:     '__str__': lambda self: object.__str__(self),
    1:     '__sizeof__': lambda self: object.__sizeof__(self),
    1:     '__fspath__': lambda self: f"{type(self).__name__}/{self._extract_mock_name()}/{id(self)}",
       }
       
    1: _return_values = {
    1:     '__lt__': NotImplemented,
    1:     '__gt__': NotImplemented,
    1:     '__le__': NotImplemented,
    1:     '__ge__': NotImplemented,
    1:     '__int__': 1,
    1:     '__contains__': False,
    1:     '__len__': 0,
    1:     '__exit__': False,
    1:     '__complex__': 1j,
    1:     '__float__': 1.0,
    1:     '__bool__': True,
    1:     '__index__': 1,
    1:     '__aexit__': False,
       }
       
       
    1: def _get_eq(self):
>>>>>>     def __eq__(other):
>>>>>>         ret_val = self.__eq__._mock_return_value
>>>>>>         if ret_val is not DEFAULT:
>>>>>>             return ret_val
>>>>>>         if self is other:
>>>>>>             return True
>>>>>>         return NotImplemented
>>>>>>     return __eq__
       
    1: def _get_ne(self):
>>>>>>     def __ne__(other):
>>>>>>         if self.__ne__._mock_return_value is not DEFAULT:
>>>>>>             return DEFAULT
>>>>>>         if self is other:
>>>>>>             return False
>>>>>>         return NotImplemented
>>>>>>     return __ne__
       
    1: def _get_iter(self):
>>>>>>     def __iter__():
>>>>>>         ret_val = self.__iter__._mock_return_value
>>>>>>         if ret_val is DEFAULT:
>>>>>>             return iter([])
               # if ret_val was already an iterator, then calling iter on it should
               # return the iterator unchanged
>>>>>>         return iter(ret_val)
>>>>>>     return __iter__
       
    1: def _get_async_iter(self):
>>>>>>     def __aiter__():
>>>>>>         ret_val = self.__aiter__._mock_return_value
>>>>>>         if ret_val is DEFAULT:
>>>>>>             return _AsyncIterator(iter([]))
>>>>>>         return _AsyncIterator(iter(ret_val))
>>>>>>     return __aiter__
       
    1: _side_effect_methods = {
    1:     '__eq__': _get_eq,
    1:     '__ne__': _get_ne,
    1:     '__iter__': _get_iter,
    1:     '__aiter__': _get_async_iter
       }
       
       
       
    1: def _set_return_value(mock, method, name):
>>>>>>     fixed = _return_values.get(name, DEFAULT)
>>>>>>     if fixed is not DEFAULT:
>>>>>>         method.return_value = fixed
>>>>>>         return
       
>>>>>>     return_calculator = _calculate_return_value.get(name)
>>>>>>     if return_calculator is not None:
>>>>>>         return_value = return_calculator(mock)
>>>>>>         method.return_value = return_value
>>>>>>         return
       
>>>>>>     side_effector = _side_effect_methods.get(name)
>>>>>>     if side_effector is not None:
>>>>>>         method.side_effect = side_effector(mock)
       
       
       
    2: class MagicMixin(Base):
    1:     def __init__(self, /, *args, **kw):
   47:         self._mock_set_magics()  # make magic work for kwargs in init
   47:         _safe_super(MagicMixin, self).__init__(*args, **kw)
   47:         self._mock_set_magics()  # fix magic broken by upper level init
       
       
    1:     def _mock_set_magics(self):
  184:         orig_magics = _magics | _async_method_magics
  184:         these_magics = orig_magics
       
  184:         if getattr(self, "_mock_methods", None) is not None:
>>>>>>             these_magics = orig_magics.intersection(self._mock_methods)
       
>>>>>>             remove_magics = set()
>>>>>>             remove_magics = orig_magics - these_magics
       
>>>>>>             for entry in remove_magics:
>>>>>>                 if entry in type(self).__dict__:
                           # remove unneeded magic methods
>>>>>>                     delattr(self, entry)
       
               # don't overwrite existing attributes if called a second time
  184:         these_magics = these_magics - set(type(self).__dict__)
       
  184:         _type = type(self)
 3944:         for entry in these_magics:
 3760:             setattr(_type, entry, MagicProxy(entry, self))
       
       
       
    2: class NonCallableMagicMock(MagicMixin, NonCallableMock):
    1:     """A version of `MagicMock` that isn't callable."""
    1:     def mock_add_spec(self, spec, spec_set=False):
               """Add a spec to a mock. `spec` can either be an object or a
               list of strings. Only attributes on the `spec` can be fetched as
               attributes from the mock.
       
               If `spec_set` is True then only attributes on the spec can be set."""
>>>>>>         self._mock_add_spec(spec, spec_set)
>>>>>>         self._mock_set_magics()
       
       
    2: class AsyncMagicMixin(MagicMixin):
    1:     def __init__(self, /, *args, **kw):
   45:         self._mock_set_magics()  # make magic work for kwargs in init
   45:         _safe_super(AsyncMagicMixin, self).__init__(*args, **kw)
   45:         self._mock_set_magics()  # fix magic broken by upper level init
       
    2: class MagicMock(MagicMixin, Mock):
    1:     """
           MagicMock is a subclass of Mock with default implementations
           of most of the magic methods. You can use MagicMock without having to
           configure the magic methods yourself.
       
           If you use the `spec` or `spec_set` arguments then *only* magic
           methods that exist in the spec will be created.
       
           Attributes and the return value of a `MagicMock` will also be `MagicMocks`.
           """
    1:     def mock_add_spec(self, spec, spec_set=False):
               """Add a spec to a mock. `spec` can either be an object or a
               list of strings. Only attributes on the `spec` can be fetched as
               attributes from the mock.
       
               If `spec_set` is True then only attributes on the spec can be set."""
>>>>>>         self._mock_add_spec(spec, spec_set)
>>>>>>         self._mock_set_magics()
       
       
       
    2: class MagicProxy(Base):
    1:     def __init__(self, name, parent):
 3760:         self.name = name
 3760:         self.parent = parent
       
    1:     def create_mock(self):
>>>>>>         entry = self.name
>>>>>>         parent = self.parent
>>>>>>         m = parent._get_child_mock(name=entry, _new_name=entry,
>>>>>>                                    _new_parent=parent)
>>>>>>         setattr(parent, entry, m)
>>>>>>         _set_return_value(parent, m, entry)
>>>>>>         return m
       
    1:     def __get__(self, obj, _type=None):
>>>>>>         return self.create_mock()
       
       
    2: class AsyncMockMixin(Base):
    1:     await_count = _delegating_property('await_count')
    1:     await_args = _delegating_property('await_args')
    1:     await_args_list = _delegating_property('await_args_list')
       
    1:     def __init__(self, /, *args, **kwargs):
   45:         super().__init__(*args, **kwargs)
               # iscoroutinefunction() checks _is_coroutine property to say if an
               # object is a coroutine. Without this check it looks to see if it is a
               # function/method, which in this case it is not (since it is an
               # AsyncMock).
               # It is set through __dict__ because when spec_set is True, this
               # attribute is likely undefined.
   45:         self.__dict__['_is_coroutine'] = asyncio.coroutines._is_coroutine
   45:         self.__dict__['_mock_await_count'] = 0
   45:         self.__dict__['_mock_await_args'] = None
   45:         self.__dict__['_mock_await_args_list'] = _CallList()
   45:         code_mock = NonCallableMock(spec_set=CodeType)
   45:         code_mock.co_flags = inspect.CO_COROUTINE
   45:         self.__dict__['__code__'] = code_mock
       
    1:     async def _execute_mock_call(self, /, *args, **kwargs):
               # This is nearly just like super(), except for special handling
               # of coroutines
       
   13:         _call = _Call((args, kwargs), two=True)
   13:         self.await_count += 1
   13:         self.await_args = _call
   13:         self.await_args_list.append(_call)
       
   13:         effect = self.side_effect
   13:         if effect is not None:
>>>>>>             if _is_exception(effect):
>>>>>>                 raise effect
>>>>>>             elif not _callable(effect):
>>>>>>                 try:
>>>>>>                     result = next(effect)
>>>>>>                 except StopIteration:
                           # It is impossible to propogate a StopIteration
                           # through coroutines because of PEP 479
>>>>>>                     raise StopAsyncIteration
>>>>>>                 if _is_exception(result):
>>>>>>                     raise result
>>>>>>             elif iscoroutinefunction(effect):
>>>>>>                 result = await effect(*args, **kwargs)
                   else:
>>>>>>                 result = effect(*args, **kwargs)
       
>>>>>>             if result is not DEFAULT:
>>>>>>                 return result
       
   13:         if self._mock_return_value is not DEFAULT:
   13:             return self.return_value
       
>>>>>>         if self._mock_wraps is not None:
>>>>>>             if iscoroutinefunction(self._mock_wraps):
>>>>>>                 return await self._mock_wraps(*args, **kwargs)
>>>>>>             return self._mock_wraps(*args, **kwargs)
       
>>>>>>         return self.return_value
       
    1:     def assert_awaited(self):
               """
               Assert that the mock was awaited at least once.
               """
>>>>>>         if self.await_count == 0:
>>>>>>             msg = f"Expected {self._mock_name or 'mock'} to have been awaited."
>>>>>>             raise AssertionError(msg)
       
    1:     def assert_awaited_once(self):
               """
               Assert that the mock was awaited exactly once.
               """
>>>>>>         if not self.await_count == 1:
>>>>>>             msg = (f"Expected {self._mock_name or 'mock'} to have been awaited once."
>>>>>>                    f" Awaited {self.await_count} times.")
>>>>>>             raise AssertionError(msg)
       
    1:     def assert_awaited_with(self, /, *args, **kwargs):
               """
               Assert that the last await was with the specified arguments.
               """
>>>>>>         if self.await_args is None:
>>>>>>             expected = self._format_mock_call_signature(args, kwargs)
>>>>>>             raise AssertionError(f'Expected await: {expected}\nNot awaited')
       
>>>>>>         def _error_message():
>>>>>>             msg = self._format_mock_failure_message(args, kwargs, action='await')
>>>>>>             return msg
       
>>>>>>         expected = self._call_matcher(_Call((args, kwargs), two=True))
>>>>>>         actual = self._call_matcher(self.await_args)
>>>>>>         if actual != expected:
>>>>>>             cause = expected if isinstance(expected, Exception) else None
>>>>>>             raise AssertionError(_error_message()) from cause
       
    1:     def assert_awaited_once_with(self, /, *args, **kwargs):
               """
               Assert that the mock was awaited exactly once and with the specified
               arguments.
               """
>>>>>>         if not self.await_count == 1:
>>>>>>             msg = (f"Expected {self._mock_name or 'mock'} to have been awaited once."
>>>>>>                    f" Awaited {self.await_count} times.")
>>>>>>             raise AssertionError(msg)
>>>>>>         return self.assert_awaited_with(*args, **kwargs)
       
    1:     def assert_any_await(self, /, *args, **kwargs):
               """
               Assert the mock has ever been awaited with the specified arguments.
               """
>>>>>>         expected = self._call_matcher(_Call((args, kwargs), two=True))
>>>>>>         cause = expected if isinstance(expected, Exception) else None
>>>>>>         actual = [self._call_matcher(c) for c in self.await_args_list]
>>>>>>         if cause or expected not in _AnyComparer(actual):
>>>>>>             expected_string = self._format_mock_call_signature(args, kwargs)
>>>>>>             raise AssertionError(
>>>>>>                 '%s await not found' % expected_string
>>>>>>             ) from cause
       
    1:     def assert_has_awaits(self, calls, any_order=False):
               """
               Assert the mock has been awaited with the specified calls.
               The :attr:`await_args_list` list is checked for the awaits.
       
               If `any_order` is False (the default) then the awaits must be
               sequential. There can be extra calls before or after the
               specified awaits.
       
               If `any_order` is True then the awaits can be in any order, but
               they must all appear in :attr:`await_args_list`.
               """
>>>>>>         expected = [self._call_matcher(c) for c in calls]
>>>>>>         cause = next((e for e in expected if isinstance(e, Exception)), None)
>>>>>>         all_awaits = _CallList(self._call_matcher(c) for c in self.await_args_list)
>>>>>>         if not any_order:
>>>>>>             if expected not in all_awaits:
>>>>>>                 if cause is None:
>>>>>>                     problem = 'Awaits not found.'
                       else:
>>>>>>                     problem = ('Error processing expected awaits.\n'
                                      'Errors: {}').format(
>>>>>>                                    [e if isinstance(e, Exception) else None
>>>>>>                                     for e in expected])
>>>>>>                 raise AssertionError(
>>>>>>                     f'{problem}\n'
>>>>>>                     f'Expected: {_CallList(calls)}\n'
>>>>>>                     f'Actual: {self.await_args_list}'
>>>>>>                 ) from cause
>>>>>>             return
       
>>>>>>         all_awaits = list(all_awaits)
       
>>>>>>         not_found = []
>>>>>>         for kall in expected:
>>>>>>             try:
>>>>>>                 all_awaits.remove(kall)
>>>>>>             except ValueError:
>>>>>>                 not_found.append(kall)
>>>>>>         if not_found:
>>>>>>             raise AssertionError(
>>>>>>                 '%r not all found in await list' % (tuple(not_found),)
>>>>>>             ) from cause
       
    1:     def assert_not_awaited(self):
               """
               Assert that the mock was never awaited.
               """
>>>>>>         if self.await_count != 0:
>>>>>>             msg = (f"Expected {self._mock_name or 'mock'} to not have been awaited."
>>>>>>                    f" Awaited {self.await_count} times.")
>>>>>>             raise AssertionError(msg)
       
    1:     def reset_mock(self, /, *args, **kwargs):
               """
               See :func:`.Mock.reset_mock()`
               """
>>>>>>         super().reset_mock(*args, **kwargs)
>>>>>>         self.await_count = 0
>>>>>>         self.await_args = None
>>>>>>         self.await_args_list = _CallList()
       
       
    2: class AsyncMock(AsyncMockMixin, AsyncMagicMixin, Mock):
    1:     """
           Enhance :class:`Mock` with features allowing to mock
           an async function.
       
           The :class:`AsyncMock` object will behave so the object is
           recognized as an async function, and the result of a call is an awaitable:
       
           >>> mock = AsyncMock()
           >>> iscoroutinefunction(mock)
           True
           >>> inspect.isawaitable(mock())
           True
       
       
           The result of ``mock()`` is an async function which will have the outcome
           of ``side_effect`` or ``return_value``:
       
           - if ``side_effect`` is a function, the async function will return the
             result of that function,
           - if ``side_effect`` is an exception, the async function will raise the
             exception,
           - if ``side_effect`` is an iterable, the async function will return the
             next value of the iterable, however, if the sequence of result is
             exhausted, ``StopIteration`` is raised immediately,
           - if ``side_effect`` is not defined, the async function will return the
             value defined by ``return_value``, hence, by default, the async function
             returns a new :class:`AsyncMock` object.
       
           If the outcome of ``side_effect`` or ``return_value`` is an async function,
           the mock async function obtained when the mock object is called will be this
           async function itself (and not an async function returning an async
           function).
       
           The test author can also specify a wrapped object with ``wraps``. In this
           case, the :class:`Mock` object behavior is the same as with an
           :class:`.Mock` object: the wrapped object may have methods
           defined as async function functions.
       
           Based on Martin Richard's asynctest project.
           """
       
       
    2: class _ANY(object):
    1:     "A helper object that compares equal to everything."
       
    1:     def __eq__(self, other):
>>>>>>         return True
       
    1:     def __ne__(self, other):
>>>>>>         return False
       
    1:     def __repr__(self):
>>>>>>         return '<ANY>'
       
    1: ANY = _ANY()
       
       
       
    1: def _format_call_signature(name, args, kwargs):
>>>>>>     message = '%s(%%s)' % name
>>>>>>     formatted_args = ''
>>>>>>     args_string = ', '.join([repr(arg) for arg in args])
>>>>>>     kwargs_string = ', '.join([
>>>>>>         '%s=%r' % (key, value) for key, value in kwargs.items()
           ])
>>>>>>     if args_string:
>>>>>>         formatted_args = args_string
>>>>>>     if kwargs_string:
>>>>>>         if formatted_args:
>>>>>>             formatted_args += ', '
>>>>>>         formatted_args += kwargs_string
       
>>>>>>     return message % formatted_args
       
       
       
    2: class _Call(tuple):
    1:     """
           A tuple for holding the results of a call to a mock, either in the form
           `(args, kwargs)` or `(name, args, kwargs)`.
       
           If args or kwargs are empty then a call tuple will compare equal to
           a tuple without those values. This makes comparisons less verbose::
       
               _Call(('name', (), {})) == ('name',)
               _Call(('name', (1,), {})) == ('name', (1,))
               _Call(((), {'a': 'b'})) == ({'a': 'b'},)
       
           The `_Call` object provides a useful shortcut for comparing with call::
       
               _Call(((1, 2), {'a': 3})) == call(1, 2, a=3)
               _Call(('foo', (1, 2), {'a': 3})) == call.foo(1, 2, a=3)
       
           If the _Call has no name then it will match any name.
           """
    1:     def __new__(cls, value=(), name='', parent=None, two=False,
                       from_kall=True):
   42:         args = ()
   42:         kwargs = {}
   42:         _len = len(value)
   42:         if _len == 3:
   14:             name, args, kwargs = value
   28:         elif _len == 2:
   27:             first, second = value
   27:             if isinstance(first, str):
>>>>>>                 name = first
>>>>>>                 if isinstance(second, tuple):
>>>>>>                     args = second
                       else:
>>>>>>                     kwargs = second
                   else:
   27:                 args, kwargs = first, second
    1:         elif _len == 1:
>>>>>>             value, = value
>>>>>>             if isinstance(value, str):
>>>>>>                 name = value
>>>>>>             elif isinstance(value, tuple):
>>>>>>                 args = value
                   else:
>>>>>>                 kwargs = value
       
   42:         if two:
   27:             return tuple.__new__(cls, (args, kwargs))
       
   15:         return tuple.__new__(cls, (name, args, kwargs))
       
       
    1:     def __init__(self, value=(), name=None, parent=None, two=False,
                        from_kall=True):
   42:         self._mock_name = name
   42:         self._mock_parent = parent
   42:         self._mock_from_kall = from_kall
       
       
    1:     def __eq__(self, other):
>>>>>>         try:
>>>>>>             len_other = len(other)
>>>>>>         except TypeError:
>>>>>>             return NotImplemented
       
>>>>>>         self_name = ''
>>>>>>         if len(self) == 2:
>>>>>>             self_args, self_kwargs = self
               else:
>>>>>>             self_name, self_args, self_kwargs = self
       
>>>>>>         if (getattr(self, '_mock_parent', None) and getattr(other, '_mock_parent', None)
>>>>>>                 and self._mock_parent != other._mock_parent):
>>>>>>             return False
       
>>>>>>         other_name = ''
>>>>>>         if len_other == 0:
>>>>>>             other_args, other_kwargs = (), {}
>>>>>>         elif len_other == 3:
>>>>>>             other_name, other_args, other_kwargs = other
>>>>>>         elif len_other == 1:
>>>>>>             value, = other
>>>>>>             if isinstance(value, tuple):
>>>>>>                 other_args = value
>>>>>>                 other_kwargs = {}
>>>>>>             elif isinstance(value, str):
>>>>>>                 other_name = value
>>>>>>                 other_args, other_kwargs = (), {}
                   else:
>>>>>>                 other_args = ()
>>>>>>                 other_kwargs = value
>>>>>>         elif len_other == 2:
                   # could be (name, args) or (name, kwargs) or (args, kwargs)
>>>>>>             first, second = other
>>>>>>             if isinstance(first, str):
>>>>>>                 other_name = first
>>>>>>                 if isinstance(second, tuple):
>>>>>>                     other_args, other_kwargs = second, {}
                       else:
>>>>>>                     other_args, other_kwargs = (), second
                   else:
>>>>>>                 other_args, other_kwargs = first, second
               else:
>>>>>>             return False
       
>>>>>>         if self_name and other_name != self_name:
>>>>>>             return False
       
               # this order is important for ANY to work!
>>>>>>         return (other_args, other_kwargs) == (self_args, self_kwargs)
       
       
    1:     __ne__ = object.__ne__
       
       
    1:     def __call__(self, /, *args, **kwargs):
>>>>>>         if self._mock_name is None:
>>>>>>             return _Call(('', args, kwargs), name='()')
       
>>>>>>         name = self._mock_name + '()'
>>>>>>         return _Call((self._mock_name, args, kwargs), name=name, parent=self)
       
       
    1:     def __getattr__(self, attr):
>>>>>>         if self._mock_name is None:
>>>>>>             return _Call(name=attr, from_kall=False)
>>>>>>         name = '%s.%s' % (self._mock_name, attr)
>>>>>>         return _Call(name=name, parent=self, from_kall=False)
       
       
    1:     def __getattribute__(self, attr):
    4:         if attr in tuple.__dict__:
>>>>>>             raise AttributeError
    4:         return tuple.__getattribute__(self, attr)
       
       
    1:     def _get_call_arguments(self):
    2:         if len(self) == 2:
    2:             args, kwargs = self
               else:
>>>>>>             name, args, kwargs = self
       
    2:         return args, kwargs
       
    1:     @property
    1:     def args(self):
>>>>>>         return self._get_call_arguments()[0]
       
    1:     @property
    1:     def kwargs(self):
    2:         return self._get_call_arguments()[1]
       
    1:     def __repr__(self):
>>>>>>         if not self._mock_from_kall:
>>>>>>             name = self._mock_name or 'call'
>>>>>>             if name.startswith('()'):
>>>>>>                 name = 'call%s' % name
>>>>>>             return name
       
>>>>>>         if len(self) == 2:
>>>>>>             name = 'call'
>>>>>>             args, kwargs = self
               else:
>>>>>>             name, args, kwargs = self
>>>>>>             if not name:
>>>>>>                 name = 'call'
>>>>>>             elif not name.startswith('()'):
>>>>>>                 name = 'call.%s' % name
                   else:
>>>>>>                 name = 'call%s' % name
>>>>>>         return _format_call_signature(name, args, kwargs)
       
       
    1:     def call_list(self):
               """For a call object that represents multiple calls, `call_list`
               returns a list of all the intermediate calls as well as the
               final call."""
>>>>>>         vals = []
>>>>>>         thing = self
>>>>>>         while thing is not None:
>>>>>>             if thing._mock_from_kall:
>>>>>>                 vals.append(thing)
>>>>>>             thing = thing._mock_parent
>>>>>>         return _CallList(reversed(vals))
       
       
    1: call = _Call(from_kall=False)
       
       
    1: def create_autospec(spec, spec_set=False, instance=False, _parent=None,
                           _name=None, **kwargs):
           """Create a mock object using another object as a spec. Attributes on the
           mock will use the corresponding attribute on the `spec` object as their
           spec.
       
           Functions or methods being mocked will have their arguments checked
           to check that they are called with the correct signature.
       
           If `spec_set` is True then attempting to set attributes that don't exist
           on the spec object will raise an `AttributeError`.
       
           If a class is used as a spec then the return value of the mock (the
           instance of the class) will have the same spec. You can use a class as the
           spec for an instance object by passing `instance=True`. The returned mock
           will only be callable if instances of the mock are callable.
       
           `create_autospec` also takes arbitrary keyword arguments that are passed to
           the constructor of the created mock."""
>>>>>>     if _is_list(spec):
               # can't pass a list instance to the mock constructor as it will be
               # interpreted as a list of strings
>>>>>>         spec = type(spec)
       
>>>>>>     is_type = isinstance(spec, type)
>>>>>>     is_async_func = _is_async_func(spec)
>>>>>>     _kwargs = {'spec': spec}
>>>>>>     if spec_set:
>>>>>>         _kwargs = {'spec_set': spec}
>>>>>>     elif spec is None:
               # None we mock with a normal mock without a spec
>>>>>>         _kwargs = {}
>>>>>>     if _kwargs and instance:
>>>>>>         _kwargs['_spec_as_instance'] = True
       
>>>>>>     _kwargs.update(kwargs)
       
>>>>>>     Klass = MagicMock
>>>>>>     if inspect.isdatadescriptor(spec):
               # descriptors don't have a spec
               # because we don't know what type they return
>>>>>>         _kwargs = {}
>>>>>>     elif is_async_func:
>>>>>>         if instance:
>>>>>>             raise RuntimeError("Instance can not be True when create_autospec "
                                      "is mocking an async function")
>>>>>>         Klass = AsyncMock
>>>>>>     elif not _callable(spec):
>>>>>>         Klass = NonCallableMagicMock
>>>>>>     elif is_type and instance and not _instance_callable(spec):
>>>>>>         Klass = NonCallableMagicMock
       
>>>>>>     _name = _kwargs.pop('name', _name)
       
>>>>>>     _new_name = _name
>>>>>>     if _parent is None:
               # for a top level object no _new_name should be set
>>>>>>         _new_name = ''
       
>>>>>>     mock = Klass(parent=_parent, _new_parent=_parent, _new_name=_new_name,
>>>>>>                  name=_name, **_kwargs)
       
>>>>>>     if isinstance(spec, FunctionTypes):
               # should only happen at the top level because we don't
               # recurse for functions
>>>>>>         mock = _set_signature(mock, spec)
>>>>>>         if is_async_func:
>>>>>>             _setup_async_mock(mock)
           else:
>>>>>>         _check_signature(spec, mock, is_type, instance)
       
>>>>>>     if _parent is not None and not instance:
>>>>>>         _parent._mock_children[_name] = mock
       
>>>>>>     if is_type and not instance and 'return_value' not in kwargs:
>>>>>>         mock.return_value = create_autospec(spec, spec_set, instance=True,
>>>>>>                                             _name='()', _parent=mock)
       
>>>>>>     for entry in dir(spec):
>>>>>>         if _is_magic(entry):
                   # MagicMock already does the useful magic methods for us
>>>>>>             continue
       
               # XXXX do we need a better way of getting attributes without
               # triggering code execution (?) Probably not - we need the actual
               # object to mock it so we would rather trigger a property than mock
               # the property descriptor. Likewise we want to mock out dynamically
               # provided attributes.
               # XXXX what about attributes that raise exceptions other than
               # AttributeError on being fetched?
               # we could be resilient against it, or catch and propagate the
               # exception when the attribute is fetched from the mock
>>>>>>         try:
>>>>>>             original = getattr(spec, entry)
>>>>>>         except AttributeError:
>>>>>>             continue
       
>>>>>>         kwargs = {'spec': original}
>>>>>>         if spec_set:
>>>>>>             kwargs = {'spec_set': original}
       
>>>>>>         if not isinstance(original, FunctionTypes):
>>>>>>             new = _SpecState(original, spec_set, mock, entry, instance)
>>>>>>             mock._mock_children[entry] = new
               else:
>>>>>>             parent = mock
>>>>>>             if isinstance(spec, FunctionTypes):
>>>>>>                 parent = mock.mock
       
>>>>>>             skipfirst = _must_skip(spec, entry, is_type)
>>>>>>             kwargs['_eat_self'] = skipfirst
>>>>>>             if iscoroutinefunction(original):
>>>>>>                 child_klass = AsyncMock
                   else:
>>>>>>                 child_klass = MagicMock
>>>>>>             new = child_klass(parent=parent, name=entry, _new_name=entry,
>>>>>>                               _new_parent=parent,
>>>>>>                               **kwargs)
>>>>>>             mock._mock_children[entry] = new
>>>>>>             _check_signature(original, new, skipfirst=skipfirst)
       
               # so functions created with _set_signature become instance attributes,
               # *plus* their underlying mock exists in _mock_children of the parent
               # mock. Adding to _mock_children may be unnecessary where we are also
               # setting as an instance attribute?
>>>>>>         if isinstance(new, FunctionTypes):
>>>>>>             setattr(mock, entry, new)
       
>>>>>>     return mock
       
       
    1: def _must_skip(spec, entry, is_type):
           """
           Return whether we should skip the first argument on spec's `entry`
           attribute.
           """
>>>>>>     if not isinstance(spec, type):
>>>>>>         if entry in getattr(spec, '__dict__', {}):
                   # instance attribute - shouldn't skip
>>>>>>             return False
>>>>>>         spec = spec.__class__
       
>>>>>>     for klass in spec.__mro__:
>>>>>>         result = klass.__dict__.get(entry, DEFAULT)
>>>>>>         if result is DEFAULT:
>>>>>>             continue
>>>>>>         if isinstance(result, (staticmethod, classmethod)):
>>>>>>             return False
>>>>>>         elif isinstance(result, FunctionTypes):
                   # Normal method => skip if looked up on type
                   # (if looked up on instance, self is already skipped)
>>>>>>             return is_type
               else:
>>>>>>             return False
       
           # function is a dynamically provided attribute
>>>>>>     return is_type
       
       
    2: class _SpecState(object):
       
    1:     def __init__(self, spec, spec_set=False, parent=None,
                        name=None, ids=None, instance=False):
>>>>>>         self.spec = spec
>>>>>>         self.ids = ids
>>>>>>         self.spec_set = spec_set
>>>>>>         self.parent = parent
>>>>>>         self.instance = instance
>>>>>>         self.name = name
       
       
    1: FunctionTypes = (
           # python function
    1:     type(create_autospec),
           # instance method
    1:     type(ANY.__eq__),
       )
       
       
    1: file_spec = None
       
       
    1: def _to_stream(read_data):
>>>>>>     if isinstance(read_data, bytes):
>>>>>>         return io.BytesIO(read_data)
           else:
>>>>>>         return io.StringIO(read_data)
       
       
    1: def mock_open(mock=None, read_data=''):
           """
           A helper function to create a mock to replace the use of `open`. It works
           for `open` called directly or used as a context manager.
       
           The `mock` argument is the mock object to configure. If `None` (the
           default) then a `MagicMock` will be created for you, with the API limited
           to methods or attributes available on standard file handles.
       
           `read_data` is a string for the `read`, `readline` and `readlines` of the
           file handle to return.  This is an empty string by default.
           """
>>>>>>     _read_data = _to_stream(read_data)
>>>>>>     _state = [_read_data, None]
       
>>>>>>     def _readlines_side_effect(*args, **kwargs):
>>>>>>         if handle.readlines.return_value is not None:
>>>>>>             return handle.readlines.return_value
>>>>>>         return _state[0].readlines(*args, **kwargs)
       
>>>>>>     def _read_side_effect(*args, **kwargs):
>>>>>>         if handle.read.return_value is not None:
>>>>>>             return handle.read.return_value
>>>>>>         return _state[0].read(*args, **kwargs)
       
>>>>>>     def _readline_side_effect(*args, **kwargs):
>>>>>>         yield from _iter_side_effect()
               while True:
>>>>>>             yield _state[0].readline(*args, **kwargs)
       
>>>>>>     def _iter_side_effect():
>>>>>>         if handle.readline.return_value is not None:
                   while True:
>>>>>>                 yield handle.readline.return_value
>>>>>>         for line in _state[0]:
>>>>>>             yield line
       
>>>>>>     def _next_side_effect():
>>>>>>         if handle.readline.return_value is not None:
>>>>>>             return handle.readline.return_value
>>>>>>         return next(_state[0])
       
           global file_spec
>>>>>>     if file_spec is None:
>>>>>>         import _io
>>>>>>         file_spec = list(set(dir(_io.TextIOWrapper)).union(set(dir(_io.BytesIO))))
       
>>>>>>     if mock is None:
>>>>>>         mock = MagicMock(name='open', spec=open)
       
>>>>>>     handle = MagicMock(spec=file_spec)
>>>>>>     handle.__enter__.return_value = handle
       
>>>>>>     handle.write.return_value = None
>>>>>>     handle.read.return_value = None
>>>>>>     handle.readline.return_value = None
>>>>>>     handle.readlines.return_value = None
       
>>>>>>     handle.read.side_effect = _read_side_effect
>>>>>>     _state[1] = _readline_side_effect()
>>>>>>     handle.readline.side_effect = _state[1]
>>>>>>     handle.readlines.side_effect = _readlines_side_effect
>>>>>>     handle.__iter__.side_effect = _iter_side_effect
>>>>>>     handle.__next__.side_effect = _next_side_effect
       
>>>>>>     def reset_data(*args, **kwargs):
>>>>>>         _state[0] = _to_stream(read_data)
>>>>>>         if handle.readline.side_effect == _state[1]:
                   # Only reset the side effect if the user hasn't overridden it.
>>>>>>             _state[1] = _readline_side_effect()
>>>>>>             handle.readline.side_effect = _state[1]
>>>>>>         return DEFAULT
       
>>>>>>     mock.side_effect = reset_data
>>>>>>     mock.return_value = handle
>>>>>>     return mock
       
       
    2: class PropertyMock(Mock):
    1:     """
           A mock intended to be used as a property, or other descriptor, on a class.
           `PropertyMock` provides `__get__` and `__set__` methods so you can specify
           a return value when it is fetched.
       
           Fetching a `PropertyMock` instance from an object calls the mock, with
           no args. Setting it calls the mock with the value being set.
           """
    1:     def _get_child_mock(self, /, **kwargs):
>>>>>>         return MagicMock(**kwargs)
       
    1:     def __get__(self, obj, obj_type=None):
>>>>>>         return self()
    1:     def __set__(self, obj, val):
>>>>>>         self(val)
       
       
    1: def seal(mock):
           """Disable the automatic generation of child mocks.
       
           Given an input Mock, seals it to ensure no further mocks will be generated
           when accessing an attribute that was not already defined.
       
           The operation recursively seals the mock passed in, meaning that
           the mock itself, any mocks generated by accessing one of its attributes,
           and all assigned mocks without a name or spec will be sealed.
           """
>>>>>>     mock._mock_sealed = True
>>>>>>     for attr in dir(mock):
>>>>>>         try:
>>>>>>             m = getattr(mock, attr)
>>>>>>         except AttributeError:
>>>>>>             continue
>>>>>>         if not isinstance(m, NonCallableMock):
>>>>>>             continue
>>>>>>         if m._mock_new_parent is mock:
>>>>>>             seal(m)
       
       
    2: class _AsyncIterator:
    1:     """
           Wraps an iterator in an asynchronous iterator.
           """
    1:     def __init__(self, iterator):
>>>>>>         self.iterator = iterator
>>>>>>         code_mock = NonCallableMock(spec_set=CodeType)
>>>>>>         code_mock.co_flags = inspect.CO_ITERABLE_COROUTINE
>>>>>>         self.__dict__['__code__'] = code_mock
       
    1:     async def __anext__(self):
>>>>>>         try:
>>>>>>             return next(self.iterator)
>>>>>>         except StopIteration:
>>>>>>             pass
>>>>>>         raise StopAsyncIteration
