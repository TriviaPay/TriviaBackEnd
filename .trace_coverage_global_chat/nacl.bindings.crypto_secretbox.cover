       # Copyright 2013 Donald Stufft and individual contributors
       #
       # Licensed under the Apache License, Version 2.0 (the "License");
       # you may not use this file except in compliance with the License.
       # You may obtain a copy of the License at
       #
       # http://www.apache.org/licenses/LICENSE-2.0
       #
       # Unless required by applicable law or agreed to in writing, software
       # distributed under the License is distributed on an "AS IS" BASIS,
       # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       # See the License for the specific language governing permissions and
       # limitations under the License.
       
       
    1: from nacl import exceptions as exc
    1: from nacl._sodium import ffi, lib
    1: from nacl.exceptions import ensure
       
       
    1: crypto_secretbox_KEYBYTES: int = lib.crypto_secretbox_keybytes()
    1: crypto_secretbox_NONCEBYTES: int = lib.crypto_secretbox_noncebytes()
    1: crypto_secretbox_ZEROBYTES: int = lib.crypto_secretbox_zerobytes()
    1: crypto_secretbox_BOXZEROBYTES: int = lib.crypto_secretbox_boxzerobytes()
    1: crypto_secretbox_MACBYTES: int = lib.crypto_secretbox_macbytes()
    1: crypto_secretbox_MESSAGEBYTES_MAX: int = (
    1:     lib.crypto_secretbox_messagebytes_max()
       )
       
       
    1: def crypto_secretbox(message: bytes, nonce: bytes, key: bytes) -> bytes:
           """
           Encrypts and returns the message ``message`` with the secret ``key`` and
           the nonce ``nonce``.
       
           :param message: bytes
           :param nonce: bytes
           :param key: bytes
           :rtype: bytes
           """
>>>>>>     if len(key) != crypto_secretbox_KEYBYTES:
>>>>>>         raise exc.ValueError("Invalid key")
       
>>>>>>     if len(nonce) != crypto_secretbox_NONCEBYTES:
>>>>>>         raise exc.ValueError("Invalid nonce")
       
>>>>>>     padded = b"\x00" * crypto_secretbox_ZEROBYTES + message
>>>>>>     ciphertext = ffi.new("unsigned char[]", len(padded))
       
>>>>>>     res = lib.crypto_secretbox(ciphertext, padded, len(padded), nonce, key)
>>>>>>     ensure(res == 0, "Encryption failed", raising=exc.CryptoError)
       
>>>>>>     ciphertext = ffi.buffer(ciphertext, len(padded))
>>>>>>     return ciphertext[crypto_secretbox_BOXZEROBYTES:]
       
       
    1: def crypto_secretbox_open(
    1:     ciphertext: bytes, nonce: bytes, key: bytes
    1: ) -> bytes:
           """
           Decrypt and returns the encrypted message ``ciphertext`` with the secret
           ``key`` and the nonce ``nonce``.
       
           :param ciphertext: bytes
           :param nonce: bytes
           :param key: bytes
           :rtype: bytes
           """
>>>>>>     if len(key) != crypto_secretbox_KEYBYTES:
>>>>>>         raise exc.ValueError("Invalid key")
       
>>>>>>     if len(nonce) != crypto_secretbox_NONCEBYTES:
>>>>>>         raise exc.ValueError("Invalid nonce")
       
>>>>>>     padded = b"\x00" * crypto_secretbox_BOXZEROBYTES + ciphertext
>>>>>>     plaintext = ffi.new("unsigned char[]", len(padded))
       
>>>>>>     res = lib.crypto_secretbox_open(plaintext, padded, len(padded), nonce, key)
>>>>>>     ensure(
>>>>>>         res == 0,
>>>>>>         "Decryption failed. Ciphertext failed verification",
>>>>>>         raising=exc.CryptoError,
           )
       
>>>>>>     plaintext = ffi.buffer(plaintext, len(padded))
>>>>>>     return plaintext[crypto_secretbox_ZEROBYTES:]
       
       
    1: def crypto_secretbox_easy(message: bytes, nonce: bytes, key: bytes) -> bytes:
           """
           Encrypts and returns the message ``message`` with the secret ``key`` and
           the nonce ``nonce``.
       
           :param message: bytes
           :param nonce: bytes
           :param key: bytes
           :rtype: bytes
           """
>>>>>>     if len(key) != crypto_secretbox_KEYBYTES:
>>>>>>         raise exc.ValueError("Invalid key")
       
>>>>>>     if len(nonce) != crypto_secretbox_NONCEBYTES:
>>>>>>         raise exc.ValueError("Invalid nonce")
       
>>>>>>     _mlen = len(message)
>>>>>>     _clen = crypto_secretbox_MACBYTES + _mlen
       
>>>>>>     ciphertext = ffi.new("unsigned char[]", _clen)
       
>>>>>>     res = lib.crypto_secretbox_easy(ciphertext, message, _mlen, nonce, key)
>>>>>>     ensure(res == 0, "Encryption failed", raising=exc.CryptoError)
       
>>>>>>     ciphertext = ffi.buffer(ciphertext, _clen)
>>>>>>     return ciphertext[:]
       
       
    1: def crypto_secretbox_open_easy(
    1:     ciphertext: bytes, nonce: bytes, key: bytes
    1: ) -> bytes:
           """
           Decrypt and returns the encrypted message ``ciphertext`` with the secret
           ``key`` and the nonce ``nonce``.
       
           :param ciphertext: bytes
           :param nonce: bytes
           :param key: bytes
           :rtype: bytes
           """
>>>>>>     if len(key) != crypto_secretbox_KEYBYTES:
>>>>>>         raise exc.ValueError("Invalid key")
       
>>>>>>     if len(nonce) != crypto_secretbox_NONCEBYTES:
>>>>>>         raise exc.ValueError("Invalid nonce")
       
>>>>>>     _clen = len(ciphertext)
       
>>>>>>     ensure(
>>>>>>         _clen >= crypto_secretbox_MACBYTES,
>>>>>>         "Input ciphertext must be at least {} long".format(
>>>>>>             crypto_secretbox_MACBYTES
               ),
>>>>>>         raising=exc.TypeError,
           )
       
>>>>>>     _mlen = _clen - crypto_secretbox_MACBYTES
       
>>>>>>     plaintext = ffi.new("unsigned char[]", max(1, _mlen))
       
>>>>>>     res = lib.crypto_secretbox_open_easy(
>>>>>>         plaintext, ciphertext, _clen, nonce, key
           )
>>>>>>     ensure(
>>>>>>         res == 0,
>>>>>>         "Decryption failed. Ciphertext failed verification",
>>>>>>         raising=exc.CryptoError,
           )
       
>>>>>>     plaintext = ffi.buffer(plaintext, _mlen)
>>>>>>     return plaintext[:]
