    1: import datetime
    1: import enum
    1: import logging
    1: import typing
    1: import warnings
    1: from contextlib import asynccontextmanager, contextmanager
    1: from types import TracebackType
       
    1: from .__version__ import __version__
    1: from ._auth import Auth, BasicAuth, FunctionAuth
    1: from ._config import (
           DEFAULT_LIMITS,
           DEFAULT_MAX_REDIRECTS,
           DEFAULT_TIMEOUT_CONFIG,
           Limits,
           Proxy,
           Timeout,
       )
    1: from ._decoders import SUPPORTED_DECODERS
    1: from ._exceptions import (
           InvalidURL,
           RemoteProtocolError,
           TooManyRedirects,
           request_context,
       )
    1: from ._models import Cookies, Headers, Request, Response
    1: from ._status_codes import codes
    1: from ._transports.asgi import ASGITransport
    1: from ._transports.base import AsyncBaseTransport, BaseTransport
    1: from ._transports.default import AsyncHTTPTransport, HTTPTransport
    1: from ._transports.wsgi import WSGITransport
    1: from ._types import (
           AsyncByteStream,
           AuthTypes,
           CertTypes,
           CookieTypes,
           HeaderTypes,
           ProxiesTypes,
           QueryParamTypes,
           RequestContent,
           RequestData,
           RequestExtensions,
           RequestFiles,
           SyncByteStream,
           TimeoutTypes,
           URLTypes,
           VerifyTypes,
       )
    1: from ._urls import URL, QueryParams
    1: from ._utils import (
           Timer,
           URLPattern,
           get_environment_proxies,
           is_https_redirect,
           same_origin,
       )
       
       # The type annotation for @classmethod and context managers here follows PEP 484
       # https://www.python.org/dev/peps/pep-0484/#annotating-instance-and-class-methods
    1: T = typing.TypeVar("T", bound="Client")
    1: U = typing.TypeVar("U", bound="AsyncClient")
       
       
    2: class UseClientDefault:
    1:     """
           For some parameters such as `auth=...` and `timeout=...` we need to be able
           to indicate the default "unset" state, in a way that is distinctly different
           to using `None`.
       
           The default "unset" state indicates that whatever default is set on the
           client should be used. This is different to setting `None`, which
           explicitly disables the parameter, possibly overriding a client default.
       
           For example we use `timeout=USE_CLIENT_DEFAULT` in the `request()` signature.
           Omitting the `timeout` parameter will send a request using whatever default
           timeout has been configured on the client. Including `timeout=None` will
           ensure no timeout is used.
       
           Note that user code shouldn't need to use the `USE_CLIENT_DEFAULT` constant,
           but it is used internally when a parameter is not included.
           """
       
       
    1: USE_CLIENT_DEFAULT = UseClientDefault()
       
       
    1: logger = logging.getLogger("httpx")
       
    1: USER_AGENT = f"python-httpx/{__version__}"
    2: ACCEPT_ENCODING = ", ".join(
    5:     [key for key in SUPPORTED_DECODERS.keys() if key != "identity"]
       )
       
       
    2: class ClientState(enum.Enum):
           # UNOPENED:
           #   The client has been instantiated, but has not been used to send a request,
           #   or been opened by entering the context of a `with` block.
    1:     UNOPENED = 1
           # OPENED:
           #   The client has either sent a request, or is within a `with` block.
    1:     OPENED = 2
           # CLOSED:
           #   The client has either exited the `with` block, or `close()` has
           #   been called explicitly.
    1:     CLOSED = 3
       
       
    2: class BoundSyncStream(SyncByteStream):
    1:     """
           A byte stream that is bound to a given response instance, and that
           ensures the `response.elapsed` is set once the response is closed.
           """
       
    1:     def __init__(
    1:         self, stream: SyncByteStream, response: Response, timer: Timer
    1:     ) -> None:
   15:         self._stream = stream
   15:         self._response = response
   15:         self._timer = timer
       
    1:     def __iter__(self) -> typing.Iterator[bytes]:
   30:         for chunk in self._stream:
   15:             yield chunk
       
    1:     def close(self) -> None:
   15:         seconds = self._timer.sync_elapsed()
   15:         self._response.elapsed = datetime.timedelta(seconds=seconds)
   15:         self._stream.close()
       
       
    2: class BoundAsyncStream(AsyncByteStream):
    1:     """
           An async byte stream that is bound to a given response instance, and that
           ensures the `response.elapsed` is set once the response is closed.
           """
       
    1:     def __init__(
    1:         self, stream: AsyncByteStream, response: Response, timer: Timer
    1:     ) -> None:
>>>>>>         self._stream = stream
>>>>>>         self._response = response
>>>>>>         self._timer = timer
       
    1:     async def __aiter__(self) -> typing.AsyncIterator[bytes]:
>>>>>>         async for chunk in self._stream:
>>>>>>             yield chunk
       
    1:     async def aclose(self) -> None:
>>>>>>         seconds = await self._timer.async_elapsed()
>>>>>>         self._response.elapsed = datetime.timedelta(seconds=seconds)
>>>>>>         await self._stream.aclose()
       
       
    1: EventHook = typing.Callable[..., typing.Any]
       
       
    2: class BaseClient:
    2:     def __init__(
               self,
               *,
    2:         auth: typing.Optional[AuthTypes] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,
    2:         follow_redirects: bool = False,
    2:         max_redirects: int = DEFAULT_MAX_REDIRECTS,
    2:         event_hooks: typing.Optional[
    1:             typing.Mapping[str, typing.List[EventHook]]
    1:         ] = None,
    2:         base_url: URLTypes = "",
    2:         trust_env: bool = True,
    2:         default_encoding: typing.Union[str, typing.Callable[[bytes], str]] = "utf-8",
           ):
   13:         event_hooks = {} if event_hooks is None else event_hooks
       
   13:         self._base_url = self._enforce_trailing_slash(URL(base_url))
       
   13:         self._auth = self._build_auth(auth)
   13:         self._params = QueryParams(params)
   13:         self.headers = Headers(headers)
   13:         self._cookies = Cookies(cookies)
   13:         self._timeout = Timeout(timeout)
   13:         self.follow_redirects = follow_redirects
   13:         self.max_redirects = max_redirects
   13:         self._event_hooks = {
   13:             "request": list(event_hooks.get("request", [])),
   13:             "response": list(event_hooks.get("response", [])),
               }
   13:         self._trust_env = trust_env
   13:         self._default_encoding = default_encoding
   13:         self._state = ClientState.UNOPENED
       
    1:     @property
    1:     def is_closed(self) -> bool:
               """
               Check if the client being closed
               """
>>>>>>         return self._state == ClientState.CLOSED
       
    1:     @property
    1:     def trust_env(self) -> bool:
>>>>>>         return self._trust_env
       
    1:     def _enforce_trailing_slash(self, url: URL) -> URL:
   13:         if url.raw_path.endswith(b"/"):
   13:             return url
>>>>>>         return url.copy_with(raw_path=url.raw_path + b"/")
       
    1:     def _get_proxy_map(
    1:         self, proxies: typing.Optional[ProxiesTypes], allow_env_proxies: bool
    1:     ) -> typing.Dict[str, typing.Optional[Proxy]]:
   13:         if proxies is None:
   13:             if allow_env_proxies:
>>>>>>                 return {
>>>>>>                     key: None if url is None else Proxy(url=url)
>>>>>>                     for key, url in get_environment_proxies().items()
                       }
   13:             return {}
>>>>>>         if isinstance(proxies, dict):
>>>>>>             new_proxies = {}
>>>>>>             for key, value in proxies.items():
>>>>>>                 proxy = Proxy(url=value) if isinstance(value, (str, URL)) else value
>>>>>>                 new_proxies[str(key)] = proxy
>>>>>>             return new_proxies
               else:
>>>>>>             proxy = Proxy(url=proxies) if isinstance(proxies, (str, URL)) else proxies
>>>>>>             return {"all://": proxy}
       
    1:     @property
    1:     def timeout(self) -> Timeout:
   15:         return self._timeout
       
    1:     @timeout.setter
    1:     def timeout(self, timeout: TimeoutTypes) -> None:
>>>>>>         self._timeout = Timeout(timeout)
       
    1:     @property
    1:     def event_hooks(self) -> typing.Dict[str, typing.List[EventHook]]:
>>>>>>         return self._event_hooks
       
    1:     @event_hooks.setter
    1:     def event_hooks(
    1:         self, event_hooks: typing.Dict[str, typing.List[EventHook]]
    1:     ) -> None:
>>>>>>         self._event_hooks = {
>>>>>>             "request": list(event_hooks.get("request", [])),
>>>>>>             "response": list(event_hooks.get("response", [])),
               }
       
    1:     @property
    1:     def auth(self) -> typing.Optional[Auth]:
               """
               Authentication class used when none is passed at the request-level.
       
               See also [Authentication][0].
       
               [0]: /quickstart/#authentication
               """
>>>>>>         return self._auth
       
    1:     @auth.setter
    1:     def auth(self, auth: AuthTypes) -> None:
>>>>>>         self._auth = self._build_auth(auth)
       
    1:     @property
    1:     def base_url(self) -> URL:
               """
               Base URL to use when sending requests with relative URLs.
               """
   30:         return self._base_url
       
    1:     @base_url.setter
    1:     def base_url(self, url: URLTypes) -> None:
>>>>>>         self._base_url = self._enforce_trailing_slash(URL(url))
       
    1:     @property
    1:     def headers(self) -> Headers:
               """
               HTTP headers to include when sending requests.
               """
   15:         return self._headers
       
    1:     @headers.setter
    1:     def headers(self, headers: HeaderTypes) -> None:
   26:         client_headers = Headers(
   13:             {
   13:                 b"Accept": b"*/*",
   13:                 b"Accept-Encoding": ACCEPT_ENCODING.encode("ascii"),
   13:                 b"Connection": b"keep-alive",
   13:                 b"User-Agent": USER_AGENT.encode("ascii"),
                   }
               )
   13:         client_headers.update(headers)
   13:         self._headers = client_headers
       
    1:     @property
    1:     def cookies(self) -> Cookies:
               """
               Cookie values to include when sending requests.
               """
   30:         return self._cookies
       
    1:     @cookies.setter
    1:     def cookies(self, cookies: CookieTypes) -> None:
>>>>>>         self._cookies = Cookies(cookies)
       
    1:     @property
    1:     def params(self) -> QueryParams:
               """
               Query parameters to include in the URL when sending requests.
               """
   15:         return self._params
       
    1:     @params.setter
    1:     def params(self, params: QueryParamTypes) -> None:
>>>>>>         self._params = QueryParams(params)
       
    2:     def build_request(
               self,
    1:         method: str,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Request:
               """
               Build and return a request instance.
       
               * The `params`, `headers` and `cookies` arguments
               are merged with any values set on the client.
               * The `url` argument is merged with any `base_url` set on the client.
       
               See also: [Request instances][0]
       
               [0]: /advanced/#request-instances
               """
   15:         url = self._merge_url(url)
   15:         headers = self._merge_headers(headers)
   15:         cookies = self._merge_cookies(cookies)
   15:         params = self._merge_queryparams(params)
   15:         extensions = {} if extensions is None else extensions
   15:         if "timeout" not in extensions:
   15:             timeout = (
   15:                 self.timeout
   15:                 if isinstance(timeout, UseClientDefault)
>>>>>>                 else Timeout(timeout)
                   )
   15:             extensions = dict(**extensions, timeout=timeout.as_dict())
   30:         return Request(
   15:             method,
   15:             url,
   15:             content=content,
   15:             data=data,
   15:             files=files,
   15:             json=json,
   15:             params=params,
   15:             headers=headers,
   15:             cookies=cookies,
   15:             extensions=extensions,
               )
       
    1:     def _merge_url(self, url: URLTypes) -> URL:
               """
               Merge a URL argument together with any 'base_url' on the client,
               to create the URL used for the outgoing request.
               """
   30:         merge_url = URL(url)
   30:         if merge_url.is_relative_url:
                   # To merge URLs we always append to the base URL. To get this
                   # behaviour correct we always ensure the base URL ends in a '/'
                   # separator, and strip any leading '/' from the merge URL.
                   #
                   # So, eg...
                   #
                   # >>> client = Client(base_url="https://www.example.com/subpath")
                   # >>> client.base_url
                   # URL('https://www.example.com/subpath/')
                   # >>> client.build_request("GET", "/path").url
                   # URL('https://www.example.com/subpath/path')
   15:             merge_raw_path = self.base_url.raw_path + merge_url.raw_path.lstrip(b"/")
   15:             return self.base_url.copy_with(raw_path=merge_raw_path)
   15:         return merge_url
       
    2:     def _merge_cookies(
    1:         self, cookies: typing.Optional[CookieTypes] = None
    1:     ) -> typing.Optional[CookieTypes]:
               """
               Merge a cookies argument together with any cookies on the client,
               to create the cookies used for the outgoing request.
               """
   15:         if cookies or self.cookies:
>>>>>>             merged_cookies = Cookies(self.cookies)
>>>>>>             merged_cookies.update(cookies)
>>>>>>             return merged_cookies
   15:         return cookies
       
    2:     def _merge_headers(
    1:         self, headers: typing.Optional[HeaderTypes] = None
    1:     ) -> typing.Optional[HeaderTypes]:
               """
               Merge a headers argument together with any headers on the client,
               to create the headers used for the outgoing request.
               """
   15:         merged_headers = Headers(self.headers)
   15:         merged_headers.update(headers)
   15:         return merged_headers
       
    2:     def _merge_queryparams(
    1:         self, params: typing.Optional[QueryParamTypes] = None
    1:     ) -> typing.Optional[QueryParamTypes]:
               """
               Merge a queryparams argument together with any queryparams on the client,
               to create the queryparams used for the outgoing request.
               """
   15:         if params or self.params:
>>>>>>             merged_queryparams = QueryParams(self.params)
>>>>>>             return merged_queryparams.merge(params)
   15:         return params
       
    1:     def _build_auth(self, auth: typing.Optional[AuthTypes]) -> typing.Optional[Auth]:
   13:         if auth is None:
   13:             return None
>>>>>>         elif isinstance(auth, tuple):
>>>>>>             return BasicAuth(username=auth[0], password=auth[1])
>>>>>>         elif isinstance(auth, Auth):
>>>>>>             return auth
>>>>>>         elif callable(auth):
>>>>>>             return FunctionAuth(func=auth)
               else:
>>>>>>             raise TypeError(f'Invalid "auth" argument: {auth!r}')
       
    2:     def _build_request_auth(
               self,
    1:         request: Request,
    2:         auth: typing.Union[AuthTypes, UseClientDefault, None] = USE_CLIENT_DEFAULT,
    1:     ) -> Auth:
   15:         auth = (
   15:             self._auth if isinstance(auth, UseClientDefault) else self._build_auth(auth)
               )
       
   15:         if auth is not None:
>>>>>>             return auth
       
   15:         username, password = request.url.username, request.url.password
   15:         if username or password:
>>>>>>             return BasicAuth(username=username, password=password)
       
   15:         return Auth()
       
    1:     def _build_redirect_request(self, request: Request, response: Response) -> Request:
               """
               Given a request and a redirect response, return a new request that
               should be used to effect the redirect.
               """
>>>>>>         method = self._redirect_method(request, response)
>>>>>>         url = self._redirect_url(request, response)
>>>>>>         headers = self._redirect_headers(request, url, method)
>>>>>>         stream = self._redirect_stream(request, method)
>>>>>>         cookies = Cookies(self.cookies)
>>>>>>         return Request(
>>>>>>             method=method,
>>>>>>             url=url,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             stream=stream,
>>>>>>             extensions=request.extensions,
               )
       
    1:     def _redirect_method(self, request: Request, response: Response) -> str:
               """
               When being redirected we may want to change the method of the request
               based on certain specs or browser behavior.
               """
>>>>>>         method = request.method
       
               # https://tools.ietf.org/html/rfc7231#section-6.4.4
>>>>>>         if response.status_code == codes.SEE_OTHER and method != "HEAD":
>>>>>>             method = "GET"
       
               # Do what the browsers do, despite standards...
               # Turn 302s into GETs.
>>>>>>         if response.status_code == codes.FOUND and method != "HEAD":
>>>>>>             method = "GET"
       
               # If a POST is responded to with a 301, turn it into a GET.
               # This bizarre behaviour is explained in 'requests' issue 1704.
>>>>>>         if response.status_code == codes.MOVED_PERMANENTLY and method == "POST":
>>>>>>             method = "GET"
       
>>>>>>         return method
       
    1:     def _redirect_url(self, request: Request, response: Response) -> URL:
               """
               Return the URL for the redirect to follow.
               """
>>>>>>         location = response.headers["Location"]
       
>>>>>>         try:
>>>>>>             url = URL(location)
>>>>>>         except InvalidURL as exc:
>>>>>>             raise RemoteProtocolError(
>>>>>>                 f"Invalid URL in location header: {exc}.", request=request
>>>>>>             ) from None
       
               # Handle malformed 'Location' headers that are "absolute" form, have no host.
               # See: https://github.com/encode/httpx/issues/771
>>>>>>         if url.scheme and not url.host:
>>>>>>             url = url.copy_with(host=request.url.host)
       
               # Facilitate relative 'Location' headers, as allowed by RFC 7231.
               # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')
>>>>>>         if url.is_relative_url:
>>>>>>             url = request.url.join(url)
       
               # Attach previous fragment if needed (RFC 7231 7.1.2)
>>>>>>         if request.url.fragment and not url.fragment:
>>>>>>             url = url.copy_with(fragment=request.url.fragment)
       
>>>>>>         return url
       
    1:     def _redirect_headers(self, request: Request, url: URL, method: str) -> Headers:
               """
               Return the headers that should be used for the redirect request.
               """
>>>>>>         headers = Headers(request.headers)
       
>>>>>>         if not same_origin(url, request.url):
>>>>>>             if not is_https_redirect(request.url, url):
                       # Strip Authorization headers when responses are redirected
                       # away from the origin. (Except for direct HTTP to HTTPS redirects.)
>>>>>>                 headers.pop("Authorization", None)
       
                   # Update the Host header.
>>>>>>             headers["Host"] = url.netloc.decode("ascii")
       
>>>>>>         if method != request.method and method == "GET":
                   # If we've switch to a 'GET' request, then strip any headers which
                   # are only relevant to the request body.
>>>>>>             headers.pop("Content-Length", None)
>>>>>>             headers.pop("Transfer-Encoding", None)
       
               # We should use the client cookie store to determine any cookie header,
               # rather than whatever was on the original outgoing request.
>>>>>>         headers.pop("Cookie", None)
       
>>>>>>         return headers
       
    1:     def _redirect_stream(
    1:         self, request: Request, method: str
    1:     ) -> typing.Optional[typing.Union[SyncByteStream, AsyncByteStream]]:
               """
               Return the body that should be used for the redirect request.
               """
>>>>>>         if method != request.method and method == "GET":
>>>>>>             return None
       
>>>>>>         return request.stream
       
       
    2: class Client(BaseClient):
    1:     """
           An HTTP client, with connection pooling, HTTP/2, redirects, cookie persistence, etc.
       
           It can be shared between threads.
       
           Usage:
       
           ```python
           >>> client = httpx.Client()
           >>> response = client.get('https://example.org')
           ```
       
           **Parameters:**
       
           * **auth** - *(optional)* An authentication class to use when sending
           requests.
           * **params** - *(optional)* Query parameters to include in request URLs, as
           a string, dictionary, or sequence of two-tuples.
           * **headers** - *(optional)* Dictionary of HTTP headers to include when
           sending requests.
           * **cookies** - *(optional)* Dictionary of Cookie items to include when
           sending requests.
           * **verify** - *(optional)* SSL certificates (a.k.a CA bundle) used to
           verify the identity of requested hosts. Either `True` (default CA bundle),
           a path to an SSL certificate file, an `ssl.SSLContext`, or `False`
           (which will disable verification).
           * **cert** - *(optional)* An SSL certificate used by the requested host
           to authenticate the client. Either a path to an SSL certificate file, or
           two-tuple of (certificate file, key file), or a three-tuple of (certificate
           file, key file, password).
           * **proxies** - *(optional)* A dictionary mapping proxy keys to proxy
           URLs.
           * **timeout** - *(optional)* The timeout configuration to use when sending
           requests.
           * **limits** - *(optional)* The limits configuration to use.
           * **max_redirects** - *(optional)* The maximum number of redirect responses
           that should be followed.
           * **base_url** - *(optional)* A URL to use as the base when building
           request URLs.
           * **transport** - *(optional)* A transport class to use for sending requests
           over the network.
           * **app** - *(optional)* An WSGI application to send requests to,
           rather than sending actual network requests.
           * **trust_env** - *(optional)* Enables or disables usage of environment
           variables for configuration.
           * **default_encoding** - *(optional)* The default encoding to use for decoding
           response text, if no charset information is included in a response Content-Type
           header. Set to a callable for automatic character set detection. Default: "utf-8".
           """
       
    2:     def __init__(
               self,
               *,
    2:         auth: typing.Optional[AuthTypes] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         verify: VerifyTypes = True,
    2:         cert: typing.Optional[CertTypes] = None,
    2:         http1: bool = True,
    2:         http2: bool = False,
    2:         proxies: typing.Optional[ProxiesTypes] = None,
    2:         mounts: typing.Optional[typing.Mapping[str, BaseTransport]] = None,
    2:         timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,
    2:         follow_redirects: bool = False,
    2:         limits: Limits = DEFAULT_LIMITS,
    2:         max_redirects: int = DEFAULT_MAX_REDIRECTS,
    2:         event_hooks: typing.Optional[
    1:             typing.Mapping[str, typing.List[EventHook]]
    1:         ] = None,
    2:         base_url: URLTypes = "",
    2:         transport: typing.Optional[BaseTransport] = None,
    2:         app: typing.Optional[typing.Callable[..., typing.Any]] = None,
    2:         trust_env: bool = True,
    2:         default_encoding: typing.Union[str, typing.Callable[[bytes], str]] = "utf-8",
           ):
   26:         super().__init__(
   13:             auth=auth,
   13:             params=params,
   13:             headers=headers,
   13:             cookies=cookies,
   13:             timeout=timeout,
   13:             follow_redirects=follow_redirects,
   13:             max_redirects=max_redirects,
   13:             event_hooks=event_hooks,
   13:             base_url=base_url,
   13:             trust_env=trust_env,
   13:             default_encoding=default_encoding,
               )
       
   13:         if http2:
>>>>>>             try:
>>>>>>                 import h2  # noqa
>>>>>>             except ImportError:  # pragma: no cover
>>>>>>                 raise ImportError(
>>>>>>                     "Using http2=True, but the 'h2' package is not installed. "
                           "Make sure to install httpx using `pip install httpx[http2]`."
>>>>>>                 ) from None
       
   13:         allow_env_proxies = trust_env and app is None and transport is None
   13:         proxy_map = self._get_proxy_map(proxies, allow_env_proxies)
       
   26:         self._transport = self._init_transport(
   13:             verify=verify,
   13:             cert=cert,
   13:             http1=http1,
   13:             http2=http2,
   13:             limits=limits,
   13:             transport=transport,
   13:             app=app,
   13:             trust_env=trust_env,
               )
   39:         self._mounts: typing.Dict[URLPattern, typing.Optional[BaseTransport]] = {
>>>>>>             URLPattern(key): None
>>>>>>             if proxy is None
>>>>>>             else self._init_proxy_transport(
>>>>>>                 proxy,
>>>>>>                 verify=verify,
>>>>>>                 cert=cert,
>>>>>>                 http1=http1,
>>>>>>                 http2=http2,
>>>>>>                 limits=limits,
>>>>>>                 trust_env=trust_env,
                   )
   13:             for key, proxy in proxy_map.items()
               }
   13:         if mounts is not None:
>>>>>>             self._mounts.update(
>>>>>>                 {URLPattern(key): transport for key, transport in mounts.items()}
                   )
       
   13:         self._mounts = dict(sorted(self._mounts.items()))
       
    2:     def _init_transport(
               self,
    2:         verify: VerifyTypes = True,
    2:         cert: typing.Optional[CertTypes] = None,
    2:         http1: bool = True,
    2:         http2: bool = False,
    2:         limits: Limits = DEFAULT_LIMITS,
    2:         transport: typing.Optional[BaseTransport] = None,
    2:         app: typing.Optional[typing.Callable[..., typing.Any]] = None,
    2:         trust_env: bool = True,
    1:     ) -> BaseTransport:
   13:         if transport is not None:
   13:             return transport
       
>>>>>>         if app is not None:
>>>>>>             return WSGITransport(app=app)
       
>>>>>>         return HTTPTransport(
>>>>>>             verify=verify,
>>>>>>             cert=cert,
>>>>>>             http1=http1,
>>>>>>             http2=http2,
>>>>>>             limits=limits,
>>>>>>             trust_env=trust_env,
               )
       
    2:     def _init_proxy_transport(
               self,
    1:         proxy: Proxy,
    2:         verify: VerifyTypes = True,
    2:         cert: typing.Optional[CertTypes] = None,
    2:         http1: bool = True,
    2:         http2: bool = False,
    2:         limits: Limits = DEFAULT_LIMITS,
    2:         trust_env: bool = True,
    1:     ) -> BaseTransport:
>>>>>>         return HTTPTransport(
>>>>>>             verify=verify,
>>>>>>             cert=cert,
>>>>>>             http1=http1,
>>>>>>             http2=http2,
>>>>>>             limits=limits,
>>>>>>             trust_env=trust_env,
>>>>>>             proxy=proxy,
               )
       
    1:     def _transport_for_url(self, url: URL) -> BaseTransport:
               """
               Returns the transport instance that should be used for a given URL.
               This will either be the standard connection pool, or a proxy.
               """
   15:         for pattern, transport in self._mounts.items():
>>>>>>             if pattern.matches(url):
>>>>>>                 return self._transport if transport is None else transport
       
   15:         return self._transport
       
    2:     def request(
               self,
    1:         method: str,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault, None] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Build and send a request.
       
               Equivalent to:
       
               ```python
               request = client.build_request(...)
               response = client.send(request, ...)
               ```
       
               See `Client.build_request()`, `Client.send()` and
               [Merging of configuration][0] for how the various parameters
               are merged with client-level configuration.
       
               [0]: /advanced/#merging-of-configuration
               """
   15:         if cookies is not None:
>>>>>>             message = (
>>>>>>                 "Setting per-request cookies=<...> is being deprecated, because "
                       "the expected behaviour on cookie persistence is ambiguous. Set "
                       "cookies directly on the client instance instead."
                   )
>>>>>>             warnings.warn(message, DeprecationWarning)
       
   30:         request = self.build_request(
   15:             method=method,
   15:             url=url,
   15:             content=content,
   15:             data=data,
   15:             files=files,
   15:             json=json,
   15:             params=params,
   15:             headers=headers,
   15:             cookies=cookies,
   15:             timeout=timeout,
   15:             extensions=extensions,
               )
   15:         return self.send(request, auth=auth, follow_redirects=follow_redirects)
       
    1:     @contextmanager
    2:     def stream(
               self,
    1:         method: str,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault, None] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> typing.Iterator[Response]:
               """
               Alternative to `httpx.request()` that streams the response body
               instead of loading it into memory at once.
       
               **Parameters**: See `httpx.request`.
       
               See also: [Streaming Responses][0]
       
               [0]: /quickstart#streaming-responses
               """
>>>>>>         request = self.build_request(
>>>>>>             method=method,
>>>>>>             url=url,
>>>>>>             content=content,
>>>>>>             data=data,
>>>>>>             files=files,
>>>>>>             json=json,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
>>>>>>         response = self.send(
>>>>>>             request=request,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             stream=True,
               )
>>>>>>         try:
>>>>>>             yield response
               finally:
>>>>>>             response.close()
       
    2:     def send(
               self,
    1:         request: Request,
               *,
    2:         stream: bool = False,
    2:         auth: typing.Union[AuthTypes, UseClientDefault, None] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    1:     ) -> Response:
               """
               Send a request.
       
               The request is sent as-is, unmodified.
       
               Typically you'll want to build one with `Client.build_request()`
               so that any client-level configuration is merged into the request,
               but passing an explicit `httpx.Request()` is supported as well.
       
               See also: [Request instances][0]
       
               [0]: /advanced/#request-instances
               """
   15:         if self._state == ClientState.CLOSED:
>>>>>>             raise RuntimeError("Cannot send a request, as the client has been closed.")
       
   15:         self._state = ClientState.OPENED
   15:         follow_redirects = (
   15:             self.follow_redirects
   15:             if isinstance(follow_redirects, UseClientDefault)
>>>>>>             else follow_redirects
               )
       
   15:         auth = self._build_request_auth(request, auth)
       
   30:         response = self._send_handling_auth(
   15:             request,
   15:             auth=auth,
   15:             follow_redirects=follow_redirects,
   15:             history=[],
               )
   15:         try:
   15:             if not stream:
   15:                 response.read()
       
   15:             return response
       
>>>>>>         except BaseException as exc:
>>>>>>             response.close()
>>>>>>             raise exc
       
    1:     def _send_handling_auth(
               self,
    1:         request: Request,
    1:         auth: Auth,
    1:         follow_redirects: bool,
    1:         history: typing.List[Response],
    1:     ) -> Response:
   15:         auth_flow = auth.sync_auth_flow(request)
   15:         try:
   15:             request = next(auth_flow)
       
                   while True:
   30:                 response = self._send_handling_redirects(
   15:                     request,
   15:                     follow_redirects=follow_redirects,
   15:                     history=history,
                       )
   15:                 try:
   15:                     try:
   15:                         next_request = auth_flow.send(response)
   15:                     except StopIteration:
   30:                         return response
       
>>>>>>                     response.history = list(history)
>>>>>>                     response.read()
>>>>>>                     request = next_request
>>>>>>                     history.append(response)
       
>>>>>>                 except BaseException as exc:
>>>>>>                     response.close()
>>>>>>                     raise exc
               finally:
   15:             auth_flow.close()
       
    1:     def _send_handling_redirects(
               self,
    1:         request: Request,
    1:         follow_redirects: bool,
    1:         history: typing.List[Response],
    1:     ) -> Response:
               while True:
   15:             if len(history) > self.max_redirects:
>>>>>>                 raise TooManyRedirects(
>>>>>>                     "Exceeded maximum allowed redirects.", request=request
                       )
       
   15:             for hook in self._event_hooks["request"]:
>>>>>>                 hook(request)
       
   15:             response = self._send_single_request(request)
   15:             try:
   15:                 for hook in self._event_hooks["response"]:
>>>>>>                     hook(response)
   15:                 response.history = list(history)
       
   15:                 if not response.has_redirect_location:
   15:                     return response
       
>>>>>>                 request = self._build_redirect_request(request, response)
>>>>>>                 history = history + [response]
       
>>>>>>                 if follow_redirects:
>>>>>>                     response.read()
                       else:
>>>>>>                     response.next_request = request
>>>>>>                     return response
       
>>>>>>             except BaseException as exc:
>>>>>>                 response.close()
>>>>>>                 raise exc
       
    1:     def _send_single_request(self, request: Request) -> Response:
               """
               Sends a single request, without handling any redirections.
               """
   15:         transport = self._transport_for_url(request.url)
   15:         timer = Timer()
   15:         timer.sync_start()
       
   15:         if not isinstance(request.stream, SyncByteStream):
>>>>>>             raise RuntimeError(
>>>>>>                 "Attempted to send an async request with a sync Client instance."
                   )
       
   15:         with request_context(request=request):
   15:             response = transport.handle_request(request)
       
   15:         assert isinstance(response.stream, SyncByteStream)
       
   15:         response.request = request
   30:         response.stream = BoundSyncStream(
   15:             response.stream, response=response, timer=timer
               )
   15:         self.cookies.extract_cookies(response)
   15:         response.default_encoding = self._default_encoding
       
   30:         logger.info(
   15:             'HTTP Request: %s %s "%s %d %s"',
   15:             request.method,
   15:             request.url,
   15:             response.http_version,
   15:             response.status_code,
   15:             response.reason_phrase,
               )
       
   15:         return response
       
    2:     def get(
               self,
    1:         url: URLTypes,
               *,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `GET` request.
       
               **Parameters**: See `httpx.request`.
               """
   12:         return self.request(
    6:             "GET",
    6:             url,
    6:             params=params,
    6:             headers=headers,
    6:             cookies=cookies,
    6:             auth=auth,
    6:             follow_redirects=follow_redirects,
    6:             timeout=timeout,
    6:             extensions=extensions,
               )
       
    2:     def options(
               self,
    1:         url: URLTypes,
               *,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send an `OPTIONS` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return self.request(
>>>>>>             "OPTIONS",
>>>>>>             url,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    2:     def head(
               self,
    1:         url: URLTypes,
               *,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `HEAD` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return self.request(
>>>>>>             "HEAD",
>>>>>>             url,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    2:     def post(
               self,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `POST` request.
       
               **Parameters**: See `httpx.request`.
               """
   18:         return self.request(
    9:             "POST",
    9:             url,
    9:             content=content,
    9:             data=data,
    9:             files=files,
    9:             json=json,
    9:             params=params,
    9:             headers=headers,
    9:             cookies=cookies,
    9:             auth=auth,
    9:             follow_redirects=follow_redirects,
    9:             timeout=timeout,
    9:             extensions=extensions,
               )
       
    2:     def put(
               self,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `PUT` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return self.request(
>>>>>>             "PUT",
>>>>>>             url,
>>>>>>             content=content,
>>>>>>             data=data,
>>>>>>             files=files,
>>>>>>             json=json,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    2:     def patch(
               self,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `PATCH` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return self.request(
>>>>>>             "PATCH",
>>>>>>             url,
>>>>>>             content=content,
>>>>>>             data=data,
>>>>>>             files=files,
>>>>>>             json=json,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    2:     def delete(
               self,
    1:         url: URLTypes,
               *,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `DELETE` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return self.request(
>>>>>>             "DELETE",
>>>>>>             url,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    1:     def close(self) -> None:
               """
               Close transport and proxies.
               """
>>>>>>         if self._state != ClientState.CLOSED:
>>>>>>             self._state = ClientState.CLOSED
       
>>>>>>             self._transport.close()
>>>>>>             for transport in self._mounts.values():
>>>>>>                 if transport is not None:
>>>>>>                     transport.close()
       
    1:     def __enter__(self: T) -> T:
>>>>>>         if self._state != ClientState.UNOPENED:
>>>>>>             msg = {
>>>>>>                 ClientState.OPENED: "Cannot open a client instance more than once.",
>>>>>>                 ClientState.CLOSED: "Cannot reopen a client instance, once it has been closed.",
>>>>>>             }[self._state]
>>>>>>             raise RuntimeError(msg)
       
>>>>>>         self._state = ClientState.OPENED
       
>>>>>>         self._transport.__enter__()
>>>>>>         for transport in self._mounts.values():
>>>>>>             if transport is not None:
>>>>>>                 transport.__enter__()
>>>>>>         return self
       
    2:     def __exit__(
               self,
    1:         exc_type: typing.Optional[typing.Type[BaseException]] = None,
    1:         exc_value: typing.Optional[BaseException] = None,
    1:         traceback: typing.Optional[TracebackType] = None,
    1:     ) -> None:
>>>>>>         self._state = ClientState.CLOSED
       
>>>>>>         self._transport.__exit__(exc_type, exc_value, traceback)
>>>>>>         for transport in self._mounts.values():
>>>>>>             if transport is not None:
>>>>>>                 transport.__exit__(exc_type, exc_value, traceback)
       
       
    2: class AsyncClient(BaseClient):
    1:     """
           An asynchronous HTTP client, with connection pooling, HTTP/2, redirects,
           cookie persistence, etc.
       
           Usage:
       
           ```python
           >>> async with httpx.AsyncClient() as client:
           >>>     response = await client.get('https://example.org')
           ```
       
           **Parameters:**
       
           * **auth** - *(optional)* An authentication class to use when sending
           requests.
           * **params** - *(optional)* Query parameters to include in request URLs, as
           a string, dictionary, or sequence of two-tuples.
           * **headers** - *(optional)* Dictionary of HTTP headers to include when
           sending requests.
           * **cookies** - *(optional)* Dictionary of Cookie items to include when
           sending requests.
           * **verify** - *(optional)* SSL certificates (a.k.a CA bundle) used to
           verify the identity of requested hosts. Either `True` (default CA bundle),
           a path to an SSL certificate file, an `ssl.SSLContext`, or `False`
           (which will disable verification).
           * **cert** - *(optional)* An SSL certificate used by the requested host
           to authenticate the client. Either a path to an SSL certificate file, or
           two-tuple of (certificate file, key file), or a three-tuple of (certificate
           file, key file, password).
           * **http2** - *(optional)* A boolean indicating if HTTP/2 support should be
           enabled. Defaults to `False`.
           * **proxies** - *(optional)* A dictionary mapping HTTP protocols to proxy
           URLs.
           * **timeout** - *(optional)* The timeout configuration to use when sending
           requests.
           * **limits** - *(optional)* The limits configuration to use.
           * **max_redirects** - *(optional)* The maximum number of redirect responses
           that should be followed.
           * **base_url** - *(optional)* A URL to use as the base when building
           request URLs.
           * **transport** - *(optional)* A transport class to use for sending requests
           over the network.
           * **app** - *(optional)* An ASGI application to send requests to,
           rather than sending actual network requests.
           * **trust_env** - *(optional)* Enables or disables usage of environment
           variables for configuration.
           * **default_encoding** - *(optional)* The default encoding to use for decoding
           response text, if no charset information is included in a response Content-Type
           header. Set to a callable for automatic character set detection. Default: "utf-8".
           """
       
    2:     def __init__(
               self,
               *,
    2:         auth: typing.Optional[AuthTypes] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         verify: VerifyTypes = True,
    2:         cert: typing.Optional[CertTypes] = None,
    2:         http1: bool = True,
    2:         http2: bool = False,
    2:         proxies: typing.Optional[ProxiesTypes] = None,
    2:         mounts: typing.Optional[typing.Mapping[str, AsyncBaseTransport]] = None,
    2:         timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,
    2:         follow_redirects: bool = False,
    2:         limits: Limits = DEFAULT_LIMITS,
    2:         max_redirects: int = DEFAULT_MAX_REDIRECTS,
    2:         event_hooks: typing.Optional[
    1:             typing.Mapping[str, typing.List[typing.Callable[..., typing.Any]]]
    1:         ] = None,
    2:         base_url: URLTypes = "",
    2:         transport: typing.Optional[AsyncBaseTransport] = None,
    2:         app: typing.Optional[typing.Callable[..., typing.Any]] = None,
    2:         trust_env: bool = True,
    2:         default_encoding: typing.Union[str, typing.Callable[[bytes], str]] = "utf-8",
           ):
>>>>>>         super().__init__(
>>>>>>             auth=auth,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             timeout=timeout,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             max_redirects=max_redirects,
>>>>>>             event_hooks=event_hooks,
>>>>>>             base_url=base_url,
>>>>>>             trust_env=trust_env,
>>>>>>             default_encoding=default_encoding,
               )
       
>>>>>>         if http2:
>>>>>>             try:
>>>>>>                 import h2  # noqa
>>>>>>             except ImportError:  # pragma: no cover
>>>>>>                 raise ImportError(
>>>>>>                     "Using http2=True, but the 'h2' package is not installed. "
                           "Make sure to install httpx using `pip install httpx[http2]`."
>>>>>>                 ) from None
       
>>>>>>         allow_env_proxies = trust_env and app is None and transport is None
>>>>>>         proxy_map = self._get_proxy_map(proxies, allow_env_proxies)
       
>>>>>>         self._transport = self._init_transport(
>>>>>>             verify=verify,
>>>>>>             cert=cert,
>>>>>>             http1=http1,
>>>>>>             http2=http2,
>>>>>>             limits=limits,
>>>>>>             transport=transport,
>>>>>>             app=app,
>>>>>>             trust_env=trust_env,
               )
       
>>>>>>         self._mounts: typing.Dict[URLPattern, typing.Optional[AsyncBaseTransport]] = {
>>>>>>             URLPattern(key): None
>>>>>>             if proxy is None
>>>>>>             else self._init_proxy_transport(
>>>>>>                 proxy,
>>>>>>                 verify=verify,
>>>>>>                 cert=cert,
>>>>>>                 http1=http1,
>>>>>>                 http2=http2,
>>>>>>                 limits=limits,
>>>>>>                 trust_env=trust_env,
                   )
>>>>>>             for key, proxy in proxy_map.items()
               }
>>>>>>         if mounts is not None:
>>>>>>             self._mounts.update(
>>>>>>                 {URLPattern(key): transport for key, transport in mounts.items()}
                   )
>>>>>>         self._mounts = dict(sorted(self._mounts.items()))
       
    2:     def _init_transport(
               self,
    2:         verify: VerifyTypes = True,
    2:         cert: typing.Optional[CertTypes] = None,
    2:         http1: bool = True,
    2:         http2: bool = False,
    2:         limits: Limits = DEFAULT_LIMITS,
    2:         transport: typing.Optional[AsyncBaseTransport] = None,
    2:         app: typing.Optional[typing.Callable[..., typing.Any]] = None,
    2:         trust_env: bool = True,
    1:     ) -> AsyncBaseTransport:
>>>>>>         if transport is not None:
>>>>>>             return transport
       
>>>>>>         if app is not None:
>>>>>>             return ASGITransport(app=app)
       
>>>>>>         return AsyncHTTPTransport(
>>>>>>             verify=verify,
>>>>>>             cert=cert,
>>>>>>             http1=http1,
>>>>>>             http2=http2,
>>>>>>             limits=limits,
>>>>>>             trust_env=trust_env,
               )
       
    2:     def _init_proxy_transport(
               self,
    1:         proxy: Proxy,
    2:         verify: VerifyTypes = True,
    2:         cert: typing.Optional[CertTypes] = None,
    2:         http1: bool = True,
    2:         http2: bool = False,
    2:         limits: Limits = DEFAULT_LIMITS,
    2:         trust_env: bool = True,
    1:     ) -> AsyncBaseTransport:
>>>>>>         return AsyncHTTPTransport(
>>>>>>             verify=verify,
>>>>>>             cert=cert,
>>>>>>             http2=http2,
>>>>>>             limits=limits,
>>>>>>             trust_env=trust_env,
>>>>>>             proxy=proxy,
               )
       
    1:     def _transport_for_url(self, url: URL) -> AsyncBaseTransport:
               """
               Returns the transport instance that should be used for a given URL.
               This will either be the standard connection pool, or a proxy.
               """
>>>>>>         for pattern, transport in self._mounts.items():
>>>>>>             if pattern.matches(url):
>>>>>>                 return self._transport if transport is None else transport
       
>>>>>>         return self._transport
       
    2:     async def request(
               self,
    1:         method: str,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault, None] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Build and send a request.
       
               Equivalent to:
       
               ```python
               request = client.build_request(...)
               response = await client.send(request, ...)
               ```
       
               See `AsyncClient.build_request()`, `AsyncClient.send()`
               and [Merging of configuration][0] for how the various parameters
               are merged with client-level configuration.
       
               [0]: /advanced/#merging-of-configuration
               """
>>>>>>         request = self.build_request(
>>>>>>             method=method,
>>>>>>             url=url,
>>>>>>             content=content,
>>>>>>             data=data,
>>>>>>             files=files,
>>>>>>             json=json,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
>>>>>>         return await self.send(request, auth=auth, follow_redirects=follow_redirects)
       
    1:     @asynccontextmanager
    2:     async def stream(
               self,
    1:         method: str,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> typing.AsyncIterator[Response]:
               """
               Alternative to `httpx.request()` that streams the response body
               instead of loading it into memory at once.
       
               **Parameters**: See `httpx.request`.
       
               See also: [Streaming Responses][0]
       
               [0]: /quickstart#streaming-responses
               """
>>>>>>         request = self.build_request(
>>>>>>             method=method,
>>>>>>             url=url,
>>>>>>             content=content,
>>>>>>             data=data,
>>>>>>             files=files,
>>>>>>             json=json,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
>>>>>>         response = await self.send(
>>>>>>             request=request,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             stream=True,
               )
>>>>>>         try:
>>>>>>             yield response
               finally:
>>>>>>             await response.aclose()
       
    2:     async def send(
               self,
    1:         request: Request,
               *,
    2:         stream: bool = False,
    2:         auth: typing.Union[AuthTypes, UseClientDefault, None] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    1:     ) -> Response:
               """
               Send a request.
       
               The request is sent as-is, unmodified.
       
               Typically you'll want to build one with `AsyncClient.build_request()`
               so that any client-level configuration is merged into the request,
               but passing an explicit `httpx.Request()` is supported as well.
       
               See also: [Request instances][0]
       
               [0]: /advanced/#request-instances
               """
>>>>>>         if self._state == ClientState.CLOSED:
>>>>>>             raise RuntimeError("Cannot send a request, as the client has been closed.")
       
>>>>>>         self._state = ClientState.OPENED
>>>>>>         follow_redirects = (
>>>>>>             self.follow_redirects
>>>>>>             if isinstance(follow_redirects, UseClientDefault)
>>>>>>             else follow_redirects
               )
       
>>>>>>         auth = self._build_request_auth(request, auth)
       
>>>>>>         response = await self._send_handling_auth(
>>>>>>             request,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             history=[],
               )
>>>>>>         try:
>>>>>>             if not stream:
>>>>>>                 await response.aread()
       
>>>>>>             return response
       
>>>>>>         except BaseException as exc:  # pragma: no cover
>>>>>>             await response.aclose()
>>>>>>             raise exc
       
    1:     async def _send_handling_auth(
               self,
    1:         request: Request,
    1:         auth: Auth,
    1:         follow_redirects: bool,
    1:         history: typing.List[Response],
    1:     ) -> Response:
>>>>>>         auth_flow = auth.async_auth_flow(request)
>>>>>>         try:
>>>>>>             request = await auth_flow.__anext__()
       
                   while True:
>>>>>>                 response = await self._send_handling_redirects(
>>>>>>                     request,
>>>>>>                     follow_redirects=follow_redirects,
>>>>>>                     history=history,
                       )
>>>>>>                 try:
>>>>>>                     try:
>>>>>>                         next_request = await auth_flow.asend(response)
>>>>>>                     except StopAsyncIteration:
>>>>>>                         return response
       
>>>>>>                     response.history = list(history)
>>>>>>                     await response.aread()
>>>>>>                     request = next_request
>>>>>>                     history.append(response)
       
>>>>>>                 except BaseException as exc:
>>>>>>                     await response.aclose()
>>>>>>                     raise exc
               finally:
>>>>>>             await auth_flow.aclose()
       
    1:     async def _send_handling_redirects(
               self,
    1:         request: Request,
    1:         follow_redirects: bool,
    1:         history: typing.List[Response],
    1:     ) -> Response:
               while True:
>>>>>>             if len(history) > self.max_redirects:
>>>>>>                 raise TooManyRedirects(
>>>>>>                     "Exceeded maximum allowed redirects.", request=request
                       )
       
>>>>>>             for hook in self._event_hooks["request"]:
>>>>>>                 await hook(request)
       
>>>>>>             response = await self._send_single_request(request)
>>>>>>             try:
>>>>>>                 for hook in self._event_hooks["response"]:
>>>>>>                     await hook(response)
       
>>>>>>                 response.history = list(history)
       
>>>>>>                 if not response.has_redirect_location:
>>>>>>                     return response
       
>>>>>>                 request = self._build_redirect_request(request, response)
>>>>>>                 history = history + [response]
       
>>>>>>                 if follow_redirects:
>>>>>>                     await response.aread()
                       else:
>>>>>>                     response.next_request = request
>>>>>>                     return response
       
>>>>>>             except BaseException as exc:
>>>>>>                 await response.aclose()
>>>>>>                 raise exc
       
    1:     async def _send_single_request(self, request: Request) -> Response:
               """
               Sends a single request, without handling any redirections.
               """
>>>>>>         transport = self._transport_for_url(request.url)
>>>>>>         timer = Timer()
>>>>>>         await timer.async_start()
       
>>>>>>         if not isinstance(request.stream, AsyncByteStream):
>>>>>>             raise RuntimeError(
>>>>>>                 "Attempted to send an sync request with an AsyncClient instance."
                   )
       
>>>>>>         with request_context(request=request):
>>>>>>             response = await transport.handle_async_request(request)
       
>>>>>>         assert isinstance(response.stream, AsyncByteStream)
>>>>>>         response.request = request
>>>>>>         response.stream = BoundAsyncStream(
>>>>>>             response.stream, response=response, timer=timer
               )
>>>>>>         self.cookies.extract_cookies(response)
>>>>>>         response.default_encoding = self._default_encoding
       
>>>>>>         logger.info(
>>>>>>             'HTTP Request: %s %s "%s %d %s"',
>>>>>>             request.method,
>>>>>>             request.url,
>>>>>>             response.http_version,
>>>>>>             response.status_code,
>>>>>>             response.reason_phrase,
               )
       
>>>>>>         return response
       
    2:     async def get(
               self,
    1:         url: URLTypes,
               *,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault, None] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `GET` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return await self.request(
>>>>>>             "GET",
>>>>>>             url,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    2:     async def options(
               self,
    1:         url: URLTypes,
               *,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send an `OPTIONS` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return await self.request(
>>>>>>             "OPTIONS",
>>>>>>             url,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    2:     async def head(
               self,
    1:         url: URLTypes,
               *,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `HEAD` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return await self.request(
>>>>>>             "HEAD",
>>>>>>             url,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    2:     async def post(
               self,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `POST` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return await self.request(
>>>>>>             "POST",
>>>>>>             url,
>>>>>>             content=content,
>>>>>>             data=data,
>>>>>>             files=files,
>>>>>>             json=json,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    2:     async def put(
               self,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `PUT` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return await self.request(
>>>>>>             "PUT",
>>>>>>             url,
>>>>>>             content=content,
>>>>>>             data=data,
>>>>>>             files=files,
>>>>>>             json=json,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    2:     async def patch(
               self,
    1:         url: URLTypes,
               *,
    2:         content: typing.Optional[RequestContent] = None,
    2:         data: typing.Optional[RequestData] = None,
    2:         files: typing.Optional[RequestFiles] = None,
    2:         json: typing.Optional[typing.Any] = None,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `PATCH` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return await self.request(
>>>>>>             "PATCH",
>>>>>>             url,
>>>>>>             content=content,
>>>>>>             data=data,
>>>>>>             files=files,
>>>>>>             json=json,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    2:     async def delete(
               self,
    1:         url: URLTypes,
               *,
    2:         params: typing.Optional[QueryParamTypes] = None,
    2:         headers: typing.Optional[HeaderTypes] = None,
    2:         cookies: typing.Optional[CookieTypes] = None,
    2:         auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         follow_redirects: typing.Union[bool, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    2:         extensions: typing.Optional[RequestExtensions] = None,
    1:     ) -> Response:
               """
               Send a `DELETE` request.
       
               **Parameters**: See `httpx.request`.
               """
>>>>>>         return await self.request(
>>>>>>             "DELETE",
>>>>>>             url,
>>>>>>             params=params,
>>>>>>             headers=headers,
>>>>>>             cookies=cookies,
>>>>>>             auth=auth,
>>>>>>             follow_redirects=follow_redirects,
>>>>>>             timeout=timeout,
>>>>>>             extensions=extensions,
               )
       
    1:     async def aclose(self) -> None:
               """
               Close transport and proxies.
               """
>>>>>>         if self._state != ClientState.CLOSED:
>>>>>>             self._state = ClientState.CLOSED
       
>>>>>>             await self._transport.aclose()
>>>>>>             for proxy in self._mounts.values():
>>>>>>                 if proxy is not None:
>>>>>>                     await proxy.aclose()
       
    1:     async def __aenter__(self: U) -> U:
>>>>>>         if self._state != ClientState.UNOPENED:
>>>>>>             msg = {
>>>>>>                 ClientState.OPENED: "Cannot open a client instance more than once.",
>>>>>>                 ClientState.CLOSED: "Cannot reopen a client instance, once it has been closed.",
>>>>>>             }[self._state]
>>>>>>             raise RuntimeError(msg)
       
>>>>>>         self._state = ClientState.OPENED
       
>>>>>>         await self._transport.__aenter__()
>>>>>>         for proxy in self._mounts.values():
>>>>>>             if proxy is not None:
>>>>>>                 await proxy.__aenter__()
>>>>>>         return self
       
    2:     async def __aexit__(
               self,
    1:         exc_type: typing.Optional[typing.Type[BaseException]] = None,
    1:         exc_value: typing.Optional[BaseException] = None,
    1:         traceback: typing.Optional[TracebackType] = None,
    1:     ) -> None:
>>>>>>         self._state = ClientState.CLOSED
       
>>>>>>         await self._transport.__aexit__(exc_type, exc_value, traceback)
>>>>>>         for proxy in self._mounts.values():
>>>>>>             if proxy is not None:
>>>>>>                 await proxy.__aexit__(exc_type, exc_value, traceback)
