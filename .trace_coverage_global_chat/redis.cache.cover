    1: from abc import ABC, abstractmethod
    1: from collections import OrderedDict
    1: from dataclasses import dataclass
    1: from enum import Enum
    1: from typing import Any, List, Optional, Union
       
       
    2: class CacheEntryStatus(Enum):
    1:     VALID = "VALID"
    1:     IN_PROGRESS = "IN_PROGRESS"
       
       
    2: class EvictionPolicyType(Enum):
    1:     time_based = "time_based"
    1:     frequency_based = "frequency_based"
       
       
    2: @dataclass(frozen=True)
    1: class CacheKey:
    1:     command: str
    1:     redis_keys: tuple
       
       
    2: class CacheEntry:
    1:     def __init__(
               self,
    1:         cache_key: CacheKey,
    1:         cache_value: bytes,
    1:         status: CacheEntryStatus,
               connection_ref,
           ):
>>>>>>         self.cache_key = cache_key
>>>>>>         self.cache_value = cache_value
>>>>>>         self.status = status
>>>>>>         self.connection_ref = connection_ref
       
    1:     def __hash__(self):
>>>>>>         return hash(
>>>>>>             (self.cache_key, self.cache_value, self.status, self.connection_ref)
               )
       
    1:     def __eq__(self, other):
>>>>>>         return hash(self) == hash(other)
       
       
    2: class EvictionPolicyInterface(ABC):
    1:     @property
    1:     @abstractmethod
    1:     def cache(self):
>>>>>>         pass
       
    1:     @cache.setter
    1:     @abstractmethod
    1:     def cache(self, value):
>>>>>>         pass
       
    1:     @property
    1:     @abstractmethod
    1:     def type(self) -> EvictionPolicyType:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def evict_next(self) -> CacheKey:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def evict_many(self, count: int) -> List[CacheKey]:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def touch(self, cache_key: CacheKey) -> None:
>>>>>>         pass
       
       
    2: class CacheConfigurationInterface(ABC):
    1:     @abstractmethod
    1:     def get_cache_class(self):
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def get_max_size(self) -> int:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def get_eviction_policy(self):
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def is_exceeds_max_size(self, count: int) -> bool:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def is_allowed_to_cache(self, command: str) -> bool:
>>>>>>         pass
       
       
    2: class CacheInterface(ABC):
    1:     @property
    1:     @abstractmethod
    1:     def collection(self) -> OrderedDict:
>>>>>>         pass
       
    1:     @property
    1:     @abstractmethod
    1:     def config(self) -> CacheConfigurationInterface:
>>>>>>         pass
       
    1:     @property
    1:     @abstractmethod
    1:     def eviction_policy(self) -> EvictionPolicyInterface:
>>>>>>         pass
       
    1:     @property
    1:     @abstractmethod
    1:     def size(self) -> int:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def get(self, key: CacheKey) -> Union[CacheEntry, None]:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def set(self, entry: CacheEntry) -> bool:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def delete_by_cache_keys(self, cache_keys: List[CacheKey]) -> List[bool]:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def delete_by_redis_keys(self, redis_keys: List[bytes]) -> List[bool]:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def flush(self) -> int:
>>>>>>         pass
       
    1:     @abstractmethod
    1:     def is_cachable(self, key: CacheKey) -> bool:
>>>>>>         pass
       
       
    2: class DefaultCache(CacheInterface):
    1:     def __init__(
               self,
    1:         cache_config: CacheConfigurationInterface,
    1:     ) -> None:
>>>>>>         self._cache = OrderedDict()
>>>>>>         self._cache_config = cache_config
>>>>>>         self._eviction_policy = self._cache_config.get_eviction_policy().value()
>>>>>>         self._eviction_policy.cache = self
       
    1:     @property
    1:     def collection(self) -> OrderedDict:
>>>>>>         return self._cache
       
    1:     @property
    1:     def config(self) -> CacheConfigurationInterface:
>>>>>>         return self._cache_config
       
    1:     @property
    1:     def eviction_policy(self) -> EvictionPolicyInterface:
>>>>>>         return self._eviction_policy
       
    1:     @property
    1:     def size(self) -> int:
>>>>>>         return len(self._cache)
       
    1:     def set(self, entry: CacheEntry) -> bool:
>>>>>>         if not self.is_cachable(entry.cache_key):
>>>>>>             return False
       
>>>>>>         self._cache[entry.cache_key] = entry
>>>>>>         self._eviction_policy.touch(entry.cache_key)
       
>>>>>>         if self._cache_config.is_exceeds_max_size(len(self._cache)):
>>>>>>             self._eviction_policy.evict_next()
       
>>>>>>         return True
       
    1:     def get(self, key: CacheKey) -> Union[CacheEntry, None]:
>>>>>>         entry = self._cache.get(key, None)
       
>>>>>>         if entry is None:
>>>>>>             return None
       
>>>>>>         self._eviction_policy.touch(key)
>>>>>>         return entry
       
    1:     def delete_by_cache_keys(self, cache_keys: List[CacheKey]) -> List[bool]:
>>>>>>         response = []
       
>>>>>>         for key in cache_keys:
>>>>>>             if self.get(key) is not None:
>>>>>>                 self._cache.pop(key)
>>>>>>                 response.append(True)
                   else:
>>>>>>                 response.append(False)
       
>>>>>>         return response
       
    1:     def delete_by_redis_keys(self, redis_keys: List[bytes]) -> List[bool]:
>>>>>>         response = []
>>>>>>         keys_to_delete = []
       
>>>>>>         for redis_key in redis_keys:
>>>>>>             if isinstance(redis_key, bytes):
>>>>>>                 redis_key = redis_key.decode()
>>>>>>             for cache_key in self._cache:
>>>>>>                 if redis_key in cache_key.redis_keys:
>>>>>>                     keys_to_delete.append(cache_key)
>>>>>>                     response.append(True)
       
>>>>>>         for key in keys_to_delete:
>>>>>>             self._cache.pop(key)
       
>>>>>>         return response
       
    1:     def flush(self) -> int:
>>>>>>         elem_count = len(self._cache)
>>>>>>         self._cache.clear()
>>>>>>         return elem_count
       
    1:     def is_cachable(self, key: CacheKey) -> bool:
>>>>>>         return self._cache_config.is_allowed_to_cache(key.command)
       
       
    2: class LRUPolicy(EvictionPolicyInterface):
    1:     def __init__(self):
>>>>>>         self.cache = None
       
    1:     @property
    1:     def cache(self):
>>>>>>         return self._cache
       
    1:     @cache.setter
    1:     def cache(self, cache: CacheInterface):
>>>>>>         self._cache = cache
       
    1:     @property
    1:     def type(self) -> EvictionPolicyType:
>>>>>>         return EvictionPolicyType.time_based
       
    1:     def evict_next(self) -> CacheKey:
>>>>>>         self._assert_cache()
>>>>>>         popped_entry = self._cache.collection.popitem(last=False)
>>>>>>         return popped_entry[0]
       
    1:     def evict_many(self, count: int) -> List[CacheKey]:
>>>>>>         self._assert_cache()
>>>>>>         if count > len(self._cache.collection):
>>>>>>             raise ValueError("Evictions count is above cache size")
       
>>>>>>         popped_keys = []
       
>>>>>>         for _ in range(count):
>>>>>>             popped_entry = self._cache.collection.popitem(last=False)
>>>>>>             popped_keys.append(popped_entry[0])
       
>>>>>>         return popped_keys
       
    1:     def touch(self, cache_key: CacheKey) -> None:
>>>>>>         self._assert_cache()
       
>>>>>>         if self._cache.collection.get(cache_key) is None:
>>>>>>             raise ValueError("Given entry does not belong to the cache")
       
>>>>>>         self._cache.collection.move_to_end(cache_key)
       
    1:     def _assert_cache(self):
>>>>>>         if self.cache is None or not isinstance(self.cache, CacheInterface):
>>>>>>             raise ValueError("Eviction policy should be associated with valid cache.")
       
       
    2: class EvictionPolicy(Enum):
    1:     LRU = LRUPolicy
       
       
    2: class CacheConfig(CacheConfigurationInterface):
    1:     DEFAULT_CACHE_CLASS = DefaultCache
    1:     DEFAULT_EVICTION_POLICY = EvictionPolicy.LRU
    1:     DEFAULT_MAX_SIZE = 10000
       
    1:     DEFAULT_ALLOW_LIST = [
               "BITCOUNT",
               "BITFIELD_RO",
               "BITPOS",
               "EXISTS",
               "GEODIST",
               "GEOHASH",
               "GEOPOS",
               "GEORADIUSBYMEMBER_RO",
               "GEORADIUS_RO",
               "GEOSEARCH",
               "GET",
               "GETBIT",
               "GETRANGE",
               "HEXISTS",
               "HGET",
               "HGETALL",
               "HKEYS",
               "HLEN",
               "HMGET",
               "HSTRLEN",
               "HVALS",
               "JSON.ARRINDEX",
               "JSON.ARRLEN",
               "JSON.GET",
               "JSON.MGET",
               "JSON.OBJKEYS",
               "JSON.OBJLEN",
               "JSON.RESP",
               "JSON.STRLEN",
               "JSON.TYPE",
               "LCS",
               "LINDEX",
               "LLEN",
               "LPOS",
               "LRANGE",
               "MGET",
               "SCARD",
               "SDIFF",
               "SINTER",
               "SINTERCARD",
               "SISMEMBER",
               "SMEMBERS",
               "SMISMEMBER",
               "SORT_RO",
               "STRLEN",
               "SUBSTR",
               "SUNION",
               "TS.GET",
               "TS.INFO",
               "TS.RANGE",
               "TS.REVRANGE",
               "TYPE",
               "XLEN",
               "XPENDING",
               "XRANGE",
               "XREAD",
               "XREVRANGE",
               "ZCARD",
               "ZCOUNT",
               "ZDIFF",
               "ZINTER",
               "ZINTERCARD",
               "ZLEXCOUNT",
               "ZMSCORE",
               "ZRANGE",
               "ZRANGEBYLEX",
               "ZRANGEBYSCORE",
               "ZRANK",
               "ZREVRANGE",
               "ZREVRANGEBYLEX",
               "ZREVRANGEBYSCORE",
               "ZREVRANK",
               "ZSCORE",
               "ZUNION",
           ]
       
    2:     def __init__(
               self,
    2:         max_size: int = DEFAULT_MAX_SIZE,
    2:         cache_class: Any = DEFAULT_CACHE_CLASS,
    2:         eviction_policy: EvictionPolicy = DEFAULT_EVICTION_POLICY,
           ):
>>>>>>         self._cache_class = cache_class
>>>>>>         self._max_size = max_size
>>>>>>         self._eviction_policy = eviction_policy
       
    1:     def get_cache_class(self):
>>>>>>         return self._cache_class
       
    1:     def get_max_size(self) -> int:
>>>>>>         return self._max_size
       
    1:     def get_eviction_policy(self) -> EvictionPolicy:
>>>>>>         return self._eviction_policy
       
    1:     def is_exceeds_max_size(self, count: int) -> bool:
>>>>>>         return count > self._max_size
       
    1:     def is_allowed_to_cache(self, command: str) -> bool:
>>>>>>         return command in self.DEFAULT_ALLOW_LIST
       
       
    2: class CacheFactoryInterface(ABC):
    1:     @abstractmethod
    1:     def get_cache(self) -> CacheInterface:
>>>>>>         pass
       
       
    2: class CacheFactory(CacheFactoryInterface):
    1:     def __init__(self, cache_config: Optional[CacheConfig] = None):
>>>>>>         self._config = cache_config
       
>>>>>>         if self._config is None:
>>>>>>             self._config = CacheConfig()
       
    1:     def get_cache(self) -> CacheInterface:
>>>>>>         cache_class = self._config.get_cache_class()
>>>>>>         return cache_class(cache_config=self._config)
