    1: import math
    1: import json
       
    1: from jmespath import exceptions
    1: from jmespath.compat import string_type as STRING_TYPE
    1: from jmespath.compat import get_methods
       
       
       # python types -> jmespath types
    1: TYPES_MAP = {
    1:     'bool': 'boolean',
    1:     'list': 'array',
    1:     'dict': 'object',
    1:     'NoneType': 'null',
    1:     'unicode': 'string',
    1:     'str': 'string',
    1:     'float': 'number',
    1:     'int': 'number',
    1:     'long': 'number',
    1:     'OrderedDict': 'object',
    1:     '_Projection': 'array',
    1:     '_Expression': 'expref',
       }
       
       
       # jmespath types -> python types
    1: REVERSE_TYPES_MAP = {
    1:     'boolean': ('bool',),
    1:     'array': ('list', '_Projection'),
    1:     'object': ('dict', 'OrderedDict',),
    1:     'null': ('NoneType',),
    1:     'string': ('unicode', 'str'),
    1:     'number': ('float', 'int', 'long'),
    1:     'expref': ('_Expression',),
       }
       
       
    1: def signature(*arguments):
   26:     def _record_signature(func):
   26:         func.signature = arguments
   26:         return func
   26:     return _record_signature
       
       
    2: class FunctionRegistry(type):
    1:     def __init__(cls, name, bases, attrs):
    1:         cls._populate_function_table()
    1:         super(FunctionRegistry, cls).__init__(name, bases, attrs)
       
    1:     def _populate_function_table(cls):
    1:         function_table = {}
               # Any method with a @signature decorator that also
               # starts with "_func_" is registered as a function.
               # _func_max_by -> max_by function.
   35:         for name, method in get_methods(cls):
   34:             if not name.startswith('_func_'):
    8:                 continue
   26:             signature = getattr(method, 'signature', None)
   26:             if signature is not None:
   26:                 function_table[name[6:]] = {
   26:                     'function': method,
   26:                     'signature': signature,
                       }
    1:         cls.FUNCTION_TABLE = function_table
       
       
    2: class Functions(metaclass=FunctionRegistry):
       
    1:     FUNCTION_TABLE = {
           }
       
    1:     def call_function(self, function_name, resolved_args):
>>>>>>         try:
>>>>>>             spec = self.FUNCTION_TABLE[function_name]
>>>>>>         except KeyError:
>>>>>>             raise exceptions.UnknownFunctionError(
>>>>>>                 "Unknown function: %s()" % function_name)
>>>>>>         function = spec['function']
>>>>>>         signature = spec['signature']
>>>>>>         self._validate_arguments(resolved_args, signature, function_name)
>>>>>>         return function(self, *resolved_args)
       
    1:     def _validate_arguments(self, args, signature, function_name):
>>>>>>         if signature and signature[-1].get('variadic'):
>>>>>>             if len(args) < len(signature):
>>>>>>                 raise exceptions.VariadictArityError(
>>>>>>                     len(signature), len(args), function_name)
>>>>>>         elif len(args) != len(signature):
>>>>>>             raise exceptions.ArityError(
>>>>>>                 len(signature), len(args), function_name)
>>>>>>         return self._type_check(args, signature, function_name)
       
    1:     def _type_check(self, actual, signature, function_name):
>>>>>>         for i in range(len(signature)):
>>>>>>             allowed_types = signature[i]['types']
>>>>>>             if allowed_types:
>>>>>>                 self._type_check_single(actual[i], allowed_types,
>>>>>>                                         function_name)
       
    1:     def _type_check_single(self, current, types, function_name):
               # Type checking involves checking the top level type,
               # and in the case of arrays, potentially checking the types
               # of each element.
>>>>>>         allowed_types, allowed_subtypes = self._get_allowed_pytypes(types)
               # We're not using isinstance() on purpose.
               # The type model for jmespath does not map
               # 1-1 with python types (booleans are considered
               # integers in python for example).
>>>>>>         actual_typename = type(current).__name__
>>>>>>         if actual_typename not in allowed_types:
>>>>>>             raise exceptions.JMESPathTypeError(
>>>>>>                 function_name, current,
>>>>>>                 self._convert_to_jmespath_type(actual_typename), types)
               # If we're dealing with a list type, we can have
               # additional restrictions on the type of the list
               # elements (for example a function can require a
               # list of numbers or a list of strings).
               # Arrays are the only types that can have subtypes.
>>>>>>         if allowed_subtypes:
>>>>>>             self._subtype_check(current, allowed_subtypes,
>>>>>>                                 types, function_name)
       
    1:     def _get_allowed_pytypes(self, types):
>>>>>>         allowed_types = []
>>>>>>         allowed_subtypes = []
>>>>>>         for t in types:
>>>>>>             type_ = t.split('-', 1)
>>>>>>             if len(type_) == 2:
>>>>>>                 type_, subtype = type_
>>>>>>                 allowed_subtypes.append(REVERSE_TYPES_MAP[subtype])
                   else:
>>>>>>                 type_ = type_[0]
>>>>>>             allowed_types.extend(REVERSE_TYPES_MAP[type_])
>>>>>>         return allowed_types, allowed_subtypes
       
    1:     def _subtype_check(self, current, allowed_subtypes, types, function_name):
>>>>>>         if len(allowed_subtypes) == 1:
                   # The easy case, we know up front what type
                   # we need to validate.
>>>>>>             allowed_subtypes = allowed_subtypes[0]
>>>>>>             for element in current:
>>>>>>                 actual_typename = type(element).__name__
>>>>>>                 if actual_typename not in allowed_subtypes:
>>>>>>                     raise exceptions.JMESPathTypeError(
>>>>>>                         function_name, element, actual_typename, types)
>>>>>>         elif len(allowed_subtypes) > 1 and current:
                   # Dynamic type validation.  Based on the first
                   # type we see, we validate that the remaining types
                   # match.
>>>>>>             first = type(current[0]).__name__
>>>>>>             for subtypes in allowed_subtypes:
>>>>>>                 if first in subtypes:
>>>>>>                     allowed = subtypes
>>>>>>                     break
                   else:
>>>>>>                 raise exceptions.JMESPathTypeError(
>>>>>>                     function_name, current[0], first, types)
>>>>>>             for element in current:
>>>>>>                 actual_typename = type(element).__name__
>>>>>>                 if actual_typename not in allowed:
>>>>>>                     raise exceptions.JMESPathTypeError(
>>>>>>                         function_name, element, actual_typename, types)
       
    1:     @signature({'types': ['number']})
    1:     def _func_abs(self, arg):
>>>>>>         return abs(arg)
       
    1:     @signature({'types': ['array-number']})
    1:     def _func_avg(self, arg):
>>>>>>         if arg:
>>>>>>             return sum(arg) / float(len(arg))
               else:
>>>>>>             return None
       
    1:     @signature({'types': [], 'variadic': True})
    1:     def _func_not_null(self, *arguments):
>>>>>>         for argument in arguments:
>>>>>>             if argument is not None:
>>>>>>                 return argument
       
    1:     @signature({'types': []})
    1:     def _func_to_array(self, arg):
>>>>>>         if isinstance(arg, list):
>>>>>>             return arg
               else:
>>>>>>             return [arg]
       
    1:     @signature({'types': []})
    1:     def _func_to_string(self, arg):
>>>>>>         if isinstance(arg, STRING_TYPE):
>>>>>>             return arg
               else:
>>>>>>             return json.dumps(arg, separators=(',', ':'),
>>>>>>                               default=str)
       
    1:     @signature({'types': []})
    1:     def _func_to_number(self, arg):
>>>>>>         if isinstance(arg, (list, dict, bool)):
>>>>>>             return None
>>>>>>         elif arg is None:
>>>>>>             return None
>>>>>>         elif isinstance(arg, (int, float)):
>>>>>>             return arg
               else:
>>>>>>             try:
>>>>>>                 return int(arg)
>>>>>>             except ValueError:
>>>>>>                 try:
>>>>>>                     return float(arg)
>>>>>>                 except ValueError:
>>>>>>                     return None
       
    1:     @signature({'types': ['array', 'string']}, {'types': []})
    1:     def _func_contains(self, subject, search):
>>>>>>         return search in subject
       
    1:     @signature({'types': ['string', 'array', 'object']})
    1:     def _func_length(self, arg):
>>>>>>         return len(arg)
       
    1:     @signature({'types': ['string']}, {'types': ['string']})
    1:     def _func_ends_with(self, search, suffix):
>>>>>>         return search.endswith(suffix)
       
    1:     @signature({'types': ['string']}, {'types': ['string']})
    1:     def _func_starts_with(self, search, suffix):
>>>>>>         return search.startswith(suffix)
       
    1:     @signature({'types': ['array', 'string']})
    1:     def _func_reverse(self, arg):
>>>>>>         if isinstance(arg, STRING_TYPE):
>>>>>>             return arg[::-1]
               else:
>>>>>>             return list(reversed(arg))
       
    1:     @signature({"types": ['number']})
    1:     def _func_ceil(self, arg):
>>>>>>         return math.ceil(arg)
       
    1:     @signature({"types": ['number']})
    1:     def _func_floor(self, arg):
>>>>>>         return math.floor(arg)
       
    1:     @signature({"types": ['string']}, {"types": ['array-string']})
    1:     def _func_join(self, separator, array):
>>>>>>         return separator.join(array)
       
    1:     @signature({'types': ['expref']}, {'types': ['array']})
    1:     def _func_map(self, expref, arg):
>>>>>>         result = []
>>>>>>         for element in arg:
>>>>>>             result.append(expref.visit(expref.expression, element))
>>>>>>         return result
       
    1:     @signature({"types": ['array-number', 'array-string']})
    1:     def _func_max(self, arg):
>>>>>>         if arg:
>>>>>>             return max(arg)
               else:
>>>>>>             return None
       
    1:     @signature({"types": ["object"], "variadic": True})
    1:     def _func_merge(self, *arguments):
>>>>>>         merged = {}
>>>>>>         for arg in arguments:
>>>>>>             merged.update(arg)
>>>>>>         return merged
       
    1:     @signature({"types": ['array-number', 'array-string']})
    1:     def _func_min(self, arg):
>>>>>>         if arg:
>>>>>>             return min(arg)
               else:
>>>>>>             return None
       
    1:     @signature({"types": ['array-string', 'array-number']})
    1:     def _func_sort(self, arg):
>>>>>>         return list(sorted(arg))
       
    1:     @signature({"types": ['array-number']})
    1:     def _func_sum(self, arg):
>>>>>>         return sum(arg)
       
    1:     @signature({"types": ['object']})
    1:     def _func_keys(self, arg):
               # To be consistent with .values()
               # should we also return the indices of a list?
>>>>>>         return list(arg.keys())
       
    1:     @signature({"types": ['object']})
    1:     def _func_values(self, arg):
>>>>>>         return list(arg.values())
       
    1:     @signature({'types': []})
    1:     def _func_type(self, arg):
>>>>>>         if isinstance(arg, STRING_TYPE):
>>>>>>             return "string"
>>>>>>         elif isinstance(arg, bool):
>>>>>>             return "boolean"
>>>>>>         elif isinstance(arg, list):
>>>>>>             return "array"
>>>>>>         elif isinstance(arg, dict):
>>>>>>             return "object"
>>>>>>         elif isinstance(arg, (float, int)):
>>>>>>             return "number"
>>>>>>         elif arg is None:
>>>>>>             return "null"
       
    1:     @signature({'types': ['array']}, {'types': ['expref']})
    1:     def _func_sort_by(self, array, expref):
>>>>>>         if not array:
>>>>>>             return array
               # sort_by allows for the expref to be either a number of
               # a string, so we have some special logic to handle this.
               # We evaluate the first array element and verify that it's
               # either a string of a number.  We then create a key function
               # that validates that type, which requires that remaining array
               # elements resolve to the same type as the first element.
>>>>>>         required_type = self._convert_to_jmespath_type(
>>>>>>             type(expref.visit(expref.expression, array[0])).__name__)
>>>>>>         if required_type not in ['number', 'string']:
>>>>>>             raise exceptions.JMESPathTypeError(
>>>>>>                 'sort_by', array[0], required_type, ['string', 'number'])
>>>>>>         keyfunc = self._create_key_func(expref,
>>>>>>                                         [required_type],
>>>>>>                                         'sort_by')
>>>>>>         return list(sorted(array, key=keyfunc))
       
    1:     @signature({'types': ['array']}, {'types': ['expref']})
    1:     def _func_min_by(self, array, expref):
>>>>>>         keyfunc = self._create_key_func(expref,
>>>>>>                                         ['number', 'string'],
>>>>>>                                         'min_by')
>>>>>>         if array:
>>>>>>             return min(array, key=keyfunc)
               else:
>>>>>>             return None
       
    1:     @signature({'types': ['array']}, {'types': ['expref']})
    1:     def _func_max_by(self, array, expref):
>>>>>>         keyfunc = self._create_key_func(expref,
>>>>>>                                         ['number', 'string'],
>>>>>>                                         'max_by')
>>>>>>         if array:
>>>>>>             return max(array, key=keyfunc)
               else:
>>>>>>             return None
       
    1:     def _create_key_func(self, expref, allowed_types, function_name):
>>>>>>         def keyfunc(x):
>>>>>>             result = expref.visit(expref.expression, x)
>>>>>>             actual_typename = type(result).__name__
>>>>>>             jmespath_type = self._convert_to_jmespath_type(actual_typename)
                   # allowed_types is in term of jmespath types, not python types.
>>>>>>             if jmespath_type not in allowed_types:
>>>>>>                 raise exceptions.JMESPathTypeError(
>>>>>>                     function_name, result, jmespath_type, allowed_types)
>>>>>>             return result
>>>>>>         return keyfunc
       
    1:     def _convert_to_jmespath_type(self, pyobject):
>>>>>>         return TYPES_MAP.get(pyobject, 'unknown')
