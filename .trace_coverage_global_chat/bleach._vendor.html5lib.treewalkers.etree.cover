    1: from __future__ import absolute_import, division, unicode_literals
       
    1: from collections import OrderedDict
    1: import re
       
    1: from bleach.six_shim import string_types
       
    1: from . import base
    1: from .._utils import moduleFactoryFactory
       
    1: tag_regexp = re.compile("{([^}]*)}(.*)")
       
       
    1: def getETreeBuilder(ElementTreeImplementation):
    1:     ElementTree = ElementTreeImplementation
    1:     ElementTreeCommentType = ElementTree.Comment("asd").tag
       
    2:     class TreeWalker(base.NonRecursiveTreeWalker):  # pylint:disable=unused-variable
    1:         """Given the particular ElementTree representation, this implementation,
               to avoid using recursion, returns "nodes" as tuples with the following
               content:
       
               1. The current element
       
               2. The index of the element relative to its parent
       
               3. A stack of ancestor elements
       
               4. A flag "text", "tail" or None to indicate if the current node is a
                  text node; either the text or tail of the current element (1)
               """
    1:         def getNodeDetails(self, node):
   20:             if isinstance(node, tuple):  # It might be the root Element
   10:                 elt, _, _, flag = node
   10:                 if flag in ("text", "tail"):
   10:                     return base.TEXT, getattr(elt, flag)
                       else:
>>>>>>                     node = elt
       
   10:             if not(hasattr(node, "tag")):
>>>>>>                 node = node.getroot()
       
   10:             if node.tag in ("DOCUMENT_ROOT", "DOCUMENT_FRAGMENT"):
   10:                 return (base.DOCUMENT,)
       
>>>>>>             elif node.tag == "<!DOCTYPE>":
>>>>>>                 return (base.DOCTYPE, node.text,
>>>>>>                         node.get("publicId"), node.get("systemId"))
       
>>>>>>             elif node.tag == ElementTreeCommentType:
>>>>>>                 return base.COMMENT, node.text
       
                   else:
>>>>>>                 assert isinstance(node.tag, string_types), type(node.tag)
                       # This is assumed to be an ordinary element
>>>>>>                 match = tag_regexp.match(node.tag)
>>>>>>                 if match:
>>>>>>                     namespace, tag = match.groups()
                       else:
>>>>>>                     namespace = None
>>>>>>                     tag = node.tag
>>>>>>                 attrs = OrderedDict()
>>>>>>                 for name, value in list(node.attrib.items()):
>>>>>>                     match = tag_regexp.match(name)
>>>>>>                     if match:
>>>>>>                         attrs[(match.group(1), match.group(2))] = value
                           else:
>>>>>>                         attrs[(None, name)] = value
>>>>>>                 return (base.ELEMENT, namespace, tag,
>>>>>>                         attrs, len(node) or node.text)
       
    1:         def getFirstChild(self, node):
    5:             if isinstance(node, tuple):
>>>>>>                 element, key, parents, flag = node
                   else:
    5:                 element, key, parents, flag = node, None, [], None
       
    5:             if flag in ("text", "tail"):
>>>>>>                 return None
                   else:
    5:                 if element.text:
    5:                     return element, key, parents, "text"
>>>>>>                 elif len(element):
>>>>>>                     parents.append(element)
>>>>>>                     return element[0], 0, parents, None
                       else:
>>>>>>                     return None
       
    1:         def getNextSibling(self, node):
    5:             if isinstance(node, tuple):
    5:                 element, key, parents, flag = node
                   else:
>>>>>>                 return None
       
    5:             if flag == "text":
    5:                 if len(element):
>>>>>>                     parents.append(element)
>>>>>>                     return element[0], 0, parents, None
                       else:
    5:                     return None
                   else:
>>>>>>                 if element.tail and flag != "tail":
>>>>>>                     return element, key, parents, "tail"
>>>>>>                 elif key < len(parents[-1]) - 1:
>>>>>>                     return parents[-1][key + 1], key + 1, parents, None
                       else:
>>>>>>                     return None
       
    1:         def getParentNode(self, node):
    5:             if isinstance(node, tuple):
    5:                 element, key, parents, flag = node
                   else:
>>>>>>                 return None
       
    5:             if flag == "text":
    5:                 if not parents:
    5:                     return element
                       else:
>>>>>>                     return element, key, parents, None
                   else:
>>>>>>                 parent = parents.pop()
>>>>>>                 if not parents:
>>>>>>                     return parent
                       else:
>>>>>>                     assert list(parents[-1]).count(parent) == 1
>>>>>>                     return parent, list(parents[-1]).index(parent), parents, None
       
    1:     return locals()
       
       
    1: getETreeModule = moduleFactoryFactory(getETreeBuilder)
