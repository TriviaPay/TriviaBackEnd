       # orm/_typing.py
       # Copyright (C) 2022-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: from __future__ import annotations
       
    1: import operator
    1: from typing import Any
    1: from typing import Dict
    1: from typing import Mapping
    1: from typing import Optional
    1: from typing import Tuple
    1: from typing import Type
    1: from typing import TYPE_CHECKING
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from ..engine.interfaces import _CoreKnownExecutionOptions
    1: from ..sql import roles
    1: from ..sql._orm_types import DMLStrategyArgument as DMLStrategyArgument
    1: from ..sql._orm_types import (
           SynchronizeSessionArgument as SynchronizeSessionArgument,
       )
    1: from ..sql._typing import _HasClauseElement
    1: from ..sql.elements import ColumnElement
    1: from ..util.typing import Protocol
    1: from ..util.typing import TypeGuard
       
    1: if TYPE_CHECKING:
>>>>>>     from .attributes import AttributeImpl
>>>>>>     from .attributes import CollectionAttributeImpl
>>>>>>     from .attributes import HasCollectionAdapter
>>>>>>     from .attributes import QueryableAttribute
>>>>>>     from .base import PassiveFlag
>>>>>>     from .decl_api import registry as _registry_type
>>>>>>     from .interfaces import InspectionAttr
>>>>>>     from .interfaces import MapperProperty
>>>>>>     from .interfaces import ORMOption
>>>>>>     from .interfaces import UserDefinedOption
>>>>>>     from .mapper import Mapper
>>>>>>     from .relationships import RelationshipProperty
>>>>>>     from .state import InstanceState
>>>>>>     from .util import AliasedClass
>>>>>>     from .util import AliasedInsp
>>>>>>     from ..sql._typing import _CE
>>>>>>     from ..sql.base import ExecutableOption
       
    1: _T = TypeVar("_T", bound=Any)
       
       
    1: _T_co = TypeVar("_T_co", bound=Any, covariant=True)
       
    1: _O = TypeVar("_O", bound=object)
       """The 'ORM mapped object' type.
       
       """
       
       
    1: if TYPE_CHECKING:
>>>>>>     _RegistryType = _registry_type
       
    1: _InternalEntityType = Union["Mapper[_T]", "AliasedInsp[_T]"]
       
    1: _ExternalEntityType = Union[Type[_T], "AliasedClass[_T]"]
       
    2: _EntityType = Union[
    1:     Type[_T], "AliasedClass[_T]", "Mapper[_T]", "AliasedInsp[_T]"
       ]
       
       
    1: _ClassDict = Mapping[str, Any]
    1: _InstanceDict = Dict[str, Any]
       
    1: _IdentityKeyType = Tuple[Type[_T], Tuple[Any, ...], Optional[Any]]
       
    2: _ORMColumnExprArgument = Union[
    2:     ColumnElement[_T],
    1:     _HasClauseElement[_T],
    1:     roles.ExpressionElementRole[_T],
       ]
       
       
    1: _ORMCOLEXPR = TypeVar("_ORMCOLEXPR", bound=ColumnElement[Any])
       
       
    2: class _OrmKnownExecutionOptions(_CoreKnownExecutionOptions, total=False):
    1:     populate_existing: bool
    1:     autoflush: bool
    1:     synchronize_session: SynchronizeSessionArgument
    1:     dml_strategy: DMLStrategyArgument
    1:     is_delete_using: bool
    1:     is_update_from: bool
    1:     render_nulls: bool
       
       
    2: OrmExecuteOptionsParameter = Union[
    1:     _OrmKnownExecutionOptions, Mapping[str, Any]
       ]
       
       
    2: class _ORMAdapterProto(Protocol):
    1:     """protocol for the :class:`.AliasedInsp._orm_adapt_element` method
           which is a synonym for :class:`.AliasedInsp._adapt_element`.
       
       
           """
       
    1:     def __call__(self, obj: _CE, key: Optional[str] = None) -> _CE: ...
       
       
    2: class _LoaderCallable(Protocol):
    1:     def __call__(
               self, state: InstanceState[Any], passive: PassiveFlag
>>>>>>     ) -> Any: ...
       
       
    1: def is_orm_option(
           opt: ExecutableOption,
       ) -> TypeGuard[ORMOption]:
>>>>>>     return not opt._is_core
       
       
    1: def is_user_defined_option(
           opt: ExecutableOption,
       ) -> TypeGuard[UserDefinedOption]:
>>>>>>     return not opt._is_core and opt._is_user_defined  # type: ignore
       
       
    1: def is_composite_class(obj: Any) -> bool:
           # inlining is_dataclass(obj)
>>>>>>     return hasattr(obj, "__composite_values__") or hasattr(
>>>>>>         obj, "__dataclass_fields__"
           )
       
       
    1: if TYPE_CHECKING:
       
>>>>>>     def insp_is_mapper_property(
               obj: Any,
>>>>>>     ) -> TypeGuard[MapperProperty[Any]]: ...
       
>>>>>>     def insp_is_mapper(obj: Any) -> TypeGuard[Mapper[Any]]: ...
       
>>>>>>     def insp_is_aliased_class(obj: Any) -> TypeGuard[AliasedInsp[Any]]: ...
       
>>>>>>     def insp_is_attribute(
               obj: InspectionAttr,
>>>>>>     ) -> TypeGuard[QueryableAttribute[Any]]: ...
       
>>>>>>     def attr_is_internal_proxy(
               obj: InspectionAttr,
>>>>>>     ) -> TypeGuard[QueryableAttribute[Any]]: ...
       
>>>>>>     def prop_is_relationship(
               prop: MapperProperty[Any],
>>>>>>     ) -> TypeGuard[RelationshipProperty[Any]]: ...
       
>>>>>>     def is_collection_impl(
               impl: AttributeImpl,
>>>>>>     ) -> TypeGuard[CollectionAttributeImpl]: ...
       
>>>>>>     def is_has_collection_adapter(
               impl: AttributeImpl,
>>>>>>     ) -> TypeGuard[HasCollectionAdapter]: ...
       
       else:
    1:     insp_is_mapper_property = operator.attrgetter("is_property")
    1:     insp_is_mapper = operator.attrgetter("is_mapper")
    1:     insp_is_aliased_class = operator.attrgetter("is_aliased_class")
    1:     insp_is_attribute = operator.attrgetter("is_attribute")
    1:     attr_is_internal_proxy = operator.attrgetter("_is_internal_proxy")
    1:     is_collection_impl = operator.attrgetter("collection")
    1:     prop_is_relationship = operator.attrgetter("_is_relationship")
    2:     is_has_collection_adapter = operator.attrgetter(
    1:         "_is_has_collection_adapter"
           )
