    1: "Core exceptions raised by the Redis client"
       
       
    2: class RedisError(Exception):
    1:     pass
       
       
    2: class ConnectionError(RedisError):
    1:     pass
       
       
    2: class TimeoutError(RedisError):
    1:     pass
       
       
    2: class AuthenticationError(ConnectionError):
    1:     pass
       
       
    2: class AuthorizationError(ConnectionError):
    1:     pass
       
       
    2: class BusyLoadingError(ConnectionError):
    1:     pass
       
       
    2: class InvalidResponse(RedisError):
    1:     pass
       
       
    2: class ResponseError(RedisError):
    1:     pass
       
       
    2: class DataError(RedisError):
    1:     pass
       
       
    2: class PubSubError(RedisError):
    1:     pass
       
       
    2: class WatchError(RedisError):
    1:     pass
       
       
    2: class NoScriptError(ResponseError):
    1:     pass
       
       
    2: class OutOfMemoryError(ResponseError):
    1:     """
           Indicates the database is full. Can only occur when either:
             * Redis maxmemory-policy=noeviction
             * Redis maxmemory-policy=volatile* and there are no evictable keys
       
           For more information see `Memory optimization in Redis <https://redis.io/docs/management/optimization/memory-optimization/#memory-allocation>`_. # noqa
           """
       
    1:     pass
       
       
    2: class ExecAbortError(ResponseError):
    1:     pass
       
       
    2: class ReadOnlyError(ResponseError):
    1:     pass
       
       
    2: class NoPermissionError(ResponseError):
    1:     pass
       
       
    2: class ModuleError(ResponseError):
    1:     pass
       
       
    2: class LockError(RedisError, ValueError):
    1:     "Errors acquiring or releasing a lock"
       
           # NOTE: For backwards compatibility, this class derives from ValueError.
           # This was originally chosen to behave like threading.Lock.
       
    1:     def __init__(self, message=None, lock_name=None):
>>>>>>         self.message = message
>>>>>>         self.lock_name = lock_name
       
       
    2: class LockNotOwnedError(LockError):
    1:     "Error trying to extend or release a lock that is not owned (anymore)"
       
    1:     pass
       
       
    2: class ChildDeadlockedError(Exception):
    1:     "Error indicating that a child process is deadlocked after a fork()"
       
    1:     pass
       
       
    2: class AuthenticationWrongNumberOfArgsError(ResponseError):
    1:     """
           An error to indicate that the wrong number of args
           were sent to the AUTH command
           """
       
    1:     pass
       
       
    2: class RedisClusterException(Exception):
    1:     """
           Base exception for the RedisCluster client
           """
       
    1:     pass
       
       
    2: class ClusterError(RedisError):
    1:     """
           Cluster errors occurred multiple times, resulting in an exhaustion of the
           command execution TTL
           """
       
    1:     pass
       
       
    2: class ClusterDownError(ClusterError, ResponseError):
    1:     """
           Error indicated CLUSTERDOWN error received from cluster.
           By default Redis Cluster nodes stop accepting queries if they detect there
           is at least a hash slot uncovered (no available node is serving it).
           This way if the cluster is partially down (for example a range of hash
           slots are no longer covered) the entire cluster eventually becomes
           unavailable. It automatically returns available as soon as all the slots
           are covered again.
           """
       
    1:     def __init__(self, resp):
>>>>>>         self.args = (resp,)
>>>>>>         self.message = resp
       
       
    2: class AskError(ResponseError):
    1:     """
           Error indicated ASK error received from cluster.
           When a slot is set as MIGRATING, the node will accept all queries that
           pertain to this hash slot, but only if the key in question exists,
           otherwise the query is forwarded using a -ASK redirection to the node that
           is target of the migration.
       
           src node: MIGRATING to dst node
               get > ASK error
               ask dst node > ASKING command
           dst node: IMPORTING from src node
               asking command only affects next command
               any op will be allowed after asking command
           """
       
    1:     def __init__(self, resp):
               """should only redirect to master node"""
>>>>>>         self.args = (resp,)
>>>>>>         self.message = resp
>>>>>>         slot_id, new_node = resp.split(" ")
>>>>>>         host, port = new_node.rsplit(":", 1)
>>>>>>         self.slot_id = int(slot_id)
>>>>>>         self.node_addr = self.host, self.port = host, int(port)
       
       
    2: class TryAgainError(ResponseError):
    1:     """
           Error indicated TRYAGAIN error received from cluster.
           Operations on keys that don't exist or are - during resharding - split
           between the source and destination nodes, will generate a -TRYAGAIN error.
           """
       
    1:     def __init__(self, *args, **kwargs):
>>>>>>         pass
       
       
    2: class ClusterCrossSlotError(ResponseError):
    1:     """
           Error indicated CROSSSLOT error received from cluster.
           A CROSSSLOT error is generated when keys in a request don't hash to the
           same slot.
           """
       
    1:     message = "Keys in request don't hash to the same slot"
       
       
    2: class MovedError(AskError):
    1:     """
           Error indicated MOVED error received from cluster.
           A request sent to a node that doesn't serve this key will be replayed with
           a MOVED error that points to the correct node.
           """
       
    1:     pass
       
       
    2: class MasterDownError(ClusterDownError):
    1:     """
           Error indicated MASTERDOWN error received from cluster.
           Link with MASTER is down and replica-serve-stale-data is set to 'no'.
           """
       
    1:     pass
       
       
    2: class SlotNotCoveredError(RedisClusterException):
    1:     """
           This error only happens in the case where the connection pool will try to
           fetch what node that is covered by a given slot.
       
           If this error is raised the client should drop the current node layout and
           attempt to reconnect and refresh the node layout again
           """
       
    1:     pass
       
       
    2: class MaxConnectionsError(ConnectionError):
    1:     """
           Raised when a connection pool has reached its max_connections limit.
           This indicates pool exhaustion rather than an actual connection failure.
           """
       
    1:     pass
       
       
    2: class CrossSlotTransactionError(RedisClusterException):
    1:     """
           Raised when a transaction or watch is triggered in a pipeline
           and not all keys or all commands belong to the same slot.
           """
       
    1:     pass
       
       
    2: class InvalidPipelineStack(RedisClusterException):
    1:     """
           Raised on unexpected response length on pipelines. This is
           most likely a handling error on the stack.
           """
       
    1:     pass
       
       
    2: class ExternalAuthProviderError(ConnectionError):
    1:     """
           Raised when an external authentication provider returns an error.
           """
       
    1:     pass
