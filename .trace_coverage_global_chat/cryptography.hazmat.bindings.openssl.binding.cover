       # This file is dual licensed under the terms of the Apache License, Version
       # 2.0, and the BSD License. See the LICENSE file in the root of this repository
       # for complete details.
       
    1: from __future__ import annotations
       
    1: import os
    1: import sys
    1: import threading
    1: import types
    1: import typing
    1: import warnings
    1: from collections.abc import Callable
       
    1: import cryptography
    1: from cryptography.exceptions import InternalError
    1: from cryptography.hazmat.bindings._rust import _openssl, openssl
    1: from cryptography.hazmat.bindings.openssl._conditional import CONDITIONAL_NAMES
    1: from cryptography.utils import CryptographyDeprecationWarning
       
       
    1: def _openssl_assert(ok: bool) -> None:
    1:     if not ok:
>>>>>>         errors = openssl.capture_error_stack()
       
>>>>>>         raise InternalError(
>>>>>>             "Unknown OpenSSL error. This error is commonly encountered when "
                   "another library is not cleaning up the OpenSSL error stack. If "
                   "you are using cryptography with another library that uses "
                   "OpenSSL try disabling it before reporting a bug. Otherwise "
                   "please file an issue at https://github.com/pyca/cryptography/"
                   "issues with information on how to reproduce "
>>>>>>             f"this. ({errors!r})",
>>>>>>             errors,
               )
       
       
    1: def build_conditional_library(
           lib: typing.Any,
           conditional_names: dict[str, Callable[[], list[str]]],
       ) -> typing.Any:
    1:     conditional_lib = types.ModuleType("lib")
    1:     conditional_lib._original_lib = lib  # type: ignore[attr-defined]
    1:     excluded_names = set()
   22:     for condition, names_cb in conditional_names.items():
   21:         if not getattr(lib, condition):
    1:             excluded_names.update(names_cb())
       
  611:     for attr in dir(lib):
  610:         if attr not in excluded_names:
  606:             setattr(conditional_lib, attr, getattr(lib, attr))
       
    1:     return conditional_lib
       
       
    2: class Binding:
    1:     """
           OpenSSL API wrapper.
           """
       
    1:     lib: typing.ClassVar[typing.Any] = None
    1:     ffi = _openssl.ffi
    1:     _lib_loaded = False
    1:     _init_lock = threading.Lock()
       
    1:     def __init__(self) -> None:
    2:         self._ensure_ffi_initialized()
       
    1:     @classmethod
    1:     def _ensure_ffi_initialized(cls) -> None:
    3:         with cls._init_lock:
    3:             if not cls._lib_loaded:
    2:                 cls.lib = build_conditional_library(
    1:                     _openssl.lib, CONDITIONAL_NAMES
                       )
    1:                 cls._lib_loaded = True
       
    1:     @classmethod
    1:     def init_static_locks(cls) -> None:
    1:         cls._ensure_ffi_initialized()
       
       
    1: def _verify_package_version(version: str) -> None:
           # Occasionally we run into situations where the version of the Python
           # package does not match the version of the shared object that is loaded.
           # This may occur in environments where multiple versions of cryptography
           # are installed and available in the python path. To avoid errors cropping
           # up later this code checks that the currently imported package and the
           # shared object that were loaded have the same version and raise an
           # ImportError if they do not
    2:     so_package_version = _openssl.ffi.string(
    1:         _openssl.lib.CRYPTOGRAPHY_PACKAGE_VERSION
           )
    1:     if version.encode("ascii") != so_package_version:
>>>>>>         raise ImportError(
>>>>>>             "The version of cryptography does not match the loaded "
                   "shared object. This can happen if you have multiple copies of "
                   "cryptography installed in your Python path. Please try creating "
                   "a new virtual environment to resolve this issue. "
>>>>>>             f"Loaded python version: {version}, "
>>>>>>             f"shared object version: {so_package_version}"
               )
       
    2:     _openssl_assert(
    1:         _openssl.lib.OpenSSL_version_num() == openssl.openssl_version(),
           )
       
       
    1: _verify_package_version(cryptography.__version__)
       
    1: Binding.init_static_locks()
       
    1: if (
    1:     sys.platform == "win32"
>>>>>>     and os.environ.get("PROCESSOR_ARCHITEW6432") is not None
       ):
>>>>>>     warnings.warn(
>>>>>>         "You are using cryptography on a 32-bit Python on a 64-bit Windows "
               "Operating System. Cryptography will be significantly faster if you "
               "switch to using a 64-bit Python.",
>>>>>>         UserWarning,
>>>>>>         stacklevel=2,
           )
       
    4: if (
    1:     not openssl.CRYPTOGRAPHY_IS_LIBRESSL
    1:     and not openssl.CRYPTOGRAPHY_IS_BORINGSSL
    1:     and not openssl.CRYPTOGRAPHY_IS_AWSLC
    1:     and not openssl.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
       ):
>>>>>>     warnings.warn(
>>>>>>         "You are using OpenSSL < 3.0. Support for OpenSSL < 3.0 is deprecated "
               "and will be removed in the next release. Please upgrade to OpenSSL "
               "3.0 or later.",
>>>>>>         CryptographyDeprecationWarning,
>>>>>>         stacklevel=2,
           )
