    1: """Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python's typing module."""
    1: from __future__ import annotations as _annotations
       
    1: import dataclasses
    1: import sys
    1: import types
    1: import typing
    1: from collections.abc import Callable
    1: from functools import partial
    1: from types import GetSetDescriptorType
    1: from typing import TYPE_CHECKING, Any, Final
       
    1: from typing_extensions import Annotated, Literal, TypeAliasType, TypeGuard, get_args, get_origin
       
    1: if TYPE_CHECKING:
>>>>>>     from ._dataclasses import StandardDataclass
       
    1: try:
    1:     from typing import _TypingBase  # type: ignore[attr-defined]
    1: except ImportError:
    1:     from typing import _Final as _TypingBase  # type: ignore[attr-defined]
       
    1: typing_base = _TypingBase
       
       
    1: if sys.version_info < (3, 9):
           # python < 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)
>>>>>>     TypingGenericAlias = ()
       else:
    1:     from typing import GenericAlias as TypingGenericAlias  # type: ignore
       
       
    1: if sys.version_info < (3, 11):
    1:     from typing_extensions import NotRequired, Required
       else:
>>>>>>     from typing import NotRequired, Required  # noqa: F401
       
       
    1: if sys.version_info < (3, 10):
       
    1:     def origin_is_union(tp: type[Any] | None) -> bool:
 3776:         return tp is typing.Union
       
    1:     WithArgsTypes = (TypingGenericAlias,)
       
       else:
       
>>>>>>     def origin_is_union(tp: type[Any] | None) -> bool:
>>>>>>         return tp is typing.Union or tp is types.UnionType
       
>>>>>>     WithArgsTypes = typing._GenericAlias, types.GenericAlias, types.UnionType  # type: ignore[attr-defined]
       
       
    1: if sys.version_info < (3, 10):
    1:     NoneType = type(None)
    1:     EllipsisType = type(Ellipsis)
       else:
>>>>>>     from types import NoneType as NoneType
       
       
    1: LITERAL_TYPES: set[Any] = {Literal}
    1: if hasattr(typing, 'Literal'):
    1:     LITERAL_TYPES.add(typing.Literal)  # type: ignore
       
    4: NONE_TYPES: tuple[Any, ...] = (None, NoneType, *(tp[None] for tp in LITERAL_TYPES))
       
       
    1: TypeVarType = Any  # since mypy doesn't allow the use of TypeVar as a type
       
       
    1: def is_none_type(type_: Any) -> bool:
>>>>>>     return type_ in NONE_TYPES
       
       
    1: def is_callable_type(type_: type[Any]) -> bool:
 1239:     return type_ is Callable or get_origin(type_) is Callable
       
       
    1: def is_literal_type(type_: type[Any]) -> bool:
 1241:     return Literal is not None and get_origin(type_) in LITERAL_TYPES
       
       
    1: def literal_values(type_: type[Any]) -> tuple[Any, ...]:
    1:     return get_args(type_)
       
       
    1: def all_literal_values(type_: type[Any]) -> list[Any]:
           """This method is used to retrieve all Literal values as
           Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)
           e.g. `Literal[Literal[Literal[1, 2, 3], "foo"], 5, None]`.
           """
    2:     if not is_literal_type(type_):
    1:         return [type_]
       
    1:     values = literal_values(type_)
    4:     return list(x for value in values for x in all_literal_values(value))
       
       
    1: def is_annotated(ann_type: Any) -> bool:
  532:     from ._utils import lenient_issubclass
       
  532:     origin = get_origin(ann_type)
  532:     return origin is not None and lenient_issubclass(origin, Annotated)
       
       
    1: def is_namedtuple(type_: type[Any]) -> bool:
           """Check if a given class is a named tuple.
           It can be either a `typing.NamedTuple` or `collections.namedtuple`.
           """
 2221:     from ._utils import lenient_issubclass
       
 2221:     return lenient_issubclass(type_, tuple) and hasattr(type_, '_fields')
       
       
    1: test_new_type = typing.NewType('test_new_type', str)
       
       
    1: def is_new_type(type_: type[Any]) -> bool:
           """Check whether type_ was created using typing.NewType.
       
           Can't use isinstance because it fails <3.10.
           """
 1230:     return isinstance(type_, test_new_type.__class__) and hasattr(type_, '__supertype__')  # type: ignore[arg-type]
       
       
    1: def _check_classvar(v: type[Any] | None) -> bool:
  474:     if v is None:
   30:         return False
       
  444:     return v.__class__ == typing.ClassVar.__class__ and getattr(v, '_name', None) == 'ClassVar'
       
       
    1: def is_classvar(ann_type: type[Any]) -> bool:
  237:     if _check_classvar(ann_type) or _check_classvar(get_origin(ann_type)):
>>>>>>         return True
       
           # this is an ugly workaround for class vars that contain forward references and are therefore themselves
           # forward references, see #3679
  237:     if ann_type.__class__ == typing.ForwardRef and ann_type.__forward_arg__.startswith('ClassVar['):  # type: ignore
>>>>>>         return True
       
  237:     return False
       
       
    1: def _check_finalvar(v: type[Any] | None) -> bool:
           """Check if a given type is a `typing.Final` type."""
 3454:     if v is None:
   85:         return False
       
 3369:     return v.__class__ == Final.__class__ and (sys.version_info < (3, 8) or getattr(v, '_name', None) == 'Final')
       
       
    1: def is_finalvar(ann_type: Any) -> bool:
 1727:     return _check_finalvar(ann_type) or _check_finalvar(get_origin(ann_type))
       
       
    1: def parent_frame_namespace(*, parent_depth: int = 2) -> dict[str, Any] | None:
           """We allow use of items in parent namespace to get around the issue with `get_type_hints` only looking in the
           global module namespace. See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -> Scope
           and suggestion at the end of the next comment by @gvanrossum.
       
           WARNING 1: it matters exactly where this is called. By default, this function will build a namespace from the
           parent of where it is called.
       
           WARNING 2: this only looks in the parent namespace, not other parents since (AFAIK) there's no way to collect a
           dict of exactly what's in scope. Using `f_back` would work sometimes but would be very wrong and confusing in many
           other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.
           """
   83:     frame = sys._getframe(parent_depth)
           # if f_back is None, it's the global module namespace and we don't need to include it here
   83:     if frame.f_back is None:
>>>>>>         return None
           else:
   83:         return frame.f_locals
       
       
    1: def add_module_globals(obj: Any, globalns: dict[str, Any] | None = None) -> dict[str, Any]:
  122:     module_name = getattr(obj, '__module__', None)
  122:     if module_name:
  122:         try:
  122:             module_globalns = sys.modules[module_name].__dict__
>>>>>>         except KeyError:
                   # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363
>>>>>>             pass
               else:
  122:             if globalns:
   41:                 return {**module_globalns, **globalns}
                   else:
                       # copy module globals to make sure it can't be updated later
   81:                 return module_globalns.copy()
       
>>>>>>     return globalns or {}
       
       
    1: def get_cls_types_namespace(cls: type[Any], parent_namespace: dict[str, Any] | None = None) -> dict[str, Any]:
  122:     ns = add_module_globals(cls, parent_namespace)
  122:     ns[cls.__name__] = cls
  122:     return ns
       
       
    1: def get_cls_type_hints_lenient(obj: Any, globalns: dict[str, Any] | None = None) -> dict[str, Any]:
           """Collect annotations from a class, including those from parent classes.
       
           Unlike `typing.get_type_hints`, this function will not error if a forward reference is not resolvable.
           """
   40:     hints = {}
  172:     for base in reversed(obj.__mro__):
  132:         ann = base.__dict__.get('__annotations__')
  132:         localns = dict(vars(base))
  132:         if ann is not None and ann is not GetSetDescriptorType:
  334:             for name, value in ann.items():
  243:                 hints[name] = eval_type_lenient(value, globalns, localns)
   40:     return hints
       
       
    1: def eval_type_lenient(value: Any, globalns: dict[str, Any] | None = None, localns: dict[str, Any] | None = None) -> Any:
           """Behaves like typing._eval_type, except it won't raise an error if a forward reference can't be resolved."""
  271:     if value is None:
>>>>>>         value = NoneType
  271:     elif isinstance(value, str):
>>>>>>         value = _make_forward_ref(value, is_argument=False, is_class=True)
       
  271:     try:
  271:         return eval_type_backport(value, globalns, localns)
   27:     except NameError:
               # the point of this function is to be tolerant to this case
   27:         return value
       
       
    1: def eval_type_backport(
           value: Any, globalns: dict[str, Any] | None = None, localns: dict[str, Any] | None = None
       ) -> Any:
           """Like `typing._eval_type`, but falls back to the `eval_type_backport` package if it's
           installed to let older Python versions use newer typing features.
           Specifically, this transforms `X | Y` into `typing.Union[X, Y]`
           and `list[X]` into `typing.List[X]` etc. (for all the types made generic in PEP 585)
           if the original syntax is not supported in the current Python version.
           """
  309:     try:
  618:         return typing._eval_type(  # type: ignore
  309:             value, globalns, localns
               )
   33:     except TypeError as e:
>>>>>>         if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):
>>>>>>             raise
>>>>>>         try:
>>>>>>             from eval_type_backport import eval_type_backport
>>>>>>         except ImportError:
>>>>>>             raise TypeError(
>>>>>>                 f'You have a type annotation {value.__forward_arg__!r} '
                       f'which makes use of newer typing features than are supported in your version of Python. '
                       f'To handle this error, you should either remove the use of new syntax '
                       f'or install the `eval_type_backport` package.'
>>>>>>             ) from e
       
>>>>>>         return eval_type_backport(value, globalns, localns, try_default=False)
       
       
    1: def is_backport_fixable_error(e: TypeError) -> bool:
>>>>>>     msg = str(e)
>>>>>>     return msg.startswith('unsupported operand type(s) for |: ') or "' object is not subscriptable" in msg
       
       
    1: def get_function_type_hints(
    1:     function: Callable[..., Any], *, include_keys: set[str] | None = None, types_namespace: dict[str, Any] | None = None
       ) -> dict[str, Any]:
           """Like `typing.get_type_hints`, but doesn't convert `X` to `Optional[X]` if the default value is `None`, also
           copes with `partial`.
           """
>>>>>>     if isinstance(function, partial):
>>>>>>         annotations = function.func.__annotations__
           else:
>>>>>>         annotations = function.__annotations__
       
>>>>>>     globalns = add_module_globals(function)
>>>>>>     type_hints = {}
>>>>>>     for name, value in annotations.items():
>>>>>>         if include_keys is not None and name not in include_keys:
>>>>>>             continue
>>>>>>         if value is None:
>>>>>>             value = NoneType
>>>>>>         elif isinstance(value, str):
>>>>>>             value = _make_forward_ref(value)
       
>>>>>>         type_hints[name] = eval_type_backport(value, globalns, types_namespace)
       
>>>>>>     return type_hints
       
       
    1: if sys.version_info < (3, 9, 8) or (3, 10) <= sys.version_info < (3, 10, 1):
       
    2:     def _make_forward_ref(
               arg: Any,
               is_argument: bool = True,
               *,
    1:         is_class: bool = False,
           ) -> typing.ForwardRef:
               """Wrapper for ForwardRef that accounts for the `is_class` argument missing in older versions.
               The `module` argument is omitted as it breaks <3.9.8, =3.10.0 and isn't used in the calls below.
       
               See https://github.com/python/cpython/pull/28560 for some background.
               The backport happened on 3.9.8, see:
               https://github.com/pydantic/pydantic/discussions/6244#discussioncomment-6275458,
               and on 3.10.1 for the 3.10 branch, see:
               https://github.com/pydantic/pydantic/issues/6912
       
               Implemented as EAFP with memory.
               """
>>>>>>         return typing.ForwardRef(arg, is_argument)
       
       else:
>>>>>>     _make_forward_ref = typing.ForwardRef
       
       
    1: if sys.version_info >= (3, 10):
>>>>>>     get_type_hints = typing.get_type_hints
       
       else:
           """
           For older versions of python, we have a custom implementation of `get_type_hints` which is a close as possible to
           the implementation in CPython 3.10.8.
           """
       
    1:     @typing.no_type_check
    1:     def get_type_hints(  # noqa: C901
               obj: Any,
               globalns: dict[str, Any] | None = None,
               localns: dict[str, Any] | None = None,
               include_extras: bool = False,
           ) -> dict[str, Any]:  # pragma: no cover
               """Taken verbatim from python 3.10.8 unchanged, except:
               * type annotations of the function definition above.
               * prefixing `typing.` where appropriate
               * Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument.
       
               https://github.com/python/cpython/blob/aaaf5174241496afca7ce4d4584570190ff972fe/Lib/typing.py#L1773-L1875
       
               DO NOT CHANGE THIS METHOD UNLESS ABSOLUTELY NECESSARY.
               ======================================================
       
               Return type hints for an object.
       
               This is often the same as obj.__annotations__, but it handles
               forward references encoded as string literals, adds Optional[t] if a
               default value equal to None is set and recursively replaces all
               'Annotated[T, ...]' with 'T' (unless 'include_extras=True').
       
               The argument may be a module, class, method, or function. The annotations
               are returned as a dictionary. For classes, annotations include also
               inherited members.
       
               TypeError is raised if the argument is not of a type that can contain
               annotations, and an empty dictionary is returned if no annotations are
               present.
       
               BEWARE -- the behavior of globalns and localns is counterintuitive
               (unless you are familiar with how eval() and exec() work).  The
               search order is locals first, then globals.
       
               - If no dict arguments are passed, an attempt is made to use the
                 globals from obj (or the respective module's globals for classes),
                 and these are also used as the locals.  If the object does not appear
                 to have globals, an empty dictionary is used.  For classes, the search
                 order is globals first then locals.
       
               - If one dict argument is passed, it is used for both globals and
                 locals.
       
               - If two dict arguments are passed, they specify globals and
                 locals, respectively.
               """
    8:         if getattr(obj, '__no_type_check__', None):
>>>>>>             return {}
               # Classes require a special treatment.
    8:         if isinstance(obj, type):
    8:             hints = {}
   32:             for base in reversed(obj.__mro__):
   24:                 if globalns is None:
>>>>>>                     base_globals = getattr(sys.modules.get(base.__module__, None), '__dict__', {})
                       else:
   24:                     base_globals = globalns
   24:                 ann = base.__dict__.get('__annotations__', {})
   24:                 if isinstance(ann, types.GetSetDescriptorType):
>>>>>>                     ann = {}
   24:                 base_locals = dict(vars(base)) if localns is None else localns
   24:                 if localns is None and globalns is None:
                           # This is surprising, but required.  Before Python 3.10,
                           # get_type_hints only evaluated the globalns of
                           # a class.  To maintain backwards compatibility, we reverse
                           # the globalns and localns order so that eval() looks into
                           # *base_globals* first rather than *base_locals*.
                           # This only affects ForwardRefs.
>>>>>>                     base_globals, base_locals = base_locals, base_globals
   56:                 for name, value in ann.items():
   32:                     if value is None:
>>>>>>                         value = type(None)
   32:                     if isinstance(value, str):
>>>>>>                         value = _make_forward_ref(value, is_argument=False, is_class=True)
       
   32:                     value = eval_type_backport(value, base_globals, base_locals)
   32:                     hints[name] = value
    8:             if not include_extras and hasattr(typing, '_strip_annotations'):
>>>>>>                 return {
>>>>>>                     k: typing._strip_annotations(t)  # type: ignore
>>>>>>                     for k, t in hints.items()
                       }
                   else:
    8:                 return hints
       
>>>>>>         if globalns is None:
>>>>>>             if isinstance(obj, types.ModuleType):
>>>>>>                 globalns = obj.__dict__
                   else:
>>>>>>                 nsobj = obj
                       # Find globalns for the unwrapped object.
>>>>>>                 while hasattr(nsobj, '__wrapped__'):
>>>>>>                     nsobj = nsobj.__wrapped__
>>>>>>                 globalns = getattr(nsobj, '__globals__', {})
>>>>>>             if localns is None:
>>>>>>                 localns = globalns
>>>>>>         elif localns is None:
>>>>>>             localns = globalns
>>>>>>         hints = getattr(obj, '__annotations__', None)
>>>>>>         if hints is None:
                   # Return empty annotations for something that _could_ have them.
>>>>>>             if isinstance(obj, typing._allowed_types):  # type: ignore
>>>>>>                 return {}
                   else:
>>>>>>                 raise TypeError(f'{obj!r} is not a module, class, method, ' 'or function.')
>>>>>>         defaults = typing._get_defaults(obj)  # type: ignore
>>>>>>         hints = dict(hints)
>>>>>>         for name, value in hints.items():
>>>>>>             if value is None:
>>>>>>                 value = type(None)
>>>>>>             if isinstance(value, str):
                       # class-level forward refs were handled above, this must be either
                       # a module-level annotation or a function argument annotation
       
>>>>>>                 value = _make_forward_ref(
>>>>>>                     value,
>>>>>>                     is_argument=not isinstance(obj, types.ModuleType),
>>>>>>                     is_class=False,
                       )
>>>>>>             value = eval_type_backport(value, globalns, localns)
>>>>>>             if name in defaults and defaults[name] is None:
>>>>>>                 value = typing.Optional[value]
>>>>>>             hints[name] = value
>>>>>>         return hints if include_extras else {k: typing._strip_annotations(t) for k, t in hints.items()}  # type: ignore
       
       
    1: def is_dataclass(_cls: type[Any]) -> TypeGuard[type[StandardDataclass]]:
           # The dataclasses.is_dataclass function doesn't seem to provide TypeGuard functionality,
           # so I created this convenience function
 2210:     return dataclasses.is_dataclass(_cls)
       
       
    1: def origin_is_type_alias_type(origin: Any) -> TypeGuard[TypeAliasType]:
>>>>>>     return isinstance(origin, TypeAliasType)
       
       
    1: if sys.version_info >= (3, 10):
       
>>>>>>     def is_generic_alias(type_: type[Any]) -> bool:
>>>>>>         return isinstance(type_, (types.GenericAlias, typing._GenericAlias))  # type: ignore[attr-defined]
       
       else:
       
    1:     def is_generic_alias(type_: type[Any]) -> bool:
 3625:         return isinstance(type_, typing._GenericAlias)  # type: ignore
