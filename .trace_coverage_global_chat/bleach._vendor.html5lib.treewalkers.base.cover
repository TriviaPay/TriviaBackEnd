    1: from __future__ import absolute_import, division, unicode_literals
       
    1: from xml.dom import Node
    1: from ..constants import namespaces, voidElements, spaceCharacters
       
    1: __all__ = ["DOCUMENT", "DOCTYPE", "TEXT", "ELEMENT", "COMMENT", "ENTITY", "UNKNOWN",
                  "TreeWalker", "NonRecursiveTreeWalker"]
       
    1: DOCUMENT = Node.DOCUMENT_NODE
    1: DOCTYPE = Node.DOCUMENT_TYPE_NODE
    1: TEXT = Node.TEXT_NODE
    1: ELEMENT = Node.ELEMENT_NODE
    1: COMMENT = Node.COMMENT_NODE
    1: ENTITY = Node.ENTITY_NODE
    1: UNKNOWN = "<#UNKNOWN#>"
       
    1: spaceCharacters = "".join(spaceCharacters)
       
       
    2: class TreeWalker(object):
    1:     """Walks a tree yielding tokens
       
           Tokens are dicts that all have a ``type`` field specifying the type of the
           token.
       
           """
    1:     def __init__(self, tree):
               """Creates a TreeWalker
       
               :arg tree: the tree to walk
       
               """
    5:         self.tree = tree
       
    1:     def __iter__(self):
>>>>>>         raise NotImplementedError
       
    1:     def error(self, msg):
               """Generates an error token with the given message
       
               :arg msg: the error message
       
               :returns: SerializeError token
       
               """
>>>>>>         return {"type": "SerializeError", "data": msg}
       
    1:     def emptyTag(self, namespace, name, attrs, hasChildren=False):
               """Generates an EmptyTag token
       
               :arg namespace: the namespace of the token--can be ``None``
       
               :arg name: the name of the element
       
               :arg attrs: the attributes of the element as a dict
       
               :arg hasChildren: whether or not to yield a SerializationError because
                   this tag shouldn't have children
       
               :returns: EmptyTag token
       
               """
>>>>>>         yield {"type": "EmptyTag", "name": name,
>>>>>>                "namespace": namespace,
>>>>>>                "data": attrs}
>>>>>>         if hasChildren:
>>>>>>             yield self.error("Void element has children")
       
    1:     def startTag(self, namespace, name, attrs):
               """Generates a StartTag token
       
               :arg namespace: the namespace of the token--can be ``None``
       
               :arg name: the name of the element
       
               :arg attrs: the attributes of the element as a dict
       
               :returns: StartTag token
       
               """
>>>>>>         return {"type": "StartTag",
>>>>>>                 "name": name,
>>>>>>                 "namespace": namespace,
>>>>>>                 "data": attrs}
       
    1:     def endTag(self, namespace, name):
               """Generates an EndTag token
       
               :arg namespace: the namespace of the token--can be ``None``
       
               :arg name: the name of the element
       
               :returns: EndTag token
       
               """
>>>>>>         return {"type": "EndTag",
>>>>>>                 "name": name,
>>>>>>                 "namespace": namespace}
       
    1:     def text(self, data):
               """Generates SpaceCharacters and Characters tokens
       
               Depending on what's in the data, this generates one or more
               ``SpaceCharacters`` and ``Characters`` tokens.
       
               For example:
       
                   >>> from html5lib.treewalkers.base import TreeWalker
                   >>> # Give it an empty tree just so it instantiates
                   >>> walker = TreeWalker([])
                   >>> list(walker.text(''))
                   []
                   >>> list(walker.text('  '))
                   [{u'data': '  ', u'type': u'SpaceCharacters'}]
                   >>> list(walker.text(' abc '))  # doctest: +NORMALIZE_WHITESPACE
                   [{u'data': ' ', u'type': u'SpaceCharacters'},
                   {u'data': u'abc', u'type': u'Characters'},
                   {u'data': u' ', u'type': u'SpaceCharacters'}]
       
               :arg data: the text data
       
               :returns: one or more ``SpaceCharacters`` and ``Characters`` tokens
       
               """
    5:         data = data
    5:         middle = data.lstrip(spaceCharacters)
    5:         left = data[:len(data) - len(middle)]
    5:         if left:
>>>>>>             yield {"type": "SpaceCharacters", "data": left}
    5:         data = middle
    5:         middle = data.rstrip(spaceCharacters)
    5:         right = data[len(middle):]
    5:         if middle:
    5:             yield {"type": "Characters", "data": middle}
    5:         if right:
>>>>>>             yield {"type": "SpaceCharacters", "data": right}
       
    1:     def comment(self, data):
               """Generates a Comment token
       
               :arg data: the comment
       
               :returns: Comment token
       
               """
>>>>>>         return {"type": "Comment", "data": data}
       
    1:     def doctype(self, name, publicId=None, systemId=None):
               """Generates a Doctype token
       
               :arg name:
       
               :arg publicId:
       
               :arg systemId:
       
               :returns: the Doctype token
       
               """
>>>>>>         return {"type": "Doctype",
>>>>>>                 "name": name,
>>>>>>                 "publicId": publicId,
>>>>>>                 "systemId": systemId}
       
    1:     def entity(self, name):
               """Generates an Entity token
       
               :arg name: the entity name
       
               :returns: an Entity token
       
               """
>>>>>>         return {"type": "Entity", "name": name}
       
    1:     def unknown(self, nodeType):
               """Handles unknown node types"""
>>>>>>         return self.error("Unknown node type: " + nodeType)
       
       
    2: class NonRecursiveTreeWalker(TreeWalker):
    1:     def getNodeDetails(self, node):
>>>>>>         raise NotImplementedError
       
    1:     def getFirstChild(self, node):
>>>>>>         raise NotImplementedError
       
    1:     def getNextSibling(self, node):
>>>>>>         raise NotImplementedError
       
    1:     def getParentNode(self, node):
>>>>>>         raise NotImplementedError
       
    1:     def __iter__(self):
    5:         currentNode = self.tree
   15:         while currentNode is not None:
   10:             details = self.getNodeDetails(currentNode)
   10:             type, details = details[0], details[1:]
   10:             hasChildren = False
       
   10:             if type == DOCTYPE:
>>>>>>                 yield self.doctype(*details)
       
   10:             elif type == TEXT:
   10:                 for token in self.text(*details):
    5:                     yield token
       
    5:             elif type == ELEMENT:
>>>>>>                 namespace, name, attributes, hasChildren = details
>>>>>>                 if (not namespace or namespace == namespaces["html"]) and name in voidElements:
>>>>>>                     for token in self.emptyTag(namespace, name, attributes,
>>>>>>                                                hasChildren):
>>>>>>                         yield token
>>>>>>                     hasChildren = False
                       else:
>>>>>>                     yield self.startTag(namespace, name, attributes)
       
    5:             elif type == COMMENT:
>>>>>>                 yield self.comment(details[0])
       
    5:             elif type == ENTITY:
>>>>>>                 yield self.entity(details[0])
       
    5:             elif type == DOCUMENT:
    5:                 hasChildren = True
       
                   else:
>>>>>>                 yield self.unknown(details[0])
       
   10:             if hasChildren:
    5:                 firstChild = self.getFirstChild(currentNode)
                   else:
    5:                 firstChild = None
       
   10:             if firstChild is not None:
    5:                 currentNode = firstChild
                   else:
   10:                 while currentNode is not None:
   10:                     details = self.getNodeDetails(currentNode)
   10:                     type, details = details[0], details[1:]
   10:                     if type == ELEMENT:
>>>>>>                         namespace, name, attributes, hasChildren = details
>>>>>>                         if (namespace and namespace != namespaces["html"]) or name not in voidElements:
>>>>>>                             yield self.endTag(namespace, name)
   10:                     if self.tree is currentNode:
    5:                         currentNode = None
    5:                         break
    5:                     nextSibling = self.getNextSibling(currentNode)
    5:                     if nextSibling is not None:
>>>>>>                         currentNode = nextSibling
>>>>>>                         break
                           else:
    5:                         currentNode = self.getParentNode(currentNode)
