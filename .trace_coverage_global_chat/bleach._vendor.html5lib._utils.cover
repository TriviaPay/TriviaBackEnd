    1: from __future__ import absolute_import, division, unicode_literals
       
    1: from types import ModuleType
       
    1: try:
    1:     from collections.abc import Mapping
>>>>>> except ImportError:
>>>>>>     from collections import Mapping
       
    1: from bleach.six_shim import text_type, PY3
       
    1: if PY3:
    1:     import xml.etree.ElementTree as default_etree
       else:
>>>>>>     try:
>>>>>>         import xml.etree.cElementTree as default_etree
>>>>>>     except ImportError:
>>>>>>         import xml.etree.ElementTree as default_etree
       
       
    1: __all__ = ["default_etree", "MethodDispatcher", "isSurrogatePair",
                  "surrogatePairToCodepoint", "moduleFactoryFactory",
                  "supports_lone_surrogates"]
       
       
       # Platforms not supporting lone surrogates (\uD800-\uDFFF) should be
       # caught by the below test. In general this would be any platform
       # using UTF-16 as its encoding of unicode strings, such as
       # Jython. This is because UTF-16 itself is based on the use of such
       # surrogates, and there is no mechanism to further escape such
       # escapes.
    1: try:
    1:     _x = eval('"\\uD800"')  # pylint:disable=eval-used
    1:     if not isinstance(_x, text_type):
               # We need this with u"" because of http://bugs.jython.org/issue2039
>>>>>>         _x = eval('u"\\uD800"')  # pylint:disable=eval-used
>>>>>>         assert isinstance(_x, text_type)
>>>>>> except Exception:
>>>>>>     supports_lone_surrogates = False
       else:
    1:     supports_lone_surrogates = True
       
       
    2: class MethodDispatcher(dict):
    1:     """Dict with 2 special properties:
       
           On initiation, keys that are lists, sets or tuples are converted to
           multiple keys so accessing any one of the items in the original
           list-like object returns the matching value
       
           md = MethodDispatcher({("foo", "bar"):"baz"})
           md["foo"] == "baz"
       
           A default value which can be set through the default attribute.
           """
       
    1:     def __init__(self, items=()):
   36:         _dictEntries = []
  168:         for name, value in items:
  132:             if isinstance(name, (list, tuple, frozenset, set)):
  333:                 for item in name:
  286:                     _dictEntries.append((item, value))
                   else:
   85:                 _dictEntries.append((name, value))
   36:         dict.__init__(self, _dictEntries)
   36:         assert len(self) == len(_dictEntries)
   36:         self.default = None
       
    1:     def __getitem__(self, key):
>>>>>>         return dict.get(self, key, self.default)
       
    1:     def __get__(self, instance, owner=None):
>>>>>>         return BoundMethodDispatcher(instance, self)
       
       
    2: class BoundMethodDispatcher(Mapping):
    1:     """Wraps a MethodDispatcher, binding its return values to `instance`"""
    1:     def __init__(self, instance, dispatcher):
>>>>>>         self.instance = instance
>>>>>>         self.dispatcher = dispatcher
       
    1:     def __getitem__(self, key):
               # see https://docs.python.org/3/reference/datamodel.html#object.__get__
               # on a function, __get__ is used to bind a function to an instance as a bound method
>>>>>>         return self.dispatcher[key].__get__(self.instance)
       
    1:     def get(self, key, default):
>>>>>>         if key in self.dispatcher:
>>>>>>             return self[key]
               else:
>>>>>>             return default
       
    1:     def __iter__(self):
>>>>>>         return iter(self.dispatcher)
       
    1:     def __len__(self):
>>>>>>         return len(self.dispatcher)
       
    1:     def __contains__(self, key):
>>>>>>         return key in self.dispatcher
       
       
       # Some utility functions to deal with weirdness around UCS2 vs UCS4
       # python builds
       
    1: def isSurrogatePair(data):
>>>>>>     return (len(data) == 2 and
>>>>>>             ord(data[0]) >= 0xD800 and ord(data[0]) <= 0xDBFF and
>>>>>>             ord(data[1]) >= 0xDC00 and ord(data[1]) <= 0xDFFF)
       
       
    1: def surrogatePairToCodepoint(data):
>>>>>>     char_val = (0x10000 + (ord(data[0]) - 0xD800) * 0x400 +
>>>>>>                 (ord(data[1]) - 0xDC00))
>>>>>>     return char_val
       
       # Module Factory Factory (no, this isn't Java, I know)
       # Here to stop this being duplicated all over the place.
       
       
    1: def moduleFactoryFactory(factory):
    2:     moduleCache = {}
       
    2:     def moduleFactory(baseModule, *args, **kwargs):
   10:         if isinstance(ModuleType.__name__, type("")):
   10:             name = "_%s_factory" % baseModule.__name__
               else:
>>>>>>             name = b"_%s_factory" % baseModule.__name__
       
   10:         kwargs_tuple = tuple(kwargs.items())
       
   10:         try:
   10:             return moduleCache[name][args][kwargs_tuple]
    2:         except KeyError:
    2:             mod = ModuleType(name)
    2:             objs = factory(baseModule, *args, **kwargs)
    2:             mod.__dict__.update(objs)
    2:             if "name" not in moduleCache:
    2:                 moduleCache[name] = {}
    2:             if "args" not in moduleCache[name]:
    2:                 moduleCache[name][args] = {}
    2:             if "kwargs" not in moduleCache[name][args]:
    2:                 moduleCache[name][args][kwargs_tuple] = {}
    2:             moduleCache[name][args][kwargs_tuple] = mod
    2:             return mod
       
    2:     return moduleFactory
       
       
    1: def memoize(func):
    1:     cache = {}
       
    1:     def wrapped(*args, **kwargs):
    5:         key = (tuple(args), tuple(kwargs.items()))
    5:         if key not in cache:
    1:             cache[key] = func(*args, **kwargs)
    5:         return cache[key]
       
    1:     return wrapped
