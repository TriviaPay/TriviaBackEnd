    1: import pusher
    1: from config import PUSHER_ENABLED, PUSHER_APP_ID, PUSHER_KEY, PUSHER_SECRET, PUSHER_CLUSTER
    1: import logging
    1: from typing import Optional, Dict, Any
    1: import asyncio
    1: from concurrent.futures import ThreadPoolExecutor
       
    1: logger = logging.getLogger(__name__)
       
    1: _pusher_client: Optional[pusher.Pusher] = None
    1: _executor = ThreadPoolExecutor(max_workers=5)
       
       
    1: def get_pusher_client() -> Optional[pusher.Pusher]:
           """Get or create Pusher client instance"""
           global _pusher_client
           
    1:     if not PUSHER_ENABLED:
>>>>>>         return None
           
    1:     if _pusher_client is None:
    1:         try:
    1:             if not all([PUSHER_APP_ID, PUSHER_KEY, PUSHER_SECRET]):
>>>>>>                 logger.warning("Pusher credentials not fully configured")
>>>>>>                 return None
                   
    2:             _pusher_client = pusher.Pusher(
    1:                 app_id=PUSHER_APP_ID,
    1:                 key=PUSHER_KEY,
    1:                 secret=PUSHER_SECRET,
    1:                 cluster=PUSHER_CLUSTER,
    1:                 ssl=True
                   )
    1:             logger.info("Pusher client initialized")
>>>>>>         except Exception as e:
>>>>>>             logger.error(f"Failed to initialize Pusher: {e}")
>>>>>>             return None
           
    1:     return _pusher_client
       
       
    1: async def publish_chat_message_async(channel: str, event: str, data: Dict[str, Any]) -> bool:
           """
           Publish message to Pusher channel asynchronously.
           Uses thread pool to avoid blocking the event loop.
           """
>>>>>>     client = get_pusher_client()
>>>>>>     if not client:
>>>>>>         logger.debug("Pusher not available, message not published")
>>>>>>         return False
           
>>>>>>     def _publish():
>>>>>>         try:
>>>>>>             client.trigger(channel, event, data)
>>>>>>             return True
>>>>>>         except Exception as e:
>>>>>>             logger.error(f"Failed to publish to Pusher channel {channel}: {e}")
>>>>>>             return False
           
>>>>>>     try:
>>>>>>         loop = asyncio.get_event_loop()
>>>>>>         result = await loop.run_in_executor(_executor, _publish)
>>>>>>         return result
>>>>>>     except Exception as e:
>>>>>>         logger.error(f"Error in async Pusher publish: {e}")
>>>>>>         return False
       
       
    1: def publish_chat_message_sync(channel: str, event: str, data: Dict[str, Any]) -> bool:
           """
           Synchronous version for use in background tasks.
           Background tasks run in a separate thread, so sync is fine.
           """
    1:     client = get_pusher_client()
    1:     if not client:
>>>>>>         logger.debug("Pusher not available, message not published")
>>>>>>         return False
           
    1:     try:
    1:         client.trigger(channel, event, data)
    1:         return True
>>>>>>     except Exception as e:
>>>>>>         logger.error(f"Failed to publish to Pusher channel {channel}: {e}")
>>>>>>         return False
       
