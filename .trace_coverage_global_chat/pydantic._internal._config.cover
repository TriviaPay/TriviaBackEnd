    1: from __future__ import annotations as _annotations
       
    1: import warnings
    1: from contextlib import contextmanager
    1: from typing import (
           TYPE_CHECKING,
           Any,
           Callable,
           cast,
       )
       
    1: from pydantic_core import core_schema
    1: from typing_extensions import (
           Literal,
           Self,
       )
       
    1: from ..aliases import AliasGenerator
    1: from ..config import ConfigDict, ExtraValues, JsonDict, JsonEncoder, JsonSchemaExtraCallable
    1: from ..errors import PydanticUserError
    1: from ..warnings import PydanticDeprecatedSince20
       
    1: if not TYPE_CHECKING:
           # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915
           # and https://youtrack.jetbrains.com/issue/PY-51428
    1:     DeprecationWarning = PydanticDeprecatedSince20
       
    1: if TYPE_CHECKING:
>>>>>>     from .._internal._schema_generation_shared import GenerateSchema
       
    1: DEPRECATION_MESSAGE = 'Support for class-based `config` is deprecated, use ConfigDict instead.'
       
       
    2: class ConfigWrapper:
    1:     """Internal wrapper for Config which exposes ConfigDict items as attributes."""
       
    1:     __slots__ = ('config_dict',)
       
    1:     config_dict: ConfigDict
       
           # all annotations are copied directly from ConfigDict, and should be kept up to date, a test will fail if they
           # stop matching
    1:     title: str | None
    1:     str_to_lower: bool
    1:     str_to_upper: bool
    1:     str_strip_whitespace: bool
    1:     str_min_length: int
    1:     str_max_length: int | None
    1:     extra: ExtraValues | None
    1:     frozen: bool
    1:     populate_by_name: bool
    1:     use_enum_values: bool
    1:     validate_assignment: bool
    1:     arbitrary_types_allowed: bool
    1:     from_attributes: bool
           # whether to use the actual key provided in the data (e.g. alias or first alias for "field required" errors) instead of field_names
           # to construct error `loc`s, default `True`
    1:     loc_by_alias: bool
    1:     alias_generator: Callable[[str], str] | AliasGenerator | None
    1:     ignored_types: tuple[type, ...]
    1:     allow_inf_nan: bool
    1:     json_schema_extra: JsonDict | JsonSchemaExtraCallable | None
    1:     json_encoders: dict[type[object], JsonEncoder] | None
       
           # new in V2
    1:     strict: bool
           # whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'
    1:     revalidate_instances: Literal['always', 'never', 'subclass-instances']
    1:     ser_json_timedelta: Literal['iso8601', 'float']
    1:     ser_json_bytes: Literal['utf8', 'base64']
    1:     ser_json_inf_nan: Literal['null', 'constants']
           # whether to validate default values during validation, default False
    1:     validate_default: bool
    1:     validate_return: bool
    1:     protected_namespaces: tuple[str, ...]
    1:     hide_input_in_errors: bool
    1:     defer_build: bool
    1:     plugin_settings: dict[str, object] | None
    1:     schema_generator: type[GenerateSchema] | None
    1:     json_schema_serialization_defaults_required: bool
    1:     json_schema_mode_override: Literal['validation', 'serialization', None]
    1:     coerce_numbers_to_str: bool
    1:     regex_engine: Literal['rust-regex', 'python-re']
    1:     validation_error_cause: bool
       
    1:     def __init__(self, config: ConfigDict | dict[str, Any] | type[Any] | None, *, check: bool = True):
  164:         if check:
   82:             self.config_dict = prepare_config(config)
               else:
   82:             self.config_dict = cast(ConfigDict, config)
       
    1:     @classmethod
    1:     def for_model(cls, bases: tuple[type[Any], ...], namespace: dict[str, Any], kwargs: dict[str, Any]) -> Self:
               """Build a new `ConfigWrapper` instance for a `BaseModel`.
       
               The config wrapper built based on (in descending order of priority):
               - options from `kwargs`
               - options from the `namespace`
               - options from the base classes (`bases`)
       
               Args:
                   bases: A tuple of base classes.
                   namespace: The namespace of the class being created.
                   kwargs: The kwargs passed to the class being created.
       
               Returns:
                   A `ConfigWrapper` instance for `BaseModel`.
               """
   40:         config_new = ConfigDict()
   80:         for base in bases:
   40:             config = getattr(base, 'model_config', None)
   40:             if config:
   11:                 config_new.update(config.copy())
       
   40:         config_class_from_namespace = namespace.get('Config')
   40:         config_dict_from_namespace = namespace.get('model_config')
       
   40:         if config_class_from_namespace and config_dict_from_namespace:
>>>>>>             raise PydanticUserError('"Config" and "model_config" cannot be used together', code='config-both')
       
   40:         config_from_namespace = config_dict_from_namespace or prepare_config(config_class_from_namespace)
       
   40:         config_new.update(config_from_namespace)
       
   40:         for k in list(kwargs.keys()):
>>>>>>             if k in config_keys:
>>>>>>                 config_new[k] = kwargs.pop(k)
       
   40:         return cls(config_new)
       
           # we don't show `__getattr__` to type checkers so missing attributes cause errors
    1:     if not TYPE_CHECKING:  # pragma: no branch
       
    1:         def __getattr__(self, name: str) -> Any:
 4243:             try:
 4243:                 return self.config_dict[name]
 4210:             except KeyError:
 4210:                 try:
 4210:                     return config_defaults[name]
>>>>>>                 except KeyError:
>>>>>>                     raise AttributeError(f'Config has no attribute {name!r}') from None
       
    1:     def core_config(self, obj: Any) -> core_schema.CoreConfig:
               """Create a pydantic-core config, `obj` is just used to populate `title` if not set in config.
       
               Pass `obj=None` if you do not want to attempt to infer the `title`.
       
               We don't use getattr here since we don't want to populate with defaults.
       
               Args:
                   obj: An object used to populate `title` if not set in config.
       
               Returns:
                   A `CoreConfig` object created from config.
               """
       
  158:         def dict_not_none(**kwargs: Any) -> Any:
 3634:             return {k: v for k, v in kwargs.items() if v is not None}
       
  316:         core_config = core_schema.CoreConfig(
  316:             **dict_not_none(
  158:                 title=self.config_dict.get('title') or (obj and obj.__name__),
  158:                 extra_fields_behavior=self.config_dict.get('extra'),
  158:                 allow_inf_nan=self.config_dict.get('allow_inf_nan'),
  158:                 populate_by_name=self.config_dict.get('populate_by_name'),
  158:                 str_strip_whitespace=self.config_dict.get('str_strip_whitespace'),
  158:                 str_to_lower=self.config_dict.get('str_to_lower'),
  158:                 str_to_upper=self.config_dict.get('str_to_upper'),
  158:                 strict=self.config_dict.get('strict'),
  158:                 ser_json_timedelta=self.config_dict.get('ser_json_timedelta'),
  158:                 ser_json_bytes=self.config_dict.get('ser_json_bytes'),
  158:                 ser_json_inf_nan=self.config_dict.get('ser_json_inf_nan'),
  158:                 from_attributes=self.config_dict.get('from_attributes'),
  158:                 loc_by_alias=self.config_dict.get('loc_by_alias'),
  158:                 revalidate_instances=self.config_dict.get('revalidate_instances'),
  158:                 validate_default=self.config_dict.get('validate_default'),
  158:                 str_max_length=self.config_dict.get('str_max_length'),
  158:                 str_min_length=self.config_dict.get('str_min_length'),
  158:                 hide_input_in_errors=self.config_dict.get('hide_input_in_errors'),
  158:                 coerce_numbers_to_str=self.config_dict.get('coerce_numbers_to_str'),
  158:                 regex_engine=self.config_dict.get('regex_engine'),
  158:                 validation_error_cause=self.config_dict.get('validation_error_cause'),
                   )
               )
  158:         return core_config
       
    1:     def __repr__(self):
>>>>>>         c = ', '.join(f'{k}={v!r}' for k, v in self.config_dict.items())
>>>>>>         return f'ConfigWrapper({c})'
       
       
    2: class ConfigWrapperStack:
    1:     """A stack of `ConfigWrapper` instances."""
       
    1:     def __init__(self, config_wrapper: ConfigWrapper):
   85:         self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]
       
    1:     @property
    1:     def tail(self) -> ConfigWrapper:
21125:         return self._config_wrapper_stack[-1]
       
    1:     @contextmanager
    1:     def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):
   79:         if config_wrapper is None:
>>>>>>             yield
>>>>>>             return
       
   79:         if not isinstance(config_wrapper, ConfigWrapper):
    8:             config_wrapper = ConfigWrapper(config_wrapper, check=False)
       
   79:         self._config_wrapper_stack.append(config_wrapper)
   79:         try:
   79:             yield
               finally:
   79:             self._config_wrapper_stack.pop()
       
       
    2: config_defaults = ConfigDict(
    1:     title=None,
    1:     str_to_lower=False,
    1:     str_to_upper=False,
    1:     str_strip_whitespace=False,
    1:     str_min_length=0,
    1:     str_max_length=None,
           # let the model / dataclass decide how to handle it
    1:     extra=None,
    1:     frozen=False,
    1:     populate_by_name=False,
    1:     use_enum_values=False,
    1:     validate_assignment=False,
    1:     arbitrary_types_allowed=False,
    1:     from_attributes=False,
    1:     loc_by_alias=True,
    1:     alias_generator=None,
    1:     ignored_types=(),
    1:     allow_inf_nan=True,
    1:     json_schema_extra=None,
    1:     strict=False,
    1:     revalidate_instances='never',
    1:     ser_json_timedelta='iso8601',
    1:     ser_json_bytes='utf8',
    1:     ser_json_inf_nan='null',
    1:     validate_default=False,
    1:     validate_return=False,
    1:     protected_namespaces=('model_',),
    1:     hide_input_in_errors=False,
    1:     json_encoders=None,
    1:     defer_build=False,
    1:     plugin_settings=None,
    1:     schema_generator=None,
    1:     json_schema_serialization_defaults_required=False,
    1:     json_schema_mode_override=None,
    1:     coerce_numbers_to_str=False,
    1:     regex_engine='rust-regex',
    1:     validation_error_cause=False,
       )
       
       
    1: def prepare_config(config: ConfigDict | dict[str, Any] | type[Any] | None) -> ConfigDict:
           """Create a `ConfigDict` instance from an existing dict, a class (e.g. old class-based config) or None.
       
           Args:
               config: The input config.
       
           Returns:
               A ConfigDict object created from config.
           """
  100:     if config is None:
   60:         return ConfigDict()
       
   40:     if not isinstance(config, dict):
>>>>>>         warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)
>>>>>>         config = {k: getattr(config, k) for k in dir(config) if not k.startswith('__')}
       
   40:     config_dict = cast(ConfigDict, config)
   40:     check_deprecated(config_dict)
   40:     return config_dict
       
       
    1: config_keys = set(ConfigDict.__annotations__.keys())
       
       
    1: V2_REMOVED_KEYS = {
           'allow_mutation',
           'error_msg_templates',
           'fields',
           'getter_dict',
           'smart_union',
           'underscore_attrs_are_private',
           'json_loads',
           'json_dumps',
           'copy_on_model_validation',
           'post_init_call',
       }
    1: V2_RENAMED_KEYS = {
    1:     'allow_population_by_field_name': 'populate_by_name',
    1:     'anystr_lower': 'str_to_lower',
    1:     'anystr_strip_whitespace': 'str_strip_whitespace',
    1:     'anystr_upper': 'str_to_upper',
    1:     'keep_untouched': 'ignored_types',
    1:     'max_anystr_length': 'str_max_length',
    1:     'min_anystr_length': 'str_min_length',
    1:     'orm_mode': 'from_attributes',
    1:     'schema_extra': 'json_schema_extra',
    1:     'validate_all': 'validate_default',
       }
       
       
    1: def check_deprecated(config_dict: ConfigDict) -> None:
           """Check for deprecated config keys and warn the user.
       
           Args:
               config_dict: The input config.
           """
   40:     deprecated_removed_keys = V2_REMOVED_KEYS & config_dict.keys()
   40:     deprecated_renamed_keys = V2_RENAMED_KEYS.keys() & config_dict.keys()
   40:     if deprecated_removed_keys or deprecated_renamed_keys:
>>>>>>         renamings = {k: V2_RENAMED_KEYS[k] for k in sorted(deprecated_renamed_keys)}
>>>>>>         renamed_bullets = [f'* {k!r} has been renamed to {v!r}' for k, v in renamings.items()]
>>>>>>         removed_bullets = [f'* {k!r} has been removed' for k in sorted(deprecated_removed_keys)]
>>>>>>         message = '\n'.join(['Valid config keys have changed in V2:'] + renamed_bullets + removed_bullets)
>>>>>>         warnings.warn(message, UserWarning)
