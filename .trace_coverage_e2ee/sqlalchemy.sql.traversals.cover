       # sql/traversals.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       # mypy: allow-untyped-defs, allow-untyped-calls
       
    1: from __future__ import annotations
       
    1: from collections import deque
    1: import collections.abc as collections_abc
    1: import itertools
    1: from itertools import zip_longest
    1: import operator
    1: import typing
    1: from typing import Any
    1: from typing import Callable
    1: from typing import Deque
    1: from typing import Dict
    1: from typing import Iterable
    1: from typing import Optional
    1: from typing import Set
    1: from typing import Tuple
    1: from typing import Type
       
    1: from . import operators
    1: from .cache_key import HasCacheKey
    1: from .visitors import _TraverseInternalsType
    1: from .visitors import anon_map
    1: from .visitors import ExternallyTraversible
    1: from .visitors import HasTraversalDispatch
    1: from .visitors import HasTraverseInternals
    1: from .. import util
    1: from ..util import langhelpers
    1: from ..util.typing import Self
       
       
    1: SKIP_TRAVERSE = util.symbol("skip_traverse")
    1: COMPARE_FAILED = False
    1: COMPARE_SUCCEEDED = True
       
       
    1: def compare(obj1: Any, obj2: Any, **kw: Any) -> bool:
           strategy: TraversalComparatorStrategy
  224:     if kw.get("use_proxies", False):
   50:         strategy = ColIdentityComparatorStrategy()
           else:
  174:         strategy = TraversalComparatorStrategy()
       
  224:     return strategy.compare(obj1, obj2, **kw)
       
       
    1: def _preconfigure_traversals(target_hierarchy: Type[Any]) -> None:
>>>>>>     for cls in util.walk_subclasses(target_hierarchy):
>>>>>>         if hasattr(cls, "_generate_cache_attrs") and hasattr(
>>>>>>             cls, "_traverse_internals"
               ):
>>>>>>             cls._generate_cache_attrs()
>>>>>>             _copy_internals.generate_dispatch(
>>>>>>                 cls,
>>>>>>                 cls._traverse_internals,
>>>>>>                 "_generated_copy_internals_traversal",
                   )
>>>>>>             _get_children.generate_dispatch(
>>>>>>                 cls,
>>>>>>                 cls._traverse_internals,
>>>>>>                 "_generated_get_children_traversal",
                   )
       
       
    2: class HasShallowCopy(HasTraverseInternals):
    1:     """attribute-wide operations that are useful for classes that use
           __slots__ and therefore can't operate on their attributes in a dictionary.
       
       
           """
       
    1:     __slots__ = ()
       
    1:     if typing.TYPE_CHECKING:
       
>>>>>>         def _generated_shallow_copy_traversal(self, other: Self) -> None: ...
       
>>>>>>         def _generated_shallow_from_dict_traversal(
                   self, d: Dict[str, Any]
>>>>>>         ) -> None: ...
       
>>>>>>         def _generated_shallow_to_dict_traversal(self) -> Dict[str, Any]: ...
       
    1:     @classmethod
    1:     def _generate_shallow_copy(
               cls,
               internal_dispatch: _TraverseInternalsType,
               method_name: str,
           ) -> Callable[[Self, Self], None]:
>>>>>>         code = "\n".join(
>>>>>>             f"    other.{attrname} = self.{attrname}"
>>>>>>             for attrname, _ in internal_dispatch
               )
>>>>>>         meth_text = f"def {method_name}(self, other):\n{code}\n"
>>>>>>         return langhelpers._exec_code_in_env(meth_text, {}, method_name)
       
    1:     @classmethod
    1:     def _generate_shallow_to_dict(
               cls,
               internal_dispatch: _TraverseInternalsType,
               method_name: str,
           ) -> Callable[[Self], Dict[str, Any]]:
>>>>>>         code = ",\n".join(
>>>>>>             f"    '{attrname}': self.{attrname}"
>>>>>>             for attrname, _ in internal_dispatch
               )
>>>>>>         meth_text = f"def {method_name}(self):\n    return {{{code}}}\n"
>>>>>>         return langhelpers._exec_code_in_env(meth_text, {}, method_name)
       
    1:     @classmethod
    1:     def _generate_shallow_from_dict(
               cls,
               internal_dispatch: _TraverseInternalsType,
               method_name: str,
           ) -> Callable[[Self, Dict[str, Any]], None]:
>>>>>>         code = "\n".join(
>>>>>>             f"    self.{attrname} = d['{attrname}']"
>>>>>>             for attrname, _ in internal_dispatch
               )
>>>>>>         meth_text = f"def {method_name}(self, d):\n{code}\n"
>>>>>>         return langhelpers._exec_code_in_env(meth_text, {}, method_name)
       
    1:     def _shallow_from_dict(self, d: Dict[str, Any]) -> None:
>>>>>>         cls = self.__class__
       
               shallow_from_dict: Callable[[HasShallowCopy, Dict[str, Any]], None]
>>>>>>         try:
>>>>>>             shallow_from_dict = cls.__dict__[
>>>>>>                 "_generated_shallow_from_dict_traversal"
                   ]
>>>>>>         except KeyError:
>>>>>>             shallow_from_dict = self._generate_shallow_from_dict(
>>>>>>                 cls._traverse_internals,
>>>>>>                 "_generated_shallow_from_dict_traversal",
                   )
       
>>>>>>             cls._generated_shallow_from_dict_traversal = shallow_from_dict  # type: ignore  # noqa: E501
       
>>>>>>         shallow_from_dict(self, d)
       
    1:     def _shallow_to_dict(self) -> Dict[str, Any]:
>>>>>>         cls = self.__class__
       
               shallow_to_dict: Callable[[HasShallowCopy], Dict[str, Any]]
       
>>>>>>         try:
>>>>>>             shallow_to_dict = cls.__dict__[
>>>>>>                 "_generated_shallow_to_dict_traversal"
                   ]
>>>>>>         except KeyError:
>>>>>>             shallow_to_dict = self._generate_shallow_to_dict(
>>>>>>                 cls._traverse_internals, "_generated_shallow_to_dict_traversal"
                   )
       
>>>>>>             cls._generated_shallow_to_dict_traversal = shallow_to_dict  # type: ignore  # noqa: E501
>>>>>>         return shallow_to_dict(self)
       
    1:     def _shallow_copy_to(self, other: Self) -> None:
>>>>>>         cls = self.__class__
       
               shallow_copy: Callable[[Self, Self], None]
>>>>>>         try:
>>>>>>             shallow_copy = cls.__dict__["_generated_shallow_copy_traversal"]
>>>>>>         except KeyError:
>>>>>>             shallow_copy = self._generate_shallow_copy(
>>>>>>                 cls._traverse_internals, "_generated_shallow_copy_traversal"
                   )
       
>>>>>>             cls._generated_shallow_copy_traversal = shallow_copy  # type: ignore  # noqa: E501
>>>>>>         shallow_copy(self, other)
       
    1:     def _clone(self, **kw: Any) -> Self:
               """Create a shallow copy"""
>>>>>>         c = self.__class__.__new__(self.__class__)
>>>>>>         self._shallow_copy_to(c)
>>>>>>         return c
       
       
    2: class GenerativeOnTraversal(HasShallowCopy):
    1:     """Supplies Generative behavior but making use of traversals to shallow
           copy.
       
           .. seealso::
       
               :class:`sqlalchemy.sql.base.Generative`
       
       
           """
       
    1:     __slots__ = ()
       
    1:     def _generate(self) -> Self:
>>>>>>         cls = self.__class__
>>>>>>         s = cls.__new__(cls)
>>>>>>         self._shallow_copy_to(s)
>>>>>>         return s
       
       
    1: def _clone(element, **kw):
>>>>>>     return element._clone()
       
       
    2: class HasCopyInternals(HasTraverseInternals):
    1:     __slots__ = ()
       
    1:     def _clone(self, **kw):
>>>>>>         raise NotImplementedError()
       
    1:     def _copy_internals(
    1:         self, *, omit_attrs: Iterable[str] = (), **kw: Any
           ) -> None:
               """Reassign internal elements to be clones of themselves.
       
               Called during a copy-and-traverse operation on newly
               shallow-copied elements to create a deep copy.
       
               The given clone function should be used, which may be applying
               additional transformations to the element (i.e. replacement
               traversal, cloned traversal, annotations).
       
               """
       
  827:         try:
  827:             traverse_internals = self._traverse_internals
>>>>>>         except AttributeError:
                   # user-defined classes may not have a _traverse_internals
>>>>>>             return
       
 3242:         for attrname, obj, meth in _copy_internals.run_generated_dispatch(
  827:             self, traverse_internals, "_generated_copy_internals_traversal"
               ):
 1588:             if attrname in omit_attrs:
>>>>>>                 continue
       
 1588:             if obj is not None:
 1588:                 result = meth(attrname, self, obj, **kw)
 1588:                 if result is not None:
 1588:                     setattr(self, attrname, result)
       
       
    2: class _CopyInternalsTraversal(HasTraversalDispatch):
    1:     """Generate a _copy_internals internal traversal dispatch for classes
           with a _traverse_internals collection."""
       
    1:     def visit_clauseelement(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
 1584:         return clone(element, **kw)
       
    1:     def visit_clauseelement_list(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
   12:         return [clone(clause, **kw) for clause in element]
       
    1:     def visit_clauseelement_tuple(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
>>>>>>         return tuple([clone(clause, **kw) for clause in element])
       
    1:     def visit_executable_options(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
>>>>>>         return tuple([clone(clause, **kw) for clause in element])
       
    1:     def visit_clauseelement_unordered_set(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
>>>>>>         return {clone(clause, **kw) for clause in element}
       
    1:     def visit_clauseelement_tuples(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
>>>>>>         return [
>>>>>>             tuple(clone(tup_elem, **kw) for tup_elem in elem)
>>>>>>             for elem in element
               ]
       
    1:     def visit_string_clauseelement_dict(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
>>>>>>         return {key: clone(value, **kw) for key, value in element.items()}
       
    1:     def visit_setup_join_tuple(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
>>>>>>         return tuple(
>>>>>>             (
>>>>>>                 clone(target, **kw) if target is not None else None,
>>>>>>                 clone(onclause, **kw) if onclause is not None else None,
>>>>>>                 clone(from_, **kw) if from_ is not None else None,
>>>>>>                 flags,
                   )
>>>>>>             for (target, onclause, from_, flags) in element
               )
       
    1:     def visit_memoized_select_entities(self, attrname, parent, element, **kw):
>>>>>>         return self.visit_clauseelement_tuple(attrname, parent, element, **kw)
       
    1:     def visit_dml_ordered_values(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
               # sequence of 2-tuples
>>>>>>         return [
>>>>>>             (
                       (
>>>>>>                     clone(key, **kw)
>>>>>>                     if hasattr(key, "__clause_element__")
>>>>>>                     else key
                       ),
>>>>>>                 clone(value, **kw),
                   )
>>>>>>             for key, value in element
               ]
       
    1:     def visit_dml_values(self, attrname, parent, element, clone=_clone, **kw):
>>>>>>         return {
                   (
>>>>>>                 clone(key, **kw) if hasattr(key, "__clause_element__") else key
>>>>>>             ): clone(value, **kw)
>>>>>>             for key, value in element.items()
               }
       
    1:     def visit_dml_multi_values(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
               # sequence of sequences, each sequence contains a list/dict/tuple
       
>>>>>>         def copy(elem):
>>>>>>             if isinstance(elem, (list, tuple)):
>>>>>>                 return [
                           (
>>>>>>                         clone(value, **kw)
>>>>>>                         if hasattr(value, "__clause_element__")
>>>>>>                         else value
                           )
>>>>>>                     for value in elem
                       ]
>>>>>>             elif isinstance(elem, dict):
>>>>>>                 return {
                           (
>>>>>>                         clone(key, **kw)
>>>>>>                         if hasattr(key, "__clause_element__")
>>>>>>                         else key
                           ): (
>>>>>>                         clone(value, **kw)
>>>>>>                         if hasattr(value, "__clause_element__")
>>>>>>                         else value
                           )
>>>>>>                     for key, value in elem.items()
                       }
                   else:
                       # TODO: use abc classes
>>>>>>                 assert False
       
>>>>>>         return [
>>>>>>             [copy(sub_element) for sub_element in sequence]
>>>>>>             for sequence in element
               ]
       
    1:     def visit_propagate_attrs(
    1:         self, attrname, parent, element, clone=_clone, **kw
           ):
>>>>>>         return element
       
       
    1: _copy_internals = _CopyInternalsTraversal()
       
       
    1: def _flatten_clauseelement(element):
>>>>>>     while hasattr(element, "__clause_element__") and not getattr(
>>>>>>         element, "is_clause_element", False
           ):
>>>>>>         element = element.__clause_element__()
       
>>>>>>     return element
       
       
    2: class _GetChildrenTraversal(HasTraversalDispatch):
    1:     """Generate a _children_traversal internal traversal dispatch for classes
           with a _traverse_internals collection."""
       
    1:     def visit_has_cache_key(self, element, **kw):
               # the GetChildren traversal refers explicitly to ClauseElement
               # structures.  Within these, a plain HasCacheKey is not a
               # ClauseElement, so don't include these.
>>>>>>         return ()
       
    1:     def visit_clauseelement(self, element, **kw):
 1791:         return (element,)
       
    1:     def visit_clauseelement_list(self, element, **kw):
    5:         return element
       
    1:     def visit_clauseelement_tuple(self, element, **kw):
>>>>>>         return element
       
    1:     def visit_clauseelement_tuples(self, element, **kw):
>>>>>>         return itertools.chain.from_iterable(element)
       
    1:     def visit_fromclause_canonical_column_collection(self, element, **kw):
   51:         return ()
       
    1:     def visit_string_clauseelement_dict(self, element, **kw):
>>>>>>         return element.values()
       
    1:     def visit_fromclause_ordered_set(self, element, **kw):
>>>>>>         return element
       
    1:     def visit_clauseelement_unordered_set(self, element, **kw):
>>>>>>         return element
       
    1:     def visit_setup_join_tuple(self, element, **kw):
>>>>>>         for target, onclause, from_, flags in element:
>>>>>>             if from_ is not None:
>>>>>>                 yield from_
       
>>>>>>             if not isinstance(target, str):
>>>>>>                 yield _flatten_clauseelement(target)
       
>>>>>>             if onclause is not None and not isinstance(onclause, str):
>>>>>>                 yield _flatten_clauseelement(onclause)
       
    1:     def visit_memoized_select_entities(self, element, **kw):
>>>>>>         return self.visit_clauseelement_tuple(element, **kw)
       
    1:     def visit_dml_ordered_values(self, element, **kw):
>>>>>>         for k, v in element:
>>>>>>             if hasattr(k, "__clause_element__"):
>>>>>>                 yield k
>>>>>>             yield v
       
    1:     def visit_dml_values(self, element, **kw):
>>>>>>         expr_values = {k for k in element if hasattr(k, "__clause_element__")}
>>>>>>         str_values = expr_values.symmetric_difference(element)
       
>>>>>>         for k in sorted(str_values):
>>>>>>             yield element[k]
>>>>>>         for k in expr_values:
>>>>>>             yield k
>>>>>>             yield element[k]
       
    1:     def visit_dml_multi_values(self, element, **kw):
>>>>>>         return ()
       
    1:     def visit_propagate_attrs(self, element, **kw):
>>>>>>         return ()
       
       
    1: _get_children = _GetChildrenTraversal()
       
       
    1: @util.preload_module("sqlalchemy.sql.elements")
    1: def _resolve_name_for_compare(element, name, anon_map, **kw):
  180:     if isinstance(name, util.preloaded.sql_elements._anonymous_label):
>>>>>>         name = name.apply_map(anon_map)
       
  180:     return name
       
       
    2: class TraversalComparatorStrategy(HasTraversalDispatch, util.MemoizedSlots):
    1:     __slots__ = "stack", "cache", "anon_map"
       
    1:     def __init__(self):
  324:         self.stack: Deque[
                   Tuple[
                       Optional[ExternallyTraversible],
                       Optional[ExternallyTraversible],
                   ]
  324:         ] = deque()
  324:         self.cache = set()
       
    1:     def _memoized_attr_anon_map(self):
   90:         return (anon_map(), anon_map())
       
    1:     def compare(
               self,
               obj1: ExternallyTraversible,
               obj2: ExternallyTraversible,
               **kw: Any,
           ) -> bool:
  324:         stack = self.stack
  324:         cache = self.cache
       
  324:         compare_annotations = kw.get("compare_annotations", False)
       
  324:         stack.append((obj1, obj2))
       
  580:         while stack:
  346:             left, right = stack.popleft()
       
  346:             if left is right:
   84:                 continue
  262:             elif left is None or right is None:
                       # we know they are different so no match
>>>>>>                 return False
  262:             elif (left, right) in cache:
>>>>>>                 continue
  262:             cache.add((left, right))
       
  262:             visit_name = left.__visit_name__
  262:             if visit_name != right.__visit_name__:
>>>>>>                 return False
       
  262:             meth = getattr(self, "compare_%s" % visit_name, None)
       
  262:             if meth:
  150:                 attributes_compared = meth(left, right, **kw)
  150:                 if attributes_compared is COMPARE_FAILED:
>>>>>>                     return False
  150:                 elif attributes_compared is SKIP_TRAVERSE:
   50:                     continue
       
                       # attributes_compared is returned as a list of attribute
                       # names that were "handled" by the comparison method above.
                       # remaining attribute names in the _traverse_internals
                       # will be compared.
                   else:
  112:                 attributes_compared = ()
       
  872:             for (
  750:                 (left_attrname, left_visit_sym),
  750:                 (right_attrname, right_visit_sym),
  424:             ) in zip_longest(
  212:                 left._traverse_internals,
  212:                 right._traverse_internals,
  212:                 fillvalue=(None, None),
                   ):
 2250:                 if not compare_annotations and (
  750:                     (left_attrname == "_annotations")
  750:                     or (right_attrname == "_annotations")
                       ):
>>>>>>                     continue
       
 1500:                 if (
  750:                     left_attrname != right_attrname
  750:                     or left_visit_sym is not right_visit_sym
                       ):
>>>>>>                     return False
  750:                 elif left_attrname in attributes_compared:
  250:                     continue
       
  500:                 assert left_visit_sym is not None
  500:                 assert left_attrname is not None
  500:                 assert right_attrname is not None
       
  500:                 dispatch = self.dispatch(left_visit_sym)
  500:                 assert dispatch is not None, (
>>>>>>                     f"{self.__class__} has no dispatch for "
>>>>>>                     f"'{self._dispatch_lookup[left_visit_sym]}'"
                       )
  500:                 left_child = operator.attrgetter(left_attrname)(left)
  500:                 right_child = operator.attrgetter(right_attrname)(right)
  500:                 if left_child is None:
  100:                     if right_child is not None:
>>>>>>                         return False
                           else:
>>>>>>                         continue
       
 1200:                 comparison = dispatch(
  800:                     left_attrname, left, left_child, right, right_child, **kw
                       )
  400:                 if comparison is COMPARE_FAILED:
   90:                     return False
       
  234:         return True
       
    1:     def compare_inner(self, obj1, obj2, **kw):
  100:         comparator = self.__class__()
  100:         return comparator.compare(obj1, obj2, **kw)
       
    1:     def visit_has_cache_key(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         if left._gen_cache_key(self.anon_map[0], []) != right._gen_cache_key(
>>>>>>             self.anon_map[1], []
               ):
>>>>>>             return COMPARE_FAILED
       
    1:     def visit_propagate_attrs(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         return self.compare_inner(
>>>>>>             left.get("plugin_subject", None), right.get("plugin_subject", None)
               )
       
    1:     def visit_has_cache_key_list(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         for l, r in zip_longest(left, right, fillvalue=None):
>>>>>>             if l is None:
>>>>>>                 if r is not None:
>>>>>>                     return COMPARE_FAILED
                       else:
>>>>>>                     continue
>>>>>>             elif r is None:
>>>>>>                 return COMPARE_FAILED
       
>>>>>>             if l._gen_cache_key(self.anon_map[0], []) != r._gen_cache_key(
>>>>>>                 self.anon_map[1], []
                   ):
>>>>>>                 return COMPARE_FAILED
       
    1:     def visit_executable_options(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         for l, r in zip_longest(left, right, fillvalue=None):
>>>>>>             if l is None:
>>>>>>                 if r is not None:
>>>>>>                     return COMPARE_FAILED
                       else:
>>>>>>                     continue
>>>>>>             elif r is None:
>>>>>>                 return COMPARE_FAILED
       
>>>>>>             if (
>>>>>>                 l._gen_cache_key(self.anon_map[0], [])
>>>>>>                 if l._is_has_cache_key
>>>>>>                 else l
                   ) != (
>>>>>>                 r._gen_cache_key(self.anon_map[1], [])
>>>>>>                 if r._is_has_cache_key
>>>>>>                 else r
                   ):
>>>>>>                 return COMPARE_FAILED
       
    1:     def visit_clauseelement(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
   22:         self.stack.append((left, right))
       
    1:     def visit_fromclause_canonical_column_collection(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
 1012:         for lcol, rcol in zip_longest(left, right, fillvalue=None):
  990:             self.stack.append((lcol, rcol))
       
    1:     def visit_fromclause_derived_column_collection(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         pass
       
    1:     def visit_string_clauseelement_dict(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         for lstr, rstr in zip_longest(
>>>>>>             sorted(left), sorted(right), fillvalue=None
               ):
>>>>>>             if lstr != rstr:
>>>>>>                 return COMPARE_FAILED
>>>>>>             self.stack.append((left[lstr], right[rstr]))
       
    1:     def visit_clauseelement_tuples(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         for ltup, rtup in zip_longest(left, right, fillvalue=None):
>>>>>>             if ltup is None or rtup is None:
>>>>>>                 return COMPARE_FAILED
       
>>>>>>             for l, r in zip_longest(ltup, rtup, fillvalue=None):
>>>>>>                 self.stack.append((l, r))
       
    1:     def visit_clauseelement_list(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         for l, r in zip_longest(left, right, fillvalue=None):
>>>>>>             self.stack.append((l, r))
       
    1:     def visit_clauseelement_tuple(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         for l, r in zip_longest(left, right, fillvalue=None):
>>>>>>             self.stack.append((l, r))
       
    1:     def _compare_unordered_sequences(self, seq1, seq2, **kw):
>>>>>>         if seq1 is None:
>>>>>>             return seq2 is None
       
>>>>>>         completed: Set[object] = set()
>>>>>>         for clause in seq1:
>>>>>>             for other_clause in set(seq2).difference(completed):
>>>>>>                 if self.compare_inner(clause, other_clause, **kw):
>>>>>>                     completed.add(other_clause)
>>>>>>                     break
>>>>>>         return len(completed) == len(seq1) == len(seq2)
       
    1:     def visit_clauseelement_unordered_set(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         return self._compare_unordered_sequences(left, right, **kw)
       
    1:     def visit_fromclause_ordered_set(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         for l, r in zip_longest(left, right, fillvalue=None):
>>>>>>             self.stack.append((l, r))
       
    1:     def visit_string(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
   22:         return left == right
       
    1:     def visit_string_list(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         return left == right
       
    1:     def visit_string_multi_dict(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         for lk, rk in zip_longest(
>>>>>>             sorted(left.keys()), sorted(right.keys()), fillvalue=(None, None)
               ):
>>>>>>             if lk != rk:
>>>>>>                 return COMPARE_FAILED
       
>>>>>>             lv, rv = left[lk], right[rk]
       
>>>>>>             lhc = isinstance(left, HasCacheKey)
>>>>>>             rhc = isinstance(right, HasCacheKey)
>>>>>>             if lhc and rhc:
>>>>>>                 if lv._gen_cache_key(
>>>>>>                     self.anon_map[0], []
>>>>>>                 ) != rv._gen_cache_key(self.anon_map[1], []):
>>>>>>                     return COMPARE_FAILED
>>>>>>             elif lhc != rhc:
>>>>>>                 return COMPARE_FAILED
>>>>>>             elif lv != rv:
>>>>>>                 return COMPARE_FAILED
       
    1:     def visit_multi(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         lhc = isinstance(left, HasCacheKey)
>>>>>>         rhc = isinstance(right, HasCacheKey)
>>>>>>         if lhc and rhc:
>>>>>>             if left._gen_cache_key(
>>>>>>                 self.anon_map[0], []
>>>>>>             ) != right._gen_cache_key(self.anon_map[1], []):
>>>>>>                 return COMPARE_FAILED
>>>>>>         elif lhc != rhc:
>>>>>>             return COMPARE_FAILED
               else:
>>>>>>             return left == right
       
    1:     def visit_anon_name(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
  360:         return _resolve_name_for_compare(
  180:             left_parent, left, self.anon_map[0], **kw
  270:         ) == _resolve_name_for_compare(
  180:             right_parent, right, self.anon_map[1], **kw
               )
       
    1:     def visit_boolean(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
   72:         return left == right
       
    1:     def visit_operator(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         return left == right
       
    1:     def visit_type(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
  122:         return left._compare_type_affinity(right)
       
    1:     def visit_plain_dict(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
   50:         return left == right
       
    1:     def visit_dialect_options(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         return left == right
       
    1:     def visit_annotations_key(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         if left and right:
>>>>>>             return (
>>>>>>                 left_parent._annotations_cache_key
>>>>>>                 == right_parent._annotations_cache_key
                   )
               else:
>>>>>>             return left == right
       
    1:     def visit_with_context_options(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         return tuple((fn.__code__, c_key) for fn, c_key in left) == tuple(
>>>>>>             (fn.__code__, c_key) for fn, c_key in right
               )
       
    1:     def visit_plain_obj(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         return left == right
       
    1:     def visit_named_ddl_element(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         if left is None:
>>>>>>             if right is not None:
>>>>>>                 return COMPARE_FAILED
       
>>>>>>         return left.name == right.name
       
    1:     def visit_prefix_sequence(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         for (l_clause, l_str), (r_clause, r_str) in zip_longest(
>>>>>>             left, right, fillvalue=(None, None)
               ):
>>>>>>             if l_str != r_str:
>>>>>>                 return COMPARE_FAILED
                   else:
>>>>>>                 self.stack.append((l_clause, r_clause))
       
    1:     def visit_setup_join_tuple(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
               # TODO: look at attrname for "legacy_join" and use different structure
>>>>>>         for (
>>>>>>             (l_target, l_onclause, l_from, l_flags),
>>>>>>             (r_target, r_onclause, r_from, r_flags),
>>>>>>         ) in zip_longest(left, right, fillvalue=(None, None, None, None)):
>>>>>>             if l_flags != r_flags:
>>>>>>                 return COMPARE_FAILED
>>>>>>             self.stack.append((l_target, r_target))
>>>>>>             self.stack.append((l_onclause, r_onclause))
>>>>>>             self.stack.append((l_from, r_from))
       
    1:     def visit_memoized_select_entities(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         return self.visit_clauseelement_tuple(
>>>>>>             attrname, left_parent, left, right_parent, right, **kw
               )
       
    1:     def visit_table_hint_list(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         left_keys = sorted(left, key=lambda elem: (elem[0].fullname, elem[1]))
>>>>>>         right_keys = sorted(
>>>>>>             right, key=lambda elem: (elem[0].fullname, elem[1])
               )
>>>>>>         for (ltable, ldialect), (rtable, rdialect) in zip_longest(
>>>>>>             left_keys, right_keys, fillvalue=(None, None)
               ):
>>>>>>             if ldialect != rdialect:
>>>>>>                 return COMPARE_FAILED
>>>>>>             elif left[(ltable, ldialect)] != right[(rtable, rdialect)]:
>>>>>>                 return COMPARE_FAILED
                   else:
>>>>>>                 self.stack.append((ltable, rtable))
       
    1:     def visit_statement_hint_list(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         return left == right
       
    1:     def visit_unknown_structure(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         raise NotImplementedError()
       
    1:     def visit_dml_ordered_values(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
               # sequence of tuple pairs
       
>>>>>>         for (lk, lv), (rk, rv) in zip_longest(
>>>>>>             left, right, fillvalue=(None, None)
               ):
>>>>>>             if not self._compare_dml_values_or_ce(lk, rk, **kw):
>>>>>>                 return COMPARE_FAILED
       
    1:     def _compare_dml_values_or_ce(self, lv, rv, **kw):
>>>>>>         lvce = hasattr(lv, "__clause_element__")
>>>>>>         rvce = hasattr(rv, "__clause_element__")
>>>>>>         if lvce != rvce:
>>>>>>             return False
>>>>>>         elif lvce and not self.compare_inner(lv, rv, **kw):
>>>>>>             return False
>>>>>>         elif not lvce and lv != rv:
>>>>>>             return False
>>>>>>         elif not self.compare_inner(lv, rv, **kw):
>>>>>>             return False
       
>>>>>>         return True
       
    1:     def visit_dml_values(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         if left is None or right is None or len(left) != len(right):
>>>>>>             return COMPARE_FAILED
       
>>>>>>         if isinstance(left, collections_abc.Sequence):
>>>>>>             for lv, rv in zip(left, right):
>>>>>>                 if not self._compare_dml_values_or_ce(lv, rv, **kw):
>>>>>>                     return COMPARE_FAILED
>>>>>>         elif isinstance(right, collections_abc.Sequence):
>>>>>>             return COMPARE_FAILED
               else:
                   # dictionaries guaranteed to support insert ordering in
                   # py37 so that we can compare the keys in order.  without
                   # this, we can't compare SQL expression keys because we don't
                   # know which key is which
>>>>>>             for (lk, lv), (rk, rv) in zip(left.items(), right.items()):
>>>>>>                 if not self._compare_dml_values_or_ce(lk, rk, **kw):
>>>>>>                     return COMPARE_FAILED
>>>>>>                 if not self._compare_dml_values_or_ce(lv, rv, **kw):
>>>>>>                     return COMPARE_FAILED
       
    1:     def visit_dml_multi_values(
               self, attrname, left_parent, left, right_parent, right, **kw
           ):
>>>>>>         for lseq, rseq in zip_longest(left, right, fillvalue=None):
>>>>>>             if lseq is None or rseq is None:
>>>>>>                 return COMPARE_FAILED
       
>>>>>>             for ld, rd in zip_longest(lseq, rseq, fillvalue=None):
>>>>>>                 if (
>>>>>>                     self.visit_dml_values(
>>>>>>                         attrname, left_parent, ld, right_parent, rd, **kw
                           )
>>>>>>                     is COMPARE_FAILED
                       ):
>>>>>>                     return COMPARE_FAILED
       
    1:     def compare_expression_clauselist(self, left, right, **kw):
>>>>>>         if left.operator is right.operator:
>>>>>>             if operators.is_associative(left.operator):
>>>>>>                 if self._compare_unordered_sequences(
>>>>>>                     left.clauses, right.clauses, **kw
                       ):
>>>>>>                     return ["operator", "clauses"]
                       else:
>>>>>>                     return COMPARE_FAILED
                   else:
>>>>>>                 return ["operator"]
               else:
>>>>>>             return COMPARE_FAILED
       
    1:     def compare_clauselist(self, left, right, **kw):
>>>>>>         return self.compare_expression_clauselist(left, right, **kw)
       
    1:     def compare_binary(self, left, right, **kw):
   50:         if left.operator == right.operator:
   50:             if operators.is_commutative(left.operator):
  100:                 if (
   50:                     self.compare_inner(left.left, right.left, **kw)
   50:                     and self.compare_inner(left.right, right.right, **kw)
                       ) or (
>>>>>>                     self.compare_inner(left.left, right.right, **kw)
>>>>>>                     and self.compare_inner(left.right, right.left, **kw)
                       ):
   50:                     return ["operator", "negate", "left", "right"]
                       else:
>>>>>>                     return COMPARE_FAILED
                   else:
>>>>>>                 return ["operator", "negate"]
               else:
>>>>>>             return COMPARE_FAILED
       
    1:     def compare_bindparam(self, left, right, **kw):
   50:         compare_keys = kw.pop("compare_keys", True)
   50:         compare_values = kw.pop("compare_values", True)
       
   50:         if compare_values:
   50:             omit = []
               else:
                   # this means, "skip these, we already compared"
>>>>>>             omit = ["callable", "value"]
       
   50:         if not compare_keys:
   50:             omit.append("key")
       
   50:         return omit
       
       
    2: class ColIdentityComparatorStrategy(TraversalComparatorStrategy):
    1:     def compare_column_element(
               self, left, right, use_proxies=True, equivalents=(), **kw
           ):
               """Compare ColumnElements using proxies and equivalent collections.
       
               This is a comparison strategy specific to the ORM.
               """
       
   50:         to_compare = (right,)
   50:         if equivalents and right in equivalents:
>>>>>>             to_compare = equivalents[right].union(to_compare)
       
   50:         for oth in to_compare:
   50:             if use_proxies and left.shares_lineage(oth):
   50:                 return SKIP_TRAVERSE
>>>>>>             elif hash(left) == hash(right):
>>>>>>                 return SKIP_TRAVERSE
               else:
>>>>>>             return COMPARE_FAILED
       
    1:     def compare_column(self, left, right, **kw):
   50:         return self.compare_column_element(left, right, **kw)
       
    1:     def compare_label(self, left, right, **kw):
>>>>>>         return self.compare_column_element(left, right, **kw)
       
    1:     def compare_table(self, left, right, **kw):
               # tables compare on identity, since it's not really feasible to
               # compare them column by column with the above rules
>>>>>>         return SKIP_TRAVERSE if left is right else COMPARE_FAILED
