       # util/topological.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: """Topological sorting algorithms."""
       
    1: from __future__ import annotations
       
    1: from typing import Any
    1: from typing import Collection
    1: from typing import DefaultDict
    1: from typing import Iterable
    1: from typing import Iterator
    1: from typing import Sequence
    1: from typing import Set
    1: from typing import Tuple
    1: from typing import TypeVar
       
    1: from .. import util
    1: from ..exc import CircularDependencyError
       
    1: _T = TypeVar("_T", bound=Any)
       
    1: __all__ = ["sort", "sort_as_subsets", "find_cycles"]
       
       
    1: def sort_as_subsets(
           tuples: Collection[Tuple[_T, _T]], allitems: Collection[_T]
       ) -> Iterator[Sequence[_T]]:
   67:     edges: DefaultDict[_T, Set[_T]] = util.defaultdict(set)
  924:     for parent, child in tuples:
  857:         edges[child].add(parent)
       
   67:     todo = list(allitems)
   67:     todo_set = set(allitems)
       
  225:     while todo_set:
  158:         output = []
 2425:         for node in todo:
 2267:             if todo_set.isdisjoint(edges[node]):
  954:                 output.append(node)
       
  158:         if not output:
>>>>>>             raise CircularDependencyError(
>>>>>>                 "Circular dependency detected.",
>>>>>>                 find_cycles(tuples, allitems),
>>>>>>                 _gen_edges(edges),
                   )
       
  158:         todo_set.difference_update(output)
 2583:         todo = [t for t in todo if t in todo_set]
  158:         yield output
       
       
    1: def sort(
           tuples: Collection[Tuple[_T, _T]],
           allitems: Collection[_T],
           deterministic_order: bool = True,
       ) -> Iterator[_T]:
           """sort the given list of items by dependency.
       
           'tuples' is a list of tuples representing a partial ordering.
       
           deterministic_order is no longer used, the order is now always
           deterministic given the order of "allitems".    the flag is there
           for backwards compatibility with Alembic.
       
           """
       
  225:     for set_ in sort_as_subsets(tuples, allitems):
  158:         yield from set_
       
       
    1: def find_cycles(
           tuples: Iterable[Tuple[_T, _T]], allitems: Iterable[_T]
       ) -> Set[_T]:
           # adapted from:
           # https://neopythonic.blogspot.com/2009/01/detecting-cycles-in-directed-graph.html
       
   43:     edges: DefaultDict[_T, Set[_T]] = util.defaultdict(set)
  108:     for parent, child in tuples:
   65:         edges[parent].add(child)
   43:     nodes_to_test = set(edges)
       
   43:     output = set()
       
           # we'd like to find all nodes that are
           # involved in cycles, so we do the full
           # pass through the whole thing for each
           # node in the original list.
       
           # we can go just through parent edge nodes.
           # if a node is only a child and never a parent,
           # by definition it can't be part of a cycle.  same
           # if it's not in the edges at all.
  108:     for node in nodes_to_test:
   65:         stack = [node]
   65:         todo = nodes_to_test.difference(stack)
  130:         while stack:
   65:             top = stack[-1]
  130:             for node in edges[top]:
   65:                 if node in stack:
>>>>>>                     cyc = stack[stack.index(node) :]
>>>>>>                     todo.difference_update(cyc)
>>>>>>                     output.update(cyc)
       
   65:                 if node in todo:
>>>>>>                     stack.append(node)
>>>>>>                     todo.remove(node)
>>>>>>                     break
                   else:
   65:                 node = stack.pop()
   43:     return output
       
       
    1: def _gen_edges(edges: DefaultDict[_T, Set[_T]]) -> Set[Tuple[_T, _T]]:
>>>>>>     return {(right, left) for left in edges for right in edges[left]}
