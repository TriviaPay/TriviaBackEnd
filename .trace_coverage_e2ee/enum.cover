>>>>>> import sys
>>>>>> from types import MappingProxyType, DynamicClassAttribute
       
       
>>>>>> __all__ = [
               'EnumMeta',
               'Enum', 'IntEnum', 'Flag', 'IntFlag',
               'auto', 'unique',
               ]
       
       
>>>>>> def _is_descriptor(obj):
           """
           Returns True if obj is a descriptor, False otherwise.
           """
  562:     return (
 1116:             hasattr(obj, '__get__') or
  554:             hasattr(obj, '__set__') or
  554:             hasattr(obj, '__delete__')
                   )
       
>>>>>> def _is_dunder(name):
           """
           Returns True if a __dunder__ name, False otherwise.
           """
  987:     return (
 2346:             len(name) > 4 and
  951:             name[:2] == name[-2:] == '__' and
  408:             name[2] != '_' and
  408:             name[-3] != '_'
                   )
       
>>>>>> def _is_sunder(name):
           """
           Returns True if a _sunder_ name, False otherwise.
           """
  873:     return (
 2055:             len(name) > 2 and
  871:             name[0] == name[-1] == '_' and
  311:             name[1:2] != '_' and
   81:             name[-2:-1] != '_'
                   )
       
>>>>>> def _is_private(cls_name, name):
           # do not use `re` as `re` imports `enum`
  873:     pattern = '_%s__' % (cls_name, )
 1710:     if (
  873:             len(name) >= 5
  837:             and name.startswith(pattern)
>>>>>>             and name[len(pattern)] != '_'
>>>>>>             and (name[-1] != '_' or name[-2] != '_')
               ):
>>>>>>         return True
           else:
  873:         return False
       
>>>>>> def _make_class_unpicklable(cls):
           """
           Make the given class un-picklable.
           """
    1:     def _break_on_call_reduce(self, proto):
>>>>>>         raise TypeError('%r cannot be pickled' % self)
    1:     cls.__reduce_ex__ = _break_on_call_reduce
    1:     cls.__module__ = '<unknown>'
       
>>>>>> _auto_null = object()
>>>>>> class auto:
           """
           Instances are replaced with an appropriate value in Enum class suites.
           """
>>>>>>     value = _auto_null
       
       
>>>>>> class _EnumDict(dict):
           """
           Track enum member order and ensure member names are not reused.
       
           EnumMeta will use the names found in self._member_names as the
           enumeration member names.
           """
>>>>>>     def __init__(self):
   81:         super().__init__()
   81:         self._member_names = []
   81:         self._last_values = []
   81:         self._ignore = []
   81:         self._auto_called = False
       
>>>>>>     def __setitem__(self, key, value):
               """
               Changes anything not dundered or not a descriptor.
       
               If an enum member name is used twice, an error is raised; duplicate
               values are not checked for.
       
               Single underscore (sunder) names are reserved.
               """
  873:         if _is_private(self._cls_name, key):
>>>>>>             import warnings
>>>>>>             warnings.warn(
>>>>>>                     "private variables, such as %r, will be normal attributes in 3.10"
>>>>>>                         % (key, ),
>>>>>>                     DeprecationWarning,
>>>>>>                     stacklevel=2,
                           )
  873:         if _is_sunder(key):
   81:             if key not in (
                           '_order_', '_create_pseudo_member_',
                           '_generate_next_value_', '_missing_', '_ignore_',
                           ):
>>>>>>                 raise ValueError('_names_ are reserved for future Enum use')
   81:             if key == '_generate_next_value_':
                       # check if members already defined as auto()
   81:                 if self._auto_called:
>>>>>>                     raise TypeError("_generate_next_value_ must be defined before members")
   81:                 setattr(self, '_generate_next_value', value)
>>>>>>             elif key == '_ignore_':
>>>>>>                 if isinstance(value, str):
>>>>>>                     value = value.replace(',',' ').split()
                       else:
>>>>>>                     value = list(value)
>>>>>>                 self._ignore = value
>>>>>>                 already = set(value) & set(self._member_names)
>>>>>>                 if already:
>>>>>>                     raise ValueError(
>>>>>>                             '_ignore_ cannot specify already set names: %r'
>>>>>>                             % (already, )
                                   )
  792:         elif _is_dunder(key):
  230:             if key == '__order__':
>>>>>>                 key = '_order_'
  562:         elif key in self._member_names:
                   # descriptor overwriting an enum?
>>>>>>             raise TypeError('Attempted to reuse key: %r' % key)
  562:         elif key in self._ignore:
>>>>>>             pass
  562:         elif not _is_descriptor(value):
  554:             if key in self:
                       # enum overwriting a descriptor?
>>>>>>                 raise TypeError('%r already defined as: %r' % (key, self[key]))
  554:             if isinstance(value, auto):
   25:                 if value.value == _auto_null:
   50:                     value.value = self._generate_next_value(
   25:                             key,
   25:                             1,
   25:                             len(self._member_names),
   25:                             self._last_values[:],
                                   )
   25:                     self._auto_called = True
   25:                 value = value.value
  554:             self._member_names.append(key)
  554:             self._last_values.append(value)
  873:         super().__setitem__(key, value)
       
       
       # Dummy value for Enum as EnumMeta explicitly checks for it, but of course
       # until EnumMeta finishes running the first time the Enum class doesn't exist.
       # This is also why there are checks in EnumMeta like `if Enum is not None`
>>>>>> Enum = None
       
>>>>>> class EnumMeta(type):
           """
           Metaclass for Enum
           """
>>>>>>     @classmethod
>>>>>>     def __prepare__(metacls, cls, bases, **kwds):
               # check that previous enum members do not exist
   81:         metacls._check_for_existing_members(cls, bases)
               # create the namespace dict
   81:         enum_dict = _EnumDict()
   81:         enum_dict._cls_name = cls
               # inherit previous flags and _generate_next_value_ function
   81:         member_type, first_enum = metacls._get_mixins_(cls, bases)
   81:         if first_enum is not None:
  162:             enum_dict['_generate_next_value_'] = getattr(
   81:                     first_enum, '_generate_next_value_', None,
                           )
   81:         return enum_dict
       
>>>>>>     def __new__(metacls, cls, bases, classdict, **kwds):
               # an Enum class is final once enumeration items have been defined; it
               # cannot be mixed with other types (int, float, etc.) if it has an
               # inherited __new__ unless a new __new__ is defined (or the resulting
               # class will fail).
               #
               # remove any keys listed in _ignore_
   81:         classdict.setdefault('_ignore_', []).append('_ignore_')
   81:         ignore = classdict['_ignore_']
  162:         for key in ignore:
   81:             classdict.pop(key, None)
   81:         member_type, first_enum = metacls._get_mixins_(cls, bases)
  162:         __new__, save_new, use_args = metacls._find_new_(
   81:                 classdict, member_type, first_enum,
                       )
       
               # save enum items into separate mapping so they don't get baked into
               # the new class
  716:         enum_members = {k: classdict[k] for k in classdict._member_names}
  635:         for name in classdict._member_names:
  554:             del classdict[name]
       
               # adjust the sunders
   81:         _order_ = classdict.pop('_order_', None)
       
               # check for illegal enum names (any others?)
   81:         invalid_names = set(enum_members) & {'mro', ''}
   81:         if invalid_names:
>>>>>>             raise ValueError('Invalid enum member name: {0}'.format(
>>>>>>                 ','.join(invalid_names)))
       
               # create a default docstring if one has not been provided
   81:         if '__doc__' not in classdict:
   60:             classdict['__doc__'] = 'An enumeration.'
       
   81:         enum_class = super().__new__(metacls, cls, bases, classdict, **kwds)
   81:         enum_class._member_names_ = []               # names in definition order
   81:         enum_class._member_map_ = {}                 # name->value map
   81:         enum_class._member_type_ = member_type
       
               # save DynamicClassAttribute attributes from super classes so we know
               # if we can take the shortcut of storing members in the class dict
  559:         dynamic_attributes = {
  559:                 k for c in enum_class.mro()
 6571:                 for k, v in c.__dict__.items()
 6255:                 if isinstance(v, DynamicClassAttribute)
                       }
       
               # Reverse value->name map for hashable values.
   81:         enum_class._value2member_map_ = {}
       
               # If a custom type is mixed into the Enum, and it does not know how
               # to pickle itself, pickle.dumps will succeed but pickle.loads will
               # fail.  Rather than have the error show up later and possibly far
               # from the source, sabotage the pickle protocol for this class so
               # that pickle.dumps also fails.
               #
               # However, if the new class implements its own __reduce_ex__, do not
               # sabotage -- it's on them to make sure it works correctly.  We use
               # __reduce_ex__ instead of any of the others as it is preferred by
               # pickle over __reduce__, and it handles all pickle protocols.
   81:         if '__reduce_ex__' not in classdict:
   81:             if member_type is not object:
   30:                 methods = ('__getnewargs_ex__', '__getnewargs__',
                               '__reduce_ex__', '__reduce__')
   93:                 if not any(m in member_type.__dict__ for m in methods):
    1:                     if '__new__' in classdict:
                               # too late, sabotage
>>>>>>                         _make_class_unpicklable(enum_class)
                           else:
                               # final attempt to verify that pickling would work:
                               # travel mro until __new__ is found, checking for
                               # __reduce__ and friends along the way -- if any of them
                               # are found before/when __new__ is found, pickling should
                               # work
    1:                         sabotage = None
    1:                         for chain in bases:
    1:                             for base in chain.__mro__:
    1:                                 if base is object:
>>>>>>                                     continue
    6:                                 elif any(m in base.__dict__ for m in methods):
                                           # found one, we're good
>>>>>>                                     sabotage = False
>>>>>>                                     break
    1:                                 elif '__new__' in base.__dict__:
                                           # not good
    1:                                     sabotage = True
    1:                                     break
    1:                             if sabotage is not None:
    1:                                 break
    1:                         if sabotage:
    1:                             _make_class_unpicklable(enum_class)
               # instantiate them, checking for duplicates as we go
               # we instantiate first instead of checking for duplicates first in case
               # a custom __new__ is doing something funky with the values -- such as
               # auto-numbering ;)
  635:         for member_name in classdict._member_names:
  554:             value = enum_members[member_name]
  554:             if not isinstance(value, tuple):
  430:                 args = (value, )
                   else:
  124:                 args = value
  554:             if member_type is tuple:   # special case for tuple enums
>>>>>>                 args = (args, )     # wrap it one more time
  554:             if not use_args:
  211:                 enum_member = __new__(enum_class)
  211:                 if not hasattr(enum_member, '_value_'):
  211:                     enum_member._value_ = value
                   else:
  343:                 enum_member = __new__(enum_class, *args)
  343:                 if not hasattr(enum_member, '_value_'):
  219:                     if member_type is object:
>>>>>>                         enum_member._value_ = value
                           else:
  219:                         enum_member._value_ = member_type(*args)
  554:             value = enum_member._value_
  554:             enum_member._name_ = member_name
  554:             enum_member.__objclass__ = enum_class
  554:             enum_member.__init__(*args)
                   # If another member with the same value was already defined, the
                   # new member becomes an alias to the existing one.
 6951:             for name, canonical_member in enum_class._member_map_.items():
 6403:                 if canonical_member._value_ == enum_member._value_:
    6:                     enum_member = canonical_member
    6:                     break
                   else:
                       # Aliases don't appear in member names (only in __members__).
  548:                 enum_class._member_names_.append(member_name)
                   # performance boost for any member that would not shadow
                   # a DynamicClassAttribute
  554:             if member_name not in dynamic_attributes:
  554:                 setattr(enum_class, member_name, enum_member)
                   # now add to _member_map_
  554:             enum_class._member_map_[member_name] = enum_member
  554:             try:
                       # This may fail if value is not hashable. We can't add the value
                       # to the map, and by-value lookups for this value will be
                       # linear.
  554:                 enum_class._value2member_map_[value] = enum_member
>>>>>>             except TypeError:
>>>>>>                 pass
       
               # double check that repr and friends are not the mixin's or various
               # things break (such as pickle)
               # however, if the method is defined in the Enum itself, don't replace
               # it
  405:         for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):
  324:             if name in classdict:
    5:                 continue
  319:             class_method = getattr(enum_class, name)
  319:             obj_method = getattr(member_type, name, None)
  319:             enum_method = getattr(first_enum, name, None)
  319:             if obj_method is not None and obj_method is class_method:
    6:                 setattr(enum_class, name, enum_method)
       
               # replace any other __new__ with our own (as long as Enum is not None,
               # anyway) -- again, this is to support pickle
   81:         if Enum is not None:
                   # if the user defined their own __new__, save it before it gets
                   # clobbered in case they subclass later
   81:             if save_new:
    2:                 enum_class.__new_member__ = __new__
   81:             enum_class.__new__ = Enum.__new__
       
               # py3 support for definition order (helps keep py2/py3 code in sync)
   81:         if _order_ is not None:
>>>>>>             if isinstance(_order_, str):
>>>>>>                 _order_ = _order_.replace(',', ' ').split()
>>>>>>             if _order_ != enum_class._member_names_:
>>>>>>                 raise TypeError('member order does not match _order_')
       
   81:         return enum_class
       
>>>>>>     def __bool__(self):
               """
               classes/types should always be True.
               """
    4:         return True
       
>>>>>>     def __call__(cls, value, names=None, *, module=None, qualname=None, type=None, start=1):
               """
               Either returns an existing member, or creates a new enum class.
       
               This method is used both when an enum class is given a value to match
               to an enumeration member (i.e. Color(3)) and for the functional API
               (i.e. Color = Enum('Color', names='RED GREEN BLUE')).
       
               When used for the functional API:
       
               `value` will be the name of the new class.
       
               `names` should be either a string of white-space/comma delimited names
               (values will start at `start`), or an iterator/mapping of name, value pairs.
       
               `module` should be set to the module this class is being created in;
               if it is not set, an attempt to find that module will be made, but if
               it fails the class will not be picklable.
       
               `qualname` should be set to the actual location this class can be found
               at in its module; by default it is set to the global scope.  If this is
               not correct, unpickling will fail in some circumstances.
       
               `type`, if set, will be mixed in as the first base class.
               """
 2913:         if names is None:  # simple value lookup
 2903:             return cls.__new__(cls, value)
               # otherwise, functional API: we're creating a new Enum type
   20:         return cls._create_(
   10:                 value,
   10:                 names,
   10:                 module=module,
   10:                 qualname=qualname,
   10:                 type=type,
   10:                 start=start,
                       )
       
>>>>>>     def __contains__(cls, member):
>>>>>>         if not isinstance(member, Enum):
>>>>>>             raise TypeError(
>>>>>>                 "unsupported operand type(s) for 'in': '%s' and '%s'" % (
>>>>>>                     type(member).__qualname__, cls.__class__.__qualname__))
>>>>>>         return isinstance(member, cls) and member._name_ in cls._member_map_
       
>>>>>>     def __delattr__(cls, attr):
               # nicer error message when someone tries to delete an attribute
               # (see issue19025).
>>>>>>         if attr in cls._member_map_:
>>>>>>             raise AttributeError("%s: cannot delete Enum member." % cls.__name__)
>>>>>>         super().__delattr__(attr)
       
>>>>>>     def __dir__(self):
>>>>>>         return (
>>>>>>                 ['__class__', '__doc__', '__members__', '__module__']
>>>>>>                 + self._member_names_
                       )
       
>>>>>>     def __getattr__(cls, name):
               """
               Return the enum member matching `name`
       
               We use __getattr__ instead of descriptors or inserting into the enum
               class' __dict__ in order to support `name` and `value` being both
               properties for enum members (which live in the class' __dict__) and
               enum members themselves.
               """
  195:         if _is_dunder(name):
  178:             raise AttributeError(name)
   17:         try:
   17:             return cls._member_map_[name]
   17:         except KeyError:
   17:             raise AttributeError(name) from None
       
>>>>>>     def __getitem__(cls, name):
>>>>>>         return cls._member_map_[name]
       
>>>>>>     def __iter__(cls):
               """
               Returns members in definition order.
               """
  239:         return (cls._member_map_[name] for name in cls._member_names_)
       
>>>>>>     def __len__(cls):
   12:         return len(cls._member_names_)
       
>>>>>>     @property
>>>>>>     def __members__(cls):
               """
               Returns a mapping of member name->value.
       
               This mapping lists all enum members, including aliases. Note that this
               is a read-only view of the internal mapping.
               """
   32:         return MappingProxyType(cls._member_map_)
       
>>>>>>     def __repr__(cls):
   22:         return "<enum %r>" % cls.__name__
       
>>>>>>     def __reversed__(cls):
               """
               Returns members in reverse definition order.
               """
>>>>>>         return (cls._member_map_[name] for name in reversed(cls._member_names_))
       
>>>>>>     def __setattr__(cls, name, value):
               """
               Block attempts to reassign Enum members.
       
               A simple assignment to the class namespace only changes one of the
               several possible ways to get an Enum member from the Enum class,
               resulting in an inconsistent Enumeration.
               """
 1053:         member_map = cls.__dict__.get('_member_map_', {})
 1053:         if name in member_map:
>>>>>>             raise AttributeError('Cannot reassign members.')
 1053:         super().__setattr__(name, value)
       
>>>>>>     def _create_(cls, class_name, names, *, module=None, qualname=None, type=None, start=1):
               """
               Convenience method to create a new Enum class.
       
               `names` can be:
       
               * A string containing member names, separated either with spaces or
                 commas.  Values are incremented by 1 from `start`.
               * An iterable of member names.  Values are incremented by 1 from `start`.
               * An iterable of (member name, value) pairs.
               * A mapping of member name -> value pairs.
               """
   10:         metacls = cls.__class__
   10:         bases = (cls, ) if type is None else (type, cls)
   10:         _, first_enum = cls._get_mixins_(cls, bases)
   10:         classdict = metacls.__prepare__(class_name, bases)
       
               # special processing needed for names?
   10:         if isinstance(names, str):
>>>>>>             names = names.replace(',', ' ').split()
   10:         if isinstance(names, (tuple, list)) and names and isinstance(names[0], str):
>>>>>>             original_names, names = names, []
>>>>>>             last_values = []
>>>>>>             for count, name in enumerate(original_names):
>>>>>>                 value = first_enum._generate_next_value_(name, start, count, last_values[:])
>>>>>>                 last_values.append(value)
>>>>>>                 names.append((name, value))
       
               # Here, names is either an iterable of (name, value) or a mapping.
  107:         for item in names:
   97:             if isinstance(item, str):
>>>>>>                 member_name, member_value = item, names[item]
                   else:
   97:                 member_name, member_value = item
   97:             classdict[member_name] = member_value
   10:         enum_class = metacls.__new__(metacls, class_name, bases, classdict)
       
               # TODO: replace the frame hack if a blessed way to know the calling
               # module is ever developed
   10:         if module is None:
>>>>>>             try:
>>>>>>                 module = sys._getframe(2).f_globals['__name__']
>>>>>>             except (AttributeError, ValueError, KeyError):
>>>>>>                 pass
   10:         if module is None:
>>>>>>             _make_class_unpicklable(enum_class)
               else:
   10:             enum_class.__module__ = module
   10:         if qualname is not None:
>>>>>>             enum_class.__qualname__ = qualname
       
   10:         return enum_class
       
>>>>>>     def _convert_(cls, name, module, filter, source=None):
               """
               Create a new Enum subclass that replaces a collection of global constants
               """
               # convert all constants from source (or module) that pass filter() to
               # a new Enum called name, and export the enum and its members back to
               # module;
               # also, replace the __reduce_ex__ method so unpickling works in
               # previous Python versions
   10:         module_globals = vars(sys.modules[module])
   10:         if source:
    6:             source = vars(source)
               else:
    4:             source = module_globals
               # _value2member_map_ is populated in the same order every time
               # for a consistent reverse mapping of number to name when there
               # are multiple names for the same number.
 1698:         members = [
   97:                 (name, value)
 1678:                 for name, value in source.items()
 1668:                 if filter(name)]
   10:         try:
                   # sort by value
  107:             members.sort(key=lambda t: (t[1], t[0]))
>>>>>>         except TypeError:
                   # unless some values aren't comparable, in which case sort by name
>>>>>>             members.sort(key=lambda t: t[0])
   10:         cls = cls(name, members, module=module)
   10:         cls.__reduce_ex__ = _reduce_ex_by_name
   10:         module_globals.update(cls.__members__)
   10:         module_globals[name] = cls
   10:         return cls
       
>>>>>>     @staticmethod
>>>>>>     def _check_for_existing_members(class_name, bases):
  165:         for chain in bases:
  322:             for base in chain.__mro__:
  238:                 if issubclass(base, Enum) and base._member_names_:
>>>>>>                     raise TypeError(
>>>>>>                             "%s: cannot extend enumeration %r"
>>>>>>                             % (class_name, base.__name__)
                                   )
       
>>>>>>     @staticmethod
>>>>>>     def _get_mixins_(class_name, bases):
               """
               Returns the type for creating enum members, and the first inherited
               enum class.
       
               bases: the tuple of bases that was given to __new__
               """
  172:         if not bases:
>>>>>>             return object, Enum
       
  172:         def _find_data_type(bases):
  172:             data_types = set()
  350:             for chain in bases:
  178:                 candidate = None
  414:                 for base in chain.__mro__:
  306:                     if base is object:
  108:                         continue
  198:                     elif issubclass(base, Enum):
  192:                         if base._member_type_ is not object:
   64:                             data_types.add(base._member_type_)
   64:                             break
    6:                     elif '__new__' in base.__dict__:
    6:                         if issubclass(base, Enum):
>>>>>>                             continue
    6:                         data_types.add(candidate or base)
    6:                         break
                           else:
>>>>>>                         candidate = candidate or base
  172:             if len(data_types) > 1:
>>>>>>                 raise TypeError('%r: too many data types: %r' % (class_name, data_types))
  172:             elif data_types:
   70:                 return data_types.pop()
                   else:
  102:                 return None
       
               # ensure final parent class is an Enum derivative, find any concrete
               # data type, and check that Enum has no members
  172:         first_enum = bases[-1]
  172:         if not issubclass(first_enum, Enum):
>>>>>>             raise TypeError("new enumerations should be created as "
                           "`EnumName([mixin_type, ...] [data_type,] enum_type)`")
  172:         member_type = _find_data_type(bases) or object
  172:         if first_enum._member_names_:
>>>>>>             raise TypeError("Cannot extend enumerations")
  172:         return member_type, first_enum
       
>>>>>>     @staticmethod
>>>>>>     def _find_new_(classdict, member_type, first_enum):
               """
               Returns the __new__ to be used for creating the enum members.
       
               classdict: the class dictionary given to __new__
               member_type: the data type whose __new__ will be used by default
               first_enum: enumeration to check for an overriding __new__
               """
               # now find the correct __new__, checking to see of one was defined
               # by the user; also check earlier enum classes in case a __new__ was
               # saved as __new_member__
   81:         __new__ = classdict.get('__new__', None)
       
               # should __new__ be saved as __new_member__ later?
   81:         save_new = __new__ is not None
       
   81:         if __new__ is None:
                   # check all possibles for __new_member__ before falling back to
                   # __new__
  209:             for method in ('__new_member__', '__new__'):
  418:                 for possible in (member_type, first_enum):
  288:                     target = getattr(possible, method, None)
  576:                     if target not in {
  288:                             None,
  288:                             None.__new__,
  288:                             object.__new__,
  288:                             Enum.__new__,
                                   }:
   28:                         __new__ = target
   28:                         break
  158:                 if __new__ is not None:
   28:                     break
                   else:
   51:                 __new__ = object.__new__
       
               # if a non-object.__new__ is used then whatever value/tuple was
               # assigned to the enum member name will be passed to __new__ and to the
               # new enum member's __init__
   81:         if __new__ is object.__new__:
   51:             use_args = False
               else:
   30:             use_args = True
   81:         return __new__, save_new, use_args
       
       
>>>>>> class Enum(metaclass=EnumMeta):
           """
           Generic enumeration.
       
           Derive from this class to define new enumerations.
           """
>>>>>>     def __new__(cls, value):
               # all enum instances are actually created during class construction
               # without calling this method; this method is called by the metaclass'
               # __call__ (i.e. Color(3) ), and by pickle
 2903:         if type(value) is cls:
                   # For lookups like Color(Color.RED)
 2353:             return value
               # by-value search for a matching enum member
               # see if it's in the reverse mapping (for hashable values)
  550:         try:
  550:             return cls._value2member_map_[value]
    5:         except KeyError:
                   # Not found, no need to do long O(n) search
    5:             pass
>>>>>>         except TypeError:
                   # not there, now do long search -- O(n) behavior
>>>>>>             for member in cls._member_map_.values():
>>>>>>                 if member._value_ == value:
>>>>>>                     return member
               # still not found -- try _missing_ hook
    5:         try:
    5:             exc = None
    5:             result = cls._missing_(value)
>>>>>>         except Exception as e:
>>>>>>             exc = e
>>>>>>             result = None
    5:         try:
    5:             if isinstance(result, cls):
   10:                 return result
                   else:
>>>>>>                 ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
>>>>>>                 if result is None and exc is None:
>>>>>>                     raise ve_exc
>>>>>>                 elif exc is None:
>>>>>>                     exc = TypeError(
>>>>>>                             'error in %s._missing_: returned %r instead of None or a valid member'
>>>>>>                             % (cls.__name__, result)
                                   )
>>>>>>                 exc.__context__ = ve_exc
>>>>>>                 raise exc
               finally:
                   # ensure all variables that could hold an exception are destroyed
    5:             exc = None
    5:             ve_exc = None
       
>>>>>>     def _generate_next_value_(name, start, count, last_values):
               """
               Generate the next value when not given.
       
               name: the name of the member
               start: the initial start value or None
               count: the number of existing members
               last_value: the last value assigned or None
               """
   20:         for last_value in reversed(last_values):
   16:             try:
   16:                 return last_value + 1
>>>>>>             except TypeError:
>>>>>>                 pass
               else:
    4:             return start
       
>>>>>>     @classmethod
>>>>>>     def _missing_(cls, value):
>>>>>>         return None
       
>>>>>>     def __repr__(self):
>>>>>>         return "<%s.%s: %r>" % (
>>>>>>                 self.__class__.__name__, self._name_, self._value_)
       
>>>>>>     def __str__(self):
>>>>>>         return "%s.%s" % (self.__class__.__name__, self._name_)
       
>>>>>>     def __dir__(self):
               """
               Returns all members and all public methods
               """
>>>>>>         added_behavior = [
>>>>>>                 m
>>>>>>                 for cls in self.__class__.mro()
>>>>>>                 for m in cls.__dict__
>>>>>>                 if m[0] != '_' and m not in self._member_map_
>>>>>>                 ] + [m for m in self.__dict__ if m[0] != '_']
>>>>>>         return (['__class__', '__doc__', '__module__'] + added_behavior)
       
>>>>>>     def __format__(self, format_spec):
               """
               Returns format using actual value type unless __str__ has been overridden.
               """
               # mixed-in Enums should use the mixed-in type's __format__, otherwise
               # we can get strange results with the Enum name showing up instead of
               # the value
       
               # pure Enum branch, or branch with __str__ explicitly overridden
>>>>>>         str_overridden = type(self).__str__ not in (Enum.__str__, Flag.__str__)
>>>>>>         if self._member_type_ is object or str_overridden:
>>>>>>             cls = str
>>>>>>             val = str(self)
               # mix-in branch
               else:
>>>>>>             cls = self._member_type_
>>>>>>             val = self._value_
>>>>>>         return cls.__format__(val, format_spec)
       
>>>>>>     def __hash__(self):
 3465:         return hash(self._name_)
       
>>>>>>     def __reduce_ex__(self, proto):
    5:         return self.__class__, (self._value_, )
       
           # DynamicClassAttribute is used to provide access to the `name` and
           # `value` properties of enum members while keeping some measure of
           # protection from modification, while still allowing for an enumeration
           # to have members named `name` and `value`.  This works because enumeration
           # members are not set directly on the enum class -- __getattr__ is
           # used to look them up.
       
>>>>>>     @DynamicClassAttribute
>>>>>>     def name(self):
               """The name of the Enum member."""
   67:         return self._name_
       
>>>>>>     @DynamicClassAttribute
>>>>>>     def value(self):
               """The value of the Enum member."""
  606:         return self._value_
       
       
>>>>>> class IntEnum(int, Enum):
           """Enum where members are also (and must be) ints"""
       
       
>>>>>> def _reduce_ex_by_name(self, proto):
>>>>>>     return self.name
       
>>>>>> class Flag(Enum):
           """
           Support for flags
           """
       
>>>>>>     def _generate_next_value_(name, start, count, last_values):
               """
               Generate the next value when not given.
       
               name: the name of the member
               start: the initial start value or None
               count: the number of existing members
               last_value: the last value assigned or None
               """
    5:         if not count:
    2:             return start if start is not None else 1
    3:         for last_value in reversed(last_values):
    3:             try:
    3:                 high_bit = _high_bit(last_value)
    3:                 break
>>>>>>             except Exception:
>>>>>>                 raise TypeError('Invalid Flag value: %r' % last_value) from None
    3:         return 2 ** (high_bit+1)
       
>>>>>>     @classmethod
>>>>>>     def _missing_(cls, value):
               """
               Returns member (possibly creating it) if one can be found for value.
               """
>>>>>>         original_value = value
>>>>>>         if value < 0:
>>>>>>             value = ~value
>>>>>>         possible_member = cls._create_pseudo_member_(value)
>>>>>>         if original_value < 0:
>>>>>>             possible_member = ~possible_member
>>>>>>         return possible_member
       
>>>>>>     @classmethod
>>>>>>     def _create_pseudo_member_(cls, value):
               """
               Create a composite member iff value contains only members.
               """
>>>>>>         pseudo_member = cls._value2member_map_.get(value, None)
>>>>>>         if pseudo_member is None:
                   # verify all bits are accounted for
>>>>>>             _, extra_flags = _decompose(cls, value)
>>>>>>             if extra_flags:
>>>>>>                 raise ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                   # construct a singleton enum pseudo-member
>>>>>>             pseudo_member = object.__new__(cls)
>>>>>>             pseudo_member._name_ = None
>>>>>>             pseudo_member._value_ = value
                   # use setdefault in case another thread already created a composite
                   # with this value
>>>>>>             pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)
>>>>>>         return pseudo_member
       
>>>>>>     def __contains__(self, other):
               """
               Returns True if self has at least the same flags set as other.
               """
>>>>>>         if not isinstance(other, self.__class__):
>>>>>>             raise TypeError(
>>>>>>                 "unsupported operand type(s) for 'in': '%s' and '%s'" % (
>>>>>>                     type(other).__qualname__, self.__class__.__qualname__))
>>>>>>         return other._value_ & self._value_ == other._value_
       
>>>>>>     def __repr__(self):
>>>>>>         cls = self.__class__
>>>>>>         if self._name_ is not None:
>>>>>>             return '<%s.%s: %r>' % (cls.__name__, self._name_, self._value_)
>>>>>>         members, uncovered = _decompose(cls, self._value_)
>>>>>>         return '<%s.%s: %r>' % (
>>>>>>                 cls.__name__,
>>>>>>                 '|'.join([str(m._name_ or m._value_) for m in members]),
>>>>>>                 self._value_,
                       )
       
>>>>>>     def __str__(self):
>>>>>>         cls = self.__class__
>>>>>>         if self._name_ is not None:
>>>>>>             return '%s.%s' % (cls.__name__, self._name_)
>>>>>>         members, uncovered = _decompose(cls, self._value_)
>>>>>>         if len(members) == 1 and members[0]._name_ is None:
>>>>>>             return '%s.%r' % (cls.__name__, members[0]._value_)
               else:
>>>>>>             return '%s.%s' % (
>>>>>>                     cls.__name__,
>>>>>>                     '|'.join([str(m._name_ or m._value_) for m in members]),
                           )
       
>>>>>>     def __bool__(self):
>>>>>>         return bool(self._value_)
       
>>>>>>     def __or__(self, other):
>>>>>>         if not isinstance(other, self.__class__):
>>>>>>             return NotImplemented
>>>>>>         return self.__class__(self._value_ | other._value_)
       
>>>>>>     def __and__(self, other):
>>>>>>         if not isinstance(other, self.__class__):
>>>>>>             return NotImplemented
>>>>>>         return self.__class__(self._value_ & other._value_)
       
>>>>>>     def __xor__(self, other):
>>>>>>         if not isinstance(other, self.__class__):
>>>>>>             return NotImplemented
>>>>>>         return self.__class__(self._value_ ^ other._value_)
       
>>>>>>     def __invert__(self):
>>>>>>         members, uncovered = _decompose(self.__class__, self._value_)
>>>>>>         inverted = self.__class__(0)
>>>>>>         for m in self.__class__:
>>>>>>             if m not in members and not (m._value_ & self._value_):
>>>>>>                 inverted = inverted | m
>>>>>>         return self.__class__(inverted)
       
       
>>>>>> class IntFlag(int, Flag):
           """
           Support for integer-based Flags
           """
       
>>>>>>     @classmethod
>>>>>>     def _missing_(cls, value):
               """
               Returns member (possibly creating it) if one can be found for value.
               """
    5:         if not isinstance(value, int):
>>>>>>             raise ValueError("%r is not a valid %s" % (value, cls.__qualname__))
    5:         new_member = cls._create_pseudo_member_(value)
    5:         return new_member
       
>>>>>>     @classmethod
>>>>>>     def _create_pseudo_member_(cls, value):
               """
               Create a composite member iff value contains only members.
               """
    5:         pseudo_member = cls._value2member_map_.get(value, None)
    5:         if pseudo_member is None:
    5:             need_to_create = [value]
                   # get unaccounted for bits
    5:             _, extra_flags = _decompose(cls, value)
                   # timer = 10
    5:             while extra_flags:
                       # timer -= 1
>>>>>>                 bit = _high_bit(extra_flags)
>>>>>>                 flag_value = 2 ** bit
>>>>>>                 if (flag_value not in cls._value2member_map_ and
>>>>>>                         flag_value not in need_to_create
                               ):
>>>>>>                     need_to_create.append(flag_value)
>>>>>>                 if extra_flags == -flag_value:
>>>>>>                     extra_flags = 0
                       else:
>>>>>>                     extra_flags ^= flag_value
   10:             for value in reversed(need_to_create):
                       # construct singleton pseudo-members
    5:                 pseudo_member = int.__new__(cls, value)
    5:                 pseudo_member._name_ = None
    5:                 pseudo_member._value_ = value
                       # use setdefault in case another thread already created a composite
                       # with this value
    5:                 pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)
    5:         return pseudo_member
       
>>>>>>     def __or__(self, other):
   24:         if not isinstance(other, (self.__class__, int)):
>>>>>>             return NotImplemented
   24:         result = self.__class__(self._value_ | self.__class__(other)._value_)
   24:         return result
       
>>>>>>     def __and__(self, other):
  201:         if not isinstance(other, (self.__class__, int)):
>>>>>>             return NotImplemented
  201:         return self.__class__(self._value_ & self.__class__(other)._value_)
       
>>>>>>     def __xor__(self, other):
>>>>>>         if not isinstance(other, (self.__class__, int)):
>>>>>>             return NotImplemented
>>>>>>         return self.__class__(self._value_ ^ self.__class__(other)._value_)
       
>>>>>>     __ror__ = __or__
>>>>>>     __rand__ = __and__
>>>>>>     __rxor__ = __xor__
       
>>>>>>     def __invert__(self):
>>>>>>         result = self.__class__(~self._value_)
>>>>>>         return result
       
       
>>>>>> def _high_bit(value):
           """
           returns index of highest bit, or -1 if value is zero or negative
           """
    3:     return value.bit_length() - 1
       
>>>>>> def unique(enumeration):
           """
           Class decorator for enumerations ensuring unique member values.
           """
    4:     duplicates = []
   20:     for name, member in enumeration.__members__.items():
   16:         if name != member.name:
>>>>>>             duplicates.append((name, member.name))
    4:     if duplicates:
>>>>>>         alias_details = ', '.join(
>>>>>>                 ["%s -> %s" % (alias, name) for (alias, name) in duplicates])
>>>>>>         raise ValueError('duplicate values found in %r: %s' %
>>>>>>                 (enumeration, alias_details))
    4:     return enumeration
       
>>>>>> def _decompose(flag, value):
           """
           Extract all members from the value.
           """
           # _decompose is only called if the value is not named
    5:     not_covered = value
    5:     negative = value < 0
    5:     members = []
   50:     for member in flag:
   45:         member_value = member.value
   45:         if member_value and member_value & value == member_value:
   10:             members.append(member)
   10:             not_covered &= ~member_value
    5:     if not negative:
    5:         tmp = not_covered
    5:         while tmp:
>>>>>>             flag_value = 2 ** _high_bit(tmp)
>>>>>>             if flag_value in flag._value2member_map_:
>>>>>>                 members.append(flag._value2member_map_[flag_value])
>>>>>>                 not_covered &= ~flag_value
>>>>>>             tmp &= ~flag_value
    5:     if not members and value in flag._value2member_map_:
>>>>>>         members.append(flag._value2member_map_[value])
   15:     members.sort(key=lambda m: m._value_, reverse=True)
    5:     if len(members) > 1 and members[0].value == value:
               # we have the breakdown, don't need the value member itself
>>>>>>         members.pop(0)
    5:     return members, not_covered
