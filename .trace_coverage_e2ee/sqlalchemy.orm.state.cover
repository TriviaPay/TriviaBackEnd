       # orm/state.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: """Defines instrumentation of instances.
       
       This module is usually not directly visible to user applications, but
       defines a large part of the ORM's interactivity.
       
       """
       
    1: from __future__ import annotations
       
    1: from typing import Any
    1: from typing import Callable
    1: from typing import Dict
    1: from typing import Generic
    1: from typing import Iterable
    1: from typing import Optional
    1: from typing import Set
    1: from typing import Tuple
    1: from typing import TYPE_CHECKING
    1: from typing import Union
    1: import weakref
       
    1: from . import base
    1: from . import exc as orm_exc
    1: from . import interfaces
    1: from ._typing import _O
    1: from ._typing import is_collection_impl
    1: from .base import ATTR_WAS_SET
    1: from .base import INIT_OK
    1: from .base import LoaderCallableStatus
    1: from .base import NEVER_SET
    1: from .base import NO_VALUE
    1: from .base import PASSIVE_NO_INITIALIZE
    1: from .base import PASSIVE_NO_RESULT
    1: from .base import PASSIVE_OFF
    1: from .base import SQL_OK
    1: from .path_registry import PathRegistry
    1: from .. import exc as sa_exc
    1: from .. import inspection
    1: from .. import util
    1: from ..util.typing import Literal
    1: from ..util.typing import Protocol
       
    1: if TYPE_CHECKING:
>>>>>>     from ._typing import _IdentityKeyType
>>>>>>     from ._typing import _InstanceDict
>>>>>>     from ._typing import _LoaderCallable
>>>>>>     from .attributes import AttributeImpl
>>>>>>     from .attributes import History
>>>>>>     from .base import PassiveFlag
>>>>>>     from .collections import _AdaptedCollectionProtocol
>>>>>>     from .identity import IdentityMap
>>>>>>     from .instrumentation import ClassManager
>>>>>>     from .interfaces import ORMOption
>>>>>>     from .mapper import Mapper
>>>>>>     from .session import Session
>>>>>>     from ..engine import Row
>>>>>>     from ..ext.asyncio.session import async_session as _async_provider
>>>>>>     from ..ext.asyncio.session import AsyncSession
       
    1: if TYPE_CHECKING:
>>>>>>     _sessions: weakref.WeakValueDictionary[int, Session]
       else:
           # late-populated by session.py
    1:     _sessions = None
       
       
    1: if not TYPE_CHECKING:
           # optionally late-provided by sqlalchemy.ext.asyncio.session
       
    1:     _async_provider = None  # noqa
       
       
    2: class _InstanceDictProto(Protocol):
    1:     def __call__(self) -> Optional[IdentityMap]: ...
       
       
    2: class _InstallLoaderCallableProto(Protocol[_O]):
    1:     """used at result loading time to install a _LoaderCallable callable
           upon a specific InstanceState, which will be used to populate an
           attribute when that attribute is accessed.
       
           Concrete examples are per-instance deferred column loaders and
           relationship lazy loaders.
       
           """
       
    1:     def __call__(
               self, state: InstanceState[_O], dict_: _InstanceDict, row: Row[Any]
>>>>>>     ) -> None: ...
       
       
    2: @inspection._self_inspects
    1: class InstanceState(interfaces.InspectionAttrInfo, Generic[_O]):
    1:     """tracks state information at the instance level.
       
           The :class:`.InstanceState` is a key object used by the
           SQLAlchemy ORM in order to track the state of an object;
           it is created the moment an object is instantiated, typically
           as a result of :term:`instrumentation` which SQLAlchemy applies
           to the ``__init__()`` method of the class.
       
           :class:`.InstanceState` is also a semi-public object,
           available for runtime inspection as to the state of a
           mapped instance, including information such as its current
           status within a particular :class:`.Session` and details
           about data on individual attributes.  The public API
           in order to acquire a :class:`.InstanceState` object
           is to use the :func:`_sa.inspect` system::
       
               >>> from sqlalchemy import inspect
               >>> insp = inspect(some_mapped_object)
               >>> insp.attrs.nickname.history
               History(added=['new nickname'], unchanged=(), deleted=['nickname'])
       
           .. seealso::
       
               :ref:`orm_mapper_inspection_instancestate`
       
           """
       
    1:     __slots__ = (
               "__dict__",
               "__weakref__",
               "class_",
               "manager",
               "obj",
               "committed_state",
               "expired_attributes",
           )
       
    1:     manager: ClassManager[_O]
    1:     session_id: Optional[int] = None
    1:     key: Optional[_IdentityKeyType[_O]] = None
    1:     runid: Optional[int] = None
    1:     load_options: Tuple[ORMOption, ...] = ()
    1:     load_path: PathRegistry = PathRegistry.root
    1:     insert_order: Optional[int] = None
    1:     _strong_obj: Optional[object] = None
    1:     obj: weakref.ref[_O]
       
    1:     committed_state: Dict[str, Any]
       
    1:     modified: bool = False
    1:     expired: bool = False
    1:     _deleted: bool = False
    1:     _load_pending: bool = False
    1:     _orphaned_outside_of_session: bool = False
    1:     is_instance: bool = True
    1:     identity_token: object = None
    1:     _last_known_values: Optional[Dict[str, Any]] = None
       
    1:     _instance_dict: _InstanceDictProto
           """A weak reference, or in the default case a plain callable, that
           returns a reference to the current :class:`.IdentityMap`, if any.
       
           """
    1:     if not TYPE_CHECKING:
       
    1:         def _instance_dict(self):
                   """default 'weak reference' for _instance_dict"""
   82:             return None
       
    1:     expired_attributes: Set[str]
           """The set of keys which are 'expired' to be loaded by
              the manager's deferred scalar loader, assuming no pending
              changes.
       
              see also the ``unmodified`` collection which is intersected
              against this set when a refresh operation occurs."""
       
    1:     callables: Dict[str, Callable[[InstanceState[_O], PassiveFlag], Any]]
           """A namespace where a per-state loader callable can be associated.
       
           In SQLAlchemy 1.0, this is only used for lazy loaders / deferred
           loaders that were set up via query option.
       
           Previously, callables was used also to indicate expired attributes
           by storing a link to the InstanceState itself in this dictionary.
           This role is now handled by the expired_attributes set.
       
           """
       
    1:     if not TYPE_CHECKING:
    1:         callables = util.EMPTY_DICT
       
    1:     def __init__(self, obj: _O, manager: ClassManager[_O]):
   99:         self.class_ = obj.__class__
   99:         self.manager = manager
   99:         self.obj = weakref.ref(obj, self._cleanup)
   99:         self.committed_state = {}
   99:         self.expired_attributes = set()
       
    1:     @util.memoized_property
    1:     def attrs(self) -> util.ReadOnlyProperties[AttributeState]:
               """Return a namespace representing each attribute on
               the mapped object, including its current value
               and history.
       
               The returned object is an instance of :class:`.AttributeState`.
               This object allows inspection of the current data
               within an attribute as well as attribute history
               since the last flush.
       
               """
>>>>>>         return util.ReadOnlyProperties(
>>>>>>             {key: AttributeState(self, key) for key in self.manager}
               )
       
    1:     @property
    1:     def transient(self) -> bool:
               """Return ``True`` if the object is :term:`transient`.
       
               .. seealso::
       
                   :ref:`session_object_states`
       
               """
>>>>>>         return self.key is None and not self._attached
       
    1:     @property
    1:     def pending(self) -> bool:
               """Return ``True`` if the object is :term:`pending`.
       
       
               .. seealso::
       
                   :ref:`session_object_states`
       
               """
>>>>>>         return self.key is None and self._attached
       
    1:     @property
    1:     def deleted(self) -> bool:
               """Return ``True`` if the object is :term:`deleted`.
       
               An object that is in the deleted state is guaranteed to
               not be within the :attr:`.Session.identity_map` of its parent
               :class:`.Session`; however if the session's transaction is rolled
               back, the object will be restored to the persistent state and
               the identity map.
       
               .. note::
       
                   The :attr:`.InstanceState.deleted` attribute refers to a specific
                   state of the object that occurs between the "persistent" and
                   "detached" states; once the object is :term:`detached`, the
                   :attr:`.InstanceState.deleted` attribute **no longer returns
                   True**; in order to detect that a state was deleted, regardless
                   of whether or not the object is associated with a
                   :class:`.Session`, use the :attr:`.InstanceState.was_deleted`
                   accessor.
       
               .. versionadded: 1.1
       
               .. seealso::
       
                   :ref:`session_object_states`
       
               """
>>>>>>         return self.key is not None and self._attached and self._deleted
       
    1:     @property
    1:     def was_deleted(self) -> bool:
               """Return True if this object is or was previously in the
               "deleted" state and has not been reverted to persistent.
       
               This flag returns True once the object was deleted in flush.
               When the object is expunged from the session either explicitly
               or via transaction commit and enters the "detached" state,
               this flag will continue to report True.
       
               .. seealso::
       
                   :attr:`.InstanceState.deleted` - refers to the "deleted" state
       
                   :func:`.orm.util.was_deleted` - standalone function
       
                   :ref:`session_object_states`
       
               """
>>>>>>         return self._deleted
       
    1:     @property
    1:     def persistent(self) -> bool:
               """Return ``True`` if the object is :term:`persistent`.
       
               An object that is in the persistent state is guaranteed to
               be within the :attr:`.Session.identity_map` of its parent
               :class:`.Session`.
       
               .. seealso::
       
                   :ref:`session_object_states`
       
               """
>>>>>>         return self.key is not None and self._attached and not self._deleted
       
    1:     @property
    1:     def detached(self) -> bool:
               """Return ``True`` if the object is :term:`detached`.
       
               .. seealso::
       
                   :ref:`session_object_states`
       
               """
>>>>>>         return self.key is not None and not self._attached
       
    1:     @util.non_memoized_property
    1:     @util.preload_module("sqlalchemy.orm.session")
    1:     def _attached(self) -> bool:
>>>>>>         return (
>>>>>>             self.session_id is not None
>>>>>>             and self.session_id in util.preloaded.orm_session._sessions
               )
       
    1:     def _track_last_known_value(self, key: str) -> None:
               """Track the last known value of a particular key after expiration
               operations.
       
               .. versionadded:: 1.3
       
               """
       
>>>>>>         lkv = self._last_known_values
>>>>>>         if lkv is None:
>>>>>>             self._last_known_values = lkv = {}
>>>>>>         if key not in lkv:
>>>>>>             lkv[key] = NO_VALUE
       
    1:     @property
    1:     def session(self) -> Optional[Session]:
               """Return the owning :class:`.Session` for this instance,
               or ``None`` if none available.
       
               Note that the result here can in some cases be *different*
               from that of ``obj in session``; an object that's been deleted
               will report as not ``in session``, however if the transaction is
               still in progress, this attribute will still refer to that session.
               Only when the transaction is completed does the object become
               fully detached under normal circumstances.
       
               .. seealso::
       
                   :attr:`_orm.InstanceState.async_session`
       
               """
   25:         if self.session_id:
   25:             try:
   25:                 return _sessions[self.session_id]
>>>>>>             except KeyError:
>>>>>>                 pass
>>>>>>         return None
       
    1:     @property
    1:     def async_session(self) -> Optional[AsyncSession]:
               """Return the owning :class:`_asyncio.AsyncSession` for this instance,
               or ``None`` if none available.
       
               This attribute is only non-None when the :mod:`sqlalchemy.ext.asyncio`
               API is in use for this ORM object. The returned
               :class:`_asyncio.AsyncSession` object will be a proxy for the
               :class:`_orm.Session` object that would be returned from the
               :attr:`_orm.InstanceState.session` attribute for this
               :class:`_orm.InstanceState`.
       
               .. versionadded:: 1.4.18
       
               .. seealso::
       
                   :ref:`asyncio_toplevel`
       
               """
>>>>>>         if _async_provider is None:
>>>>>>             return None
       
>>>>>>         sess = self.session
>>>>>>         if sess is not None:
>>>>>>             return _async_provider(sess)
               else:
>>>>>>             return None
       
    1:     @property
    1:     def object(self) -> Optional[_O]:
               """Return the mapped object represented by this
               :class:`.InstanceState`.
       
               Returns None if the object has been garbage collected
       
               """
>>>>>>         return self.obj()
       
    1:     @property
    1:     def identity(self) -> Optional[Tuple[Any, ...]]:
               """Return the mapped identity of the mapped object.
               This is the primary key identity as persisted by the ORM
               which can always be passed directly to
               :meth:`_query.Query.get`.
       
               Returns ``None`` if the object has no primary key identity.
       
               .. note::
                   An object which is :term:`transient` or :term:`pending`
                   does **not** have a mapped identity until it is flushed,
                   even if its attributes include primary key values.
       
               """
>>>>>>         if self.key is None:
>>>>>>             return None
               else:
>>>>>>             return self.key[1]
       
    1:     @property
    1:     def identity_key(self) -> Optional[_IdentityKeyType[_O]]:
               """Return the identity key for the mapped object.
       
               This is the key used to locate the object within
               the :attr:`.Session.identity_map` mapping.   It contains
               the identity as returned by :attr:`.identity` within it.
       
       
               """
>>>>>>         return self.key
       
    1:     @util.memoized_property
    1:     def parents(self) -> Dict[int, Union[Literal[False], InstanceState[Any]]]:
>>>>>>         return {}
       
    1:     @util.memoized_property
    1:     def _pending_mutations(self) -> Dict[str, PendingCollection]:
   32:         return {}
       
    1:     @util.memoized_property
    1:     def _empty_collections(self) -> Dict[str, _AdaptedCollectionProtocol]:
>>>>>>         return {}
       
    1:     @util.memoized_property
    1:     def mapper(self) -> Mapper[_O]:
               """Return the :class:`_orm.Mapper` used for this mapped object."""
   84:         return self.manager.mapper
       
    1:     @property
    1:     def has_identity(self) -> bool:
               """Return ``True`` if this object has an identity key.
       
               This should always have the same value as the
               expression ``state.persistent`` or ``state.detached``.
       
               """
>>>>>>         return bool(self.key)
       
    1:     @classmethod
    1:     def _detach_states(
               self,
               states: Iterable[InstanceState[_O]],
               session: Session,
               to_transient: bool = False,
           ) -> None:
   54:         persistent_to_detached = (
   54:             session.dispatch.persistent_to_detached or None
               )
   54:         deleted_to_detached = session.dispatch.deleted_to_detached or None
   54:         pending_to_transient = session.dispatch.pending_to_transient or None
   54:         persistent_to_transient = (
   54:             session.dispatch.persistent_to_transient or None
               )
       
   96:         for state in states:
   42:             deleted = state._deleted
   42:             pending = state.key is None
   42:             persistent = not pending and not deleted
       
   42:             state.session_id = None
       
   42:             if to_transient and state.key:
>>>>>>                 del state.key
   42:             if persistent:
   42:                 if to_transient:
>>>>>>                     if persistent_to_transient is not None:
>>>>>>                         persistent_to_transient(session, state)
   42:                 elif persistent_to_detached is not None:
>>>>>>                     persistent_to_detached(session, state)
>>>>>>             elif deleted and deleted_to_detached is not None:
>>>>>>                 deleted_to_detached(session, state)
>>>>>>             elif pending and pending_to_transient is not None:
>>>>>>                 pending_to_transient(session, state)
       
   42:             state._strong_obj = None
       
    1:     def _detach(self, session: Optional[Session] = None) -> None:
>>>>>>         if session:
>>>>>>             InstanceState._detach_states([self], session)
               else:
>>>>>>             self.session_id = self._strong_obj = None
       
    1:     def _dispose(self) -> None:
               # used by the test suite, apparently
>>>>>>         self._detach()
       
    1:     def _cleanup(self, ref: weakref.ref[_O]) -> None:
               """Weakref callback cleanup.
       
               This callable cleans out the state when it is being garbage
               collected.
       
               this _cleanup **assumes** that there are no strong refs to us!
               Will not work otherwise!
       
               """
       
               # Python builtins become undefined during interpreter shutdown.
               # Guard against exceptions during this phase, as the method cannot
               # proceed in any case if builtins have been undefined.
   73:         if dict is None:
>>>>>>             return
       
   73:         instance_dict = self._instance_dict()
   73:         if instance_dict is not None:
   54:             instance_dict._fast_discard(self)
   54:             del self._instance_dict
       
                   # we can't possibly be in instance_dict._modified
                   # b.c. this is weakref cleanup only, that set
                   # is strong referencing!
                   # assert self not in instance_dict._modified
       
   73:         self.session_id = self._strong_obj = None
       
    1:     @property
    1:     def dict(self) -> _InstanceDict:
               """Return the instance dict used by the object.
       
               Under normal circumstances, this is always synonymous
               with the ``__dict__`` attribute of the mapped object,
               unless an alternative instrumentation system has been
               configured.
       
               In the case that the actual object has been garbage
               collected, this accessor returns a blank dictionary.
       
               """
 1665:         o = self.obj()
 1665:         if o is not None:
 1665:             return base.instance_dict(o)
               else:
>>>>>>             return {}
       
    1:     def _initialize_instance(*mixed: Any, **kwargs: Any) -> None:
   80:         self, instance, args = mixed[0], mixed[1], mixed[2:]  # noqa
   80:         manager = self.manager
       
   80:         manager.dispatch.init(self, args, kwargs)
       
   80:         try:
   80:             manager.original_init(*mixed[1:], **kwargs)
>>>>>>         except:
>>>>>>             with util.safe_reraise():
>>>>>>                 manager.dispatch.init_failure(self, args, kwargs)
       
    1:     def get_history(self, key: str, passive: PassiveFlag) -> History:
>>>>>>         return self.manager[key].impl.get_history(self, self.dict, passive)
       
    1:     def get_impl(self, key: str) -> AttributeImpl:
>>>>>>         return self.manager[key].impl
       
    1:     def _get_pending_mutation(self, key: str) -> PendingCollection:
>>>>>>         if key not in self._pending_mutations:
>>>>>>             self._pending_mutations[key] = PendingCollection()
>>>>>>         return self._pending_mutations[key]
       
    1:     def __getstate__(self) -> Dict[str, Any]:
>>>>>>         state_dict: Dict[str, Any] = {
>>>>>>             "instance": self.obj(),
>>>>>>             "class_": self.class_,
>>>>>>             "committed_state": self.committed_state,
>>>>>>             "expired_attributes": self.expired_attributes,
               }
>>>>>>         state_dict.update(
>>>>>>             (k, self.__dict__[k])
>>>>>>             for k in (
                       "_pending_mutations",
                       "modified",
                       "expired",
                       "callables",
                       "key",
                       "parents",
                       "load_options",
                       "class_",
                       "expired_attributes",
                       "info",
                   )
>>>>>>             if k in self.__dict__
               )
>>>>>>         if self.load_path:
>>>>>>             state_dict["load_path"] = self.load_path.serialize()
       
>>>>>>         state_dict["manager"] = self.manager._serialize(self, state_dict)
       
>>>>>>         return state_dict
       
    1:     def __setstate__(self, state_dict: Dict[str, Any]) -> None:
>>>>>>         inst = state_dict["instance"]
>>>>>>         if inst is not None:
>>>>>>             self.obj = weakref.ref(inst, self._cleanup)
>>>>>>             self.class_ = inst.__class__
               else:
>>>>>>             self.obj = lambda: None  # type: ignore
>>>>>>             self.class_ = state_dict["class_"]
       
>>>>>>         self.committed_state = state_dict.get("committed_state", {})
>>>>>>         self._pending_mutations = state_dict.get("_pending_mutations", {})
>>>>>>         self.parents = state_dict.get("parents", {})
>>>>>>         self.modified = state_dict.get("modified", False)
>>>>>>         self.expired = state_dict.get("expired", False)
>>>>>>         if "info" in state_dict:
>>>>>>             self.info.update(state_dict["info"])
>>>>>>         if "callables" in state_dict:
>>>>>>             self.callables = state_dict["callables"]
       
>>>>>>             self.expired_attributes = state_dict["expired_attributes"]
               else:
>>>>>>             if "expired_attributes" in state_dict:
>>>>>>                 self.expired_attributes = state_dict["expired_attributes"]
                   else:
>>>>>>                 self.expired_attributes = set()
       
>>>>>>         self.__dict__.update(
>>>>>>             [
>>>>>>                 (k, state_dict[k])
>>>>>>                 for k in ("key", "load_options")
>>>>>>                 if k in state_dict
                   ]
               )
>>>>>>         if self.key:
>>>>>>             self.identity_token = self.key[2]
       
>>>>>>         if "load_path" in state_dict:
>>>>>>             self.load_path = PathRegistry.deserialize(state_dict["load_path"])
       
>>>>>>         state_dict["manager"](self, inst, state_dict)
       
    1:     def _reset(self, dict_: _InstanceDict, key: str) -> None:
               """Remove the given attribute and any
               callables associated with it."""
       
>>>>>>         old = dict_.pop(key, None)
>>>>>>         manager_impl = self.manager[key].impl
>>>>>>         if old is not None and is_collection_impl(manager_impl):
>>>>>>             manager_impl._invalidate_collection(old)
>>>>>>         self.expired_attributes.discard(key)
>>>>>>         if self.callables:
>>>>>>             self.callables.pop(key, None)
       
    1:     def _copy_callables(self, from_: InstanceState[Any]) -> None:
>>>>>>         if "callables" in from_.__dict__:
>>>>>>             self.callables = dict(from_.callables)
       
    1:     @classmethod
    1:     def _instance_level_callable_processor(
               cls, manager: ClassManager[_O], fn: _LoaderCallable, key: Any
           ) -> _InstallLoaderCallableProto[_O]:
>>>>>>         impl = manager[key].impl
>>>>>>         if is_collection_impl(impl):
>>>>>>             fixed_impl = impl
       
>>>>>>             def _set_callable(
                       state: InstanceState[_O], dict_: _InstanceDict, row: Row[Any]
                   ) -> None:
>>>>>>                 if "callables" not in state.__dict__:
>>>>>>                     state.callables = {}
>>>>>>                 old = dict_.pop(key, None)
>>>>>>                 if old is not None:
>>>>>>                     fixed_impl._invalidate_collection(old)
>>>>>>                 state.callables[key] = fn
       
               else:
       
>>>>>>             def _set_callable(
                       state: InstanceState[_O], dict_: _InstanceDict, row: Row[Any]
                   ) -> None:
>>>>>>                 if "callables" not in state.__dict__:
>>>>>>                     state.callables = {}
>>>>>>                 state.callables[key] = fn
       
>>>>>>         return _set_callable
       
    1:     def _expire(
               self, dict_: _InstanceDict, modified_set: Set[InstanceState[Any]]
           ) -> None:
  116:         self.expired = True
  116:         if self.modified:
>>>>>>             modified_set.discard(self)
>>>>>>             self.committed_state.clear()
>>>>>>             self.modified = False
       
  116:         self._strong_obj = None
       
  116:         if "_pending_mutations" in self.__dict__:
>>>>>>             del self.__dict__["_pending_mutations"]
       
  116:         if "parents" in self.__dict__:
>>>>>>             del self.__dict__["parents"]
       
  232:         self.expired_attributes.update(
 6422:             [impl.key for impl in self.manager._loader_impls]
               )
       
  116:         if self.callables:
                   # the per state loader callables we can remove here are
                   # LoadDeferredColumns, which undefers a column at the instance
                   # level that is mapped with deferred, and LoadLazyAttribute,
                   # which lazy loads a relationship at the instance level that
                   # is mapped with "noload" or perhaps "immediateload".
                   # Before 1.4, only column-based
                   # attributes could be considered to be "expired", so here they
                   # were the only ones "unexpired", which means to make them deferred
                   # again.   For the moment, as of 1.4 we also apply the same
                   # treatment relationships now, that is, an instance level lazy
                   # loader is reset in the same way as a column loader.
>>>>>>             for k in self.expired_attributes.intersection(self.callables):
>>>>>>                 del self.callables[k]
       
  116:         for k in self.manager._collection_impl_keys.intersection(dict_):
>>>>>>             collection = dict_.pop(k)
>>>>>>             collection._sa_adapter.invalidated = True
       
  116:         if self._last_known_values:
>>>>>>             self._last_known_values.update(
>>>>>>                 {k: dict_[k] for k in self._last_known_values if k in dict_}
                   )
       
 2632:         for key in self.manager._all_key_set.intersection(dict_):
 2516:             del dict_[key]
       
  116:         self.manager.dispatch.expire(self, None)
       
    1:     def _expire_attributes(
               self,
               dict_: _InstanceDict,
               attribute_names: Iterable[str],
               no_loader: bool = False,
           ) -> None:
>>>>>>         pending = self.__dict__.get("_pending_mutations", None)
       
>>>>>>         callables = self.callables
       
>>>>>>         for key in attribute_names:
>>>>>>             impl = self.manager[key].impl
>>>>>>             if impl.accepts_scalar_loader:
>>>>>>                 if no_loader and (impl.callable_ or key in callables):
>>>>>>                     continue
       
>>>>>>                 self.expired_attributes.add(key)
>>>>>>                 if callables and key in callables:
>>>>>>                     del callables[key]
>>>>>>             old = dict_.pop(key, NO_VALUE)
>>>>>>             if is_collection_impl(impl) and old is not NO_VALUE:
>>>>>>                 impl._invalidate_collection(old)
       
>>>>>>             lkv = self._last_known_values
>>>>>>             if lkv is not None and key in lkv and old is not NO_VALUE:
>>>>>>                 lkv[key] = old
       
>>>>>>             self.committed_state.pop(key, None)
>>>>>>             if pending:
>>>>>>                 pending.pop(key, None)
       
>>>>>>         self.manager.dispatch.expire(self, attribute_names)
       
    1:     def _load_expired(
               self, state: InstanceState[_O], passive: PassiveFlag
           ) -> LoaderCallableStatus:
               """__call__ allows the InstanceState to act as a deferred
               callable for loading expired attributes, which is also
               serializable (picklable).
       
               """
       
   25:         if not passive & SQL_OK:
>>>>>>             return PASSIVE_NO_RESULT
       
   25:         toload = self.expired_attributes.intersection(self.unmodified)
 1806:         toload = toload.difference(
>>>>>>             attr
 1756:             for attr in toload
 1731:             if not self.manager[attr].impl.load_on_unexpire
               )
       
   25:         self.manager.expired_attribute_loader(self, toload, passive)
       
               # if the loader failed, or this
               # instance state didn't have an identity,
               # the attributes still might be in the callables
               # dict.  ensure they are removed.
   25:         self.expired_attributes.clear()
       
   25:         return ATTR_WAS_SET
       
    1:     @property
    1:     def unmodified(self) -> Set[str]:
               """Return the set of keys which have no uncommitted changes"""
       
   26:         return set(self.manager).difference(self.committed_state)
       
    1:     def unmodified_intersection(self, keys: Iterable[str]) -> Set[str]:
               """Return self.unmodified.intersection(keys)."""
       
>>>>>>         return (
>>>>>>             set(keys)
>>>>>>             .intersection(self.manager)
>>>>>>             .difference(self.committed_state)
               )
       
    1:     @property
    1:     def unloaded(self) -> Set[str]:
               """Return the set of keys which do not have a loaded value.
       
               This includes expired attributes and any other attribute that was never
               populated or modified.
       
               """
   35:         return (
  105:             set(self.manager)
   35:             .difference(self.committed_state)
   35:             .difference(self.dict)
               )
       
    1:     @property
    2:     @util.deprecated(
    1:         "2.0",
    1:         "The :attr:`.InstanceState.unloaded_expirable` attribute is "
               "deprecated.  Please use :attr:`.InstanceState.unloaded`.",
           )
    1:     def unloaded_expirable(self) -> Set[str]:
               """Synonymous with :attr:`.InstanceState.unloaded`.
       
               This attribute was added as an implementation-specific detail at some
               point and should be considered to be private.
       
               """
>>>>>>         return self.unloaded
       
    1:     @property
    1:     def _unloaded_non_object(self) -> Set[str]:
>>>>>>         return self.unloaded.intersection(
>>>>>>             attr
>>>>>>             for attr in self.manager
>>>>>>             if self.manager[attr].impl.accepts_scalar_loader
               )
       
    1:     def _modified_event(
               self,
               dict_: _InstanceDict,
               attr: Optional[AttributeImpl],
               previous: Any,
               collection: bool = False,
               is_userland: bool = False,
           ) -> None:
  293:         if attr:
  293:             if not attr.send_modified_events:
>>>>>>                 return
  293:             if is_userland and attr.key not in dict_:
>>>>>>                 raise sa_exc.InvalidRequestError(
>>>>>>                     "Can't flag attribute '%s' modified; it's not present in "
>>>>>>                     "the object state" % attr.key
                       )
  293:             if attr.key not in self.committed_state or is_userland:
  293:                 if collection:
>>>>>>                     if TYPE_CHECKING:
>>>>>>                         assert is_collection_impl(attr)
>>>>>>                     if previous is NEVER_SET:
>>>>>>                         if attr.key in dict_:
>>>>>>                             previous = dict_[attr.key]
       
>>>>>>                     if previous not in (None, NO_VALUE, NEVER_SET):
>>>>>>                         previous = attr.copy(previous)
  293:                 self.committed_state[attr.key] = previous
       
  293:             lkv = self._last_known_values
  293:             if lkv is not None and attr.key in lkv:
>>>>>>                 lkv[attr.key] = NO_VALUE
       
               # assert self._strong_obj is None or self.modified
       
  293:         if (self.session_id and self._strong_obj is None) or not self.modified:
   85:             self.modified = True
   85:             instance_dict = self._instance_dict()
   85:             if instance_dict:
    6:                 has_modified = bool(instance_dict._modified)
    6:                 instance_dict._modified.add(self)
                   else:
   79:                 has_modified = False
       
                   # only create _strong_obj link if attached
                   # to a session
       
   85:             inst = self.obj()
   85:             if self.session_id:
    6:                 self._strong_obj = inst
       
                       # if identity map already had modified objects,
                       # assume autobegin already occurred, else check
                       # for autobegin
    6:                 if not has_modified:
                           # inline of autobegin, to ensure session transaction
                           # snapshot is established
    6:                     try:
    6:                         session = _sessions[self.session_id]
>>>>>>                     except KeyError:
>>>>>>                         pass
                           else:
    6:                         if session._transaction is None:
>>>>>>                             session._autobegin_t()
       
   85:             if inst is None and attr:
>>>>>>                 raise orm_exc.ObjectDereferencedError(
>>>>>>                     "Can't emit change event for attribute '%s' - "
                           "parent object of type %s has been garbage "
                           "collected."
>>>>>>                     % (self.manager[attr.key], base.state_class_str(self))
                       )
       
    1:     def _commit(self, dict_: _InstanceDict, keys: Iterable[str]) -> None:
               """Commit attributes.
       
               This is used by a partial-attribute load operation to mark committed
               those attributes which were refreshed from the database.
       
               Attributes marked as "expired" can potentially remain "expired" after
               this step if a value was not populated in state.dict.
       
               """
 4300:         for key in keys:
 4240:             self.committed_state.pop(key, None)
       
   60:         self.expired = False
       
  120:         self.expired_attributes.difference_update(
   60:             set(keys).intersection(dict_)
               )
       
               # the per-keys commit removes object-level callables,
               # while that of commit_all does not.  it's not clear
               # if this behavior has a clear rationale, however tests do
               # ensure this is what it does.
   60:         if self.callables:
>>>>>>             for key in (
>>>>>>                 set(self.callables).intersection(keys).intersection(dict_)
                   ):
>>>>>>                 del self.callables[key]
       
    1:     def _commit_all(
               self, dict_: _InstanceDict, instance_dict: Optional[IdentityMap] = None
           ) -> None:
               """commit all attributes unconditionally.
       
               This is used after a flush() or a full load/refresh
               to remove all pending state from the instance.
       
                - all attributes are marked as "committed"
                - the "strong dirty reference" is removed
                - the "modified" flag is set to False
                - any "expired" markers for scalar attributes loaded are removed.
                - lazy load callables for objects / collections *stay*
       
               Attributes marked as "expired" can potentially remain
               "expired" after this step if a value was not populated in state.dict.
       
               """
    2:         self._commit_all_states([(self, dict_)], instance_dict)
       
    1:     @classmethod
    1:     def _commit_all_states(
               self,
               iter_: Iterable[Tuple[InstanceState[Any], _InstanceDict]],
               instance_dict: Optional[IdentityMap] = None,
           ) -> None:
               """Mass / highly inlined version of commit_all()."""
       
  130:         for state, dict_ in iter_:
   85:             state_dict = state.__dict__
       
   85:             state.committed_state.clear()
       
   85:             if "_pending_mutations" in state_dict:
   32:                 del state_dict["_pending_mutations"]
       
   85:             state.expired_attributes.difference_update(dict_)
       
   85:             if instance_dict and state.modified:
   82:                 instance_dict._modified.discard(state)
       
   85:             state.modified = state.expired = False
   85:             state._strong_obj = None
       
       
    2: class AttributeState:
    1:     """Provide an inspection interface corresponding
           to a particular attribute on a particular mapped object.
       
           The :class:`.AttributeState` object is accessed
           via the :attr:`.InstanceState.attrs` collection
           of a particular :class:`.InstanceState`::
       
               from sqlalchemy import inspect
       
               insp = inspect(some_mapped_object)
               attr_state = insp.attrs.some_attribute
       
           """
       
    1:     __slots__ = ("state", "key")
       
    1:     state: InstanceState[Any]
    1:     key: str
       
    1:     def __init__(self, state: InstanceState[Any], key: str):
>>>>>>         self.state = state
>>>>>>         self.key = key
       
    1:     @property
    1:     def loaded_value(self) -> Any:
               """The current value of this attribute as loaded from the database.
       
               If the value has not been loaded, or is otherwise not present
               in the object's dictionary, returns NO_VALUE.
       
               """
>>>>>>         return self.state.dict.get(self.key, NO_VALUE)
       
    1:     @property
    1:     def value(self) -> Any:
               """Return the value of this attribute.
       
               This operation is equivalent to accessing the object's
               attribute directly or via ``getattr()``, and will fire
               off any pending loader callables if needed.
       
               """
>>>>>>         return self.state.manager[self.key].__get__(
>>>>>>             self.state.obj(), self.state.class_
               )
       
    1:     @property
    1:     def history(self) -> History:
               """Return the current **pre-flush** change history for
               this attribute, via the :class:`.History` interface.
       
               This method will **not** emit loader callables if the value of the
               attribute is unloaded.
       
               .. note::
       
                   The attribute history system tracks changes on a **per flush
                   basis**. Each time the :class:`.Session` is flushed, the history
                   of each attribute is reset to empty.   The :class:`.Session` by
                   default autoflushes each time a :class:`_query.Query` is invoked.
                   For
                   options on how to control this, see :ref:`session_flushing`.
       
       
               .. seealso::
       
                   :meth:`.AttributeState.load_history` - retrieve history
                   using loader callables if the value is not locally present.
       
                   :func:`.attributes.get_history` - underlying function
       
               """
>>>>>>         return self.state.get_history(self.key, PASSIVE_NO_INITIALIZE)
       
    1:     def load_history(self) -> History:
               """Return the current **pre-flush** change history for
               this attribute, via the :class:`.History` interface.
       
               This method **will** emit loader callables if the value of the
               attribute is unloaded.
       
               .. note::
       
                   The attribute history system tracks changes on a **per flush
                   basis**. Each time the :class:`.Session` is flushed, the history
                   of each attribute is reset to empty.   The :class:`.Session` by
                   default autoflushes each time a :class:`_query.Query` is invoked.
                   For
                   options on how to control this, see :ref:`session_flushing`.
       
               .. seealso::
       
                   :attr:`.AttributeState.history`
       
                   :func:`.attributes.get_history` - underlying function
       
               """
>>>>>>         return self.state.get_history(self.key, PASSIVE_OFF ^ INIT_OK)
       
       
    2: class PendingCollection:
    1:     """A writable placeholder for an unloaded collection.
       
           Stores items appended to and removed from a collection that has not yet
           been loaded. When the collection is loaded, the changes stored in
           PendingCollection are applied to it to produce the final result.
       
           """
       
    1:     __slots__ = ("deleted_items", "added_items")
       
    1:     deleted_items: util.IdentitySet
    1:     added_items: util.OrderedIdentitySet
       
    1:     def __init__(self) -> None:
>>>>>>         self.deleted_items = util.IdentitySet()
>>>>>>         self.added_items = util.OrderedIdentitySet()
       
    1:     def merge_with_history(self, history: History) -> History:
>>>>>>         return history._merge(self.added_items, self.deleted_items)
       
    1:     def append(self, value: Any) -> None:
>>>>>>         if value in self.deleted_items:
>>>>>>             self.deleted_items.remove(value)
               else:
>>>>>>             self.added_items.add(value)
       
    1:     def remove(self, value: Any) -> None:
>>>>>>         if value in self.added_items:
>>>>>>             self.added_items.remove(value)
               else:
>>>>>>             self.deleted_items.add(value)
