    1: from contextlib import contextmanager
    1: from typing import Iterator, Optional, Union
       
    1: from .._models import (
           URL,
           Extensions,
           HeaderTypes,
           Origin,
           Request,
           Response,
           enforce_bytes,
           enforce_headers,
           enforce_url,
           include_request_headers,
       )
       
       
    2: class RequestInterface:
    2:     def request(
               self,
    1:         method: Union[bytes, str],
    1:         url: Union[URL, bytes, str],
               *,
    2:         headers: HeaderTypes = None,
    2:         content: Union[bytes, Iterator[bytes], None] = None,
    2:         extensions: Optional[Extensions] = None,
    1:     ) -> Response:
               # Strict type checking on our parameters.
>>>>>>         method = enforce_bytes(method, name="method")
>>>>>>         url = enforce_url(url, name="url")
>>>>>>         headers = enforce_headers(headers, name="headers")
       
               # Include Host header, and optionally Content-Length or Transfer-Encoding.
>>>>>>         headers = include_request_headers(headers, url=url, content=content)
       
>>>>>>         request = Request(
>>>>>>             method=method,
>>>>>>             url=url,
>>>>>>             headers=headers,
>>>>>>             content=content,
>>>>>>             extensions=extensions,
               )
>>>>>>         response = self.handle_request(request)
>>>>>>         try:
>>>>>>             response.read()
               finally:
>>>>>>             response.close()
>>>>>>         return response
       
    1:     @contextmanager
    2:     def stream(
               self,
    1:         method: Union[bytes, str],
    1:         url: Union[URL, bytes, str],
               *,
    2:         headers: HeaderTypes = None,
    2:         content: Union[bytes, Iterator[bytes], None] = None,
    2:         extensions: Optional[Extensions] = None,
    1:     ) -> Iterator[Response]:
               # Strict type checking on our parameters.
>>>>>>         method = enforce_bytes(method, name="method")
>>>>>>         url = enforce_url(url, name="url")
>>>>>>         headers = enforce_headers(headers, name="headers")
       
               # Include Host header, and optionally Content-Length or Transfer-Encoding.
>>>>>>         headers = include_request_headers(headers, url=url, content=content)
       
>>>>>>         request = Request(
>>>>>>             method=method,
>>>>>>             url=url,
>>>>>>             headers=headers,
>>>>>>             content=content,
>>>>>>             extensions=extensions,
               )
>>>>>>         response = self.handle_request(request)
>>>>>>         try:
>>>>>>             yield response
               finally:
>>>>>>             response.close()
       
    1:     def handle_request(self, request: Request) -> Response:
>>>>>>         raise NotImplementedError()  # pragma: nocover
       
       
    2: class ConnectionInterface(RequestInterface):
    1:     def close(self) -> None:
>>>>>>         raise NotImplementedError()  # pragma: nocover
       
    1:     def info(self) -> str:
>>>>>>         raise NotImplementedError()  # pragma: nocover
       
    1:     def can_handle_request(self, origin: Origin) -> bool:
>>>>>>         raise NotImplementedError()  # pragma: nocover
       
    1:     def is_available(self) -> bool:
               """
               Return `True` if the connection is currently able to accept an
               outgoing request.
       
               An HTTP/1.1 connection will only be available if it is currently idle.
       
               An HTTP/2 connection will be available so long as the stream ID space is
               not yet exhausted, and the connection is not in an error state.
       
               While the connection is being established we may not yet know if it is going
               to result in an HTTP/1.1 or HTTP/2 connection. The connection should be
               treated as being available, but might ultimately raise `NewConnectionRequired`
               required exceptions if multiple requests are attempted over a connection
               that ends up being established as HTTP/1.1.
               """
>>>>>>         raise NotImplementedError()  # pragma: nocover
       
    1:     def has_expired(self) -> bool:
               """
               Return `True` if the connection is in a state where it should be closed.
       
               This either means that the connection is idle and it has passed the
               expiry time on its keep-alive, or that server has sent an EOF.
               """
>>>>>>         raise NotImplementedError()  # pragma: nocover
       
    1:     def is_idle(self) -> bool:
               """
               Return `True` if the connection is currently idle.
               """
>>>>>>         raise NotImplementedError()  # pragma: nocover
       
    1:     def is_closed(self) -> bool:
               """
               Return `True` if the connection has been closed.
       
               Used when a response is closed to determine if the connection may be
               returned to the connection pool or not.
               """
>>>>>>         raise NotImplementedError()  # pragma: nocover
