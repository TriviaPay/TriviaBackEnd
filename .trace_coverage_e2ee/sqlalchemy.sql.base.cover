       # sql/base.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       # mypy: allow-untyped-defs, allow-untyped-calls
       
    1: """Foundational utilities common to many sql modules.
       
       """
       
       
    1: from __future__ import annotations
       
    1: import collections
    1: from enum import Enum
    1: import itertools
    1: from itertools import zip_longest
    1: import operator
    1: import re
    1: from typing import Any
    1: from typing import Callable
    1: from typing import cast
    1: from typing import Dict
    1: from typing import FrozenSet
    1: from typing import Generic
    1: from typing import Iterable
    1: from typing import Iterator
    1: from typing import List
    1: from typing import Mapping
    1: from typing import MutableMapping
    1: from typing import NamedTuple
    1: from typing import NoReturn
    1: from typing import Optional
    1: from typing import overload
    1: from typing import Sequence
    1: from typing import Set
    1: from typing import Tuple
    1: from typing import Type
    1: from typing import TYPE_CHECKING
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from . import roles
    1: from . import visitors
    1: from .cache_key import HasCacheKey  # noqa
    1: from .cache_key import MemoizedHasCacheKey  # noqa
    1: from .traversals import HasCopyInternals  # noqa
    1: from .visitors import ClauseVisitor
    1: from .visitors import ExtendedInternalTraversal
    1: from .visitors import ExternallyTraversible
    1: from .visitors import InternalTraversal
    1: from .. import event
    1: from .. import exc
    1: from .. import util
    1: from ..util import HasMemoized as HasMemoized
    1: from ..util import hybridmethod
    1: from ..util import typing as compat_typing
    1: from ..util.typing import Protocol
    1: from ..util.typing import Self
    1: from ..util.typing import TypeGuard
       
    1: if TYPE_CHECKING:
>>>>>>     from . import coercions
>>>>>>     from . import elements
>>>>>>     from . import type_api
>>>>>>     from ._orm_types import DMLStrategyArgument
>>>>>>     from ._orm_types import SynchronizeSessionArgument
>>>>>>     from ._typing import _CLE
>>>>>>     from .elements import BindParameter
>>>>>>     from .elements import ClauseList
>>>>>>     from .elements import ColumnClause  # noqa
>>>>>>     from .elements import ColumnElement
>>>>>>     from .elements import KeyedColumnElement
>>>>>>     from .elements import NamedColumn
>>>>>>     from .elements import SQLCoreOperations
>>>>>>     from .elements import TextClause
>>>>>>     from .schema import Column
>>>>>>     from .schema import DefaultGenerator
>>>>>>     from .selectable import _JoinTargetElement
>>>>>>     from .selectable import _SelectIterable
>>>>>>     from .selectable import FromClause
>>>>>>     from ..engine import Connection
>>>>>>     from ..engine import CursorResult
>>>>>>     from ..engine.interfaces import _CoreMultiExecuteParams
>>>>>>     from ..engine.interfaces import _ExecuteOptions
>>>>>>     from ..engine.interfaces import _ImmutableExecuteOptions
>>>>>>     from ..engine.interfaces import CacheStats
>>>>>>     from ..engine.interfaces import Compiled
>>>>>>     from ..engine.interfaces import CompiledCacheType
>>>>>>     from ..engine.interfaces import CoreExecuteOptionsParameter
>>>>>>     from ..engine.interfaces import Dialect
>>>>>>     from ..engine.interfaces import IsolationLevel
>>>>>>     from ..engine.interfaces import SchemaTranslateMapType
>>>>>>     from ..event import dispatcher
       
    1: if not TYPE_CHECKING:
    1:     coercions = None  # noqa
    1:     elements = None  # noqa
    1:     type_api = None  # noqa
       
       
    2: class _NoArg(Enum):
    1:     NO_ARG = 0
       
    1:     def __repr__(self):
    6:         return f"_NoArg.{self.name}"
       
       
    1: NO_ARG = _NoArg.NO_ARG
       
       
    2: class _NoneName(Enum):
    1:     NONE_NAME = 0
    1:     """indicate a 'deferred' name that was ultimately the value None."""
       
       
    1: _NONE_NAME = _NoneName.NONE_NAME
       
    1: _T = TypeVar("_T", bound=Any)
       
    1: _Fn = TypeVar("_Fn", bound=Callable[..., Any])
       
    1: _AmbiguousTableNameMap = MutableMapping[str, str]
       
       
    2: class _DefaultDescriptionTuple(NamedTuple):
    1:     arg: Any
    1:     is_scalar: Optional[bool]
    1:     is_callable: Optional[bool]
    1:     is_sentinel: Optional[bool]
       
    1:     @classmethod
    1:     def _from_column_default(
               cls, default: Optional[DefaultGenerator]
           ) -> _DefaultDescriptionTuple:
>>>>>>         return (
   69:             _DefaultDescriptionTuple(
   23:                 default.arg,  # type: ignore
   23:                 default.is_scalar,
   23:                 default.is_callable,
   23:                 default.is_sentinel,
                   )
   23:             if default
                   and (
   23:                 default.has_arg
>>>>>>                 or (not default.for_update and default.is_sentinel)
                   )
>>>>>>             else _DefaultDescriptionTuple(None, None, None, None)
               )
       
       
    1: _never_select_column = operator.attrgetter("_omit_from_statements")
       
       
    2: class _EntityNamespace(Protocol):
    1:     def __getattr__(self, key: str) -> SQLCoreOperations[Any]: ...
       
       
    2: class _HasEntityNamespace(Protocol):
    1:     @util.ro_non_memoized_property
    1:     def entity_namespace(self) -> _EntityNamespace: ...
       
       
    1: def _is_has_entity_namespace(element: Any) -> TypeGuard[_HasEntityNamespace]:
>>>>>>     return hasattr(element, "entity_namespace")
       
       
       # Remove when https://github.com/python/mypy/issues/14640 will be fixed
    1: _Self = TypeVar("_Self", bound=Any)
       
       
    2: class Immutable:
    1:     """mark a ClauseElement as 'immutable' when expressions are cloned.
       
           "immutable" objects refers to the "mutability" of an object in the
           context of SQL DQL and DML generation.   Such as, in DQL, one can
           compose a SELECT or subquery of varied forms, but one cannot modify
           the structure of a specific table or column within DQL.
           :class:`.Immutable` is mostly intended to follow this concept, and as
           such the primary "immutable" objects are :class:`.ColumnClause`,
           :class:`.Column`, :class:`.TableClause`, :class:`.Table`.
       
           """
       
    1:     __slots__ = ()
       
    1:     _is_immutable = True
       
    1:     def unique_params(self, *optionaldict, **kwargs):
>>>>>>         raise NotImplementedError("Immutable objects do not support copying")
       
    1:     def params(self, *optionaldict, **kwargs):
>>>>>>         raise NotImplementedError("Immutable objects do not support copying")
       
    1:     def _clone(self: _Self, **kw: Any) -> _Self:
  863:         return self
       
    1:     def _copy_internals(
    1:         self, *, omit_attrs: Iterable[str] = (), **kw: Any
           ) -> None:
  972:         pass
       
       
    2: class SingletonConstant(Immutable):
    1:     """Represent SQL constants like NULL, TRUE, FALSE"""
       
    1:     _is_singleton_constant = True
       
    1:     _singleton: SingletonConstant
       
    1:     def __new__(cls: _T, *arg: Any, **kw: Any) -> _T:
   10:         return cast(_T, cls._singleton)
       
    1:     @util.non_memoized_property
    1:     def proxy_set(self) -> FrozenSet[ColumnElement[Any]]:
>>>>>>         raise NotImplementedError()
       
    1:     @classmethod
    1:     def _create_singleton(cls):
    3:         obj = object.__new__(cls)
    3:         obj.__init__()  # type: ignore
       
               # for a long time this was an empty frozenset, meaning
               # a SingletonConstant would never be a "corresponding column" in
               # a statement.  This referred to #6259.  However, in #7154 we see
               # that we do in fact need "correspondence" to work when matching cols
               # in result sets, so the non-correspondence was moved to a more
               # specific level when we are actually adapting expressions for SQL
               # render only.
    3:         obj.proxy_set = frozenset([obj])
    3:         cls._singleton = obj
       
       
    1: def _from_objects(
           *elements: Union[
               ColumnElement[Any], FromClause, TextClause, _JoinTargetElement
           ]
       ) -> Iterator[FromClause]:
   84:     return itertools.chain.from_iterable(
  128:         [element._from_objects for element in elements]
           )
       
       
    1: def _select_iterables(
           elements: Iterable[roles.ColumnsClauseRole],
       ) -> _SelectIterable:
           """expand tables into individual columns in the
           given list of column expressions.
       
           """
   90:     return itertools.chain.from_iterable(
  351:         [c._select_iterable for c in elements]
           )
       
       
    1: _SelfGenerativeType = TypeVar("_SelfGenerativeType", bound="_GenerativeType")
       
       
    2: class _GenerativeType(compat_typing.Protocol):
    1:     def _generate(self) -> Self: ...
       
       
    1: def _generative(fn: _Fn) -> _Fn:
           """non-caching _generative() decorator.
       
           This is basically the legacy decorator that copies the object and
           runs a method on the new copy.
       
           """
       
   92:     @util.decorator
   92:     def _generative(
               fn: _Fn, self: _SelfGenerativeType, *args: Any, **kw: Any
           ) -> _SelfGenerativeType:
               """Mark a method as generative."""
       
  238:         self = self._generate()
  238:         x = fn(self, *args, **kw)
  238:         assert x is self, "generative methods must return self"
  238:         return self
       
   92:     decorated = _generative(fn)
   92:     decorated.non_generative = fn  # type: ignore
   92:     return decorated
       
       
    1: def _exclusive_against(*names: str, **kw: Any) -> Callable[[_Fn], _Fn]:
    2:     msgs = kw.pop("msgs", {})
       
    2:     defaults = kw.pop("defaults", {})
       
    9:     getters = [
    3:         (name, operator.attrgetter(name), defaults.get(name, None))
    5:         for name in names
           ]
       
    2:     @util.decorator
    2:     def check(fn, *args, **kw):
               # make pylance happy by not including "self" in the argument
               # list
    3:         self = args[0]
    3:         args = args[1:]
    9:         for name, getter, default_ in getters:
    6:             if getter(self) is not default_:
>>>>>>                 msg = msgs.get(
>>>>>>                     name,
>>>>>>                     "Method %s() has already been invoked on this %s construct"
>>>>>>                     % (fn.__name__, self.__class__),
                       )
>>>>>>                 raise exc.InvalidRequestError(msg)
    3:         return fn(self, *args, **kw)
       
    2:     return check
       
       
    1: def _clone(element, **kw):
>>>>>>     return element._clone(**kw)
       
       
    1: def _expand_cloned(
           elements: Iterable[_CLE],
       ) -> Iterable[_CLE]:
           """expand the given set of ClauseElements to be the set of all 'cloned'
           predecessors.
       
           """
           # TODO: cython candidate
 1246:     return itertools.chain(*[x._cloned_set for x in elements])
       
       
    1: def _de_clone(
           elements: Iterable[_CLE],
       ) -> Iterable[_CLE]:
  139:     for x in elements:
   53:         while x._is_clone_of is not None:
>>>>>>             x = x._is_clone_of
   53:         yield x
       
       
    1: def _cloned_intersection(a: Iterable[_CLE], b: Iterable[_CLE]) -> Set[_CLE]:
           """return the intersection of sets a and b, counting
           any overlap between 'cloned' predecessors.
       
           The returned set is in terms of the entities present within 'a'.
       
           """
>>>>>>     all_overlap = set(_expand_cloned(a)).intersection(_expand_cloned(b))
>>>>>>     return {elem for elem in a if all_overlap.intersection(elem._cloned_set)}
       
       
    1: def _cloned_difference(a: Iterable[_CLE], b: Iterable[_CLE]) -> Set[_CLE]:
>>>>>>     all_overlap = set(_expand_cloned(a)).intersection(_expand_cloned(b))
>>>>>>     return {
>>>>>>         elem for elem in a if not all_overlap.intersection(elem._cloned_set)
           }
       
       
    2: class _DialectArgView(MutableMapping[str, Any]):
    1:     """A dictionary view of dialect-level arguments in the form
           <dialectname>_<argument_name>.
       
           """
       
    1:     def __init__(self, obj):
>>>>>>         self.obj = obj
       
    1:     def _key(self, key):
>>>>>>         try:
>>>>>>             dialect, value_key = key.split("_", 1)
>>>>>>         except ValueError as err:
>>>>>>             raise KeyError(key) from err
               else:
>>>>>>             return dialect, value_key
       
    1:     def __getitem__(self, key):
>>>>>>         dialect, value_key = self._key(key)
       
>>>>>>         try:
>>>>>>             opt = self.obj.dialect_options[dialect]
>>>>>>         except exc.NoSuchModuleError as err:
>>>>>>             raise KeyError(key) from err
               else:
>>>>>>             return opt[value_key]
       
    1:     def __setitem__(self, key, value):
>>>>>>         try:
>>>>>>             dialect, value_key = self._key(key)
>>>>>>         except KeyError as err:
>>>>>>             raise exc.ArgumentError(
>>>>>>                 "Keys must be of the form <dialectname>_<argname>"
>>>>>>             ) from err
               else:
>>>>>>             self.obj.dialect_options[dialect][value_key] = value
       
    1:     def __delitem__(self, key):
>>>>>>         dialect, value_key = self._key(key)
>>>>>>         del self.obj.dialect_options[dialect][value_key]
       
    1:     def __len__(self):
>>>>>>         return sum(
>>>>>>             len(args._non_defaults)
>>>>>>             for args in self.obj.dialect_options.values()
               )
       
    1:     def __iter__(self):
>>>>>>         return (
>>>>>>             "%s_%s" % (dialect_name, value_name)
>>>>>>             for dialect_name in self.obj.dialect_options
>>>>>>             for value_name in self.obj.dialect_options[
>>>>>>                 dialect_name
                   ]._non_defaults
               )
       
       
    2: class _DialectArgDict(MutableMapping[str, Any]):
    1:     """A dictionary view of dialect-level arguments for a specific
           dialect.
       
           Maintains a separate collection of user-specified arguments
           and dialect-specified default arguments.
       
           """
       
    1:     def __init__(self):
  215:         self._non_defaults = {}
  215:         self._defaults = {}
       
    1:     def __len__(self):
>>>>>>         return len(set(self._non_defaults).union(self._defaults))
       
    1:     def __iter__(self):
>>>>>>         return iter(set(self._non_defaults).union(self._defaults))
       
    1:     def __getitem__(self, key):
17296:         if key in self._non_defaults:
>>>>>>             return self._non_defaults[key]
               else:
17296:             return self._defaults[key]
       
    1:     def __setitem__(self, key, value):
>>>>>>         self._non_defaults[key] = value
       
    1:     def __delitem__(self, key):
>>>>>>         del self._non_defaults[key]
       
       
    1: @util.preload_module("sqlalchemy.dialects")
    1: def _kw_reg_for_dialect(dialect_name):
    1:     dialect_cls = util.preloaded.dialects.registry.load(dialect_name)
    1:     if dialect_cls.construct_arguments is None:
>>>>>>         return None
    1:     return dict(dialect_cls.construct_arguments)
       
       
    2: class DialectKWArgs:
    1:     """Establish the ability for a class to have dialect-specific arguments
           with defaults and constructor validation.
       
           The :class:`.DialectKWArgs` interacts with the
           :attr:`.DefaultDialect.construct_arguments` present on a dialect.
       
           .. seealso::
       
               :attr:`.DefaultDialect.construct_arguments`
       
           """
       
    1:     __slots__ = ()
       
    1:     _dialect_kwargs_traverse_internals = [
    1:         ("dialect_options", InternalTraversal.dp_dialect_options)
           ]
       
    1:     @classmethod
    1:     def argument_for(cls, dialect_name, argument_name, default):
               """Add a new kind of dialect-specific keyword argument for this class.
       
               E.g.::
       
                   Index.argument_for("mydialect", "length", None)
       
                   some_index = Index('a', 'b', mydialect_length=5)
       
               The :meth:`.DialectKWArgs.argument_for` method is a per-argument
               way adding extra arguments to the
               :attr:`.DefaultDialect.construct_arguments` dictionary. This
               dictionary provides a list of argument names accepted by various
               schema-level constructs on behalf of a dialect.
       
               New dialects should typically specify this dictionary all at once as a
               data member of the dialect class.  The use case for ad-hoc addition of
               argument names is typically for end-user code that is also using
               a custom compilation scheme which consumes the additional arguments.
       
               :param dialect_name: name of a dialect.  The dialect must be
                locatable, else a :class:`.NoSuchModuleError` is raised.   The
                dialect must also include an existing
                :attr:`.DefaultDialect.construct_arguments` collection, indicating
                that it participates in the keyword-argument validation and default
                system, else :class:`.ArgumentError` is raised.  If the dialect does
                not include this collection, then any keyword argument can be
                specified on behalf of this dialect already.  All dialects packaged
                within SQLAlchemy include this collection, however for third party
                dialects, support may vary.
       
               :param argument_name: name of the parameter.
       
               :param default: default value of the parameter.
       
               """
       
>>>>>>         construct_arg_dictionary = DialectKWArgs._kw_registry[dialect_name]
>>>>>>         if construct_arg_dictionary is None:
>>>>>>             raise exc.ArgumentError(
>>>>>>                 "Dialect '%s' does have keyword-argument "
>>>>>>                 "validation and defaults enabled configured" % dialect_name
                   )
>>>>>>         if cls not in construct_arg_dictionary:
>>>>>>             construct_arg_dictionary[cls] = {}
>>>>>>         construct_arg_dictionary[cls][argument_name] = default
       
    1:     @util.memoized_property
    1:     def dialect_kwargs(self):
               """A collection of keyword arguments specified as dialect-specific
               options to this construct.
       
               The arguments are present here in their original ``<dialect>_<kwarg>``
               format.  Only arguments that were actually passed are included;
               unlike the :attr:`.DialectKWArgs.dialect_options` collection, which
               contains all options known by this dialect including defaults.
       
               The collection is also writable; keys are accepted of the
               form ``<dialect>_<kwarg>`` where the value will be assembled
               into the list of options.
       
               .. seealso::
       
                   :attr:`.DialectKWArgs.dialect_options` - nested dictionary form
       
               """
>>>>>>         return _DialectArgView(self)
       
    1:     @property
    1:     def kwargs(self):
               """A synonym for :attr:`.DialectKWArgs.dialect_kwargs`."""
>>>>>>         return self.dialect_kwargs
       
    1:     _kw_registry = util.PopulateDict(_kw_reg_for_dialect)
       
    1:     def _kw_reg_for_dialect_cls(self, dialect_name):
  215:         construct_arg_dictionary = DialectKWArgs._kw_registry[dialect_name]
  215:         d = _DialectArgDict()
       
  215:         if construct_arg_dictionary is None:
>>>>>>             d._defaults.update({"*": None})
               else:
 3848:             for cls in reversed(self.__class__.__mro__):
 3633:                 if cls in construct_arg_dictionary:
  215:                     d._defaults.update(construct_arg_dictionary[cls])
  215:         return d
       
    1:     @util.memoized_property
    1:     def dialect_options(self):
               """A collection of keyword arguments specified as dialect-specific
               options to this construct.
       
               This is a two-level nested registry, keyed to ``<dialect_name>``
               and ``<argument_name>``.  For example, the ``postgresql_where``
               argument would be locatable as::
       
                   arg = my_object.dialect_options['postgresql']['where']
       
               .. versionadded:: 0.9.2
       
               .. seealso::
       
                   :attr:`.DialectKWArgs.dialect_kwargs` - flat dictionary form
       
               """
       
  490:         return util.PopulateDict(
  245:             util.portable_instancemethod(self._kw_reg_for_dialect_cls)
               )
       
    1:     def _validate_dialect_kwargs(self, kwargs: Dict[str, Any]) -> None:
               # validate remaining kwargs that they all specify DB prefixes
       
  926:         if not kwargs:
  926:             return
       
>>>>>>         for k in kwargs:
>>>>>>             m = re.match("^(.+?)_(.+)$", k)
>>>>>>             if not m:
>>>>>>                 raise TypeError(
>>>>>>                     "Additional arguments should be "
>>>>>>                     "named <dialectname>_<argument>, got '%s'" % k
                       )
>>>>>>             dialect_name, arg_name = m.group(1, 2)
       
>>>>>>             try:
>>>>>>                 construct_arg_dictionary = self.dialect_options[dialect_name]
>>>>>>             except exc.NoSuchModuleError:
>>>>>>                 util.warn(
>>>>>>                     "Can't validate argument %r; can't "
                           "locate any SQLAlchemy dialect named %r"
>>>>>>                     % (k, dialect_name)
                       )
>>>>>>                 self.dialect_options[dialect_name] = d = _DialectArgDict()
>>>>>>                 d._defaults.update({"*": None})
>>>>>>                 d._non_defaults[arg_name] = kwargs[k]
                   else:
>>>>>>                 if (
>>>>>>                     "*" not in construct_arg_dictionary
>>>>>>                     and arg_name not in construct_arg_dictionary
                       ):
>>>>>>                     raise exc.ArgumentError(
>>>>>>                         "Argument %r is not accepted by "
                               "dialect %r on behalf of %r"
>>>>>>                         % (k, dialect_name, self.__class__)
                           )
                       else:
>>>>>>                     construct_arg_dictionary[arg_name] = kwargs[k]
       
       
    2: class CompileState:
    1:     """Produces additional object state necessary for a statement to be
           compiled.
       
           the :class:`.CompileState` class is at the base of classes that assemble
           state for a particular statement object that is then used by the
           compiler.   This process is essentially an extension of the process that
           the SQLCompiler.visit_XYZ() method takes, however there is an emphasis
           on converting raw user intent into more organized structures rather than
           producing string output.   The top-level :class:`.CompileState` for the
           statement being executed is also accessible when the execution context
           works with invoking the statement and collecting results.
       
           The production of :class:`.CompileState` is specific to the compiler,  such
           as within the :meth:`.SQLCompiler.visit_insert`,
           :meth:`.SQLCompiler.visit_select` etc. methods.  These methods are also
           responsible for associating the :class:`.CompileState` with the
           :class:`.SQLCompiler` itself, if the statement is the "toplevel" statement,
           i.e. the outermost SQL statement that's actually being executed.
           There can be other :class:`.CompileState` objects that are not the
           toplevel, such as when a SELECT subquery or CTE-nested
           INSERT/UPDATE/DELETE is generated.
       
           .. versionadded:: 1.4
       
           """
       
    1:     __slots__ = ("statement", "_ambiguous_table_name_map")
       
    1:     plugins: Dict[Tuple[str, str], Type[CompileState]] = {}
       
    1:     _ambiguous_table_name_map: Optional[_AmbiguousTableNameMap]
       
    1:     @classmethod
    1:     def create_for_statement(cls, statement, compiler, **kw):
               # factory construction.
       
   56:         if statement._propagate_attrs:
   52:             plugin_name = statement._propagate_attrs.get(
   26:                 "compile_state_plugin", "default"
                   )
   52:             klass = cls.plugins.get(
   26:                 (plugin_name, statement._effective_plugin_target), None
                   )
   26:             if klass is None:
>>>>>>                 klass = cls.plugins[
>>>>>>                     ("default", statement._effective_plugin_target)
                       ]
       
               else:
   60:             klass = cls.plugins[
   30:                 ("default", statement._effective_plugin_target)
                   ]
       
   56:         if klass is cls:
   15:             return cls(statement, compiler, **kw)
               else:
   41:             return klass.create_for_statement(statement, compiler, **kw)
       
    1:     def __init__(self, statement, compiler, **kw):
>>>>>>         self.statement = statement
       
    1:     @classmethod
    1:     def get_plugin_class(
               cls, statement: Executable
           ) -> Optional[Type[CompileState]]:
   66:         plugin_name = statement._propagate_attrs.get(
   33:             "compile_state_plugin", None
               )
       
   33:         if plugin_name:
    7:             key = (plugin_name, statement._effective_plugin_target)
    7:             if key in cls.plugins:
    7:                 return cls.plugins[key]
       
               # there's no case where we call upon get_plugin_class() and want
               # to get None back, there should always be a default.  return that
               # if there was no plugin-specific class  (e.g. Insert with "orm"
               # plugin)
   26:         try:
   26:             return cls.plugins[("default", statement._effective_plugin_target)]
>>>>>>         except KeyError:
>>>>>>             return None
       
    1:     @classmethod
    1:     def _get_plugin_class_for_plugin(
               cls, statement: Executable, plugin_name: str
           ) -> Optional[Type[CompileState]]:
  106:         try:
  212:             return cls.plugins[
  106:                 (plugin_name, statement._effective_plugin_target)
                   ]
>>>>>>         except KeyError:
>>>>>>             return None
       
    1:     @classmethod
    1:     def plugin_for(
               cls, plugin_name: str, visit_name: str
           ) -> Callable[[_Fn], _Fn]:
   11:         def decorate(cls_to_decorate):
   11:             cls.plugins[(plugin_name, visit_name)] = cls_to_decorate
   11:             return cls_to_decorate
       
   11:         return decorate
       
       
    2: class Generative(HasMemoized):
    1:     """Provide a method-chaining pattern in conjunction with the
           @_generative decorator."""
       
    1:     def _generate(self) -> Self:
  243:         skip = self._memoized_keys
  243:         cls = self.__class__
  243:         s = cls.__new__(cls)
  243:         if skip:
                   # ensure this iteration remains atomic
   36:             s.__dict__ = {
   30:                 k: v for k, v in self.__dict__.copy().items() if k not in skip
                   }
               else:
  240:             s.__dict__ = self.__dict__.copy()
  243:         return s
       
       
    2: class InPlaceGenerative(HasMemoized):
    1:     """Provide a method-chaining pattern in conjunction with the
           @_generative decorator that mutates in place."""
       
    1:     __slots__ = ()
       
    1:     def _generate(self):
   27:         skip = self._memoized_keys
               # note __dict__ needs to be in __slots__ if this is used
   27:         for k in skip:
>>>>>>             self.__dict__.pop(k, None)
   27:         return self
       
       
    2: class HasCompileState(Generative):
    1:     """A class that has a :class:`.CompileState` associated with it."""
       
    1:     _compile_state_plugin: Optional[Type[CompileState]] = None
       
    1:     _attributes: util.immutabledict[str, Any] = util.EMPTY_DICT
       
    1:     _compile_state_factory = CompileState.create_for_statement
       
       
    2: class _MetaOptions(type):
    1:     """metaclass for the Options class.
       
           This metaclass is actually necessary despite the availability of the
           ``__init_subclass__()`` hook as this type also provides custom class-level
           behavior for the ``__add__()`` method.
       
           """
       
    1:     _cache_attrs: Tuple[str, ...]
       
    1:     def __add__(self, other):
  166:         o1 = self()
       
  166:         if set(other).difference(self._cache_attrs):
>>>>>>             raise TypeError(
>>>>>>                 "dictionary contains attributes not covered by "
                       "Options class %s: %r"
>>>>>>                 % (self, set(other).difference(self._cache_attrs))
                   )
       
  166:         o1.__dict__.update(other)
  166:         return o1
       
    1:     if TYPE_CHECKING:
       
>>>>>>         def __getattr__(self, key: str) -> Any: ...
       
>>>>>>         def __setattr__(self, key: str, value: Any) -> None: ...
       
>>>>>>         def __delattr__(self, key: str) -> None: ...
       
       
    2: class Options(metaclass=_MetaOptions):
    1:     """A cacheable option dictionary with defaults."""
       
    1:     __slots__ = ()
       
    1:     _cache_attrs: Tuple[str, ...]
       
    1:     def __init_subclass__(cls) -> None:
    7:         dict_ = cls.__dict__
   14:         cls._cache_attrs = tuple(
  102:             sorted(
   49:                 d
   88:                 for d in dict_
   81:                 if not d.startswith("__")
   51:                 and d not in ("_cache_key_traversal",)
                   )
               )
    7:         super().__init_subclass__()
       
    1:     def __init__(self, **kw):
  166:         self.__dict__.update(kw)
       
    1:     def __add__(self, other):
   44:         o1 = self.__class__.__new__(self.__class__)
   44:         o1.__dict__.update(self.__dict__)
       
   44:         if set(other).difference(self._cache_attrs):
>>>>>>             raise TypeError(
>>>>>>                 "dictionary contains attributes not covered by "
                       "Options class %s: %r"
>>>>>>                 % (self, set(other).difference(self._cache_attrs))
                   )
       
   44:         o1.__dict__.update(other)
   44:         return o1
       
    1:     def __eq__(self, other):
               # TODO: very inefficient.  This is used only in test suites
               # right now.
>>>>>>         for a, b in zip_longest(self._cache_attrs, other._cache_attrs):
>>>>>>             if getattr(self, a) != getattr(other, b):
>>>>>>                 return False
>>>>>>         return True
       
    1:     def __repr__(self):
               # TODO: fairly inefficient, used only in debugging right now.
       
>>>>>>         return "%s(%s)" % (
>>>>>>             self.__class__.__name__,
>>>>>>             ", ".join(
>>>>>>                 "%s=%r" % (k, self.__dict__[k])
>>>>>>                 for k in self._cache_attrs
>>>>>>                 if k in self.__dict__
                   ),
               )
       
    1:     @classmethod
    1:     def isinstance(cls, klass: Type[Any]) -> bool:
>>>>>>         return issubclass(cls, klass)
       
    1:     @hybridmethod
    1:     def add_to_element(self, name, value):
>>>>>>         return self + {name: getattr(self, name) + value}
       
    1:     @hybridmethod
    1:     def _state_dict_inst(self) -> Mapping[str, Any]:
   24:         return self.__dict__
       
    1:     _state_dict_const: util.immutabledict[str, Any] = util.EMPTY_DICT
       
    1:     @_state_dict_inst.classlevel
    1:     def _state_dict(cls) -> Mapping[str, Any]:
>>>>>>         return cls._state_dict_const
       
    1:     @classmethod
    1:     def safe_merge(cls, other):
   24:         d = other._state_dict()
       
               # only support a merge with another object of our class
               # and which does not have attrs that we don't.   otherwise
               # we risk having state that might not be part of our cache
               # key strategy
       
   24:         if (
   24:             cls is not other.__class__
>>>>>>             and other._cache_attrs
>>>>>>             and set(other._cache_attrs).difference(cls._cache_attrs)
               ):
>>>>>>             raise TypeError(
>>>>>>                 "other element %r is not empty, is not of type %s, "
                       "and contains attributes not covered here %r"
>>>>>>                 % (
>>>>>>                     other,
>>>>>>                     cls,
>>>>>>                     set(other._cache_attrs).difference(cls._cache_attrs),
                       )
                   )
   24:         return cls + d
       
    1:     @classmethod
    1:     def from_execution_options(
               cls, key, attrs, exec_options, statement_exec_options
           ):
               """process Options argument in terms of execution options.
       
       
               e.g.::
       
                   (
                       load_options,
                       execution_options,
                   ) = QueryContext.default_load_options.from_execution_options(
                       "_sa_orm_load_options",
                       {
                           "populate_existing",
                           "autoflush",
                           "yield_per"
                       },
                       execution_options,
                       statement._execution_options,
                   )
       
               get back the Options and refresh "_sa_orm_load_options" in the
               exec options dict w/ the Options as well
       
               """
       
               # common case is that no options we are looking for are
               # in either dictionary, so cancel for that first
  212:         check_argnames = attrs.intersection(
  106:             set(exec_options).union(statement_exec_options)
               )
       
  106:         existing_options = exec_options.get(key, cls)
       
  106:         if check_argnames:
    2:             result = {}
    4:             for argname in check_argnames:
    2:                 local = "_" + argname
    2:                 if argname in exec_options:
    2:                     result[local] = exec_options[argname]
>>>>>>                 elif argname in statement_exec_options:
>>>>>>                     result[local] = statement_exec_options[argname]
       
    2:             new_options = existing_options + result
    4:             exec_options = util.immutabledict().merge_with(
    2:                 exec_options, {key: new_options}
                   )
    2:             return new_options, exec_options
       
               else:
  104:             return existing_options, exec_options
       
    1:     if TYPE_CHECKING:
       
>>>>>>         def __getattr__(self, key: str) -> Any: ...
       
>>>>>>         def __setattr__(self, key: str, value: Any) -> None: ...
       
>>>>>>         def __delattr__(self, key: str) -> None: ...
       
       
    2: class CacheableOptions(Options, HasCacheKey):
    1:     __slots__ = ()
       
    1:     @hybridmethod
    1:     def _gen_cache_key_inst(self, anon_map, bindparams):
  107:         return HasCacheKey._gen_cache_key(self, anon_map, bindparams)
       
    1:     @_gen_cache_key_inst.classlevel
    1:     def _gen_cache_key(cls, anon_map, bindparams):
    1:         return (cls, ())
       
    1:     @hybridmethod
    1:     def _generate_cache_key(self):
>>>>>>         return HasCacheKey._generate_cache_key_for_object(self)
       
       
    2: class ExecutableOption(HasCopyInternals):
    1:     __slots__ = ()
       
    1:     _annotations = util.EMPTY_DICT
       
    1:     __visit_name__ = "executable_option"
       
    1:     _is_has_cache_key = False
       
    1:     _is_core = True
       
    1:     def _clone(self, **kw):
               """Create a shallow copy of this ExecutableOption."""
>>>>>>         c = self.__class__.__new__(self.__class__)
>>>>>>         c.__dict__ = dict(self.__dict__)  # type: ignore
>>>>>>         return c
       
       
    2: class Executable(roles.StatementRole):
    1:     """Mark a :class:`_expression.ClauseElement` as supporting execution.
       
           :class:`.Executable` is a superclass for all "statement" types
           of objects, including :func:`select`, :func:`delete`, :func:`update`,
           :func:`insert`, :func:`text`.
       
           """
       
    1:     supports_execution: bool = True
    1:     _execution_options: _ImmutableExecuteOptions = util.EMPTY_DICT
    1:     _is_default_generator = False
    1:     _with_options: Tuple[ExecutableOption, ...] = ()
    1:     _with_context_options: Tuple[
               Tuple[Callable[[CompileState], None], Any], ...
    1:     ] = ()
    1:     _compile_options: Optional[Union[Type[CacheableOptions], CacheableOptions]]
       
    1:     _executable_traverse_internals = [
    1:         ("_with_options", InternalTraversal.dp_executable_options),
    1:         (
    1:             "_with_context_options",
    1:             ExtendedInternalTraversal.dp_with_context_options,
               ),
    1:         ("_propagate_attrs", ExtendedInternalTraversal.dp_propagate_attrs),
           ]
       
    1:     is_select = False
    1:     is_update = False
    1:     is_insert = False
    1:     is_text = False
    1:     is_delete = False
    1:     is_dml = False
       
    1:     if TYPE_CHECKING:
>>>>>>         __visit_name__: str
       
>>>>>>         def _compile_w_cache(
                   self,
                   dialect: Dialect,
                   *,
                   compiled_cache: Optional[CompiledCacheType],
                   column_keys: List[str],
>>>>>>             for_executemany: bool = False,
>>>>>>             schema_translate_map: Optional[SchemaTranslateMapType] = None,
                   **kw: Any,
               ) -> Tuple[
                   Compiled, Optional[Sequence[BindParameter[Any]]], CacheStats
>>>>>>         ]: ...
       
>>>>>>         def _execute_on_connection(
                   self,
                   connection: Connection,
                   distilled_params: _CoreMultiExecuteParams,
                   execution_options: CoreExecuteOptionsParameter,
>>>>>>         ) -> CursorResult[Any]: ...
       
>>>>>>         def _execute_on_scalar(
                   self,
                   connection: Connection,
                   distilled_params: _CoreMultiExecuteParams,
                   execution_options: CoreExecuteOptionsParameter,
>>>>>>         ) -> Any: ...
       
    1:     @util.ro_non_memoized_property
    1:     def _all_selected_columns(self):
>>>>>>         raise NotImplementedError()
       
    1:     @property
    1:     def _effective_plugin_target(self) -> str:
  195:         return self.__visit_name__
       
    1:     @_generative
    1:     def options(self, *options: ExecutableOption) -> Self:
               """Apply options to this statement.
       
               In the general sense, options are any kind of Python object
               that can be interpreted by the SQL compiler for the statement.
               These options can be consumed by specific dialects or specific kinds
               of compilers.
       
               The most commonly known kind of option are the ORM level options
               that apply "eager load" and other loading behaviors to an ORM
               query.   However, options can theoretically be used for many other
               purposes.
       
               For background on specific kinds of options for specific kinds of
               statements, refer to the documentation for those option objects.
       
               .. versionchanged:: 1.4 - added :meth:`.Executable.options` to
                  Core statement objects towards the goal of allowing unified
                  Core / ORM querying capabilities.
       
               .. seealso::
       
                   :ref:`loading_columns` - refers to options specific to the usage
                   of ORM queries
       
                   :ref:`relationship_loader_options` - refers to options specific
                   to the usage of ORM queries
       
               """
    3:         self._with_options += tuple(
>>>>>>             coercions.expect(roles.ExecutableOptionRole, opt)
    1:             for opt in options
               )
    1:         return self
       
    1:     @_generative
    1:     def _set_compile_options(self, compile_options: CacheableOptions) -> Self:
               """Assign the compile options to a new value.
       
               :param compile_options: appropriate CacheableOptions structure
       
               """
       
>>>>>>         self._compile_options = compile_options
>>>>>>         return self
       
    1:     @_generative
    1:     def _update_compile_options(self, options: CacheableOptions) -> Self:
               """update the _compile_options with new keys."""
       
>>>>>>         assert self._compile_options is not None
>>>>>>         self._compile_options += options
>>>>>>         return self
       
    1:     @_generative
    1:     def _add_context_option(
               self,
               callable_: Callable[[CompileState], None],
               cache_args: Any,
           ) -> Self:
               """Add a context option to this statement.
       
               These are callable functions that will
               be given the CompileState object upon compilation.
       
               A second argument cache_args is required, which will be combined with
               the ``__code__`` identity of the function itself in order to produce a
               cache key.
       
               """
>>>>>>         self._with_context_options += ((callable_, cache_args),)
>>>>>>         return self
       
    1:     @overload
    1:     def execution_options(
               self,
               *,
    1:         compiled_cache: Optional[CompiledCacheType] = ...,
    1:         logging_token: str = ...,
    1:         isolation_level: IsolationLevel = ...,
    1:         no_parameters: bool = False,
    1:         stream_results: bool = False,
    1:         max_row_buffer: int = ...,
    1:         yield_per: int = ...,
    1:         insertmanyvalues_page_size: int = ...,
    1:         schema_translate_map: Optional[SchemaTranslateMapType] = ...,
    1:         populate_existing: bool = False,
    1:         autoflush: bool = False,
    1:         synchronize_session: SynchronizeSessionArgument = ...,
    1:         dml_strategy: DMLStrategyArgument = ...,
    1:         render_nulls: bool = ...,
    1:         is_delete_using: bool = ...,
    1:         is_update_from: bool = ...,
               **opt: Any,
>>>>>>     ) -> Self: ...
       
    1:     @overload
    1:     def execution_options(self, **opt: Any) -> Self: ...
       
    1:     @_generative
    1:     def execution_options(self, **kw: Any) -> Self:
               """Set non-SQL options for the statement which take effect during
               execution.
       
               Execution options can be set at many scopes, including per-statement,
               per-connection, or per execution, using methods such as
               :meth:`_engine.Connection.execution_options` and parameters which
               accept a dictionary of options such as
               :paramref:`_engine.Connection.execute.execution_options` and
               :paramref:`_orm.Session.execute.execution_options`.
       
               The primary characteristic of an execution option, as opposed to
               other kinds of options such as ORM loader options, is that
               **execution options never affect the compiled SQL of a query, only
               things that affect how the SQL statement itself is invoked or how
               results are fetched**.  That is, execution options are not part of
               what's accommodated by SQL compilation nor are they considered part of
               the cached state of a statement.
       
               The :meth:`_sql.Executable.execution_options` method is
               :term:`generative`, as
               is the case for the method as applied to the :class:`_engine.Engine`
               and :class:`_orm.Query` objects, which means when the method is called,
               a copy of the object is returned, which applies the given parameters to
               that new copy, but leaves the original unchanged::
       
                   statement = select(table.c.x, table.c.y)
                   new_statement = statement.execution_options(my_option=True)
       
               An exception to this behavior is the :class:`_engine.Connection`
               object, where the :meth:`_engine.Connection.execution_options` method
               is explicitly **not** generative.
       
               The kinds of options that may be passed to
               :meth:`_sql.Executable.execution_options` and other related methods and
               parameter dictionaries include parameters that are explicitly consumed
               by SQLAlchemy Core or ORM, as well as arbitrary keyword arguments not
               defined by SQLAlchemy, which means the methods and/or parameter
               dictionaries may be used for user-defined parameters that interact with
               custom code, which may access the parameters using methods such as
               :meth:`_sql.Executable.get_execution_options` and
               :meth:`_engine.Connection.get_execution_options`, or within selected
               event hooks using a dedicated ``execution_options`` event parameter
               such as
               :paramref:`_events.ConnectionEvents.before_execute.execution_options`
               or :attr:`_orm.ORMExecuteState.execution_options`, e.g.::
       
                    from sqlalchemy import event
       
                    @event.listens_for(some_engine, "before_execute")
                    def _process_opt(conn, statement, multiparams, params, execution_options):
                        "run a SQL function before invoking a statement"
       
                        if execution_options.get("do_special_thing", False):
                            conn.exec_driver_sql("run_special_function()")
       
               Within the scope of options that are explicitly recognized by
               SQLAlchemy, most apply to specific classes of objects and not others.
               The most common execution options include:
       
               * :paramref:`_engine.Connection.execution_options.isolation_level` -
                 sets the isolation level for a connection or a class of connections
                 via an :class:`_engine.Engine`.  This option is accepted only
                 by :class:`_engine.Connection` or :class:`_engine.Engine`.
       
               * :paramref:`_engine.Connection.execution_options.stream_results` -
                 indicates results should be fetched using a server side cursor;
                 this option is accepted by :class:`_engine.Connection`, by the
                 :paramref:`_engine.Connection.execute.execution_options` parameter
                 on :meth:`_engine.Connection.execute`, and additionally by
                 :meth:`_sql.Executable.execution_options` on a SQL statement object,
                 as well as by ORM constructs like :meth:`_orm.Session.execute`.
       
               * :paramref:`_engine.Connection.execution_options.compiled_cache` -
                 indicates a dictionary that will serve as the
                 :ref:`SQL compilation cache <sql_caching>`
                 for a :class:`_engine.Connection` or :class:`_engine.Engine`, as
                 well as for ORM methods like :meth:`_orm.Session.execute`.
                 Can be passed as ``None`` to disable caching for statements.
                 This option is not accepted by
                 :meth:`_sql.Executable.execution_options` as it is inadvisable to
                 carry along a compilation cache within a statement object.
       
               * :paramref:`_engine.Connection.execution_options.schema_translate_map`
                 - a mapping of schema names used by the
                 :ref:`Schema Translate Map <schema_translating>` feature, accepted
                 by :class:`_engine.Connection`, :class:`_engine.Engine`,
                 :class:`_sql.Executable`, as well as by ORM constructs
                 like :meth:`_orm.Session.execute`.
       
               .. seealso::
       
                   :meth:`_engine.Connection.execution_options`
       
                   :paramref:`_engine.Connection.execute.execution_options`
       
                   :paramref:`_orm.Session.execute.execution_options`
       
                   :ref:`orm_queryguide_execution_options` - documentation on all
                   ORM-specific execution options
       
               """  # noqa: E501
    1:         if "isolation_level" in kw:
>>>>>>             raise exc.ArgumentError(
>>>>>>                 "'isolation_level' execution option may only be specified "
                       "on Connection.execution_options(), or "
                       "per-engine using the isolation_level "
                       "argument to create_engine()."
                   )
    1:         if "compiled_cache" in kw:
>>>>>>             raise exc.ArgumentError(
>>>>>>                 "'compiled_cache' execution option may only be specified "
                       "on Connection.execution_options(), not per statement."
                   )
    1:         self._execution_options = self._execution_options.union(kw)
    1:         return self
       
    1:     def get_execution_options(self) -> _ExecuteOptions:
               """Get the non-SQL options which will take effect during execution.
       
               .. versionadded:: 1.3
       
               .. seealso::
       
                   :meth:`.Executable.execution_options`
               """
>>>>>>         return self._execution_options
       
       
    2: class SchemaEventTarget(event.EventTarget):
    1:     """Base class for elements that are the targets of :class:`.DDLEvents`
           events.
       
           This includes :class:`.SchemaItem` as well as :class:`.SchemaType`.
       
           """
       
    1:     dispatch: dispatcher[SchemaEventTarget]
       
    1:     def _set_parent(self, parent: SchemaEventTarget, **kw: Any) -> None:
   14:         """Associate with this SchemaEvent's parent object."""
       
    1:     def _set_parent_with_dispatch(
               self, parent: SchemaEventTarget, **kw: Any
           ) -> None:
 1108:         self.dispatch.before_parent_attach(self, parent)
 1108:         self._set_parent(parent, **kw)
 1108:         self.dispatch.after_parent_attach(self, parent)
       
       
    2: class SchemaVisitor(ClauseVisitor):
    1:     """Define the visiting for ``SchemaItem`` objects."""
       
    1:     __traverse_options__ = {"schema_visitor": True}
       
       
    2: class _SentinelDefaultCharacterization(Enum):
    1:     NONE = "none"
    1:     UNKNOWN = "unknown"
    1:     CLIENTSIDE = "clientside"
    1:     SENTINEL_DEFAULT = "sentinel_default"
    1:     SERVERSIDE = "serverside"
    1:     IDENTITY = "identity"
    1:     SEQUENCE = "sequence"
       
       
    2: class _SentinelColumnCharacterization(NamedTuple):
    1:     columns: Optional[Sequence[Column[Any]]] = None
    1:     is_explicit: bool = False
    1:     is_autoinc: bool = False
    1:     default_characterization: _SentinelDefaultCharacterization = (
    1:         _SentinelDefaultCharacterization.NONE
           )
       
       
    1: _COLKEY = TypeVar("_COLKEY", Union[None, str], str)
       
    1: _COL_co = TypeVar("_COL_co", bound="ColumnElement[Any]", covariant=True)
    1: _COL = TypeVar("_COL", bound="KeyedColumnElement[Any]")
       
       
    2: class _ColumnMetrics(Generic[_COL_co]):
    1:     __slots__ = ("column",)
       
    1:     column: _COL_co
       
    1:     def __init__(
               self, collection: ColumnCollection[Any, _COL_co], col: _COL_co
           ):
 1334:         self.column = col
       
               # proxy_index being non-empty means it was initialized.
               # so we need to update it
 1334:         pi = collection._proxy_index
 1334:         if pi:
>>>>>>             for eps_col in col._expanded_proxy_set:
>>>>>>                 pi[eps_col].add(self)
       
    1:     def get_expanded_proxy_set(self):
>>>>>>         return self.column._expanded_proxy_set
       
    1:     def dispose(self, collection):
>>>>>>         pi = collection._proxy_index
>>>>>>         if not pi:
>>>>>>             return
>>>>>>         for col in self.column._expanded_proxy_set:
>>>>>>             colset = pi.get(col, None)
>>>>>>             if colset:
>>>>>>                 colset.discard(self)
>>>>>>             if colset is not None and not colset:
>>>>>>                 del pi[col]
       
    1:     def embedded(
               self,
               target_set: Union[
                   Set[ColumnElement[Any]], FrozenSet[ColumnElement[Any]]
               ],
           ) -> bool:
>>>>>>         expanded_proxy_set = self.column._expanded_proxy_set
>>>>>>         for t in target_set.difference(expanded_proxy_set):
>>>>>>             if not expanded_proxy_set.intersection(_expand_cloned([t])):
>>>>>>                 return False
>>>>>>         return True
       
       
    2: class ColumnCollection(Generic[_COLKEY, _COL_co]):
    1:     """Collection of :class:`_expression.ColumnElement` instances,
           typically for
           :class:`_sql.FromClause` objects.
       
           The :class:`_sql.ColumnCollection` object is most commonly available
           as the :attr:`_schema.Table.c` or :attr:`_schema.Table.columns` collection
           on the :class:`_schema.Table` object, introduced at
           :ref:`metadata_tables_and_columns`.
       
           The :class:`_expression.ColumnCollection` has both mapping- and sequence-
           like behaviors. A :class:`_expression.ColumnCollection` usually stores
           :class:`_schema.Column` objects, which are then accessible both via mapping
           style access as well as attribute access style.
       
           To access :class:`_schema.Column` objects using ordinary attribute-style
           access, specify the name like any other object attribute, such as below
           a column named ``employee_name`` is accessed::
       
               >>> employee_table.c.employee_name
       
           To access columns that have names with special characters or spaces,
           index-style access is used, such as below which illustrates a column named
           ``employee ' payment`` is accessed::
       
               >>> employee_table.c["employee ' payment"]
       
           As the :class:`_sql.ColumnCollection` object provides a Python dictionary
           interface, common dictionary method names like
           :meth:`_sql.ColumnCollection.keys`, :meth:`_sql.ColumnCollection.values`,
           and :meth:`_sql.ColumnCollection.items` are available, which means that
           database columns that are keyed under these names also need to use indexed
           access::
       
               >>> employee_table.c["values"]
       
       
           The name for which a :class:`_schema.Column` would be present is normally
           that of the :paramref:`_schema.Column.key` parameter.  In some contexts,
           such as a :class:`_sql.Select` object that uses a label style set
           using the :meth:`_sql.Select.set_label_style` method, a column of a certain
           key may instead be represented under a particular label name such
           as ``tablename_columnname``::
       
               >>> from sqlalchemy import select, column, table
               >>> from sqlalchemy import LABEL_STYLE_TABLENAME_PLUS_COL
               >>> t = table("t", column("c"))
               >>> stmt = select(t).set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
               >>> subq = stmt.subquery()
               >>> subq.c.t_c
               <sqlalchemy.sql.elements.ColumnClause at 0x7f59dcf04fa0; t_c>
       
           :class:`.ColumnCollection` also indexes the columns in order and allows
           them to be accessible by their integer position::
       
               >>> cc[0]
               Column('x', Integer(), table=None)
               >>> cc[1]
               Column('y', Integer(), table=None)
       
           .. versionadded:: 1.4 :class:`_expression.ColumnCollection`
              allows integer-based
              index access to the collection.
       
           Iterating the collection yields the column expressions in order::
       
               >>> list(cc)
               [Column('x', Integer(), table=None),
                Column('y', Integer(), table=None)]
       
           The base :class:`_expression.ColumnCollection` object can store
           duplicates, which can
           mean either two columns with the same key, in which case the column
           returned by key  access is **arbitrary**::
       
               >>> x1, x2 = Column('x', Integer), Column('x', Integer)
               >>> cc = ColumnCollection(columns=[(x1.name, x1), (x2.name, x2)])
               >>> list(cc)
               [Column('x', Integer(), table=None),
                Column('x', Integer(), table=None)]
               >>> cc['x'] is x1
               False
               >>> cc['x'] is x2
               True
       
           Or it can also mean the same column multiple times.   These cases are
           supported as :class:`_expression.ColumnCollection`
           is used to represent the columns in
           a SELECT statement which may include duplicates.
       
           A special subclass :class:`.DedupeColumnCollection` exists which instead
           maintains SQLAlchemy's older behavior of not allowing duplicates; this
           collection is used for schema level objects like :class:`_schema.Table`
           and
           :class:`.PrimaryKeyConstraint` where this deduping is helpful.  The
           :class:`.DedupeColumnCollection` class also has additional mutation methods
           as the schema constructs have more use cases that require removal and
           replacement of columns.
       
           .. versionchanged:: 1.4 :class:`_expression.ColumnCollection`
              now stores duplicate
              column keys as well as the same column in multiple positions.  The
              :class:`.DedupeColumnCollection` class is added to maintain the
              former behavior in those cases where deduplication as well as
              additional replace/remove operations are needed.
       
       
           """
       
    1:     __slots__ = "_collection", "_index", "_colset", "_proxy_index"
       
    1:     _collection: List[Tuple[_COLKEY, _COL_co, _ColumnMetrics[_COL_co]]]
    1:     _index: Dict[Union[None, str, int], Tuple[_COLKEY, _COL_co]]
    1:     _proxy_index: Dict[ColumnElement[Any], Set[_ColumnMetrics[_COL_co]]]
    1:     _colset: Set[_COL_co]
       
    1:     def __init__(
               self, columns: Optional[Iterable[Tuple[_COLKEY, _COL_co]]] = None
           ):
  347:         object.__setattr__(self, "_colset", set())
  347:         object.__setattr__(self, "_index", {})
  694:         object.__setattr__(
  347:             self, "_proxy_index", collections.defaultdict(util.OrderedSet)
               )
  347:         object.__setattr__(self, "_collection", [])
  347:         if columns:
>>>>>>             self._initial_populate(columns)
       
    1:     @util.preload_module("sqlalchemy.sql.elements")
    1:     def __clause_element__(self) -> ClauseList:
>>>>>>         elements = util.preloaded.sql_elements
       
>>>>>>         return elements.ClauseList(
>>>>>>             _literal_as_text_role=roles.ColumnsClauseRole,
>>>>>>             group=False,
>>>>>>             *self._all_columns,
               )
       
    1:     def _initial_populate(
               self, iter_: Iterable[Tuple[_COLKEY, _COL_co]]
           ) -> None:
>>>>>>         self._populate_separate_keys(iter_)
       
    1:     @property
    1:     def _all_columns(self) -> List[_COL_co]:
>>>>>>         return [col for (_, col, _) in self._collection]
       
    1:     def keys(self) -> List[_COLKEY]:
               """Return a sequence of string key names for all columns in this
               collection."""
>>>>>>         return [k for (k, _, _) in self._collection]
       
    1:     def values(self) -> List[_COL_co]:
               """Return a sequence of :class:`_sql.ColumnClause` or
               :class:`_schema.Column` objects for all columns in this
               collection."""
>>>>>>         return [col for (_, col, _) in self._collection]
       
    1:     def items(self) -> List[Tuple[_COLKEY, _COL_co]]:
               """Return a sequence of (key, column) tuples for all columns in this
               collection each consisting of a string key name and a
               :class:`_sql.ColumnClause` or
               :class:`_schema.Column` object.
               """
       
>>>>>>         return [(k, col) for (k, col, _) in self._collection]
       
    1:     def __bool__(self) -> bool:
   62:         return bool(self._collection)
       
    1:     def __len__(self) -> int:
 2928:         return len(self._collection)
       
    1:     def __iter__(self) -> Iterator[_COL_co]:
               # turn to a list first to maintain over a course of changes
45932:         return iter([col for _, col, _ in self._collection])
       
    1:     @overload
    1:     def __getitem__(self, key: Union[str, int]) -> _COL_co: ...
       
    1:     @overload
    1:     def __getitem__(
               self, key: Tuple[Union[str, int], ...]
>>>>>>     ) -> ReadOnlyColumnCollection[_COLKEY, _COL_co]: ...
       
    1:     @overload
    1:     def __getitem__(
               self, key: slice
>>>>>>     ) -> ReadOnlyColumnCollection[_COLKEY, _COL_co]: ...
       
    1:     def __getitem__(
               self, key: Union[str, int, slice, Tuple[Union[str, int], ...]]
           ) -> Union[ReadOnlyColumnCollection[_COLKEY, _COL_co], _COL_co]:
  219:         try:
  219:             if isinstance(key, (tuple, slice)):
>>>>>>                 if isinstance(key, slice):
>>>>>>                     cols = (
>>>>>>                         (sub_key, col)
>>>>>>                         for (sub_key, col, _) in self._collection[key]
                           )
                       else:
>>>>>>                     cols = (self._index[sub_key] for sub_key in key)
       
>>>>>>                 return ColumnCollection(cols).as_readonly()
                   else:
  219:                 return self._index[key][1]
>>>>>>         except KeyError as err:
>>>>>>             if isinstance(err.args[0], int):
>>>>>>                 raise IndexError(err.args[0]) from err
                   else:
>>>>>>                 raise
       
    1:     def __getattr__(self, key: str) -> _COL_co:
    7:         try:
    7:             return self._index[key][1]
>>>>>>         except KeyError as err:
>>>>>>             raise AttributeError(key) from err
       
    1:     def __contains__(self, key: str) -> bool:
 1218:         if key not in self._index:
 1218:             if not isinstance(key, str):
>>>>>>                 raise exc.ArgumentError(
>>>>>>                     "__contains__ requires a string argument"
                       )
 1218:             return False
               else:
>>>>>>             return True
       
    1:     def compare(self, other: ColumnCollection[Any, Any]) -> bool:
               """Compare this :class:`_expression.ColumnCollection` to another
               based on the names of the keys"""
       
>>>>>>         for l, r in zip_longest(self, other):
>>>>>>             if l is not r:
>>>>>>                 return False
               else:
>>>>>>             return True
       
    1:     def __eq__(self, other: Any) -> bool:
>>>>>>         return self.compare(other)
       
    1:     def get(
               self, key: str, default: Optional[_COL_co] = None
           ) -> Optional[_COL_co]:
               """Get a :class:`_sql.ColumnClause` or :class:`_schema.Column` object
               based on a string key name from this
               :class:`_expression.ColumnCollection`."""
       
   60:         if key in self._index:
   60:             return self._index[key][1]
               else:
>>>>>>             return default
       
    1:     def __str__(self) -> str:
>>>>>>         return "%s(%s)" % (
>>>>>>             self.__class__.__name__,
>>>>>>             ", ".join(str(c) for c in self),
               )
       
    1:     def __setitem__(self, key: str, value: Any) -> NoReturn:
>>>>>>         raise NotImplementedError()
       
    1:     def __delitem__(self, key: str) -> NoReturn:
>>>>>>         raise NotImplementedError()
       
    1:     def __setattr__(self, key: str, obj: Any) -> NoReturn:
>>>>>>         raise NotImplementedError()
       
    1:     def clear(self) -> NoReturn:
               """Dictionary clear() is not implemented for
               :class:`_sql.ColumnCollection`."""
>>>>>>         raise NotImplementedError()
       
    1:     def remove(self, column: Any) -> None:
>>>>>>         raise NotImplementedError()
       
    1:     def update(self, iter_: Any) -> NoReturn:
               """Dictionary update() is not implemented for
               :class:`_sql.ColumnCollection`."""
>>>>>>         raise NotImplementedError()
       
           # https://github.com/python/mypy/issues/4266
    1:     __hash__ = None  # type: ignore
       
    1:     def _populate_separate_keys(
               self, iter_: Iterable[Tuple[_COLKEY, _COL_co]]
           ) -> None:
               """populate from an iterator of (key, column)"""
       
   64:         self._collection[:] = collection = [
   48:             (k, c, _ColumnMetrics(self, c)) for k, c in iter_
               ]
   56:         self._colset.update(c._deannotate() for _, c, _ in collection)
   16:         self._index.update(
   56:             {idx: (k, c) for idx, (k, c, _) in enumerate(collection)}
               )
   56:         self._index.update({k: (k, col) for k, col, _ in reversed(collection)})
       
    1:     def add(
               self, column: ColumnElement[Any], key: Optional[_COLKEY] = None
           ) -> None:
               """Add a column to this :class:`_sql.ColumnCollection`.
       
               .. note::
       
                   This method is **not normally used by user-facing code**, as the
                   :class:`_sql.ColumnCollection` is usually part of an existing
                   object such as a :class:`_schema.Table`. To add a
                   :class:`_schema.Column` to an existing :class:`_schema.Table`
                   object, use the :meth:`_schema.Table.append_column` method.
       
               """
               colkey: _COLKEY
       
  451:         if key is None:
>>>>>>             colkey = column.key  # type: ignore
               else:
  451:             colkey = key
       
  451:         l = len(self._collection)
       
               # don't really know how this part is supposed to work w/ the
               # covariant thing
       
  451:         _column = cast(_COL_co, column)
       
  902:         self._collection.append(
  451:             (colkey, _column, _ColumnMetrics(self, _column))
               )
  451:         self._colset.add(_column._deannotate())
  451:         self._index[l] = (colkey, _column)
  451:         if colkey not in self._index:
  451:             self._index[colkey] = (colkey, _column)
       
    1:     def __getstate__(self) -> Dict[str, Any]:
>>>>>>         return {
>>>>>>             "_collection": [(k, c) for k, c, _ in self._collection],
>>>>>>             "_index": self._index,
               }
       
    1:     def __setstate__(self, state: Dict[str, Any]) -> None:
>>>>>>         object.__setattr__(self, "_index", state["_index"])
>>>>>>         object.__setattr__(
>>>>>>             self, "_proxy_index", collections.defaultdict(util.OrderedSet)
               )
>>>>>>         object.__setattr__(
>>>>>>             self,
>>>>>>             "_collection",
>>>>>>             [
>>>>>>                 (k, c, _ColumnMetrics(self, c))
>>>>>>                 for (k, c) in state["_collection"]
                   ],
               )
>>>>>>         object.__setattr__(
>>>>>>             self, "_colset", {col for k, col, _ in self._collection}
               )
       
    1:     def contains_column(self, col: ColumnElement[Any]) -> bool:
               """Checks if a column object exists in this collection"""
 1197:         if col not in self._colset:
  364:             if isinstance(col, str):
>>>>>>                 raise exc.ArgumentError(
>>>>>>                     "contains_column cannot be used with string arguments. "
                           "Use ``col_name in table.c`` instead."
                       )
  364:             return False
               else:
  833:             return True
       
    1:     def as_readonly(self) -> ReadOnlyColumnCollection[_COLKEY, _COL_co]:
               """Return a "read only" form of this
               :class:`_sql.ColumnCollection`."""
       
  146:         return ReadOnlyColumnCollection(self)
       
    1:     def _init_proxy_index(self):
               """populate the "proxy index", if empty.
       
               proxy index is added in 2.0 to provide more efficient operation
               for the corresponding_column() method.
       
               For reasons of both time to construct new .c collections as well as
               memory conservation for large numbers of large .c collections, the
               proxy_index is only filled if corresponding_column() is called. once
               filled it stays that way, and new _ColumnMetrics objects created after
               that point will populate it with new data. Note this case would be
               unusual, if not nonexistent, as it means a .c collection is being
               mutated after corresponding_column() were used, however it is tested in
               test/base/test_utils.py.
       
               """
   40:         pi = self._proxy_index
   40:         if pi:
>>>>>>             return
       
  416:         for _, _, metrics in self._collection:
  376:             eps = metrics.column._expanded_proxy_set
       
  792:             for eps_col in eps:
  416:                 pi[eps_col].add(metrics)
       
    1:     def corresponding_column(
               self, column: _COL, require_embedded: bool = False
           ) -> Optional[Union[_COL, _COL_co]]:
               """Given a :class:`_expression.ColumnElement`, return the exported
               :class:`_expression.ColumnElement` object from this
               :class:`_expression.ColumnCollection`
               which corresponds to that original :class:`_expression.ColumnElement`
               via a common
               ancestor column.
       
               :param column: the target :class:`_expression.ColumnElement`
                             to be matched.
       
               :param require_embedded: only return corresponding columns for
                the given :class:`_expression.ColumnElement`, if the given
                :class:`_expression.ColumnElement`
                is actually present within a sub-element
                of this :class:`_expression.Selectable`.
                Normally the column will match if
                it merely shares a common ancestor with one of the exported
                columns of this :class:`_expression.Selectable`.
       
               .. seealso::
       
                   :meth:`_expression.Selectable.corresponding_column`
                   - invokes this method
                   against the collection returned by
                   :attr:`_expression.Selectable.exported_columns`.
       
               .. versionchanged:: 1.4 the implementation for ``corresponding_column``
                  was moved onto the :class:`_expression.ColumnCollection` itself.
       
               """
               # TODO: cython candidate
       
               # don't dig around if the column is locally present
 1035:         if column in self._colset:
  959:             return column
       
   76:         selected_intersection, selected_metrics = None, None
   76:         target_set = column.proxy_set
       
   76:         pi = self._proxy_index
   76:         if not pi:
   40:             self._init_proxy_index()
       
  304:         for current_metrics in (
  152:             mm for ts in target_set if ts in pi for mm in pi[ts]
               ):
>>>>>>             if not require_embedded or current_metrics.embedded(target_set):
>>>>>>                 if selected_metrics is None:
                           # no corresponding column yet, pick this one.
>>>>>>                     selected_metrics = current_metrics
>>>>>>                     continue
       
>>>>>>                 current_intersection = target_set.intersection(
>>>>>>                     current_metrics.column._expanded_proxy_set
                       )
>>>>>>                 if selected_intersection is None:
>>>>>>                     selected_intersection = target_set.intersection(
>>>>>>                         selected_metrics.column._expanded_proxy_set
                           )
       
>>>>>>                 if len(current_intersection) > len(selected_intersection):
                           # 'current' has a larger field of correspondence than
                           # 'selected'. i.e. selectable.c.a1_x->a1.c.x->table.c.x
                           # matches a1.c.x->table.c.x better than
                           # selectable.c.x->table.c.x does.
       
>>>>>>                     selected_metrics = current_metrics
>>>>>>                     selected_intersection = current_intersection
>>>>>>                 elif current_intersection == selected_intersection:
                           # they have the same field of correspondence. see
                           # which proxy_set has fewer columns in it, which
                           # indicates a closer relationship with the root
                           # column. Also take into account the "weight"
                           # attribute which CompoundSelect() uses to give
                           # higher precedence to columns based on vertical
                           # position in the compound statement, and discard
                           # columns that have no reference to the target
                           # column (also occurs with CompoundSelect)
       
>>>>>>                     selected_col_distance = sum(
>>>>>>                         [
>>>>>>                             sc._annotations.get("weight", 1)
>>>>>>                             for sc in (
>>>>>>                                 selected_metrics.column._uncached_proxy_list()
                                   )
>>>>>>                             if sc.shares_lineage(column)
                               ],
                           )
>>>>>>                     current_col_distance = sum(
>>>>>>                         [
>>>>>>                             sc._annotations.get("weight", 1)
>>>>>>                             for sc in (
>>>>>>                                 current_metrics.column._uncached_proxy_list()
                                   )
>>>>>>                             if sc.shares_lineage(column)
                               ],
                           )
>>>>>>                     if current_col_distance < selected_col_distance:
>>>>>>                         selected_metrics = current_metrics
>>>>>>                         selected_intersection = current_intersection
       
   76:         return selected_metrics.column if selected_metrics else None
       
       
    1: _NAMEDCOL = TypeVar("_NAMEDCOL", bound="NamedColumn[Any]")
       
       
    2: class DedupeColumnCollection(ColumnCollection[str, _NAMEDCOL]):
    1:     """A :class:`_expression.ColumnCollection`
           that maintains deduplicating behavior.
       
           This is useful by schema level objects such as :class:`_schema.Table` and
           :class:`.PrimaryKeyConstraint`.    The collection includes more
           sophisticated mutator methods as well to suit schema objects which
           require mutable column collections.
       
           .. versionadded:: 1.4
       
           """
       
    1:     def add(
               self, column: ColumnElement[Any], key: Optional[str] = None
           ) -> None:
  189:         named_column = cast(_NAMEDCOL, column)
  189:         if key is not None and named_column.key != key:
>>>>>>             raise exc.ArgumentError(
>>>>>>                 "DedupeColumnCollection requires columns be under "
                       "the same key as their .key"
                   )
  189:         key = named_column.key
       
  189:         if key is None:
>>>>>>             raise exc.ArgumentError(
>>>>>>                 "Can't add unnamed column to column collection"
                   )
       
  189:         if key in self._index:
>>>>>>             existing = self._index[key][1]
       
>>>>>>             if existing is named_column:
>>>>>>                 return
       
>>>>>>             self.replace(named_column)
       
                   # pop out memoized proxy_set as this
                   # operation may very well be occurring
                   # in a _make_proxy operation
>>>>>>             util.memoized_property.reset(named_column, "proxy_set")
               else:
  189:             self._append_new_column(key, named_column)
       
    1:     def _append_new_column(self, key: str, named_column: _NAMEDCOL) -> None:
  843:         l = len(self._collection)
 1686:         self._collection.append(
  843:             (key, named_column, _ColumnMetrics(self, named_column))
               )
  843:         self._colset.add(named_column._deannotate())
  843:         self._index[l] = (key, named_column)
  843:         self._index[key] = (key, named_column)
       
    1:     def _populate_separate_keys(
               self, iter_: Iterable[Tuple[str, _NAMEDCOL]]
           ) -> None:
               """populate from an iterator of (key, column)"""
>>>>>>         cols = list(iter_)
       
>>>>>>         replace_col = []
>>>>>>         for k, col in cols:
>>>>>>             if col.key != k:
>>>>>>                 raise exc.ArgumentError(
>>>>>>                     "DedupeColumnCollection requires columns be under "
                           "the same key as their .key"
                       )
>>>>>>             if col.name in self._index and col.key != col.name:
>>>>>>                 replace_col.append(col)
>>>>>>             elif col.key in self._index:
>>>>>>                 replace_col.append(col)
                   else:
>>>>>>                 self._index[k] = (k, col)
>>>>>>                 self._collection.append((k, col, _ColumnMetrics(self, col)))
>>>>>>         self._colset.update(c._deannotate() for (k, c, _) in self._collection)
       
>>>>>>         self._index.update(
>>>>>>             (idx, (k, c)) for idx, (k, c, _) in enumerate(self._collection)
               )
>>>>>>         for col in replace_col:
>>>>>>             self.replace(col)
       
    1:     def extend(self, iter_: Iterable[_NAMEDCOL]) -> None:
>>>>>>         self._populate_separate_keys((col.key, col) for col in iter_)
       
    1:     def remove(self, column: _NAMEDCOL) -> None:
>>>>>>         if column not in self._colset:
>>>>>>             raise ValueError(
>>>>>>                 "Can't remove column %r; column is not in this collection"
>>>>>>                 % column
                   )
>>>>>>         del self._index[column.key]
>>>>>>         self._colset.remove(column)
>>>>>>         self._collection[:] = [
>>>>>>             (k, c, metrics)
>>>>>>             for (k, c, metrics) in self._collection
>>>>>>             if c is not column
               ]
>>>>>>         for metrics in self._proxy_index.get(column, ()):
>>>>>>             metrics.dispose(self)
       
>>>>>>         self._index.update(
>>>>>>             {idx: (k, col) for idx, (k, col, _) in enumerate(self._collection)}
               )
               # delete higher index
>>>>>>         del self._index[len(self._collection)]
       
    1:     def replace(
               self,
               column: _NAMEDCOL,
               extra_remove: Optional[Iterable[_NAMEDCOL]] = None,
           ) -> None:
               """add the given column to this collection, removing unaliased
               versions of this column  as well as existing columns with the
               same key.
       
               e.g.::
       
                   t = Table('sometable', metadata, Column('col1', Integer))
                   t.columns.replace(Column('col1', Integer, key='columnone'))
       
               will remove the original 'col1' from the collection, and add
               the new column under the name 'columnname'.
       
               Used by schema.Column to override columns during table reflection.
       
               """
       
  654:         if extra_remove:
>>>>>>             remove_col = set(extra_remove)
               else:
  654:             remove_col = set()
               # remove up to two columns based on matches of name as well as key
  654:         if column.name in self._index and column.key != column.name:
>>>>>>             other = self._index[column.name][1]
>>>>>>             if other.name == other.key:
>>>>>>                 remove_col.add(other)
       
  654:         if column.key in self._index:
>>>>>>             remove_col.add(self._index[column.key][1])
       
  654:         if not remove_col:
  654:             self._append_new_column(column.key, column)
  654:             return
>>>>>>         new_cols: List[Tuple[str, _NAMEDCOL, _ColumnMetrics[_NAMEDCOL]]] = []
>>>>>>         replaced = False
>>>>>>         for k, col, metrics in self._collection:
>>>>>>             if col in remove_col:
>>>>>>                 if not replaced:
>>>>>>                     replaced = True
>>>>>>                     new_cols.append(
>>>>>>                         (column.key, column, _ColumnMetrics(self, column))
                           )
                   else:
>>>>>>                 new_cols.append((k, col, metrics))
       
>>>>>>         if remove_col:
>>>>>>             self._colset.difference_update(remove_col)
       
>>>>>>             for rc in remove_col:
>>>>>>                 for metrics in self._proxy_index.get(rc, ()):
>>>>>>                     metrics.dispose(self)
       
>>>>>>         if not replaced:
>>>>>>             new_cols.append((column.key, column, _ColumnMetrics(self, column)))
       
>>>>>>         self._colset.add(column._deannotate())
>>>>>>         self._collection[:] = new_cols
       
>>>>>>         self._index.clear()
       
>>>>>>         self._index.update(
>>>>>>             {idx: (k, col) for idx, (k, col, _) in enumerate(self._collection)}
               )
>>>>>>         self._index.update({k: (k, col) for (k, col, _) in self._collection})
       
       
    3: class ReadOnlyColumnCollection(
    1:     util.ReadOnlyContainer, ColumnCollection[_COLKEY, _COL_co]
       ):
    1:     __slots__ = ("_parent",)
       
    1:     def __init__(self, collection):
  146:         object.__setattr__(self, "_parent", collection)
  146:         object.__setattr__(self, "_colset", collection._colset)
  146:         object.__setattr__(self, "_index", collection._index)
  146:         object.__setattr__(self, "_collection", collection._collection)
  146:         object.__setattr__(self, "_proxy_index", collection._proxy_index)
       
    1:     def __getstate__(self):
>>>>>>         return {"_parent": self._parent}
       
    1:     def __setstate__(self, state):
>>>>>>         parent = state["_parent"]
>>>>>>         self.__init__(parent)  # type: ignore
       
    1:     def add(self, column: Any, key: Any = ...) -> Any:
>>>>>>         self._readonly()
       
    1:     def extend(self, elements: Any) -> NoReturn:
>>>>>>         self._readonly()
       
    1:     def remove(self, item: Any) -> NoReturn:
>>>>>>         self._readonly()
       
       
    2: class ColumnSet(util.OrderedSet["ColumnClause[Any]"]):
    1:     def contains_column(self, col):
>>>>>>         return col in self
       
    1:     def extend(self, cols):
>>>>>>         for col in cols:
>>>>>>             self.add(col)
       
    1:     def __eq__(self, other):
>>>>>>         l = []
>>>>>>         for c in other:
>>>>>>             for local in self:
>>>>>>                 if c.shares_lineage(local):
>>>>>>                     l.append(c == local)
>>>>>>         return elements.and_(*l)
       
    1:     def __hash__(self):
  124:         return hash(tuple(x for x in self))
       
       
    1: def _entity_namespace(
           entity: Union[_HasEntityNamespace, ExternallyTraversible]
       ) -> _EntityNamespace:
           """Return the nearest .entity_namespace for the given entity.
       
           If not immediately available, does an iterate to find a sub-element
           that has one, if any.
       
           """
    3:     try:
    3:         return cast(_HasEntityNamespace, entity).entity_namespace
>>>>>>     except AttributeError:
>>>>>>         for elem in visitors.iterate(cast(ExternallyTraversible, entity)):
>>>>>>             if _is_has_entity_namespace(elem):
>>>>>>                 return elem.entity_namespace
               else:
>>>>>>             raise
       
       
    1: def _entity_namespace_key(
           entity: Union[_HasEntityNamespace, ExternallyTraversible],
           key: str,
    1:     default: Union[SQLCoreOperations[Any], _NoArg] = NO_ARG,
       ) -> SQLCoreOperations[Any]:
           """Return an entry from an entity_namespace.
       
       
           Raises :class:`_exc.InvalidRequestError` rather than attribute error
           on not found.
       
           """
       
    3:     try:
    3:         ns = _entity_namespace(entity)
    3:         if default is not NO_ARG:
    3:             return getattr(ns, key, default)
               else:
>>>>>>             return getattr(ns, key)  # type: ignore
>>>>>>     except AttributeError as err:
>>>>>>         raise exc.InvalidRequestError(
>>>>>>             'Entity namespace for "%s" has no property "%s"' % (entity, key)
>>>>>>         ) from err
