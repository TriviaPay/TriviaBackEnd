       # orm/properties.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: """MapperProperty implementations.
       
       This is a private module which defines the behavior of individual ORM-
       mapped attributes.
       
       """
       
    1: from __future__ import annotations
       
    1: from typing import Any
    1: from typing import cast
    1: from typing import Dict
    1: from typing import List
    1: from typing import Optional
    1: from typing import Sequence
    1: from typing import Set
    1: from typing import Tuple
    1: from typing import Type
    1: from typing import TYPE_CHECKING
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from . import attributes
    1: from . import strategy_options
    1: from .base import _DeclarativeMapped
    1: from .base import class_mapper
    1: from .descriptor_props import CompositeProperty
    1: from .descriptor_props import ConcreteInheritedProperty
    1: from .descriptor_props import SynonymProperty
    1: from .interfaces import _AttributeOptions
    1: from .interfaces import _DEFAULT_ATTRIBUTE_OPTIONS
    1: from .interfaces import _IntrospectsAnnotations
    1: from .interfaces import _MapsColumns
    1: from .interfaces import MapperProperty
    1: from .interfaces import PropComparator
    1: from .interfaces import StrategizedProperty
    1: from .relationships import RelationshipProperty
    1: from .util import de_stringify_annotation
    1: from .util import de_stringify_union_elements
    1: from .. import exc as sa_exc
    1: from .. import ForeignKey
    1: from .. import log
    1: from .. import util
    1: from ..sql import coercions
    1: from ..sql import roles
    1: from ..sql.base import _NoArg
    1: from ..sql.schema import Column
    1: from ..sql.schema import SchemaConst
    1: from ..sql.type_api import TypeEngine
    1: from ..util.typing import de_optionalize_union_types
    1: from ..util.typing import is_fwd_ref
    1: from ..util.typing import is_optional_union
    1: from ..util.typing import is_pep593
    1: from ..util.typing import is_union
    1: from ..util.typing import Self
    1: from ..util.typing import typing_get_args
       
    1: if TYPE_CHECKING:
>>>>>>     from ._typing import _IdentityKeyType
>>>>>>     from ._typing import _InstanceDict
>>>>>>     from ._typing import _ORMColumnExprArgument
>>>>>>     from ._typing import _RegistryType
>>>>>>     from .base import Mapped
>>>>>>     from .decl_base import _ClassScanMapperConfig
>>>>>>     from .mapper import Mapper
>>>>>>     from .session import Session
>>>>>>     from .state import _InstallLoaderCallableProto
>>>>>>     from .state import InstanceState
>>>>>>     from ..sql._typing import _InfoType
>>>>>>     from ..sql.elements import ColumnElement
>>>>>>     from ..sql.elements import NamedColumn
>>>>>>     from ..sql.operators import OperatorType
>>>>>>     from ..util.typing import _AnnotationScanType
>>>>>>     from ..util.typing import RODescriptorReference
       
    1: _T = TypeVar("_T", bound=Any)
    1: _PT = TypeVar("_PT", bound=Any)
    1: _NC = TypeVar("_NC", bound="NamedColumn[Any]")
       
    1: __all__ = [
           "ColumnProperty",
           "CompositeProperty",
           "ConcreteInheritedProperty",
           "RelationshipProperty",
           "SynonymProperty",
       ]
       
       
    2: @log.class_logger
    2: class ColumnProperty(
    1:     _MapsColumns[_T],
    1:     StrategizedProperty[_T],
    1:     _IntrospectsAnnotations,
    1:     log.Identified,
       ):
    1:     """Describes an object attribute that corresponds to a table column
           or other column expression.
       
           Public constructor is the :func:`_orm.column_property` function.
       
           """
       
    1:     strategy_wildcard_key = strategy_options._COLUMN_TOKEN
    1:     inherit_cache = True
           """:meta private:"""
       
    1:     _links_to_entity = False
       
    1:     columns: List[NamedColumn[Any]]
       
    1:     _is_polymorphic_discriminator: bool
       
    1:     _mapped_by_synonym: Optional[str]
       
    1:     comparator_factory: Type[PropComparator[_T]]
       
    1:     __slots__ = (
               "columns",
               "group",
               "deferred",
               "instrument",
               "comparator_factory",
               "active_history",
               "expire_on_flush",
               "_creation_order",
               "_is_polymorphic_discriminator",
               "_mapped_by_synonym",
               "_deferred_column_loader",
               "_raise_column_loader",
               "_renders_in_subqueries",
               "raiseload",
           )
       
    1:     def __init__(
               self,
               column: _ORMColumnExprArgument[_T],
               *additional_columns: _ORMColumnExprArgument[Any],
    1:         attribute_options: Optional[_AttributeOptions] = None,
    1:         group: Optional[str] = None,
    1:         deferred: bool = False,
    1:         raiseload: bool = False,
    1:         comparator_factory: Optional[Type[PropComparator[_T]]] = None,
    1:         active_history: bool = False,
    1:         expire_on_flush: bool = True,
    1:         info: Optional[_InfoType] = None,
    1:         doc: Optional[str] = None,
    1:         _instrument: bool = True,
    1:         _assume_readonly_dc_attributes: bool = False,
           ):
  902:         super().__init__(
  451:             attribute_options=attribute_options,
  451:             _assume_readonly_dc_attributes=_assume_readonly_dc_attributes,
               )
  451:         columns = (column,) + additional_columns
 1804:         self.columns = [
  902:             coercions.expect(roles.LabeledColumnExprRole, c) for c in columns
               ]
  451:         self.group = group
  451:         self.deferred = deferred
  451:         self.raiseload = raiseload
  451:         self.instrument = _instrument
  451:         self.comparator_factory = (
  451:             comparator_factory
  451:             if comparator_factory is not None
  451:             else self.__class__.Comparator
               )
  451:         self.active_history = active_history
  451:         self.expire_on_flush = expire_on_flush
       
  451:         if info is not None:
>>>>>>             self.info.update(info)
       
  451:         if doc is not None:
>>>>>>             self.doc = doc
               else:
  902:             for col in reversed(self.columns):
  451:                 doc = getattr(col, "doc", None)
  451:                 if doc is not None:
>>>>>>                     self.doc = doc
>>>>>>                     break
                   else:
  451:                 self.doc = None
       
  451:         util.set_creation_order(self)
       
  451:         self.strategy_key = (
  451:             ("deferred", self.deferred),
  451:             ("instrument", self.instrument),
               )
  451:         if self.raiseload:
>>>>>>             self.strategy_key += (("raiseload", True),)
       
    1:     def declarative_scan(
               self,
               decl_scan: _ClassScanMapperConfig,
               registry: _RegistryType,
               cls: Type[Any],
               originating_module: Optional[str],
               key: str,
               mapped_container: Optional[Type[Mapped[Any]]],
               annotation: Optional[_AnnotationScanType],
               extracted_mapped_annotation: Optional[_AnnotationScanType],
               is_dataclass_field: bool,
           ) -> None:
>>>>>>         column = self.columns[0]
>>>>>>         if column.key is None:
>>>>>>             column.key = key
>>>>>>         if column.name is None:
>>>>>>             column.name = key
       
    1:     @property
    1:     def mapper_property_to_assign(self) -> Optional[MapperProperty[_T]]:
>>>>>>         return self
       
    1:     @property
    1:     def columns_to_assign(self) -> List[Tuple[Column[Any], int]]:
               # mypy doesn't care about the isinstance here
>>>>>>         return [
>>>>>>             (c, 0)  # type: ignore
>>>>>>             for c in self.columns
>>>>>>             if isinstance(c, Column) and c.table is None
               ]
       
    1:     def _memoized_attr__renders_in_subqueries(self) -> bool:
   10:         if ("query_expression", True) in self.strategy_key:
>>>>>>             return self.strategy._have_default_expression  # type: ignore
       
   20:         return ("deferred", True) not in self.strategy_key or (
>>>>>>             self not in self.parent._readonly_props  # type: ignore
               )
       
    1:     @util.preload_module("sqlalchemy.orm.state", "sqlalchemy.orm.strategies")
    1:     def _memoized_attr__deferred_column_loader(
               self,
           ) -> _InstallLoaderCallableProto[Any]:
>>>>>>         state = util.preloaded.orm_state
>>>>>>         strategies = util.preloaded.orm_strategies
>>>>>>         return state.InstanceState._instance_level_callable_processor(
>>>>>>             self.parent.class_manager,
>>>>>>             strategies.LoadDeferredColumns(self.key),
>>>>>>             self.key,
               )
       
    1:     @util.preload_module("sqlalchemy.orm.state", "sqlalchemy.orm.strategies")
    1:     def _memoized_attr__raise_column_loader(
               self,
           ) -> _InstallLoaderCallableProto[Any]:
>>>>>>         state = util.preloaded.orm_state
>>>>>>         strategies = util.preloaded.orm_strategies
>>>>>>         return state.InstanceState._instance_level_callable_processor(
>>>>>>             self.parent.class_manager,
>>>>>>             strategies.LoadDeferredColumns(self.key, True),
>>>>>>             self.key,
               )
       
    1:     def __clause_element__(self) -> roles.ColumnsClauseRole:
               """Allow the ColumnProperty to work in expression before it is turned
               into an instrumented attribute.
               """
       
>>>>>>         return self.expression
       
    1:     @property
    1:     def expression(self) -> roles.ColumnsClauseRole:
               """Return the primary column or expression for this ColumnProperty.
       
               E.g.::
       
       
                   class File(Base):
                       # ...
       
                       name = Column(String(64))
                       extension = Column(String(8))
                       filename = column_property(name + '.' + extension)
                       path = column_property('C:/' + filename.expression)
       
               .. seealso::
       
                   :ref:`mapper_column_property_sql_expressions_composed`
       
               """
  904:         return self.columns[0]
       
    1:     def instrument_class(self, mapper: Mapper[Any]) -> None:
  451:         if not self.instrument:
>>>>>>             return
       
  902:         attributes.register_descriptor(
  451:             mapper.class_,
  451:             self.key,
  451:             comparator=self.comparator_factory(self, mapper),
  451:             parententity=mapper,
  451:             doc=self.doc,
               )
       
    1:     def do_init(self) -> None:
  451:         super().do_init()
       
  451:         if len(self.columns) > 1 and set(self.parent.primary_key).issuperset(
>>>>>>             self.columns
               ):
>>>>>>             util.warn(
>>>>>>                 (
>>>>>>                     "On mapper %s, primary key column '%s' is being combined "
                           "with distinct primary key column '%s' in attribute '%s'. "
                           "Use explicit properties to give each column its own "
                           "mapped attribute name."
                       )
>>>>>>                 % (self.parent, self.columns[1], self.columns[0], self.key)
                   )
       
    1:     def copy(self) -> ColumnProperty[_T]:
>>>>>>         return ColumnProperty(
>>>>>>             *self.columns,
>>>>>>             deferred=self.deferred,
>>>>>>             group=self.group,
>>>>>>             active_history=self.active_history,
               )
       
    1:     def merge(
               self,
               session: Session,
               source_state: InstanceState[Any],
               source_dict: _InstanceDict,
               dest_state: InstanceState[Any],
               dest_dict: _InstanceDict,
               load: bool,
               _recursive: Dict[Any, object],
               _resolve_conflict_map: Dict[_IdentityKeyType[Any], object],
           ) -> None:
>>>>>>         if not self.instrument:
>>>>>>             return
>>>>>>         elif self.key in source_dict:
>>>>>>             value = source_dict[self.key]
       
>>>>>>             if not load:
>>>>>>                 dest_dict[self.key] = value
                   else:
>>>>>>                 impl = dest_state.get_impl(self.key)
>>>>>>                 impl.set(dest_state, dest_dict, value, None)
>>>>>>         elif dest_state.has_identity and self.key not in dest_dict:
>>>>>>             dest_state._expire_attributes(
>>>>>>                 dest_dict, [self.key], no_loader=True
                   )
       
    2:     class Comparator(util.MemoizedSlots, PropComparator[_PT]):
    1:         """Produce boolean, comparison, and other operators for
               :class:`.ColumnProperty` attributes.
       
               See the documentation for :class:`.PropComparator` for a brief
               overview.
       
               .. seealso::
       
                   :class:`.PropComparator`
       
                   :class:`.ColumnOperators`
       
                   :ref:`types_operators`
       
                   :attr:`.TypeEngine.comparator_factory`
       
               """
       
    1:         if not TYPE_CHECKING:
                   # prevent pylance from being clever about slots
    1:             __slots__ = "__clause_element__", "info", "expressions"
       
    1:         prop: RODescriptorReference[ColumnProperty[_PT]]
       
    1:         expressions: Sequence[NamedColumn[Any]]
               """The full sequence of columns referenced by this
                attribute, adjusted for any aliasing in progress.
       
               .. versionadded:: 1.3.17
       
               .. seealso::
       
                  :ref:`maptojoin` - usage example
               """
       
    1:         def _orm_annotate_column(self, column: _NC) -> _NC:
                   """annotate and possibly adapt a column to be returned
                   as the mapped-attribute exposed version of the column.
       
                   The column in this context needs to act as much like the
                   column in an ORM mapped context as possible, so includes
                   annotations to give hints to various ORM functions as to
                   the source entity of this column.   It also adapts it
                   to the mapper's with_polymorphic selectable if one is
                   present.
       
                   """
       
  451:             pe = self._parententity
  451:             annotations: Dict[str, Any] = {
  451:                 "entity_namespace": pe,
  451:                 "parententity": pe,
  451:                 "parentmapper": pe,
  451:                 "proxy_key": self.prop.key,
                   }
       
  451:             col = column
       
                   # for a mapper with polymorphic_on and an adapter, return
                   # the column against the polymorphic selectable.
                   # see also orm.util._orm_downgrade_polymorphic_columns
                   # for the reverse operation.
  451:             if self._parentmapper._polymorphic_adapter:
>>>>>>                 mapper_local_col = col
>>>>>>                 col = self._parentmapper._polymorphic_adapter.traverse(col)
       
                       # this is a clue to the ORM Query etc. that this column
                       # was adapted to the mapper's polymorphic_adapter.  the
                       # ORM uses this hint to know which column its adapting.
>>>>>>                 annotations["adapt_column"] = mapper_local_col
       
  902:             return col._annotate(annotations)._set_propagate_attrs(
  451:                 {"compile_state_plugin": "orm", "plugin_subject": pe}
                   )
       
    1:         if TYPE_CHECKING:
       
>>>>>>             def __clause_element__(self) -> NamedColumn[_PT]: ...
       
    1:         def _memoized_method___clause_element__(
                   self,
               ) -> NamedColumn[_PT]:
  451:             if self.adapter:
>>>>>>                 return self.adapter(self.prop.columns[0], self.prop.key)
                   else:
  451:                 return self._orm_annotate_column(self.prop.columns[0])
       
    1:         def _memoized_attr_info(self) -> _InfoType:
                   """The .info dictionary for this attribute."""
       
>>>>>>             ce = self.__clause_element__()
>>>>>>             try:
>>>>>>                 return ce.info  # type: ignore
>>>>>>             except AttributeError:
>>>>>>                 return self.prop.info
       
    1:         def _memoized_attr_expressions(self) -> Sequence[NamedColumn[Any]]:
                   """The full sequence of columns referenced by this
                   attribute, adjusted for any aliasing in progress.
       
                   .. versionadded:: 1.3.17
       
                   """
>>>>>>             if self.adapter:
>>>>>>                 return [
>>>>>>                     self.adapter(col, self.prop.key)
>>>>>>                     for col in self.prop.columns
                       ]
                   else:
>>>>>>                 return [
>>>>>>                     self._orm_annotate_column(col) for col in self.prop.columns
                       ]
       
    1:         def _fallback_getattr(self, key: str) -> Any:
                   """proxy attribute access down to the mapped column.
       
                   this allows user-defined comparison methods to be accessed.
                   """
  451:             return getattr(self.__clause_element__(), key)
       
    1:         def operate(
                   self, op: OperatorType, *other: Any, **kwargs: Any
               ) -> ColumnElement[Any]:
  102:             return op(self.__clause_element__(), *other, **kwargs)  # type: ignore[no-any-return]  # noqa: E501
       
    1:         def reverse_operate(
                   self, op: OperatorType, other: Any, **kwargs: Any
               ) -> ColumnElement[Any]:
>>>>>>             col = self.__clause_element__()
>>>>>>             return op(col._bind_param(op, other), col, **kwargs)  # type: ignore[no-any-return]  # noqa: E501
       
    1:     def __str__(self) -> str:
>>>>>>         if not self.parent or not self.key:
>>>>>>             return object.__repr__(self)
>>>>>>         return str(self.parent.class_.__name__) + "." + self.key
       
       
    2: class MappedSQLExpression(ColumnProperty[_T], _DeclarativeMapped[_T]):
    1:     """Declarative front-end for the :class:`.ColumnProperty` class.
       
           Public constructor is the :func:`_orm.column_property` function.
       
           .. versionchanged:: 2.0 Added :class:`_orm.MappedSQLExpression` as
              a Declarative compatible subclass for :class:`_orm.ColumnProperty`.
       
           .. seealso::
       
               :class:`.MappedColumn`
       
           """
       
    1:     inherit_cache = True
    1:     """:meta private:"""
       
       
    3: class MappedColumn(
    1:     _IntrospectsAnnotations,
    1:     _MapsColumns[_T],
    1:     _DeclarativeMapped[_T],
       ):
    1:     """Maps a single :class:`_schema.Column` on a class.
       
           :class:`_orm.MappedColumn` is a specialization of the
           :class:`_orm.ColumnProperty` class and is oriented towards declarative
           configuration.
       
           To construct :class:`_orm.MappedColumn` objects, use the
           :func:`_orm.mapped_column` constructor function.
       
           .. versionadded:: 2.0
       
       
           """
       
    1:     __slots__ = (
               "column",
               "_creation_order",
               "_sort_order",
               "foreign_keys",
               "_has_nullable",
               "_has_insert_default",
               "deferred",
               "deferred_group",
               "deferred_raiseload",
               "active_history",
               "_attribute_options",
               "_has_dataclass_arguments",
               "_use_existing_column",
           )
       
    1:     deferred: Union[_NoArg, bool]
    1:     deferred_raiseload: bool
    1:     deferred_group: Optional[str]
       
    1:     column: Column[_T]
    1:     foreign_keys: Optional[Set[ForeignKey]]
    1:     _attribute_options: _AttributeOptions
       
    1:     def __init__(self, *arg: Any, **kw: Any):
>>>>>>         self._attribute_options = attr_opts = kw.pop(
>>>>>>             "attribute_options", _DEFAULT_ATTRIBUTE_OPTIONS
               )
       
>>>>>>         self._use_existing_column = kw.pop("use_existing_column", False)
       
>>>>>>         self._has_dataclass_arguments = (
>>>>>>             attr_opts is not None
>>>>>>             and attr_opts != _DEFAULT_ATTRIBUTE_OPTIONS
>>>>>>             and any(
>>>>>>                 attr_opts[i] is not _NoArg.NO_ARG
>>>>>>                 for i, attr in enumerate(attr_opts._fields)
>>>>>>                 if attr != "dataclasses_default"
                   )
               )
       
>>>>>>         insert_default = kw.pop("insert_default", _NoArg.NO_ARG)
>>>>>>         self._has_insert_default = insert_default is not _NoArg.NO_ARG
       
>>>>>>         if self._has_insert_default:
>>>>>>             kw["default"] = insert_default
>>>>>>         elif attr_opts.dataclasses_default is not _NoArg.NO_ARG:
>>>>>>             kw["default"] = attr_opts.dataclasses_default
       
>>>>>>         self.deferred_group = kw.pop("deferred_group", None)
>>>>>>         self.deferred_raiseload = kw.pop("deferred_raiseload", None)
>>>>>>         self.deferred = kw.pop("deferred", _NoArg.NO_ARG)
>>>>>>         self.active_history = kw.pop("active_history", False)
       
>>>>>>         self._sort_order = kw.pop("sort_order", _NoArg.NO_ARG)
>>>>>>         self.column = cast("Column[_T]", Column(*arg, **kw))
>>>>>>         self.foreign_keys = self.column.foreign_keys
>>>>>>         self._has_nullable = "nullable" in kw and kw.get("nullable") not in (
>>>>>>             None,
>>>>>>             SchemaConst.NULL_UNSPECIFIED,
               )
>>>>>>         util.set_creation_order(self)
       
    1:     def _copy(self, **kw: Any) -> Self:
>>>>>>         new = self.__class__.__new__(self.__class__)
>>>>>>         new.column = self.column._copy(**kw)
>>>>>>         new.deferred = self.deferred
>>>>>>         new.deferred_group = self.deferred_group
>>>>>>         new.deferred_raiseload = self.deferred_raiseload
>>>>>>         new.foreign_keys = new.column.foreign_keys
>>>>>>         new.active_history = self.active_history
>>>>>>         new._has_nullable = self._has_nullable
>>>>>>         new._attribute_options = self._attribute_options
>>>>>>         new._has_insert_default = self._has_insert_default
>>>>>>         new._has_dataclass_arguments = self._has_dataclass_arguments
>>>>>>         new._use_existing_column = self._use_existing_column
>>>>>>         new._sort_order = self._sort_order
>>>>>>         util.set_creation_order(new)
>>>>>>         return new
       
    1:     @property
    1:     def name(self) -> str:
>>>>>>         return self.column.name
       
    1:     @property
    1:     def mapper_property_to_assign(self) -> Optional[MapperProperty[_T]]:
>>>>>>         effective_deferred = self.deferred
>>>>>>         if effective_deferred is _NoArg.NO_ARG:
>>>>>>             effective_deferred = bool(
>>>>>>                 self.deferred_group or self.deferred_raiseload
                   )
       
>>>>>>         if effective_deferred or self.active_history:
>>>>>>             return ColumnProperty(
>>>>>>                 self.column,
>>>>>>                 deferred=effective_deferred,
>>>>>>                 group=self.deferred_group,
>>>>>>                 raiseload=self.deferred_raiseload,
>>>>>>                 attribute_options=self._attribute_options,
>>>>>>                 active_history=self.active_history,
                   )
               else:
>>>>>>             return None
       
    1:     @property
    1:     def columns_to_assign(self) -> List[Tuple[Column[Any], int]]:
>>>>>>         return [
>>>>>>             (
>>>>>>                 self.column,
                       (
>>>>>>                     self._sort_order
>>>>>>                     if self._sort_order is not _NoArg.NO_ARG
>>>>>>                     else 0
                       ),
                   )
               ]
       
    1:     def __clause_element__(self) -> Column[_T]:
>>>>>>         return self.column
       
    1:     def operate(
               self, op: OperatorType, *other: Any, **kwargs: Any
           ) -> ColumnElement[Any]:
>>>>>>         return op(self.__clause_element__(), *other, **kwargs)  # type: ignore[no-any-return]  # noqa: E501
       
    1:     def reverse_operate(
               self, op: OperatorType, other: Any, **kwargs: Any
           ) -> ColumnElement[Any]:
>>>>>>         col = self.__clause_element__()
>>>>>>         return op(col._bind_param(op, other), col, **kwargs)  # type: ignore[no-any-return]  # noqa: E501
       
    1:     def found_in_pep593_annotated(self) -> Any:
               # return a blank mapped_column().  This mapped_column()'s
               # Column will be merged into it in _init_column_for_annotation().
>>>>>>         return MappedColumn()
       
    1:     def declarative_scan(
               self,
               decl_scan: _ClassScanMapperConfig,
               registry: _RegistryType,
               cls: Type[Any],
               originating_module: Optional[str],
               key: str,
               mapped_container: Optional[Type[Mapped[Any]]],
               annotation: Optional[_AnnotationScanType],
               extracted_mapped_annotation: Optional[_AnnotationScanType],
               is_dataclass_field: bool,
           ) -> None:
>>>>>>         column = self.column
       
>>>>>>         if (
>>>>>>             self._use_existing_column
>>>>>>             and decl_scan.inherits
>>>>>>             and decl_scan.single
               ):
>>>>>>             if decl_scan.is_deferred:
>>>>>>                 raise sa_exc.ArgumentError(
>>>>>>                     "Can't use use_existing_column with deferred mappers"
                       )
>>>>>>             supercls_mapper = class_mapper(decl_scan.inherits, False)
       
>>>>>>             colname = column.name if column.name is not None else key
>>>>>>             column = self.column = supercls_mapper.local_table.c.get(  # type: ignore # noqa: E501
>>>>>>                 colname, column
                   )
       
>>>>>>         if column.key is None:
>>>>>>             column.key = key
>>>>>>         if column.name is None:
>>>>>>             column.name = key
       
>>>>>>         sqltype = column.type
       
>>>>>>         if extracted_mapped_annotation is None:
>>>>>>             if sqltype._isnull and not self.column.foreign_keys:
>>>>>>                 self._raise_for_required(key, cls)
                   else:
>>>>>>                 return
       
>>>>>>         self._init_column_for_annotation(
>>>>>>             cls,
>>>>>>             registry,
>>>>>>             extracted_mapped_annotation,
>>>>>>             originating_module,
               )
       
    1:     @util.preload_module("sqlalchemy.orm.decl_base")
    1:     def declarative_scan_for_composite(
               self,
               registry: _RegistryType,
               cls: Type[Any],
               originating_module: Optional[str],
               key: str,
               param_name: str,
               param_annotation: _AnnotationScanType,
           ) -> None:
>>>>>>         decl_base = util.preloaded.orm_decl_base
>>>>>>         decl_base._undefer_column_name(param_name, self.column)
>>>>>>         self._init_column_for_annotation(
>>>>>>             cls, registry, param_annotation, originating_module
               )
       
    1:     def _init_column_for_annotation(
               self,
               cls: Type[Any],
               registry: _RegistryType,
               argument: _AnnotationScanType,
               originating_module: Optional[str],
           ) -> None:
>>>>>>         sqltype = self.column.type
       
>>>>>>         if isinstance(argument, str) or is_fwd_ref(
>>>>>>             argument, check_generic=True
               ):
>>>>>>             assert originating_module is not None
>>>>>>             argument = de_stringify_annotation(
>>>>>>                 cls, argument, originating_module, include_generic=True
                   )
       
>>>>>>         if is_union(argument):
>>>>>>             assert originating_module is not None
>>>>>>             argument = de_stringify_union_elements(
>>>>>>                 cls, argument, originating_module
                   )
       
>>>>>>         nullable = is_optional_union(argument)
       
>>>>>>         if not self._has_nullable:
>>>>>>             self.column.nullable = nullable
       
>>>>>>         our_type = de_optionalize_union_types(argument)
       
>>>>>>         use_args_from = None
       
>>>>>>         if is_pep593(our_type):
>>>>>>             our_type_is_pep593 = True
       
>>>>>>             pep_593_components = typing_get_args(our_type)
>>>>>>             raw_pep_593_type = pep_593_components[0]
>>>>>>             if is_optional_union(raw_pep_593_type):
>>>>>>                 raw_pep_593_type = de_optionalize_union_types(raw_pep_593_type)
       
>>>>>>                 nullable = True
>>>>>>                 if not self._has_nullable:
>>>>>>                     self.column.nullable = nullable
>>>>>>             for elem in pep_593_components[1:]:
>>>>>>                 if isinstance(elem, MappedColumn):
>>>>>>                     use_args_from = elem
>>>>>>                     break
               else:
>>>>>>             our_type_is_pep593 = False
>>>>>>             raw_pep_593_type = None
       
>>>>>>         if use_args_from is not None:
>>>>>>             if (
>>>>>>                 not self._has_insert_default
>>>>>>                 and use_args_from.column.default is not None
                   ):
>>>>>>                 self.column.default = None
       
>>>>>>             use_args_from.column._merge(self.column)
>>>>>>             sqltype = self.column.type
       
>>>>>>             if (
>>>>>>                 use_args_from.deferred is not _NoArg.NO_ARG
>>>>>>                 and self.deferred is _NoArg.NO_ARG
                   ):
>>>>>>                 self.deferred = use_args_from.deferred
       
>>>>>>             if (
>>>>>>                 use_args_from.deferred_group is not None
>>>>>>                 and self.deferred_group is None
                   ):
>>>>>>                 self.deferred_group = use_args_from.deferred_group
       
>>>>>>             if (
>>>>>>                 use_args_from.deferred_raiseload is not None
>>>>>>                 and self.deferred_raiseload is None
                   ):
>>>>>>                 self.deferred_raiseload = use_args_from.deferred_raiseload
       
>>>>>>             if (
>>>>>>                 use_args_from._use_existing_column
>>>>>>                 and not self._use_existing_column
                   ):
>>>>>>                 self._use_existing_column = True
       
>>>>>>             if use_args_from.active_history:
>>>>>>                 self.active_history = use_args_from.active_history
       
>>>>>>             if (
>>>>>>                 use_args_from._sort_order is not None
>>>>>>                 and self._sort_order is _NoArg.NO_ARG
                   ):
>>>>>>                 self._sort_order = use_args_from._sort_order
       
>>>>>>             if (
>>>>>>                 use_args_from.column.key is not None
>>>>>>                 or use_args_from.column.name is not None
                   ):
>>>>>>                 util.warn_deprecated(
>>>>>>                     "Can't use the 'key' or 'name' arguments in "
                           "Annotated with mapped_column(); this will be ignored",
>>>>>>                     "2.0.22",
                       )
       
>>>>>>             if use_args_from._has_dataclass_arguments:
>>>>>>                 for idx, arg in enumerate(
>>>>>>                     use_args_from._attribute_options._fields
                       ):
>>>>>>                     if (
>>>>>>                         use_args_from._attribute_options[idx]
>>>>>>                         is not _NoArg.NO_ARG
                           ):
>>>>>>                         arg = arg.replace("dataclasses_", "")
>>>>>>                         util.warn_deprecated(
>>>>>>                             f"Argument '{arg}' is a dataclass argument and "
                                   "cannot be specified within a mapped_column() "
                                   "bundled inside of an Annotated object",
>>>>>>                             "2.0.22",
                               )
       
>>>>>>         if sqltype._isnull and not self.column.foreign_keys:
>>>>>>             new_sqltype = None
       
>>>>>>             if our_type_is_pep593:
>>>>>>                 checks = [our_type, raw_pep_593_type]
                   else:
>>>>>>                 checks = [our_type]
       
>>>>>>             for check_type in checks:
>>>>>>                 new_sqltype = registry._resolve_type(check_type)
>>>>>>                 if new_sqltype is not None:
>>>>>>                     break
                   else:
>>>>>>                 if isinstance(our_type, TypeEngine) or (
>>>>>>                     isinstance(our_type, type)
>>>>>>                     and issubclass(our_type, TypeEngine)
                       ):
>>>>>>                     raise sa_exc.ArgumentError(
>>>>>>                         f"The type provided inside the {self.column.key!r} "
                               "attribute Mapped annotation is the SQLAlchemy type "
>>>>>>                         f"{our_type}. Expected a Python type instead"
                           )
                       else:
>>>>>>                     raise sa_exc.ArgumentError(
>>>>>>                         "Could not locate SQLAlchemy Core type for Python "
>>>>>>                         f"type {our_type} inside the {self.column.key!r} "
                               "attribute Mapped annotation"
                           )
       
>>>>>>             self.column._set_type(new_sqltype)
