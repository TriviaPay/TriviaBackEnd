       # engine/row.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       
    1: """Define row constructs including :class:`.Row`."""
       
    1: from __future__ import annotations
       
    1: from abc import ABC
    1: import collections.abc as collections_abc
    1: import operator
    1: import typing
    1: from typing import Any
    1: from typing import Callable
    1: from typing import Dict
    1: from typing import Generic
    1: from typing import Iterator
    1: from typing import List
    1: from typing import Mapping
    1: from typing import NoReturn
    1: from typing import Optional
    1: from typing import overload
    1: from typing import Sequence
    1: from typing import Tuple
    1: from typing import TYPE_CHECKING
    1: from typing import TypeVar
    1: from typing import Union
       
    1: from ..sql import util as sql_util
    1: from ..util import deprecated
    1: from ..util._has_cy import HAS_CYEXTENSION
       
    1: if TYPE_CHECKING or not HAS_CYEXTENSION:
>>>>>>     from ._py_row import BaseRow as BaseRow
       else:
    1:     from sqlalchemy.cyextension.resultproxy import BaseRow as BaseRow
       
    1: if TYPE_CHECKING:
>>>>>>     from .result import _KeyType
>>>>>>     from .result import _ProcessorsType
>>>>>>     from .result import RMKeyView
       
    1: _T = TypeVar("_T", bound=Any)
    1: _TP = TypeVar("_TP", bound=Tuple[Any, ...])
       
       
    2: class Row(BaseRow, Sequence[Any], Generic[_TP]):
    1:     """Represent a single result row.
       
           The :class:`.Row` object represents a row of a database result.  It is
           typically associated in the 1.x series of SQLAlchemy with the
           :class:`_engine.CursorResult` object, however is also used by the ORM for
           tuple-like results as of SQLAlchemy 1.4.
       
           The :class:`.Row` object seeks to act as much like a Python named
           tuple as possible.   For mapping (i.e. dictionary) behavior on a row,
           such as testing for containment of keys, refer to the :attr:`.Row._mapping`
           attribute.
       
           .. seealso::
       
               :ref:`tutorial_selecting_data` - includes examples of selecting
               rows from SELECT statements.
       
           .. versionchanged:: 1.4
       
               Renamed ``RowProxy`` to :class:`.Row`. :class:`.Row` is no longer a
               "proxy" object in that it contains the final form of data within it,
               and now acts mostly like a named tuple. Mapping-like functionality is
               moved to the :attr:`.Row._mapping` attribute. See
               :ref:`change_4710_core` for background on this change.
       
           """
       
    1:     __slots__ = ()
       
    1:     def __setattr__(self, name: str, value: Any) -> NoReturn:
>>>>>>         raise AttributeError("can't set attribute")
       
    1:     def __delattr__(self, name: str) -> NoReturn:
>>>>>>         raise AttributeError("can't delete attribute")
       
    1:     def _tuple(self) -> _TP:
               """Return a 'tuple' form of this :class:`.Row`.
       
               At runtime, this method returns "self"; the :class:`.Row` object is
               already a named tuple. However, at the typing level, if this
               :class:`.Row` is typed, the "tuple" return type will be a :pep:`484`
               ``Tuple`` datatype that contains typing information about individual
               elements, supporting typed unpacking and attribute access.
       
               .. versionadded:: 2.0.19 - The :meth:`.Row._tuple` method supersedes
                  the previous :meth:`.Row.tuple` method, which is now underscored
                  to avoid name conflicts with column names in the same way as other
                  named-tuple methods on :class:`.Row`.
       
               .. seealso::
       
                   :attr:`.Row._t` - shorthand attribute notation
       
                   :meth:`.Result.tuples`
       
       
               """
>>>>>>         return self  # type: ignore
       
    2:     @deprecated(
    1:         "2.0.19",
    1:         "The :meth:`.Row.tuple` method is deprecated in favor of "
               ":meth:`.Row._tuple`; all :class:`.Row` "
               "methods and library-level attributes are intended to be underscored "
               "to avoid name conflicts.  Please use :meth:`Row._tuple`.",
           )
    1:     def tuple(self) -> _TP:
               """Return a 'tuple' form of this :class:`.Row`.
       
               .. versionadded:: 2.0
       
               """
>>>>>>         return self._tuple()
       
    1:     @property
    1:     def _t(self) -> _TP:
               """A synonym for :meth:`.Row._tuple`.
       
               .. versionadded:: 2.0.19 - The :attr:`.Row._t` attribute supersedes
                  the previous :attr:`.Row.t` attribute, which is now underscored
                  to avoid name conflicts with column names in the same way as other
                  named-tuple methods on :class:`.Row`.
       
               .. seealso::
       
                   :attr:`.Result.t`
               """
>>>>>>         return self  # type: ignore
       
    1:     @property
    2:     @deprecated(
    1:         "2.0.19",
    1:         "The :attr:`.Row.t` attribute is deprecated in favor of "
               ":attr:`.Row._t`; all :class:`.Row` "
               "methods and library-level attributes are intended to be underscored "
               "to avoid name conflicts.  Please use :attr:`Row._t`.",
           )
    1:     def t(self) -> _TP:
               """A synonym for :meth:`.Row._tuple`.
       
               .. versionadded:: 2.0
       
               """
>>>>>>         return self._t
       
    1:     @property
    1:     def _mapping(self) -> RowMapping:
               """Return a :class:`.RowMapping` for this :class:`.Row`.
       
               This object provides a consistent Python mapping (i.e. dictionary)
               interface for the data contained within the row.   The :class:`.Row`
               by itself behaves like a named tuple.
       
               .. seealso::
       
                   :attr:`.Row._fields`
       
               .. versionadded:: 1.4
       
               """
>>>>>>         return RowMapping(self._parent, None, self._key_to_index, self._data)
       
    1:     def _filter_on_values(
               self, processor: Optional[_ProcessorsType]
           ) -> Row[Any]:
>>>>>>         return Row(self._parent, processor, self._key_to_index, self._data)
       
    1:     if not TYPE_CHECKING:
       
    1:         def _special_name_accessor(name: str) -> Any:
                   """Handle ambiguous names such as "count" and "index" """
       
    2:             @property
    2:             def go(self: Row) -> Any:
>>>>>>                 if self._parent._has_key(name):
>>>>>>                     return self.__getattr__(name)
                       else:
       
>>>>>>                     def meth(*arg: Any, **kw: Any) -> Any:
>>>>>>                         return getattr(collections_abc.Sequence, name)(
>>>>>>                             self, *arg, **kw
                               )
       
>>>>>>                     return meth
       
    2:             return go
       
    1:         count = _special_name_accessor("count")
    1:         index = _special_name_accessor("index")
       
    1:     def __contains__(self, key: Any) -> bool:
>>>>>>         return key in self._data
       
    1:     def _op(self, other: Any, op: Callable[[Any, Any], bool]) -> bool:
>>>>>>         return (
>>>>>>             op(self._to_tuple_instance(), other._to_tuple_instance())
>>>>>>             if isinstance(other, Row)
>>>>>>             else op(self._to_tuple_instance(), other)
               )
       
    1:     __hash__ = BaseRow.__hash__
       
    1:     if TYPE_CHECKING:
       
>>>>>>         @overload
>>>>>>         def __getitem__(self, index: int) -> Any: ...
       
>>>>>>         @overload
>>>>>>         def __getitem__(self, index: slice) -> Sequence[Any]: ...
       
>>>>>>         def __getitem__(self, index: Union[int, slice]) -> Any: ...
       
    1:     def __lt__(self, other: Any) -> bool:
>>>>>>         return self._op(other, operator.lt)
       
    1:     def __le__(self, other: Any) -> bool:
>>>>>>         return self._op(other, operator.le)
       
    1:     def __ge__(self, other: Any) -> bool:
>>>>>>         return self._op(other, operator.ge)
       
    1:     def __gt__(self, other: Any) -> bool:
>>>>>>         return self._op(other, operator.gt)
       
    1:     def __eq__(self, other: Any) -> bool:
>>>>>>         return self._op(other, operator.eq)
       
    1:     def __ne__(self, other: Any) -> bool:
>>>>>>         return self._op(other, operator.ne)
       
    1:     def __repr__(self) -> str:
>>>>>>         return repr(sql_util._repr_row(self))
       
    1:     @property
    1:     def _fields(self) -> Tuple[str, ...]:
               """Return a tuple of string keys as represented by this
               :class:`.Row`.
       
               The keys can represent the labels of the columns returned by a core
               statement or the names of the orm classes returned by an orm
               execution.
       
               This attribute is analogous to the Python named tuple ``._fields``
               attribute.
       
               .. versionadded:: 1.4
       
               .. seealso::
       
                   :attr:`.Row._mapping`
       
               """
>>>>>>         return tuple([k for k in self._parent.keys if k is not None])
       
    1:     def _asdict(self) -> Dict[str, Any]:
               """Return a new dict which maps field names to their corresponding
               values.
       
               This method is analogous to the Python named tuple ``._asdict()``
               method, and works by applying the ``dict()`` constructor to the
               :attr:`.Row._mapping` attribute.
       
               .. versionadded:: 1.4
       
               .. seealso::
       
                   :attr:`.Row._mapping`
       
               """
>>>>>>         return dict(self._mapping)
       
       
    1: BaseRowProxy = BaseRow
    1: RowProxy = Row
       
       
    2: class ROMappingView(ABC):
    1:     __slots__ = ()
       
    1:     _items: Sequence[Any]
    1:     _mapping: Mapping["_KeyType", Any]
       
    1:     def __init__(
               self, mapping: Mapping["_KeyType", Any], items: Sequence[Any]
           ):
>>>>>>         self._mapping = mapping  # type: ignore[misc]
>>>>>>         self._items = items  # type: ignore[misc]
       
    1:     def __len__(self) -> int:
>>>>>>         return len(self._items)
       
    1:     def __repr__(self) -> str:
>>>>>>         return "{0.__class__.__name__}({0._mapping!r})".format(self)
       
    1:     def __iter__(self) -> Iterator[Any]:
>>>>>>         return iter(self._items)
       
    1:     def __contains__(self, item: Any) -> bool:
>>>>>>         return item in self._items
       
    1:     def __eq__(self, other: Any) -> bool:
>>>>>>         return list(other) == list(self)
       
    1:     def __ne__(self, other: Any) -> bool:
>>>>>>         return list(other) != list(self)
       
       
    3: class ROMappingKeysValuesView(
    1:     ROMappingView, typing.KeysView["_KeyType"], typing.ValuesView[Any]
       ):
    1:     __slots__ = ("_items",)  # mapping slot is provided by KeysView
       
       
    2: class ROMappingItemsView(ROMappingView, typing.ItemsView["_KeyType", Any]):
    1:     __slots__ = ("_items",)  # mapping slot is provided by ItemsView
       
       
    2: class RowMapping(BaseRow, typing.Mapping["_KeyType", Any]):
    1:     """A ``Mapping`` that maps column names and objects to :class:`.Row`
           values.
       
           The :class:`.RowMapping` is available from a :class:`.Row` via the
           :attr:`.Row._mapping` attribute, as well as from the iterable interface
           provided by the :class:`.MappingResult` object returned by the
           :meth:`_engine.Result.mappings` method.
       
           :class:`.RowMapping` supplies Python mapping (i.e. dictionary) access to
           the  contents of the row.   This includes support for testing of
           containment of specific keys (string column names or objects), as well
           as iteration of keys, values, and items::
       
               for row in result:
                   if 'a' in row._mapping:
                       print("Column 'a': %s" % row._mapping['a'])
       
                   print("Column b: %s" % row._mapping[table.c.b])
       
       
           .. versionadded:: 1.4 The :class:`.RowMapping` object replaces the
              mapping-like access previously provided by a database result row,
              which now seeks to behave mostly like a named tuple.
       
           """
       
    1:     __slots__ = ()
       
    1:     if TYPE_CHECKING:
       
>>>>>>         def __getitem__(self, key: _KeyType) -> Any: ...
       
           else:
    1:         __getitem__ = BaseRow._get_by_key_impl_mapping
       
    1:     def _values_impl(self) -> List[Any]:
>>>>>>         return list(self._data)
       
    1:     def __iter__(self) -> Iterator[str]:
>>>>>>         return (k for k in self._parent.keys if k is not None)
       
    1:     def __len__(self) -> int:
>>>>>>         return len(self._data)
       
    1:     def __contains__(self, key: object) -> bool:
>>>>>>         return self._parent._has_key(key)
       
    1:     def __repr__(self) -> str:
>>>>>>         return repr(dict(self))
       
    1:     def items(self) -> ROMappingItemsView:
               """Return a view of key/value tuples for the elements in the
               underlying :class:`.Row`.
       
               """
>>>>>>         return ROMappingItemsView(
>>>>>>             self, [(key, self[key]) for key in self.keys()]
               )
       
    1:     def keys(self) -> RMKeyView:
               """Return a view of 'keys' for string column names represented
               by the underlying :class:`.Row`.
       
               """
       
>>>>>>         return self._parent.keys
       
    1:     def values(self) -> ROMappingKeysValuesView:
               """Return a view of values for the values represented in the
               underlying :class:`.Row`.
       
               """
>>>>>>         return ROMappingKeysValuesView(self, self._values_impl())
