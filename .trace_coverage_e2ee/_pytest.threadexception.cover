    1: from __future__ import annotations
       
    1: import threading
    1: import traceback
    1: from types import TracebackType
    1: from typing import Any
    1: from typing import Callable
    1: from typing import Generator
    1: from typing import TYPE_CHECKING
    1: import warnings
       
    1: import pytest
       
       
    1: if TYPE_CHECKING:
>>>>>>     from typing_extensions import Self
       
       
       # Copied from cpython/Lib/test/support/threading_helper.py, with modifications.
    2: class catch_threading_exception:
    1:     """Context manager catching threading.Thread exception using
           threading.excepthook.
       
           Storing exc_value using a custom hook can create a reference cycle. The
           reference cycle is broken explicitly when the context manager exits.
       
           Storing thread using a custom hook can resurrect it if it is set to an
           object which is being finalized. Exiting the context manager clears the
           stored object.
       
           Usage:
               with threading_helper.catch_threading_exception() as cm:
                   # code spawning a thread which raises an exception
                   ...
                   # check the thread exception: use cm.args
                   ...
               # cm.args attribute no longer exists at this point
               # (to break a reference cycle)
           """
       
    1:     def __init__(self) -> None:
   48:         self.args: threading.ExceptHookArgs | None = None
   48:         self._old_hook: Callable[[threading.ExceptHookArgs], Any] | None = None
       
    1:     def _hook(self, args: threading.ExceptHookArgs) -> None:
>>>>>>         self.args = args
       
    1:     def __enter__(self) -> Self:
   48:         self._old_hook = threading.excepthook
   48:         threading.excepthook = self._hook
   48:         return self
       
    1:     def __exit__(
               self,
               exc_type: type[BaseException] | None,
               exc_val: BaseException | None,
               exc_tb: TracebackType | None,
           ) -> None:
   48:         assert self._old_hook is not None
   48:         threading.excepthook = self._old_hook
   48:         self._old_hook = None
   48:         del self.args
       
       
    1: def thread_exception_runtest_hook() -> Generator[None]:
   48:     with catch_threading_exception() as cm:
   48:         try:
   48:             yield
               finally:
   48:             if cm.args:
>>>>>>                 thread_name = (
>>>>>>                     "<unknown>" if cm.args.thread is None else cm.args.thread.name
                       )
>>>>>>                 msg = f"Exception in thread {thread_name}\n\n"
>>>>>>                 msg += "".join(
>>>>>>                     traceback.format_exception(
>>>>>>                         cm.args.exc_type,
>>>>>>                         cm.args.exc_value,
>>>>>>                         cm.args.exc_traceback,
                           )
                       )
>>>>>>                 warnings.warn(pytest.PytestUnhandledThreadExceptionWarning(msg))
       
       
    1: @pytest.hookimpl(wrapper=True, trylast=True)
    1: def pytest_runtest_setup() -> Generator[None]:
   16:     yield from thread_exception_runtest_hook()
       
       
    1: @pytest.hookimpl(wrapper=True, tryfirst=True)
    1: def pytest_runtest_call() -> Generator[None]:
   16:     yield from thread_exception_runtest_hook()
       
       
    1: @pytest.hookimpl(wrapper=True, tryfirst=True)
    1: def pytest_runtest_teardown() -> Generator[None]:
   16:     yield from thread_exception_runtest_hook()
