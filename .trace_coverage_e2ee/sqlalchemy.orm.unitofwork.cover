       # orm/unitofwork.py
       # Copyright (C) 2005-2024 the SQLAlchemy authors and contributors
       # <see AUTHORS file>
       #
       # This module is part of SQLAlchemy and is released under
       # the MIT License: https://www.opensource.org/licenses/mit-license.php
       # mypy: ignore-errors
       
       
    1: """The internals for the unit of work system.
       
       The session's flush() process passes objects to a contextual object
       here, which assembles flush tasks based on mappers and their properties,
       organizes them in order of dependency, and executes.
       
       """
       
    1: from __future__ import annotations
       
    1: from typing import Any
    1: from typing import Dict
    1: from typing import Optional
    1: from typing import Set
    1: from typing import TYPE_CHECKING
       
    1: from . import attributes
    1: from . import exc as orm_exc
    1: from . import util as orm_util
    1: from .. import event
    1: from .. import util
    1: from ..util import topological
       
       
    1: if TYPE_CHECKING:
>>>>>>     from .dependency import DependencyProcessor
>>>>>>     from .interfaces import MapperProperty
>>>>>>     from .mapper import Mapper
>>>>>>     from .session import Session
>>>>>>     from .session import SessionTransaction
>>>>>>     from .state import InstanceState
       
       
    1: def track_cascade_events(descriptor, prop):
           """Establish event listeners on object attributes which handle
           cascade-on-set/append.
       
           """
   97:     key = prop.key
       
   97:     def append(state, item, initiator, **kw):
               # process "save_update" cascade rules for when
               # an instance is appended to the list of another instance
       
>>>>>>         if item is None:
>>>>>>             return
       
>>>>>>         sess = state.session
>>>>>>         if sess:
>>>>>>             if sess._warn_on_events:
>>>>>>                 sess._flush_warning("collection append")
       
>>>>>>             prop = state.manager.mapper._props[key]
>>>>>>             item_state = attributes.instance_state(item)
       
>>>>>>             if (
>>>>>>                 prop._cascade.save_update
>>>>>>                 and (key == initiator.key)
>>>>>>                 and not sess._contains_state(item_state)
                   ):
>>>>>>                 sess._save_or_update_state(item_state)
>>>>>>         return item
       
   97:     def remove(state, item, initiator, **kw):
>>>>>>         if item is None:
>>>>>>             return
       
>>>>>>         sess = state.session
       
>>>>>>         prop = state.manager.mapper._props[key]
       
>>>>>>         if sess and sess._warn_on_events:
>>>>>>             sess._flush_warning(
>>>>>>                 "collection remove"
>>>>>>                 if prop.uselist
>>>>>>                 else "related attribute delete"
                   )
       
>>>>>>         if (
>>>>>>             item is not None
>>>>>>             and item is not attributes.NEVER_SET
>>>>>>             and item is not attributes.PASSIVE_NO_RESULT
>>>>>>             and prop._cascade.delete_orphan
               ):
                   # expunge pending orphans
>>>>>>             item_state = attributes.instance_state(item)
       
>>>>>>             if prop.mapper._is_orphan(item_state):
>>>>>>                 if sess and item_state in sess._new:
>>>>>>                     sess.expunge(item)
                       else:
                           # the related item may or may not itself be in a
                           # Session, however the parent for which we are catching
                           # the event is not in a session, so memoize this on the
                           # item
>>>>>>                     item_state._orphaned_outside_of_session = True
       
   97:     def set_(state, newvalue, oldvalue, initiator, **kw):
               # process "save_update" cascade rules for when an instance
               # is attached to another instance
>>>>>>         if oldvalue is newvalue:
>>>>>>             return newvalue
       
>>>>>>         sess = state.session
>>>>>>         if sess:
>>>>>>             if sess._warn_on_events:
>>>>>>                 sess._flush_warning("related attribute set")
       
>>>>>>             prop = state.manager.mapper._props[key]
>>>>>>             if newvalue is not None:
>>>>>>                 newvalue_state = attributes.instance_state(newvalue)
>>>>>>                 if (
>>>>>>                     prop._cascade.save_update
>>>>>>                     and (key == initiator.key)
>>>>>>                     and not sess._contains_state(newvalue_state)
                       ):
>>>>>>                     sess._save_or_update_state(newvalue_state)
       
>>>>>>             if (
>>>>>>                 oldvalue is not None
>>>>>>                 and oldvalue is not attributes.NEVER_SET
>>>>>>                 and oldvalue is not attributes.PASSIVE_NO_RESULT
>>>>>>                 and prop._cascade.delete_orphan
                   ):
                       # possible to reach here with attributes.NEVER_SET ?
>>>>>>                 oldvalue_state = attributes.instance_state(oldvalue)
       
>>>>>>                 if oldvalue_state in sess._new and prop.mapper._is_orphan(
>>>>>>                     oldvalue_state
                       ):
>>>>>>                     sess.expunge(oldvalue)
>>>>>>         return newvalue
       
  194:     event.listen(
   97:         descriptor, "append_wo_mutation", append, raw=True, include_key=True
           )
  194:     event.listen(
   97:         descriptor, "append", append, raw=True, retval=True, include_key=True
           )
  194:     event.listen(
   97:         descriptor, "remove", remove, raw=True, retval=True, include_key=True
           )
  194:     event.listen(
   97:         descriptor, "set", set_, raw=True, retval=True, include_key=True
           )
       
       
    2: class UOWTransaction:
    1:     session: Session
    1:     transaction: SessionTransaction
    1:     attributes: Dict[str, Any]
    1:     deps: util.defaultdict[Mapper[Any], Set[DependencyProcessor]]
    1:     mappers: util.defaultdict[Mapper[Any], Set[InstanceState[Any]]]
       
    1:     def __init__(self, session: Session):
   43:         self.session = session
       
               # dictionary used by external actors to
               # store arbitrary state information.
   43:         self.attributes = {}
       
               # dictionary of mappers to sets of
               # DependencyProcessors, which are also
               # set to be part of the sorted flush actions,
               # which have that mapper as a parent.
   43:         self.deps = util.defaultdict(set)
       
               # dictionary of mappers to sets of InstanceState
               # items pending for flush which have that mapper
               # as a parent.
   43:         self.mappers = util.defaultdict(set)
       
               # a dictionary of Preprocess objects, which gather
               # additional states impacted by the flush
               # and determine if a flush action is needed
   43:         self.presort_actions = {}
       
               # dictionary of PostSortRec objects, each
               # one issues work during the flush within
               # a certain ordering.
   43:         self.postsort_actions = {}
       
               # a set of 2-tuples, each containing two
               # PostSortRec objects where the second
               # is dependent on the first being executed
               # first
   43:         self.dependencies = set()
       
               # dictionary of InstanceState-> (isdelete, listonly)
               # tuples, indicating if this state is to be deleted
               # or insert/updated, or just refreshed
   43:         self.states = {}
       
               # tracks InstanceStates which will be receiving
               # a "post update" call.  Keys are mappers,
               # values are a set of states and a set of the
               # columns which should be included in the update.
   43:         self.post_update_states = util.defaultdict(lambda: (set(), set()))
       
    1:     @property
    1:     def has_work(self):
   43:         return bool(self.states)
       
    1:     def was_already_deleted(self, state):
               """Return ``True`` if the given state is expired and was deleted
               previously.
               """
>>>>>>         if state.expired:
>>>>>>             try:
>>>>>>                 state._load_expired(state, attributes.PASSIVE_OFF)
>>>>>>             except orm_exc.ObjectDeletedError:
>>>>>>                 self.session._remove_newly_deleted([state])
>>>>>>                 return True
>>>>>>         return False
       
    1:     def is_deleted(self, state):
               """Return ``True`` if the given state is marked as deleted
               within this uowtransaction."""
       
>>>>>>         return state in self.states and self.states[state][0]
       
    1:     def memo(self, key, callable_):
  544:         if key in self.attributes:
>>>>>>             return self.attributes[key]
               else:
  544:             self.attributes[key] = ret = callable_()
  544:             return ret
       
    1:     def remove_state_actions(self, state):
               """Remove pending actions for a state from the uowtransaction."""
       
>>>>>>         isdelete = self.states[state][0]
       
>>>>>>         self.states[state] = (isdelete, True)
       
    1:     def get_attribute_history(
    1:         self, state, key, passive=attributes.PASSIVE_NO_INITIALIZE
           ):
               """Facade to attributes.get_state_history(), including
               caching of results."""
       
 3108:         hashkey = ("history", state, key)
       
               # cache the objects, not the states; the strong reference here
               # prevents newly loaded objects from being dereferenced during the
               # flush process
       
 3108:         if hashkey in self.attributes:
 2016:             history, state_history, cached_passive = self.attributes[hashkey]
                   # if the cached lookup was "passive" and now
                   # we want non-passive, do a non-passive lookup and re-cache
       
 2016:             if (
 2016:                 not cached_passive & attributes.SQL_OK
>>>>>>                 and passive & attributes.SQL_OK
                   ):
>>>>>>                 impl = state.manager[key].impl
>>>>>>                 history = impl.get_history(
>>>>>>                     state,
>>>>>>                     state.dict,
>>>>>>                     attributes.PASSIVE_OFF
>>>>>>                     | attributes.LOAD_AGAINST_COMMITTED
>>>>>>                     | attributes.NO_RAISE,
                       )
>>>>>>                 if history and impl.uses_objects:
>>>>>>                     state_history = history.as_state()
                       else:
>>>>>>                     state_history = history
>>>>>>                 self.attributes[hashkey] = (history, state_history, passive)
               else:
 1092:             impl = state.manager[key].impl
                   # TODO: store the history as (state, object) tuples
                   # so we don't have to keep converting here
 2184:             history = impl.get_history(
 1092:                 state,
 1092:                 state.dict,
 3276:                 passive
 1092:                 | attributes.LOAD_AGAINST_COMMITTED
 1092:                 | attributes.NO_RAISE,
                   )
 1092:             if history and impl.uses_objects:
>>>>>>                 state_history = history.as_state()
                   else:
 1092:                 state_history = history
 1092:             self.attributes[hashkey] = (history, state_history, passive)
       
 3108:         return state_history
       
    1:     def has_dep(self, processor):
>>>>>>         return (processor, True) in self.presort_actions
       
    1:     def register_preprocessor(self, processor, fromparent):
  564:         key = (processor, fromparent)
  564:         if key not in self.presort_actions:
  564:             self.presort_actions[key] = Preprocess(processor, fromparent)
       
    1:     def register_object(
               self,
               state: InstanceState[Any],
               isdelete: bool = False,
               listonly: bool = False,
               cancel_delete: bool = False,
               operation: Optional[str] = None,
               prop: Optional[MapperProperty] = None,
           ) -> bool:
  119:         if not self.session._contains_state(state):
                   # this condition is normal when objects are registered
                   # as part of a relationship cascade operation.  it should
                   # not occur for the top-level register from Session.flush().
>>>>>>             if not state.deleted and operation is not None:
>>>>>>                 util.warn(
>>>>>>                     "Object of type %s not in session, %s operation "
                           "along '%s' will not proceed"
>>>>>>                     % (orm_util.state_class_str(state), operation, prop)
                       )
>>>>>>             return False
       
  119:         if state not in self.states:
   83:             mapper = state.manager.mapper
       
   83:             if mapper not in self.mappers:
   65:                 self._per_mapper_flush_actions(mapper)
       
   83:             self.mappers[mapper].add(state)
   83:             self.states[state] = (isdelete, listonly)
               else:
   36:             if not listonly and (isdelete or cancel_delete):
>>>>>>                 self.states[state] = (isdelete, False)
  119:         return True
       
    1:     def register_post_update(self, state, post_update_cols):
>>>>>>         mapper = state.manager.mapper.base_mapper
>>>>>>         states, cols = self.post_update_states[mapper]
>>>>>>         states.add(state)
>>>>>>         cols.update(post_update_cols)
       
    1:     def _per_mapper_flush_actions(self, mapper):
   65:         saves = SaveUpdateAll(self, mapper.base_mapper)
   65:         deletes = DeleteAll(self, mapper.base_mapper)
   65:         self.dependencies.add((saves, deletes))
       
  609:         for dep in mapper._dependency_processors:
  544:             dep.per_property_preprocessors(self)
       
  597:         for prop in mapper.relationships:
  532:             if prop.viewonly:
>>>>>>                 continue
  532:             dep = prop._dependency_processor
  532:             dep.per_property_preprocessors(self)
       
    1:     @util.memoized_property
    1:     def _mapper_for_dep(self):
               """return a dynamic mapping of (Mapper, DependencyProcessor) to
               True or False, indicating if the DependencyProcessor operates
               on objects of that Mapper.
       
               The result is stored in the dictionary persistently once
               calculated.
       
               """
   36:         return util.PopulateDict(
  550:             lambda tup: tup[0]._props.get(tup[1].key) is tup[1].prop
               )
       
    1:     def filter_states_for_dep(self, dep, states):
               """Filter the given list of InstanceStates to those relevant to the
               given DependencyProcessor.
       
               """
>>>>>>         mapper_for_dep = self._mapper_for_dep
>>>>>>         return [s for s in states if mapper_for_dep[(s.manager.mapper, dep)]]
       
    1:     def states_for_mapper_hierarchy(self, mapper, isdelete, listonly):
  130:         checktup = (isdelete, listonly)
  260:         for mapper in mapper.base_mapper.self_and_descendants:
  296:             for state in self.mappers[mapper]:
  166:                 if self.states[state] == checktup:
   83:                     yield state
       
    1:     def _generate_actions(self):
               """Generate the full, unsorted collection of PostSortRecs as
               well as dependency pairs for this UOWTransaction.
       
               """
               # execute presort_actions, until all states
               # have been processed.   a presort_action might
               # add new states to the uow.
               while True:
   61:             ret = False
 1189:             for action in list(self.presort_actions.values()):
 1128:                 if action.execute(self):
  564:                     ret = True
   61:             if not ret:
   43:                 break
       
               # see if the graph of mapper dependencies has cycles.
   86:         self.cycles = cycles = topological.find_cycles(
   43:             self.dependencies, list(self.postsort_actions.values())
               )
       
   43:         if cycles:
                   # if yes, break the per-mapper actions into
                   # per-state actions
>>>>>>             convert = {
>>>>>>                 rec: set(rec.per_state_flush_actions(self)) for rec in cycles
                   }
       
                   # rewrite the existing dependencies to point to
                   # the per-state actions for those per-mapper actions
                   # that were broken up.
>>>>>>             for edge in list(self.dependencies):
>>>>>>                 if (
>>>>>>                     None in edge
>>>>>>                     or edge[0].disabled
>>>>>>                     or edge[1].disabled
>>>>>>                     or cycles.issuperset(edge)
                       ):
>>>>>>                     self.dependencies.remove(edge)
>>>>>>                 elif edge[0] in cycles:
>>>>>>                     self.dependencies.remove(edge)
>>>>>>                     for dep in convert[edge[0]]:
>>>>>>                         self.dependencies.add((dep, edge[1]))
>>>>>>                 elif edge[1] in cycles:
>>>>>>                     self.dependencies.remove(edge)
>>>>>>                     for dep in convert[edge[1]]:
>>>>>>                         self.dependencies.add((edge[0], dep))
       
  302:         return {
  173:             a for a in self.postsort_actions.values() if not a.disabled
   43:         }.difference(cycles)
       
    1:     def execute(self) -> None:
   43:         postsort_actions = self._generate_actions()
       
   86:         postsort_actions = sorted(
   43:             postsort_actions,
  173:             key=lambda item: item.sort_key,
               )
               # sort = topological.sort(self.dependencies, postsort_actions)
               # print "--------------"
               # print "\ndependencies:", self.dependencies
               # print "\ncycles:", self.cycles
               # print "\nsort:", list(sort)
               # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
       
               # execute
   43:         if self.cycles:
>>>>>>             for subset in topological.sort_as_subsets(
>>>>>>                 self.dependencies, postsort_actions
                   ):
>>>>>>                 set_ = set(subset)
>>>>>>                 while set_:
>>>>>>                     n = set_.pop()
>>>>>>                     n.execute_aggregate(self, set_)
               else:
  173:             for rec in topological.sort(self.dependencies, postsort_actions):
  130:                 rec.execute(self)
       
    1:     def finalize_flush_changes(self) -> None:
               """Mark processed objects as clean / deleted after a successful
               flush().
       
               This method is called within the flush() method after the
               execute() method has succeeded and the transaction has been committed.
       
               """
   43:         if not self.states:
>>>>>>             return
       
   43:         states = set(self.states)
  212:         isdel = {
  126:             s for (s, (isdelete, listonly)) in self.states.items() if isdelete
               }
   43:         other = states.difference(isdel)
   43:         if isdel:
>>>>>>             self.session._remove_newly_deleted(isdel)
   43:         if other:
   43:             self.session._register_persistent(other)
       
       
    2: class IterateMappersMixin:
    1:     __slots__ = ()
       
    1:     def _mappers(self, uow):
 1128:         if self.fromparent:
 4256:             return iter(
 1064:                 m
 2128:                 for m in self.dependency_processor.parent.self_and_descendants
 1064:                 if uow._mapper_for_dep[(m, self.dependency_processor)]
                   )
               else:
   64:             return self.dependency_processor.mapper.self_and_descendants
       
       
    2: class Preprocess(IterateMappersMixin):
    1:     __slots__ = (
               "dependency_processor",
               "fromparent",
               "processed",
               "setup_flush_actions",
           )
       
    1:     def __init__(self, dependency_processor, fromparent):
  564:         self.dependency_processor = dependency_processor
  564:         self.fromparent = fromparent
  564:         self.processed = set()
  564:         self.setup_flush_actions = False
       
    1:     def execute(self, uow):
 1128:         delete_states = set()
 1128:         save_states = set()
       
 2256:         for mapper in self._mappers(uow):
 2252:             for state in uow.mappers[mapper].difference(self.processed):
 1124:                 (isdelete, listonly) = uow.states[state]
 1124:                 if not listonly:
 1124:                     if isdelete:
>>>>>>                         delete_states.add(state)
                           else:
 1124:                         save_states.add(state)
       
 1128:         if delete_states:
>>>>>>             self.dependency_processor.presort_deletes(uow, delete_states)
>>>>>>             self.processed.update(delete_states)
 1128:         if save_states:
  564:             self.dependency_processor.presort_saves(uow, save_states)
  564:             self.processed.update(save_states)
       
 1128:         if delete_states or save_states:
 1692:             if not self.setup_flush_actions and (
 1128:                 self.dependency_processor.prop_has_changes(
  564:                     uow, delete_states, True
                       )
 1128:                 or self.dependency_processor.prop_has_changes(
  564:                     uow, save_states, False
                       )
                   ):
>>>>>>                 self.dependency_processor.per_property_flush_actions(uow)
>>>>>>                 self.setup_flush_actions = True
  564:             return True
               else:
  564:             return False
       
       
    2: class PostSortRec:
    1:     __slots__ = ("disabled",)
       
    1:     def __new__(cls, uow, *args):
  130:         key = (cls,) + args
  130:         if key in uow.postsort_actions:
>>>>>>             return uow.postsort_actions[key]
               else:
  130:             uow.postsort_actions[key] = ret = object.__new__(cls)
  130:             ret.disabled = False
  130:             return ret
       
    1:     def execute_aggregate(self, uow, recs):
>>>>>>         self.execute(uow)
       
       
    2: class ProcessAll(IterateMappersMixin, PostSortRec):
    1:     __slots__ = "dependency_processor", "isdelete", "fromparent", "sort_key"
       
    1:     def __init__(self, uow, dependency_processor, isdelete, fromparent):
>>>>>>         self.dependency_processor = dependency_processor
>>>>>>         self.sort_key = (
>>>>>>             "ProcessAll",
>>>>>>             self.dependency_processor.sort_key,
>>>>>>             isdelete,
               )
>>>>>>         self.isdelete = isdelete
>>>>>>         self.fromparent = fromparent
>>>>>>         uow.deps[dependency_processor.parent.base_mapper].add(
>>>>>>             dependency_processor
               )
       
    1:     def execute(self, uow):
>>>>>>         states = self._elements(uow)
>>>>>>         if self.isdelete:
>>>>>>             self.dependency_processor.process_deletes(uow, states)
               else:
>>>>>>             self.dependency_processor.process_saves(uow, states)
       
    1:     def per_state_flush_actions(self, uow):
               # this is handled by SaveUpdateAll and DeleteAll,
               # since a ProcessAll should unconditionally be pulled
               # into per-state if either the parent/child mappers
               # are part of a cycle
>>>>>>         return iter([])
       
    1:     def __repr__(self):
>>>>>>         return "%s(%s, isdelete=%s)" % (
>>>>>>             self.__class__.__name__,
>>>>>>             self.dependency_processor,
>>>>>>             self.isdelete,
               )
       
    1:     def _elements(self, uow):
>>>>>>         for mapper in self._mappers(uow):
>>>>>>             for state in uow.mappers[mapper]:
>>>>>>                 (isdelete, listonly) = uow.states[state]
>>>>>>                 if isdelete == self.isdelete and not listonly:
>>>>>>                     yield state
       
       
    2: class PostUpdateAll(PostSortRec):
    1:     __slots__ = "mapper", "isdelete", "sort_key"
       
    1:     def __init__(self, uow, mapper, isdelete):
>>>>>>         self.mapper = mapper
>>>>>>         self.isdelete = isdelete
>>>>>>         self.sort_key = ("PostUpdateAll", mapper._sort_key, isdelete)
       
    1:     @util.preload_module("sqlalchemy.orm.persistence")
    1:     def execute(self, uow):
>>>>>>         persistence = util.preloaded.orm_persistence
>>>>>>         states, cols = uow.post_update_states[self.mapper]
>>>>>>         states = [s for s in states if uow.states[s][0] == self.isdelete]
       
>>>>>>         persistence.post_update(self.mapper, states, uow, cols)
       
       
    2: class SaveUpdateAll(PostSortRec):
    1:     __slots__ = ("mapper", "sort_key")
       
    1:     def __init__(self, uow, mapper):
   65:         self.mapper = mapper
   65:         self.sort_key = ("SaveUpdateAll", mapper._sort_key)
   65:         assert mapper is mapper.base_mapper
       
    1:     @util.preload_module("sqlalchemy.orm.persistence")
    1:     def execute(self, uow):
  130:         util.preloaded.orm_persistence.save_obj(
   65:             self.mapper,
   65:             uow.states_for_mapper_hierarchy(self.mapper, False, False),
   65:             uow,
               )
       
    1:     def per_state_flush_actions(self, uow):
>>>>>>         states = list(
>>>>>>             uow.states_for_mapper_hierarchy(self.mapper, False, False)
               )
>>>>>>         base_mapper = self.mapper.base_mapper
>>>>>>         delete_all = DeleteAll(uow, base_mapper)
>>>>>>         for state in states:
                   # keep saves before deletes -
                   # this ensures 'row switch' operations work
>>>>>>             action = SaveUpdateState(uow, state)
>>>>>>             uow.dependencies.add((action, delete_all))
>>>>>>             yield action
       
>>>>>>         for dep in uow.deps[self.mapper]:
>>>>>>             states_for_prop = uow.filter_states_for_dep(dep, states)
>>>>>>             dep.per_state_flush_actions(uow, states_for_prop, False)
       
    1:     def __repr__(self):
>>>>>>         return "%s(%s)" % (self.__class__.__name__, self.mapper)
       
       
    2: class DeleteAll(PostSortRec):
    1:     __slots__ = ("mapper", "sort_key")
       
    1:     def __init__(self, uow, mapper):
   65:         self.mapper = mapper
   65:         self.sort_key = ("DeleteAll", mapper._sort_key)
   65:         assert mapper is mapper.base_mapper
       
    1:     @util.preload_module("sqlalchemy.orm.persistence")
    1:     def execute(self, uow):
  130:         util.preloaded.orm_persistence.delete_obj(
   65:             self.mapper,
   65:             uow.states_for_mapper_hierarchy(self.mapper, True, False),
   65:             uow,
               )
       
    1:     def per_state_flush_actions(self, uow):
>>>>>>         states = list(
>>>>>>             uow.states_for_mapper_hierarchy(self.mapper, True, False)
               )
>>>>>>         base_mapper = self.mapper.base_mapper
>>>>>>         save_all = SaveUpdateAll(uow, base_mapper)
>>>>>>         for state in states:
                   # keep saves before deletes -
                   # this ensures 'row switch' operations work
>>>>>>             action = DeleteState(uow, state)
>>>>>>             uow.dependencies.add((save_all, action))
>>>>>>             yield action
       
>>>>>>         for dep in uow.deps[self.mapper]:
>>>>>>             states_for_prop = uow.filter_states_for_dep(dep, states)
>>>>>>             dep.per_state_flush_actions(uow, states_for_prop, True)
       
    1:     def __repr__(self):
>>>>>>         return "%s(%s)" % (self.__class__.__name__, self.mapper)
       
       
    2: class ProcessState(PostSortRec):
    1:     __slots__ = "dependency_processor", "isdelete", "state", "sort_key"
       
    1:     def __init__(self, uow, dependency_processor, isdelete, state):
>>>>>>         self.dependency_processor = dependency_processor
>>>>>>         self.sort_key = ("ProcessState", dependency_processor.sort_key)
>>>>>>         self.isdelete = isdelete
>>>>>>         self.state = state
       
    1:     def execute_aggregate(self, uow, recs):
>>>>>>         cls_ = self.__class__
>>>>>>         dependency_processor = self.dependency_processor
>>>>>>         isdelete = self.isdelete
>>>>>>         our_recs = [
>>>>>>             r
>>>>>>             for r in recs
>>>>>>             if r.__class__ is cls_
>>>>>>             and r.dependency_processor is dependency_processor
>>>>>>             and r.isdelete is isdelete
               ]
>>>>>>         recs.difference_update(our_recs)
>>>>>>         states = [self.state] + [r.state for r in our_recs]
>>>>>>         if isdelete:
>>>>>>             dependency_processor.process_deletes(uow, states)
               else:
>>>>>>             dependency_processor.process_saves(uow, states)
       
    1:     def __repr__(self):
>>>>>>         return "%s(%s, %s, delete=%s)" % (
>>>>>>             self.__class__.__name__,
>>>>>>             self.dependency_processor,
>>>>>>             orm_util.state_str(self.state),
>>>>>>             self.isdelete,
               )
       
       
    2: class SaveUpdateState(PostSortRec):
    1:     __slots__ = "state", "mapper", "sort_key"
       
    1:     def __init__(self, uow, state):
>>>>>>         self.state = state
>>>>>>         self.mapper = state.mapper.base_mapper
>>>>>>         self.sort_key = ("ProcessState", self.mapper._sort_key)
       
    1:     @util.preload_module("sqlalchemy.orm.persistence")
    1:     def execute_aggregate(self, uow, recs):
>>>>>>         persistence = util.preloaded.orm_persistence
>>>>>>         cls_ = self.__class__
>>>>>>         mapper = self.mapper
>>>>>>         our_recs = [
>>>>>>             r for r in recs if r.__class__ is cls_ and r.mapper is mapper
               ]
>>>>>>         recs.difference_update(our_recs)
>>>>>>         persistence.save_obj(
>>>>>>             mapper, [self.state] + [r.state for r in our_recs], uow
               )
       
    1:     def __repr__(self):
>>>>>>         return "%s(%s)" % (
>>>>>>             self.__class__.__name__,
>>>>>>             orm_util.state_str(self.state),
               )
       
       
    2: class DeleteState(PostSortRec):
    1:     __slots__ = "state", "mapper", "sort_key"
       
    1:     def __init__(self, uow, state):
>>>>>>         self.state = state
>>>>>>         self.mapper = state.mapper.base_mapper
>>>>>>         self.sort_key = ("DeleteState", self.mapper._sort_key)
       
    1:     @util.preload_module("sqlalchemy.orm.persistence")
    1:     def execute_aggregate(self, uow, recs):
>>>>>>         persistence = util.preloaded.orm_persistence
>>>>>>         cls_ = self.__class__
>>>>>>         mapper = self.mapper
>>>>>>         our_recs = [
>>>>>>             r for r in recs if r.__class__ is cls_ and r.mapper is mapper
               ]
>>>>>>         recs.difference_update(our_recs)
>>>>>>         states = [self.state] + [r.state for r in our_recs]
>>>>>>         persistence.delete_obj(
>>>>>>             mapper, [s for s in states if uow.states[s][0]], uow
               )
       
    1:     def __repr__(self):
>>>>>>         return "%s(%s)" % (
>>>>>>             self.__class__.__name__,
>>>>>>             orm_util.state_str(self.state),
               )
