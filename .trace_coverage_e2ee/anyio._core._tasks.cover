    1: from __future__ import annotations
       
    1: import math
    1: from types import TracebackType
    1: from warnings import warn
       
    1: from ..abc._tasks import TaskGroup, TaskStatus
    1: from ._compat import (
           DeprecatedAsyncContextManager,
           DeprecatedAwaitable,
           DeprecatedAwaitableFloat,
       )
    1: from ._eventloop import get_asynclib
       
       
    2: class _IgnoredTaskStatus(TaskStatus[object]):
    1:     def started(self, value: object = None) -> None:
>>>>>>         pass
       
       
    1: TASK_STATUS_IGNORED = _IgnoredTaskStatus()
       
       
    2: class CancelScope(DeprecatedAsyncContextManager["CancelScope"]):
    1:     """
           Wraps a unit of work that can be made separately cancellable.
       
           :param deadline: The time (clock value) when this scope is cancelled automatically
           :param shield: ``True`` to shield the cancel scope from external cancellation
           """
       
    1:     def __new__(
    1:         cls, *, deadline: float = math.inf, shield: bool = False
           ) -> CancelScope:
   81:         return get_asynclib().CancelScope(shield=shield, deadline=deadline)
       
    1:     def cancel(self) -> DeprecatedAwaitable:
               """Cancel this scope immediately."""
>>>>>>         raise NotImplementedError
       
    1:     @property
    1:     def deadline(self) -> float:
               """
               The time (clock value) when this scope is cancelled automatically.
       
               Will be ``float('inf')`` if no timeout has been set.
       
               """
>>>>>>         raise NotImplementedError
       
    1:     @deadline.setter
    1:     def deadline(self, value: float) -> None:
>>>>>>         raise NotImplementedError
       
    1:     @property
    1:     def cancel_called(self) -> bool:
               """``True`` if :meth:`cancel` has been called."""
>>>>>>         raise NotImplementedError
       
    1:     @property
    1:     def shield(self) -> bool:
               """
               ``True`` if this scope is shielded from external cancellation.
       
               While a scope is shielded, it will not receive cancellations from outside.
       
               """
>>>>>>         raise NotImplementedError
       
    1:     @shield.setter
    1:     def shield(self, value: bool) -> None:
>>>>>>         raise NotImplementedError
       
    1:     def __enter__(self) -> CancelScope:
>>>>>>         raise NotImplementedError
       
    1:     def __exit__(
               self,
               exc_type: type[BaseException] | None,
               exc_val: BaseException | None,
               exc_tb: TracebackType | None,
           ) -> bool | None:
>>>>>>         raise NotImplementedError
       
       
    1: def open_cancel_scope(*, shield: bool = False) -> CancelScope:
           """
           Open a cancel scope.
       
           :param shield: ``True`` to shield the cancel scope from external cancellation
           :return: a cancel scope
       
           .. deprecated:: 3.0
              Use :class:`~CancelScope` directly.
       
           """
>>>>>>     warn(
>>>>>>         "open_cancel_scope() is deprecated -- use CancelScope() directly",
>>>>>>         DeprecationWarning,
           )
>>>>>>     return get_asynclib().CancelScope(shield=shield)
       
       
    2: class FailAfterContextManager(DeprecatedAsyncContextManager[CancelScope]):
    1:     def __init__(self, cancel_scope: CancelScope):
>>>>>>         self._cancel_scope = cancel_scope
       
    1:     def __enter__(self) -> CancelScope:
>>>>>>         return self._cancel_scope.__enter__()
       
    1:     def __exit__(
               self,
               exc_type: type[BaseException] | None,
               exc_val: BaseException | None,
               exc_tb: TracebackType | None,
           ) -> bool | None:
>>>>>>         retval = self._cancel_scope.__exit__(exc_type, exc_val, exc_tb)
>>>>>>         if self._cancel_scope.cancel_called:
>>>>>>             raise TimeoutError
       
>>>>>>         return retval
       
       
    1: def fail_after(delay: float | None, shield: bool = False) -> FailAfterContextManager:
           """
           Create a context manager which raises a :class:`TimeoutError` if does not finish in time.
       
           :param delay: maximum allowed time (in seconds) before raising the exception, or ``None`` to
               disable the timeout
           :param shield: ``True`` to shield the cancel scope from external cancellation
           :return: a context manager that yields a cancel scope
           :rtype: :class:`~typing.ContextManager`\\[:class:`~anyio.CancelScope`\\]
       
           """
>>>>>>     deadline = (
>>>>>>         (get_asynclib().current_time() + delay) if delay is not None else math.inf
           )
>>>>>>     cancel_scope = get_asynclib().CancelScope(deadline=deadline, shield=shield)
>>>>>>     return FailAfterContextManager(cancel_scope)
       
       
    1: def move_on_after(delay: float | None, shield: bool = False) -> CancelScope:
           """
           Create a cancel scope with a deadline that expires after the given delay.
       
           :param delay: maximum allowed time (in seconds) before exiting the context block, or ``None``
               to disable the timeout
           :param shield: ``True`` to shield the cancel scope from external cancellation
           :return: a cancel scope
       
           """
>>>>>>     deadline = (
>>>>>>         (get_asynclib().current_time() + delay) if delay is not None else math.inf
           )
>>>>>>     return get_asynclib().CancelScope(deadline=deadline, shield=shield)
       
       
    1: def current_effective_deadline() -> DeprecatedAwaitableFloat:
           """
           Return the nearest deadline among all the cancel scopes effective for the current task.
       
           :return: a clock value from the event loop's internal clock (or ``float('inf')`` if
               there is no deadline in effect, or ``float('-inf')`` if the current scope has
               been cancelled)
           :rtype: float
       
           """
>>>>>>     return DeprecatedAwaitableFloat(
>>>>>>         get_asynclib().current_effective_deadline(), current_effective_deadline
           )
       
       
    1: def create_task_group() -> TaskGroup:
           """
           Create a task group.
       
           :return: a task group
       
           """
   32:     return get_asynclib().TaskGroup()
