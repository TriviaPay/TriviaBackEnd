    1: import threading
    1: from types import TracebackType
    1: from typing import Optional, Type
       
    1: import sniffio
       
    1: from ._exceptions import ExceptionMapping, PoolTimeout, map_exceptions
       
       # Our async synchronization primatives use either 'anyio' or 'trio' depending
       # on if they're running under asyncio or trio.
       
    1: try:
    1:     import trio
    1: except ImportError:  # pragma: nocover
    1:     trio = None  # type: ignore
       
    1: try:
    1:     import anyio
>>>>>> except ImportError:  # pragma: nocover
>>>>>>     anyio = None  # type: ignore
       
       
    2: class AsyncLock:
    1:     def __init__(self) -> None:
>>>>>>         self._backend = ""
       
    1:     def setup(self) -> None:
               """
               Detect if we're running under 'asyncio' or 'trio' and create
               a lock with the correct implementation.
               """
>>>>>>         self._backend = sniffio.current_async_library()
>>>>>>         if self._backend == "trio":
>>>>>>             if trio is None:  # pragma: nocover
>>>>>>                 raise RuntimeError(
>>>>>>                     "Running under trio, requires the 'trio' package to be installed."
                       )
>>>>>>             self._trio_lock = trio.Lock()
               else:
>>>>>>             if anyio is None:  # pragma: nocover
>>>>>>                 raise RuntimeError(
>>>>>>                     "Running under asyncio requires the 'anyio' package to be installed."
                       )
>>>>>>             self._anyio_lock = anyio.Lock()
       
    1:     async def __aenter__(self) -> "AsyncLock":
>>>>>>         if not self._backend:
>>>>>>             self.setup()
       
>>>>>>         if self._backend == "trio":
>>>>>>             await self._trio_lock.acquire()
               else:
>>>>>>             await self._anyio_lock.acquire()
       
>>>>>>         return self
       
    2:     async def __aexit__(
               self,
    1:         exc_type: Optional[Type[BaseException]] = None,
    1:         exc_value: Optional[BaseException] = None,
    1:         traceback: Optional[TracebackType] = None,
    1:     ) -> None:
>>>>>>         if self._backend == "trio":
>>>>>>             self._trio_lock.release()
               else:
>>>>>>             self._anyio_lock.release()
       
       
    2: class AsyncEvent:
    1:     def __init__(self) -> None:
>>>>>>         self._backend = ""
       
    1:     def setup(self) -> None:
               """
               Detect if we're running under 'asyncio' or 'trio' and create
               a lock with the correct implementation.
               """
>>>>>>         self._backend = sniffio.current_async_library()
>>>>>>         if self._backend == "trio":
>>>>>>             if trio is None:  # pragma: nocover
>>>>>>                 raise RuntimeError(
>>>>>>                     "Running under trio requires the 'trio' package to be installed."
                       )
>>>>>>             self._trio_event = trio.Event()
               else:
>>>>>>             if anyio is None:  # pragma: nocover
>>>>>>                 raise RuntimeError(
>>>>>>                     "Running under asyncio requires the 'anyio' package to be installed."
                       )
>>>>>>             self._anyio_event = anyio.Event()
       
    1:     def set(self) -> None:
>>>>>>         if not self._backend:
>>>>>>             self.setup()
       
>>>>>>         if self._backend == "trio":
>>>>>>             self._trio_event.set()
               else:
>>>>>>             self._anyio_event.set()
       
    1:     async def wait(self, timeout: Optional[float] = None) -> None:
>>>>>>         if not self._backend:
>>>>>>             self.setup()
       
>>>>>>         if self._backend == "trio":
>>>>>>             if trio is None:  # pragma: nocover
>>>>>>                 raise RuntimeError(
>>>>>>                     "Running under trio requires the 'trio' package to be installed."
                       )
       
>>>>>>             trio_exc_map: ExceptionMapping = {trio.TooSlowError: PoolTimeout}
>>>>>>             timeout_or_inf = float("inf") if timeout is None else timeout
>>>>>>             with map_exceptions(trio_exc_map):
>>>>>>                 with trio.fail_after(timeout_or_inf):
>>>>>>                     await self._trio_event.wait()
               else:
>>>>>>             if anyio is None:  # pragma: nocover
>>>>>>                 raise RuntimeError(
>>>>>>                     "Running under asyncio requires the 'anyio' package to be installed."
                       )
       
>>>>>>             anyio_exc_map: ExceptionMapping = {TimeoutError: PoolTimeout}
>>>>>>             with map_exceptions(anyio_exc_map):
>>>>>>                 with anyio.fail_after(timeout):
>>>>>>                     await self._anyio_event.wait()
       
       
    2: class AsyncSemaphore:
    1:     def __init__(self, bound: int) -> None:
>>>>>>         self._bound = bound
>>>>>>         self._backend = ""
       
    1:     def setup(self) -> None:
               """
               Detect if we're running under 'asyncio' or 'trio' and create
               a semaphore with the correct implementation.
               """
>>>>>>         self._backend = sniffio.current_async_library()
>>>>>>         if self._backend == "trio":
>>>>>>             if trio is None:  # pragma: nocover
>>>>>>                 raise RuntimeError(
>>>>>>                     "Running under trio requires the 'trio' package to be installed."
                       )
       
>>>>>>             self._trio_semaphore = trio.Semaphore(
>>>>>>                 initial_value=self._bound, max_value=self._bound
                   )
               else:
>>>>>>             if anyio is None:  # pragma: nocover
>>>>>>                 raise RuntimeError(
>>>>>>                     "Running under asyncio requires the 'anyio' package to be installed."
                       )
       
>>>>>>             self._anyio_semaphore = anyio.Semaphore(
>>>>>>                 initial_value=self._bound, max_value=self._bound
                   )
       
    1:     async def acquire(self) -> None:
>>>>>>         if not self._backend:
>>>>>>             self.setup()
       
>>>>>>         if self._backend == "trio":
>>>>>>             await self._trio_semaphore.acquire()
               else:
>>>>>>             await self._anyio_semaphore.acquire()
       
    1:     async def release(self) -> None:
>>>>>>         if self._backend == "trio":
>>>>>>             self._trio_semaphore.release()
               else:
>>>>>>             self._anyio_semaphore.release()
       
       
    2: class AsyncShieldCancellation:
           # For certain portions of our codebase where we're dealing with
           # closing connections during exception handling we want to shield
           # the operation from being cancelled.
           #
           # with AsyncShieldCancellation():
           #     ... # clean-up operations, shielded from cancellation.
       
    1:     def __init__(self) -> None:
               """
               Detect if we're running under 'asyncio' or 'trio' and create
               a shielded scope with the correct implementation.
               """
>>>>>>         self._backend = sniffio.current_async_library()
       
>>>>>>         if self._backend == "trio":
>>>>>>             if trio is None:  # pragma: nocover
>>>>>>                 raise RuntimeError(
>>>>>>                     "Running under trio requires the 'trio' package to be installed."
                       )
       
>>>>>>             self._trio_shield = trio.CancelScope(shield=True)
               else:
>>>>>>             if anyio is None:  # pragma: nocover
>>>>>>                 raise RuntimeError(
>>>>>>                     "Running under asyncio requires the 'anyio' package to be installed."
                       )
       
>>>>>>             self._anyio_shield = anyio.CancelScope(shield=True)
       
    1:     def __enter__(self) -> "AsyncShieldCancellation":
>>>>>>         if self._backend == "trio":
>>>>>>             self._trio_shield.__enter__()
               else:
>>>>>>             self._anyio_shield.__enter__()
>>>>>>         return self
       
    2:     def __exit__(
               self,
    1:         exc_type: Optional[Type[BaseException]] = None,
    1:         exc_value: Optional[BaseException] = None,
    1:         traceback: Optional[TracebackType] = None,
    1:     ) -> None:
>>>>>>         if self._backend == "trio":
>>>>>>             self._trio_shield.__exit__(exc_type, exc_value, traceback)
               else:
>>>>>>             self._anyio_shield.__exit__(exc_type, exc_value, traceback)
       
       
       # Our thread-based synchronization primitives...
       
       
    2: class Lock:
    1:     def __init__(self) -> None:
>>>>>>         self._lock = threading.Lock()
       
    1:     def __enter__(self) -> "Lock":
>>>>>>         self._lock.acquire()
>>>>>>         return self
       
    2:     def __exit__(
               self,
    1:         exc_type: Optional[Type[BaseException]] = None,
    1:         exc_value: Optional[BaseException] = None,
    1:         traceback: Optional[TracebackType] = None,
    1:     ) -> None:
>>>>>>         self._lock.release()
       
       
    2: class Event:
    1:     def __init__(self) -> None:
>>>>>>         self._event = threading.Event()
       
    1:     def set(self) -> None:
>>>>>>         self._event.set()
       
    1:     def wait(self, timeout: Optional[float] = None) -> None:
>>>>>>         if not self._event.wait(timeout=timeout):
>>>>>>             raise PoolTimeout()  # pragma: nocover
       
       
    2: class Semaphore:
    1:     def __init__(self, bound: int) -> None:
>>>>>>         self._semaphore = threading.Semaphore(value=bound)
       
    1:     def acquire(self) -> None:
>>>>>>         self._semaphore.acquire()
       
    1:     def release(self) -> None:
>>>>>>         self._semaphore.release()
       
       
    2: class ShieldCancellation:
           # Thread-synchronous codebases don't support cancellation semantics.
           # We have this class because we need to mirror the async and sync
           # cases within our package, but it's just a no-op.
    1:     def __enter__(self) -> "ShieldCancellation":
>>>>>>         return self
       
    2:     def __exit__(
               self,
    1:         exc_type: Optional[Type[BaseException]] = None,
    1:         exc_value: Optional[BaseException] = None,
    1:         traceback: Optional[TracebackType] = None,
    1:     ) -> None:
>>>>>>         pass
